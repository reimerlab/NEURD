

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.neuron &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.neuron</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.neuron</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span> 
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span> <span class="k">as</span> <span class="n">dc</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span> 
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1">#neuron module specific imports</span>
<span class="c1">#to be used for the soma_vertex nullification</span>



<span class="n">current_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>


<span class="kn">from</span> <span class="nn">.documentation_utils</span> <span class="kn">import</span> <span class="n">tag</span>

<span class="n">branch_mesh_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spines&quot;</span><span class="p">,</span><span class="s2">&quot;boutons&quot;</span><span class="p">]</span>
<span class="n">object_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">]</span>
<span class="n">computed_attribute_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;width_array&quot;</span><span class="p">,</span><span class="s2">&quot;width_array_skeletal_lengths&quot;</span><span class="p">,</span><span class="s2">&quot;width_new&quot;</span><span class="p">,</span><span class="s2">&quot;spines_volume&quot;</span><span class="p">,</span>
                                                  <span class="s2">&quot;boutons_volume&quot;</span><span class="p">,</span>
                                                  <span class="s2">&quot;labels&quot;</span><span class="p">,</span><span class="s2">&quot;boutons_cdfs&quot;</span><span class="p">,</span><span class="s2">&quot;web_cdf&quot;</span><span class="p">,</span><span class="s2">&quot;web&quot;</span><span class="p">,</span><span class="s2">&quot;head_neck_shaft_idx&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_mesh_attributes</span> <span class="o">+</span> <span class="n">object_attributes</span>


<div class="viewcode-block" id="export_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.export_skeleton">[docs]</a><span class="k">def</span> <span class="nf">export_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">subgraph_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">subgraph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">total_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_graph</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span></div>
        <span class="c1"># do some subgraphing</span>
        <span class="c1">#total_graph = self.neuron_graph.subgraph([])</span>
    
    <span class="c1">#proce</span>


<div class="viewcode-block" id="export_mesh_labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.export_mesh_labels">[docs]</a><span class="k">def</span> <span class="nf">export_mesh_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="convert_soma_to_piece_connectivity_to_graph"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.convert_soma_to_piece_connectivity_to_graph">[docs]</a><span class="k">def</span> <span class="nf">convert_soma_to_piece_connectivity_to_graph</span><span class="p">(</span><span class="n">soma_to_piece_connectivity</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Create the edges with the new names from the soma_to_piece_connectivity</span>
<span class="sd">    2) Create a GraphOrderedEdges from the new edges</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">        </span>
<span class="sd">    concept_network = convert_soma_to_piece_connectivity_to_graph(current_mesh_data[0][&quot;soma_to_piece_connectivity&quot;])</span>
<span class="sd">    nx.draw(concept_network,with_labels=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">total_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">soma_key</span><span class="p">,</span><span class="n">list_of_limbs</span> <span class="ow">in</span> <span class="n">soma_to_piece_connectivity</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">total_edges</span> <span class="o">+=</span> <span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">soma_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">list_of_limbs</span><span class="p">]</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_edges = </span><span class="si">{</span><span class="n">total_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">concept_network</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span>
    <span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">total_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">concept_network</span> </div>

    
<div class="viewcode-block" id="dc_check"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.dc_check">[docs]</a><span class="k">def</span> <span class="nf">dc_check</span><span class="p">(</span><span class="n">current_object</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_object</span><span class="p">,</span><span class="n">attribute</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_value</span></div>

<div class="viewcode-block" id="copy_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.copy_concept_network">[docs]</a><span class="k">def</span> <span class="nf">copy_concept_network</span><span class="p">(</span><span class="n">curr_network</span><span class="p">):</span>
    <span class="n">copy_network</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">curr_network</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">copy_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Old way that didn&#39;t account for dynamic updates</span>
<span class="sd">        current_node_class = copy_network.nodes[n][&quot;data&quot;].__class__</span>
<span class="sd">        #print(f&quot;current_node_class = {current_node_class}&quot;)</span>
<span class="sd">        copy_network.nodes[n][&quot;data&quot;] = current_node_class(copy_network.nodes[n][&quot;data&quot;])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        New way:</span>
<span class="sd">        1) get the name of the class</span>
<span class="sd">        2) get a reference to the definition based on the current module definition </span>
<span class="sd">        3) Use that instantiation</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_node_class_name</span> <span class="o">=</span> <span class="n">copy_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">class_constructor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_module</span><span class="p">,</span><span class="n">current_node_class_name</span><span class="p">)</span>
        <span class="n">copy_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">class_constructor</span><span class="p">(</span><span class="n">copy_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        
        
    <span class="k">return</span> <span class="n">copy_network</span></div>

<div class="viewcode-block" id="Branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Branch">[docs]</a><span class="k">class</span> <span class="nc">Branch</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that will hold one continus skeleton</span>
<span class="sd">    piece that has no branching</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
<div class="viewcode-block" id="Branch.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Branch.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">skeleton</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">mesh_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">labels</span><span class="o">=</span><span class="p">[]</span> <span class="c1">#for any labels of that branch</span>
        <span class="p">):</span>
        
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">skeleton</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">Branch</span><span class="p">):</span>
            <span class="c1">#print(&quot;Recived Branch object so copying object&quot;)</span>
            <span class="c1">#self = copy.deepcopy(skeleton)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">=</span><span class="n">dc</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span>
            
            <span class="c1">#self.endpoints = dc(skeleton.endpoints)</span>
            <span class="c1">#doing the new storage and ordering skeletons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_endpoints</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_skeleton_by_smallest_endpoint</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_graph</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_skeleton_graph&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endpoints_nodes</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_endpoints_nodes&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints_upstream_downstream_idx</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;endpoints_upstream_downstream_idx&quot;</span><span class="p">)</span>
                
            
            
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>

            
            
            
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="n">dc</span><span class="p">(</span><span class="n">skeleton</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">]</span>
                
                
            <span class="bp">self</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;spines&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boutons</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;boutons&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boutons_cdfs</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;boutons_cdfs&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">web</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;web&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">web_cdf</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;web_cdf&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;spines_volume&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boutons_volume</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;boutons_volume&quot;</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">width_new</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;width_new&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">width_new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">width_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">width_array</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;width_array&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">width_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">width_array</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">width_array_skeletal_lengths</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;width_array_skeletal_lengths&quot;</span><span class="p">)</span>
                
            <span class="c1">#copying over of the synapse data</span>
            <span class="n">syn_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;synapses&quot;</span><span class="p">]</span><span class="c1">#list(syu.synapse_types.values())</span>
            <span class="k">for</span> <span class="n">s_id</span> <span class="ow">in</span> <span class="n">syn_types</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s_id</span><span class="p">,</span><span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="n">s_id</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s_id</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s_id</span><span class="p">,[])</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="p">[]</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">head_neck_shaft_idx</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;head_neck_shaft_idx&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_volume</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_mesh_volume&quot;</span><span class="p">)</span>
            <span class="c1">#self._mesh_area = dc_check(skeleton,&quot;_mesh_area&quot;)</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spines_volume</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spines_volume</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spines</span><span class="p">)</span>
                
                
            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_upstream</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_skeleton_vector_upstream&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_downstream</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_skeleton_vector_downstream&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_width_downstream</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_width_downstream&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_width_upstream</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span><span class="s2">&quot;_width_upstream&quot;</span><span class="p">)</span>
            
            
            <span class="k">return</span> 
            
        <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_graph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endpoints_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="o">=</span><span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">mesh_face_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_volume</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints_upstream_downstream_idx</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">#calculate the end coordinates of skeleton branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_endpoints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_skeleton_by_smallest_endpoint</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">]</span>
            
        
        <span class="bp">self</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boutons</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boutons_volume</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boutons_cdfs</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">web</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">web_cdf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_array</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_array_skeletal_lengths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">head_neck_shaft_idx</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_upstream</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_downstream</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width_downstream</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width_upstream</span> <span class="o">=</span> <span class="kc">None</span></div>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --- Branch comparison:</span>
<span class="sd">    &#39;endpoints&#39;, #sort them by row and then subtract and then if distance is within threshold then equal</span>
<span class="sd">    &#39;labels&#39;,</span>
<span class="sd">    &#39;mesh&#39;,</span>
<span class="sd">    &#39;mesh_center&#39;,</span>
<span class="sd">    &#39;skeleton&#39;, : how do we compare skeletons? (compare just like a networkx graph)</span>
<span class="sd">    --&gt; convert to networkx graph</span>
<span class="sd">    --&gt; define functions that make nodes equal if within a certain distance</span>
<span class="sd">    --&gt; define function that makes edges equal if have same distance</span>
<span class="sd">    &#39;width&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    
<div class="viewcode-block" id="Branch.calculate_endpoints"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Branch.calculate_endpoints">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Branch.order_skeleton_by_smallest_endpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Branch.order_skeleton_by_smallest_endpoint">[docs]</a>    <span class="k">def</span> <span class="nf">order_skeleton_by_smallest_endpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
        <span class="p">)</span></div>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_from_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints_upstream_downstream_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints_upstream_downstream_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_upstream_with_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">endpoint_upstream_with_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_downstream_with_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">endpoint_downstream_with_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_array_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">width_array_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_array_skeletal_lengths_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">width_array_skeletal_lengths_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_coordinates_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">skeletal_coordinates_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_coordinates_dist_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">skeletal_coordinates_dist_upstream_to_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
<span class="c1">#     @property</span>
<span class="c1">#     def width_array_upstream_to_downstream(self):</span>
<span class="c1">#         for </span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_shaft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">mesh_shaft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_shaft_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">mesh_shaft_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_overall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_new</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_upstream_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoint_upstream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_upstream_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoint_upstream</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_upstream_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoint_upstream</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_downstream_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoint_downstream</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_downstream_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoint_downstream</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_downstream_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoint_downstream</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton_vector_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the skelelton vector near upstream coordinate where the vector is oriented in the skeletal walk direction away from the soma</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_upstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_upstream</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">skeleton_vector_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_upstream</span> 
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton_vector_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the skelelton vector near downstream coordinate where the vector is oriented in the skeletal walk direction away from the soma</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_downstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_downstream</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">skeleton_vector_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_vector_downstream</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width_upstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_width_upstream</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">width_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width_upstream</span> 
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width_downstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_width_downstream</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">width_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width_downstream</span> 
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_dist_synapses_pre_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">min_dist_synapses_pre_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_dist_synapses_post_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">min_dist_synapses_post_upstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_dist_synapses_pre_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">min_dist_synapses_pre_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_dist_synapses_post_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">min_dist_synapses_post_downstream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_volume</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_volume</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">divisor</span><span class="o">=</span><span class="mi">1_000_000_000</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_volume</span><span class="o">/</span><span class="n">divisor</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dictionary mapping the index to the </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">divisor</span><span class="o">=</span><span class="mi">1000000</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">area</span><span class="o">/</span><span class="n">divisor</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_web</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_web</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_spine_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_volume_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_volume_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_length_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> 
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    def compute_spines_volume(self,</span>
<span class="sd">              max_hole_size=2000,</span>
<span class="sd">              self_itersect_faces=False):</span>
<span class="sd">        if self.spines is None:</span>
<span class="sd">            self.spines_volume = None</span>
<span class="sd">        else:</span>
<span class="sd">            self.spines_volume = [tu.mesh_volume(sp,verbose=False) for sp in self.spines]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
<div class="viewcode-block" id="Branch.compute_spines_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Branch.compute_spines_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_spines_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">max_hole_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
              <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">compute_mesh_attribute_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;spines&quot;</span><span class="p">,</span>
                                         <span class="n">max_hole_size</span><span class="o">=</span><span class="n">max_hole_size</span><span class="p">,</span>
                                         <span class="n">self_itersect_faces</span><span class="o">=</span><span class="n">self_itersect_faces</span><span class="p">)</span></div>
<div class="viewcode-block" id="Branch.compute_boutons_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Branch.compute_boutons_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_boutons_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">max_hole_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
              <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">compute_mesh_attribute_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                         <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;boutons&quot;</span><span class="p">,</span>
                                         <span class="n">max_hole_size</span><span class="o">=</span><span class="n">max_hole_size</span><span class="p">,</span>
                                         <span class="n">self_itersect_faces</span><span class="o">=</span><span class="n">self_itersect_faces</span><span class="p">)</span></div>
        
    
    
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="c1">#print(&quot;inside equality function&quot;)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Computes equality of all members except the face_idx (will print out if not equal)</span>
<span class="sd">        </span>
<span class="sd">        Examples: </span>
<span class="sd">        </span>
<span class="sd">        tu = reload(tu)</span>
<span class="sd">        neuron= reload(neuron)</span>
<span class="sd">        B1 = neuron.Branch(copy.deepcopy(double_soma_obj.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;].concept_network.nodes[0][&quot;data&quot;]))</span>
<span class="sd">        B2= copy.deepcopy(B1)</span>

<span class="sd">        #initial comparison was equal</span>
<span class="sd">        #B1 == B2</span>


<span class="sd">        #when changed the skeleton was not equal</span>
<span class="sd">        # B2.skeleton[0][0] = [2,3,4]</span>
<span class="sd">        # B1 == B2</span>

<span class="sd">        #when changed the labels was not equal</span>
<span class="sd">        # B1.labels=[&quot;new Labels&quot;]</span>
<span class="sd">        # B1 == B2</span>

<span class="sd">        B2.mesh = B2.mesh.submesh([np.arange(0,len(B2.mesh.faces)-5)],append=True)</span>
<span class="sd">        B1 != B2</span>

<span class="sd">        # B1 != B2</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#comparing the meshes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh didn&#39;t match&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.mesh = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">endpoints</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.endpoints = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="si">}</span><span class="s2">, other.endpoints = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;labels didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.labels = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="si">}</span><span class="s2">, other.labels = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_center didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh_center = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="si">}</span><span class="s2">, other.mesh_center = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.width = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2">, other.width = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sk</span><span class="o">.</span><span class="n">compare_skeletons_ordered</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">skeleton</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skeleton didn&#39;t match&quot;</span><span class="p">)</span>
        
        <span class="c1">#print out if face idx was different but not make part of the comparison</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">):</span>
            <span class="c1">#print(&quot;*** Warning: mesh_face_idx didn&#39;t match (but not factored into equality comparison)&quot;)</span>
            <span class="k">pass</span>
        
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Differences List:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">differences</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)   </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
    
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="c1">#print(f&quot;self.__eq__(other) = {self.__eq__(other)}&quot;)</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    
    <span class="c1"># -------- 6/8 Addition For quick skeleton ------- #</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton_graph</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">endpoints_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endpoints_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endpoints_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton_graph</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endpoints_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;axon&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;dendrite&quot;</span>
        
    <span class="c1"># ------- 7/21: The synapse head/neck/shaft ----</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_head</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_shaft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_shaft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_spine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_spine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_no_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_no_head</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_head</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_shaft</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_shaft</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_spine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_spine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_no_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_no_head</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="Limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb">[docs]</a><span class="k">class</span> <span class="nc">Limb</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that will hold one continus skeleton</span>
<span class="sd">    piece that has no branching (called a limb)</span>
<span class="sd">    </span>
<span class="sd">    3) Limb Process: For each limb made </span>
<span class="sd">    a. Build all the branches from the </span>
<span class="sd">        - mesh</span>
<span class="sd">        - skeleton</span>
<span class="sd">        - width</span>
<span class="sd">        - branch_face_idx</span>
<span class="sd">    b. Pick the top concept graph (will use to store the nodes)</span>
<span class="sd">    c. Put the branches as &quot;data&quot; in the network</span>
<span class="sd">    d. Get all of the starting coordinates and starting edges and put as member attributes in the limb</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Limb.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">mesh</span><span class="p">,</span>
                             <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">concept_network_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">mesh_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">branch_objects</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#this will have a dictionary mapping to the branch objects if provided</span>
                             <span class="n">deleted_edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">created_edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow for an initialization of a limb with another limb oconcept_network_dictbject</span>
<span class="sd">        </span>
<span class="sd">        Parts that need to be copied over:</span>
<span class="sd">        &#39;all_concept_network_data&#39;,</span>
<span class="sd">         &#39;concept_network&#39;,</span>
<span class="sd">         &#39;concept_network_directional&#39;,</span>
<span class="sd">         &#39;current_starting_coordinate&#39;,</span>
<span class="sd">         &#39;current_starting_endpoints&#39;,</span>
<span class="sd">         &#39;current_starting_node&#39;,</span>
<span class="sd">         </span>
<span class="sd">         &#39;current_starting_soma&#39;,</span>
<span class="sd">         &#39;label&#39;,</span>
<span class="sd">         &#39;mesh&#39;,</span>
<span class="sd">         &#39;mesh_center&#39;,</span>
<span class="sd">         &#39;mesh_face_idx&#39;</span>
<span class="sd">         </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">deleted_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deleted_edges</span> <span class="o">=</span> <span class="p">[]</span>
            
        <span class="k">if</span> <span class="n">created_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">created_edges</span> <span class="o">=</span> <span class="p">[]</span>
        
        
        <span class="k">if</span> <span class="n">branch_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">branch_objects</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">Limb</span><span class="p">):</span>
            <span class="c1">#print(&quot;Recived Limb object so copying object&quot;)</span>
            <span class="c1"># properties we are copying: [k for k in dir(example_limb) if &quot;__&quot; not in k]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">=</span><span class="n">copy_concept_network</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
            <span class="c1">#want to do and copy the meshes in each of the networks to make sure their properties update</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_directional</span> <span class="o">=</span> <span class="n">copy_concept_network</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
            <span class="c1">#want to do and copy the meshes in each of the networks to make sure their properties update</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">current_starting_endpoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_node</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">)</span>
            
            
            
            <span class="n">attributes_to_set</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">current_touching_soma_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">current_soma_group_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">deleted_edges</span> <span class="o">=</span> <span class="p">[],</span>
                                <span class="n">created_edges</span> <span class="o">=</span> <span class="p">[])</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span><span class="n">attr_v</span> <span class="ow">in</span> <span class="n">attributes_to_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">attr</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attr</span><span class="p">,</span><span class="n">dc</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">attr</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attr</span><span class="p">,</span><span class="n">attr_v</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">current_starting_soma</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            
            <span class="c1"># axon spines and short thick endnodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;axon_spines&quot;</span><span class="p">,</span><span class="n">default_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;short_thick_endnodes&quot;</span><span class="p">,</span><span class="n">default_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
            
            
            <span class="k">return</span> 
        
        <span class="n">debug_edges</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">debug_edges</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;before set: deleted_edges=</span><span class="si">{</span><span class="n">deleted_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;before set: created_edges=</span><span class="si">{</span><span class="n">created_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
        <span class="bp">self</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span>
        
        <span class="c1">#checking that some of arguments aren&#39;t None</span>
        <span class="k">if</span> <span class="n">curr_limb_correspondence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;curr_limb_correspondence is None before start of Limb processing in init&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">concept_network_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;concept_network_dict is None before start of Limb processing in init&quot;</span><span class="p">)</span>
        
        <span class="c1">#make sure it is a list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">labels</span><span class="p">]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span>
        
        <span class="c1">#All the stuff dealing with the concept graph</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;concept_network_dict = </span><span class="si">{</span><span class="n">concept_network_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">concept_network_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">concept_network_data</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_starting_info_from_concept_network</span><span class="p">(</span><span class="n">concept_network_dict</span><span class="p">)</span>
            <span class="c1">#print(f&quot;concept_network_data = {concept_network_data}&quot;)</span>
            <span class="n">current_concept_network</span> <span class="o">=</span> <span class="n">concept_network_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span> <span class="o">=</span> <span class="n">current_concept_network</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_node</span> <span class="o">=</span> <span class="n">current_concept_network</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span> <span class="o">=</span> <span class="n">current_concept_network</span><span class="p">[</span><span class="s2">&quot;starting_endpoints&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span> <span class="o">=</span> <span class="n">current_concept_network</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span> <span class="o">=</span> <span class="n">current_concept_network</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_soma_group_idx</span> <span class="o">=</span> <span class="n">current_concept_network</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">concept_network_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">current_soma_group_idx</span><span class="p">]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="n">concept_network_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_soma_group_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="p">[]</span>
            
        
        <span class="c1">#get all of the starting coordinates an</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">mesh_face_idx</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">#just adding these in case could be useful in the future (what we computed for somas)</span>
        <span class="c1">#self.volume_ratio = sm.soma_volume_ratio(self.mesh)</span>
        <span class="c1">#self.side_length_ratios = sm.side_length_ratios(self.mesh)</span>
        
        <span class="c1">#Start with the branch stuff</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a. Build all the branches from the </span>
<span class="sd">        - mesh</span>
<span class="sd">        - skeleton</span>
<span class="sd">        - width</span>
<span class="sd">        - branch_face_idx</span>
<span class="sd">        b. Pick the top concept graph (will use to store the nodes)</span>
<span class="sd">        c. Put the branches as &quot;data&quot; in the network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">branch_data</span> <span class="ow">in</span> <span class="n">curr_limb_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">branch_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">branch_objects</span><span class="p">:</span>
                <span class="c1">#print(f&quot;using existing branch object for node {j}&quot;)</span>
                <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">branch_objects</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_skeleton</span> <span class="o">=</span> <span class="n">branch_data</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
                <span class="n">curr_width</span> <span class="o">=</span> <span class="n">branch_data</span><span class="p">[</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span>
                <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">branch_data</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span>
                <span class="n">curr_face_idx</span> <span class="o">=</span> <span class="n">branch_data</span><span class="p">[</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span>

                <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">(</span>
                                    <span class="n">skeleton</span><span class="o">=</span><span class="n">curr_skeleton</span><span class="p">,</span>
                                    <span class="n">width</span><span class="o">=</span><span class="n">curr_width</span><span class="p">,</span>
                                    <span class="n">mesh</span><span class="o">=</span><span class="n">curr_mesh</span><span class="p">,</span>
                                   <span class="n">mesh_face_idx</span><span class="o">=</span><span class="n">curr_face_idx</span><span class="p">,</span>
                                    <span class="n">labels</span><span class="o">=</span><span class="p">[],</span>
                <span class="p">)</span>
            
            <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span>
            
            
            <span class="c1">#Set all  of the branches as data in the nodes</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">set_node_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                            <span class="n">node_name</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                            <span class="n">curr_data</span><span class="o">=</span><span class="n">branch_obj</span><span class="p">,</span>
                             <span class="n">curr_data_label</span><span class="o">=</span><span class="s2">&quot;data&quot;</span>
                            <span class="p">)</span>
            
        <span class="c1">#Setting the concept network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deleted_edges</span> <span class="o">=</span><span class="n">deleted_edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created_edges</span> <span class="o">=</span> <span class="n">created_edges</span>
        
        <span class="k">if</span> <span class="n">debug_edges</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.deleted_edges = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">deleted_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.created_edges = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">created_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
            <span class="bp">self</span><span class="o">.</span><span class="n">set_concept_network_edges_from_current_starting_data</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_directional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_concept_network_to_directional</span><span class="p">(</span><span class="n">no_cycles</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                                                <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="n">suppress_disconnected_errors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_directional</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">debug_edges</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.deleted_edges = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">deleted_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.created_edges = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">created_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_starting_soma_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span>    
    
<div class="viewcode-block" id="Limb.set_branches_endpoints_upstream_downstream_idx"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.set_branches_endpoints_upstream_downstream_idx">[docs]</a>    <span class="k">def</span> <span class="nf">set_branches_endpoints_upstream_downstream_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx_on_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">(),</span>
                             <span class="s2">&quot;mesh_volume&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dictionary mapping the index to the </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_objects</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dictionary mapping the index to the </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_objects</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">branch_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dictionary mapping the index to the </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)])</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">n_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        number of branches in the limb</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">network_starting_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: will generate the dictionary that is organized</span>
<span class="sd">        soma_idx --&gt; soma_group_idx --&gt; dict(touching_verts,endpoint)</span>
<span class="sd">        </span>
<span class="sd">        that can be used to generate a concept network from </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">soma_idx</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> 
            <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="n">st</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> 
            <span class="k">if</span> <span class="n">st</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">st_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">st_dict</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">st_dict</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">][</span><span class="n">soma_group_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">touching_verts</span><span class="o">=</span><span class="n">st</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">],</span>
                                                    <span class="n">endpoint</span><span class="o">=</span><span class="n">st</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">st_dict</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_starting_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: will generate the dictionary that is organized</span>
<span class="sd">        soma_idx --&gt; soma_group_idx --&gt; dict(touching_verts,endpoint)</span>
<span class="sd">        </span>
<span class="sd">        that can be used to generate a concept network from </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">start_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">])</span>
            
        <span class="n">start_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start_coordinates</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_starting_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: will generate the dictionary that is organized</span>
<span class="sd">        soma_idx --&gt; soma_group_idx --&gt; dict(touching_verts,endpoint)</span>
<span class="sd">        </span>
<span class="sd">        that can be used to generate a concept network from </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starting_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">starting_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">])</span>
            
        <span class="k">return</span> <span class="n">starting_nodes</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limb_correspondence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">limb_corr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1">#for idx,b in enumerate(self):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">curr_width</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">width</span>    
            <span class="k">try</span><span class="p">:</span>
                <span class="n">curr_width</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">limb_corr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">branch_skeleton</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                  <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">curr_width</span><span class="p">,</span>
                                 <span class="n">branch_mesh</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                 <span class="n">branch_face_idx</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span>
                                 <span class="p">)</span>
        
            
        <span class="k">return</span> <span class="n">limb_corr</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">divided_skeletons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">curr_corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limb_correspondence</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">curr_corr</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_corr</span><span class="o">.</span><span class="n">keys</span><span class="p">()))])</span>
        
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_web</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_web</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;synapses&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;boutons&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">web</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;web&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines_volume&quot;</span><span class="p">))</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boutons_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;boutons_volume&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="Limb.compute_spines_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.compute_spines_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_spines_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">compute_feature_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines_volume&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Limb.compute_boutons_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.compute_boutons_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_boutons_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">compute_feature_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;boutons_volume&quot;</span><span class="p">)</span></div>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; older less efficient way</span>
<span class="sd">    @property</span>
<span class="sd">    def spines(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        total_spines = []</span>
<span class="sd">        for b in self:</span>
<span class="sd">            if not b.spines is None:</span>
<span class="sd">                total_spines += b.spines</span>
<span class="sd">        return total_spines</span>
<span class="sd">    </span>
<span class="sd">    @property</span>
<span class="sd">    def boutons(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        total_spines = []</span>
<span class="sd">        for b in self:</span>
<span class="sd">            if not b.boutons is None:</span>
<span class="sd">                total_spines += b.boutons</span>
<span class="sd">        return total_spines</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    @property</span>
<span class="sd">    def spines_volume(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        total_spines_volume = []</span>
<span class="sd">        for b in self:</span>
<span class="sd">            if not b.spines_volume is None:</span>
<span class="sd">                total_spines_volume += b.spines_volume</span>
<span class="sd">        return total_spines_volume</span>
<span class="sd">    </span>
<span class="sd">    @property</span>
<span class="sd">    def boutons_volume(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        total_boutons_volume = []</span>
<span class="sd">        for b in self:</span>
<span class="sd">            if not b.boutons_volume is None:</span>
<span class="sd">                total_boutons_volume += b.boutons_volume</span>
<span class="sd">        return total_boutons_volume</span>
<span class="sd">    </span>
<span class="sd">    def compute_spines_volume(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        for b in self:</span>
<span class="sd">            b.compute_spines_volume()</span>
<span class="sd">            </span>
<span class="sd">    def compute_boutons_volume(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        for b in self:</span>
<span class="sd">            b.compute_boutons_volume()&#39;&#39;&#39;</span>
    
    
    
<div class="viewcode-block" id="Limb.get_branch_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_branch_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_branch_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">return_int</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node_names</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node_names</span></div>
    
<div class="viewcode-block" id="Limb.get_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">get_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">check_connected_component</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Will return the entire skeleton of all the branches</span>
<span class="sd">        stitched together</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">convert_limb_concept_network_to_neuron_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                             <span class="n">check_connected_component</span><span class="o">=</span><span class="n">check_connected_component</span><span class="p">)</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">check_connected_component</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Will return the entire skeleton of all the branches</span>
<span class="sd">        stitched together</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">convert_limb_concept_network_to_neuron_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                             <span class="n">check_connected_component</span><span class="o">=</span><span class="n">check_connected_component</span><span class="p">)</span>
    
<div class="viewcode-block" id="Limb.get_concept_network_data_by_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_concept_network_data_by_soma">[docs]</a>    <span class="k">def</span> <span class="nf">get_concept_network_data_by_soma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#compile a dictionary of all of the starting material</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;starting_soma&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">soma_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_dict</span></div>
    
    
    
<div class="viewcode-block" id="Limb.get_concept_network_data_by_soma_and_idx"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_concept_network_data_by_soma_and_idx">[docs]</a>    <span class="k">def</span> <span class="nf">get_concept_network_data_by_soma_and_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_group_idx</span><span class="p">):</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">curr_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">soma_group_idx</span> <span class="ow">and</span> <span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">soma_idx</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_data</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not find exactly one starting dictionary for soma_idx </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">, soma_group_idx </span><span class="si">{</span><span class="n">soma_group_idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">return_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_dict</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
         
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concept_network_data_by_soma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#compile a dictionary of all of the starting material</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;starting_soma&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">return_dict</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">concept_network_data_by_starting_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#compile a dictionary of all of the starting material</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">curr_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;starting_node&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">return_dict</span>
    
<div class="viewcode-block" id="Limb.touching_somas"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.touching_somas">[docs]</a>    <span class="k">def</span> <span class="nf">touching_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The soma identifiers that a current limb is adjacent two (useful for finding paths to cut for multi-soma or multi-touch limbs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span></div>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">        def get_soma_starting_coordinate(self,starting_soma,print_flag=False):</span>
<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            This function can now be replaced by </span>
<span class="sd">            curr_limb_obj.concept_network_data_by_soma[soma_idx][&quot;starting_coordinate&quot;]</span>

<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            if starting_soma not in self.touching_somas():</span>
<span class="sd">                raise Exception(f&quot;Current limb does not touch soma {starting_soma}&quot;)</span>

<span class="sd">            matching_concept_network_data = [k for k in self.all_concept_network_data if ((k[&quot;starting_soma&quot;] == starting_soma) or (nru.soma_label(k[&quot;starting_soma&quot;]) == starting_soma))]</span>

<span class="sd">            if len(matching_concept_network_data) != 1:</span>
<span class="sd">                raise Exception(f&quot;The concept_network data for the starting soma ({starting_soma}) did not have exactly one match: {matching_concept_network_data}&quot;)</span>
<span class="sd">            else:</span>
<span class="sd">                return matching_concept_network_data[0][&quot;starting_coordinate&quot;]</span>

<span class="sd">        &#39;&#39;&#39;</span>
    
<div class="viewcode-block" id="Limb.get_skeleton_soma_starting_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_skeleton_soma_starting_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_skeleton_soma_starting_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: from the all</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soma</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">soma</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">soma</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        
        <span class="c1">#limb_starting_coordinate = self.get_soma_starting_coordinate(soma)</span>
        <span class="n">limb_starting_coordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_data_by_soma</span><span class="p">[</span><span class="n">soma</span><span class="p">][</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_starting_coordinate = </span><span class="si">{</span><span class="n">limb_starting_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

        <span class="n">sk_starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">limb_skeleton_graph</span><span class="p">,</span>
                                      <span class="n">attribute_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">limb_starting_coordinate</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_starting_node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not exactly one skeleton starting node: sk_starting_node = </span><span class="si">{</span><span class="n">sk_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sk_starting_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="Limb.get_starting_branch_by_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_starting_branch_by_soma">[docs]</a>    <span class="k">def</span> <span class="nf">get_starting_branch_by_soma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: from the all</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soma</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">soma</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">soma</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_data_by_soma</span><span class="p">[</span><span class="n">soma</span><span class="p">][</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="Limb.get_soma_by_starting_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_soma_by_starting_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_soma_by_starting_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">starting_node</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: from the all</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_data_by_starting_node</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="Limb.get_soma_group_by_starting_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_soma_group_by_starting_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_soma_group_by_starting_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">starting_node</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: from the all</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_data_by_starting_node</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span></div>
    
    
<div class="viewcode-block" id="Limb.find_branch_by_skeleton_coordinate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.find_branch_by_skeleton_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">find_branch_by_skeleton_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">target_coordinate</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To be able to find the branch where the skeleton point resides</span>

<span class="sd">        Pseudocode: </span>
<span class="sd">        For each branch:</span>
<span class="sd">        1) get the skeleton</span>
<span class="sd">        2) ravel the skeleton into a numpy array</span>
<span class="sd">        3) searh for that coordinate:</span>
<span class="sd">        - if returns a non empty list then add to list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matching_node</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">curr_skeleton_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">row_matches</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">curr_skeleton_points</span><span class="p">,</span><span class="n">target_coordinate</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">matching_node</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;***Warning More than one branch skeleton matches the desired corrdinate: </span><span class="si">{</span><span class="n">matching_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">matching_node</span> <span class="o">=</span> <span class="n">matching_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching branches found&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matching_node</span></div>
    
    
<div class="viewcode-block" id="Limb.convert_concept_network_to_directional"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.convert_concept_network_to_directional">[docs]</a>    <span class="k">def</span> <span class="nf">convert_concept_network_to_directional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">no_cycles</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="n">width_source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">convert_concept_network_to_directional_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Example on how it was developed: </span>
<span class="sd">        </span>
<span class="sd">        from datasci_tools import numpy_dep as np</span>
<span class="sd">        from datasci_tools import networkx_utils as xu</span>
<span class="sd">        xu = reload(xu)</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        from neurd import neuron_utils as nru</span>
<span class="sd">        </span>
<span class="sd">        curr_limb_idx = 0</span>
<span class="sd">        no_cycles = True</span>
<span class="sd">        curr_limb_concept_network = my_neuron.concept_network.nodes[f&quot;L{curr_limb_idx}&quot;][&quot;data&quot;].concept_network </span>
<span class="sd">        curr_neuron_mesh =  my_neuron.mesh</span>
<span class="sd">        curr_limb_mesh =  my_neuron.concept_network.nodes[f&quot;L{curr_limb_idx}&quot;][&quot;data&quot;].mesh</span>
<span class="sd">        nx.draw(curr_limb_concept_network,with_labels=True)</span>
<span class="sd">        plt.show()</span>


<span class="sd">        mesh_widths = dict([(k,curr_limb_concept_network.nodes[k][&quot;data&quot;].width) for k in curr_limb_concept_network.nodes() ])</span>

<span class="sd">        directional_concept_network = nru.convert_concept_network_to_directional(curr_limb_concept_network,no_cycles=True)</span>


<span class="sd">        nx.draw(directional_concept_network,with_labels=True)</span>
<span class="sd">        plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot use convert_concept_nextwork_to_directional on limb if concept_network is None&quot;</span><span class="p">)</span>
            
        <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span>    
        
        <span class="c1">#make sure that there is one and only one starting node embedded in the graph</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There was not exactly one starting nodes in the current self.concept_network&quot;</span>
                  <span class="s2">&quot; when trying to convert to concept network &quot;</span><span class="p">)</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="n">width_source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#check to see if the mesh center width is available</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;no_spine_average_mesh_center&quot;</span> <span class="ow">in</span> <span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">width_source</span> <span class="o">=</span> <span class="s2">&quot;no_spine_average_mesh_center&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">width_source</span> <span class="o">=</span> <span class="s2">&quot;width&quot;</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">width_source</span> <span class="o">=</span> <span class="s2">&quot;width&quot;</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_source = </span><span class="si">{</span><span class="n">width_source</span><span class="si">}</span><span class="s2">, type = </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">width_source</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">width_source</span> <span class="o">==</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the default width&quot;</span><span class="p">)</span>
            <span class="n">node_widths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using the </span><span class="si">{</span><span class="n">width_source</span><span class="si">}</span><span class="s2"> in width_new that was calculated&quot;</span><span class="p">)</span>
            <span class="n">node_widths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_source</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="p">])</span>
            
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_widths= </span><span class="si">{</span><span class="n">node_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
        
        <span class="n">directional_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">convert_concept_network_to_directional</span><span class="p">(</span>
            <span class="n">curr_limb_concept_network</span><span class="p">,</span>
            <span class="n">node_widths</span><span class="o">=</span><span class="n">node_widths</span><span class="p">,</span>                                                    
            <span class="n">no_cycles</span><span class="o">=</span><span class="n">no_cycles</span><span class="p">,</span>
            <span class="n">suppress_disconnected_errors</span> <span class="o">=</span><span class="n">suppress_disconnected_errors</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">convert_concept_network_to_directional_verbose</span><span class="p">)</span>
                                                                            
        
        <span class="k">return</span> <span class="n">directional_concept_network</span></div>
    
    
<div class="viewcode-block" id="Limb.set_concept_network_directional"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.set_concept_network_directional">[docs]</a>    <span class="k">def</span> <span class="nf">set_concept_network_directional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">starting_soma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">soma_group_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">starting_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">no_cycles</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">convert_concept_network_to_directional_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        1) Get the current concept_network</span>
<span class="sd">        2) Delete the current starting coordinate</span>
<span class="sd">        3) Use the all_concept_network_data to find the starting node and coordinate for the</span>
<span class="sd">        starting soma specified</span>
<span class="sd">        4) set the starting coordinate of that node</span>
<span class="sd">        5) rerun the convert_concept_network_to_directional and set the output to the self attribute</span>
<span class="sd">        Using: </span>
<span class="sd">        self.concept_network_directional = self.convert_concept_network_to_directional(no_cycles = True)</span>
<span class="sd">        </span>
<span class="sd">        Example: </span>
<span class="sd">        </span>
<span class="sd">        from neurd import neuron_visualizations as nviz</span>

<span class="sd">        curr_limb_obj = recovered_neuron.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;]</span>
<span class="sd">        print(xu.get_starting_node(curr_limb_obj.concept_network_directional))</span>
<span class="sd">        print(curr_limb_obj.current_starting_coordinate)</span>
<span class="sd">        print(curr_limb_obj.current_starting_node)</span>
<span class="sd">        print(curr_limb_obj.current_starting_endpoints)</span>
<span class="sd">        print(curr_limb_obj.current_starting_soma)</span>
<span class="sd">        </span>
<span class="sd">        nviz.plot_concept_network(curr_limb_obj.concept_network_directional,</span>
<span class="sd">                         arrow_size=5,</span>
<span class="sd">                         scatter_size=3)</span>
<span class="sd">                         </span>
<span class="sd">        curr_limb_obj.set_concept_network_directional(starting_soma=1,print_flag=False)</span>
<span class="sd">        </span>
<span class="sd">        print(xu.get_starting_node(curr_limb_obj.concept_network_directional))</span>
<span class="sd">        print(curr_limb_obj.current_starting_coordinate)</span>
<span class="sd">        print(curr_limb_obj.current_starting_node)</span>
<span class="sd">        print(curr_limb_obj.current_starting_endpoints)</span>
<span class="sd">        print(curr_limb_obj.current_starting_soma)</span>

<span class="sd">        nviz.plot_concept_network(curr_limb_obj.concept_network_directional,</span>
<span class="sd">                                 arrow_size=5,</span>
<span class="sd">                                 scatter_size=3)</span>
<span class="sd">        </span>
<span class="sd">        Example 8/4:</span>
<span class="sd">        uncompressed_neuron_revised.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;].set_concept_network_directional(starting_soma=0,width_source=&quot;width&quot;,print_flag=True)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">starting_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_soma_group_by_starting_node</span><span class="p">(</span><span class="n">starting_node</span><span class="p">)</span>
            <span class="n">starting_soma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_soma_by_starting_node</span><span class="p">(</span><span class="n">starting_node</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">soma_group_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_soma_int_name</span><span class="p">(</span><span class="n">soma_group_idx</span><span class="p">)</span>
            
        
        <span class="k">if</span> <span class="n">soma_group_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_soma_group_idx</span>
            
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_node = </span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_group_idx = </span><span class="si">{</span><span class="n">soma_group_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_soma = </span><span class="si">{</span><span class="n">starting_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">            </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  Old way:     </span>
<span class="sd">        </span>
<span class="sd">        matching_concept_network_data = [k for k in self.all_concept_network_data if ((k[&quot;starting_soma&quot;] == starting_soma) or (nru.soma_label(k[&quot;starting_soma&quot;]) == starting_soma))]</span>

<span class="sd">        if len(matching_concept_network_data) &lt; 1:</span>
<span class="sd">            raise Exception(f&quot;The concept_network data for the starting soma ({starting_soma}) did not have exactly one match: {matching_concept_network_data}&quot;)</span>
<span class="sd">            </span>
<span class="sd">        matching_concept_network_dict = matching_concept_network_data[soma_group_idx]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        
        <span class="c1"># ------- 1/19 New way ------------ #</span>
        <span class="n">matching_concept_network_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_matching_concept_network_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma_idx</span><span class="o">=</span><span class="n">starting_soma</span><span class="p">,</span>
                                                                          <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">soma_group_idx</span><span class="p">,</span>
                                     <span class="n">starting_node</span><span class="o">=</span><span class="n">starting_node</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1">#if debug:</span>
        <span class="c1">#print(f&quot;matching_concept_network_dict = {matching_concept_network_dict}&quot;)</span>
        
        
        
        <span class="c1">#find which the starting_coordinate and starting_node</span>

        <span class="n">previous_starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">previous_starting_node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**** Warning there were more than 1 starting nodes in concept networks&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">previous_starting_node = </span><span class="si">{</span><span class="n">previous_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">previous_starting_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**** Warning there were 0 starting nodes in concept networks&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">previous_starting_node = </span><span class="si">{</span><span class="n">previous_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deleting starting coordinate from nodes: </span><span class="si">{</span><span class="n">previous_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">prev_st_node</span> <span class="ow">in</span> <span class="n">previous_starting_node</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prev_st_node</span><span class="p">][</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prev_st_node</span><span class="p">][</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prev_st_node</span><span class="p">][</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">prev_st_node</span><span class="p">][</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        
        
        
        
        <span class="c1">#print(f&quot;matching_concept_network_dict = {matching_concept_network_dict}&quot;)</span>
        <span class="n">curr_starting_node</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
        <span class="n">curr_starting_coordinate</span><span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>
        <span class="n">curr_touching_soma_vertices</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
        <span class="n">curr_soma_group_idx</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Applying the set_directional change!!!!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_touching_soma_vertices = </span><span class="si">{</span><span class="n">curr_touching_soma_vertices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#set the starting coordinate in the concept network</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_starting_node</span><span class="p">:{</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">:</span><span class="n">curr_starting_coordinate</span><span class="p">,</span>
                                    <span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">:</span><span class="n">curr_touching_soma_vertices</span><span class="p">,</span>
                                    <span class="s2">&quot;soma_group_idx&quot;</span><span class="p">:</span><span class="n">curr_soma_group_idx</span><span class="p">,</span>
                                    <span class="s2">&quot;starting_soma&quot;</span><span class="p">:</span><span class="n">starting_soma</span><span class="p">}</span>
                <span class="p">}</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;attrs = </span><span class="si">{</span><span class="n">attrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">attrs</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;self.concept_network.nodes[curr_starting_node] = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">curr_starting_node</span><span class="p">]</span><span class="w"> </span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1">#make sure only one starting coordinate</span>
        <span class="n">new_starting_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New starting coordinate at node </span><span class="si">{</span><span class="n">new_starting_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        
        <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_node</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_endpoints&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_soma_group_idx</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --- 1/4/2021 Change: Making so redoes the edges of the concept network when resetting the source</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Now need to reset the edges according to the new starting info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_concept_network_edges_from_current_starting_data</span><span class="p">()</span>

        
        <span class="k">if</span> <span class="n">print_flag</span> <span class="ow">or</span> <span class="n">convert_concept_network_to_directional_verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_directional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_concept_network_to_directional</span><span class="p">(</span><span class="n">no_cycles</span> <span class="o">=</span> <span class="n">no_cycles</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                                                                                           <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="n">suppress_disconnected_errors</span><span class="p">,</span>
                                                                                           <span class="n">convert_concept_network_to_directional_verbose</span><span class="o">=</span><span class="n">convert_concept_network_to_directional_verbose</span><span class="p">,</span>
                                                                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">concept_network_directional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_concept_network_to_directional</span><span class="p">(</span><span class="n">no_cycles</span> <span class="o">=</span> <span class="n">no_cycles</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                                                                                               <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="n">suppress_disconnected_errors</span><span class="p">,</span>
                                                                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="Limb.set_concept_network_edges_from_current_starting_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.set_concept_network_edges_from_current_starting_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_concept_network_edges_from_current_starting_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">new_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_to_concept_network</span><span class="p">(</span><span class="n">curr_branch_skeletons</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divided_skeletons</span><span class="p">,</span>
                                                                  <span class="n">starting_coordinate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">,</span>
                                                                  <span class="n">starting_edge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span><span class="p">,</span>
                                                                  <span class="n">touching_soma_vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span><span class="p">,</span>
                                                                       <span class="n">soma_group_idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_soma_group_idx</span><span class="p">,</span>
                                                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deleted_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">created_edges</span><span class="p">)</span></div>
        
        
    
        
    <span class="c1"># ----------------- 9/2 To help with compression ------------------------- #</span>
<div class="viewcode-block" id="Limb.get_attribute_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_attribute_dict">[docs]</a>    <span class="k">def</span> <span class="nf">get_attribute_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">):</span>
        <span class="n">attribute_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1">#for branch_idx,curr_branch in enumerate(self):</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="n">curr_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">branch_mesh_attributes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">curr_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">curr_attr</span><span class="p">):</span>
                            <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_attr</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">curr_attr</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">object_attributes</span><span class="p">:</span>
                    <span class="n">curr_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">curr_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">curr_attr</span><span class="p">):</span>
                            <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">export</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_attr</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_attr</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">att_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">attribute_name</span> <span class="o">==</span> <span class="s2">&quot;spines_volume&quot;</span> <span class="ow">and</span> <span class="n">att_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">att_val</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">att_val</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span> 
                        <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="k">return</span> <span class="n">attribute_dict</span></div>
    
<div class="viewcode-block" id="Limb.set_attribute_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.set_attribute_dict">[docs]</a>    <span class="k">def</span> <span class="nf">set_attribute_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">branch_idx</span><span class="p">,</span><span class="n">curr_branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">branch_mesh_attributes</span><span class="p">:</span>
                    <span class="c1">#print(f&quot;     Branch {branch_idx}&quot;)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                        <span class="c1">#print(f&quot;curr_branch.mesh = {curr_branch.mesh}&quot;)</span>
                            <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span>
                                    <span class="p">[</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]])</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span>
                                    <span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">object_attributes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,[</span><span class="n">object_name_to_class</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">](</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">att_val</span> <span class="o">=</span> <span class="n">attribute_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">attribute_name</span> <span class="o">==</span> <span class="s2">&quot;spines_volume&quot;</span> <span class="ow">and</span> <span class="n">att_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">att_val</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">att_val</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span><span class="n">att_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping attributes for Branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> because not in dictionary&quot;</span><span class="p">)</span></div>
                
<div class="viewcode-block" id="Limb.set_computed_attribute_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.set_computed_attribute_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_computed_attribute_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">computed_attribute_data</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">computed_attribute_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">computed_attribute_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Limb.get_computed_attribute_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Limb.get_computed_attribute_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_computed_attribute_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">attributes</span> <span class="o">=</span> <span class="n">computed_attribute_list</span><span class="p">,</span>
                                    <span class="n">one_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">lookup_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lookup_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span> 
            <span class="n">current_lookup_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute_dict</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">lookup_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_lookup_value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">one_dict</span><span class="p">:</span>
                <span class="n">lookup_dict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_lookup_value</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for spine/bouton/width compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="n">one_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lookup_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lookup_values</span></div>
                
    
    <span class="c1"># Defining some useful built in functions</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">newvalue</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newvalue</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="c1">#for the iterable</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#print(f&quot;Limb self._index = {self._index}&quot;)</span>
        <span class="n">sorted_node_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">sorted_node_indexes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]]</span>
    
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Computes equality of all members except the face_idx</span>
<span class="sd">        </span>
<span class="sd">        Things we want to compare: </span>
<span class="sd">        &#39;all_concept_network_data&#39;, #array of dictionary: inside dictionary</span>
<span class="sd">        </span>
<span class="sd">        How to compare this array of dictionaries (because may not be in order)</span>
<span class="sd">        Pseudocode</span>
<span class="sd">        0) check that arrays are the same size (if not register as a difference)</span>
<span class="sd">        1) make an array of all the indexes in the self and than other arrays</span>
<span class="sd">        2) Start with the first index in self array:</span>
<span class="sd">        a. Iterate with those left in the other array to see if can match a dictionary </span>
<span class="sd">        b. Once find a match, eliminate those indices from the lists and add as a pairings</span>
<span class="sd">        c. Go to next one in list</span>
<span class="sd">        d. If can&#39;t find pairing, add to differnces list and keep going</span>
<span class="sd">        </span>
<span class="sd">        3) At end if no differences then make sure self and others indicies list is empty</span>

<span class="sd">        </span>
<span class="sd">         &#39;concept_network&#39;, #networkx graph</span>
<span class="sd">         &#39;concept_network_directional&#39;, #networkx graph</span>
<span class="sd">         &#39;current_starting_coordinate&#39;, #np.array</span>
<span class="sd">         &#39;current_starting_endpoints&#39;, #np.array (for endpoints)</span>
<span class="sd">         &#39;current_starting_node&#39;, #int</span>
<span class="sd">         </span>
<span class="sd">         &#39;current_starting_soma&#39;,#int</span>
<span class="sd">         &#39;label&#39;, #list</span>
<span class="sd">         &#39;mesh&#39;, #mesh (compare_meshes_by_face_midpoints)</span>
<span class="sd">         &#39;mesh_center&#39;, #1D array (compare threshold)</span>
<span class="sd">         &#39;mesh_face_idx&#39; #set comparison </span>
<span class="sd">         </span>
<span class="sd">         </span>
<span class="sd">         Example: How tested the comparison</span>
<span class="sd">         tu = reload(tu)</span>
<span class="sd">        neuron= reload(neuron)</span>
<span class="sd">        xu = reload(xu)</span>
<span class="sd">        example_limb = double_soma_obj.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;]</span>
<span class="sd">        example_limb.labels = example_limb.label</span>
<span class="sd">        [k for k in dir(example_limb) if &quot;__&quot; not in k]</span>
<span class="sd">        L1 = neuron.Limb(example_limb)</span>

<span class="sd">        L2 = neuron.Limb(L1)</span>

<span class="sd">        #----testing the all_concept_network_data</span>
<span class="sd">        # L1.all_concept_network_data = [L1.all_concept_network_data[1],L1.all_concept_network_data[0]]</span>
<span class="sd">        # L2.all_concept_network_data[0][&quot;starting_soma&quot;] = 10</span>

<span class="sd">        #---testing the concept network comparison</span>
<span class="sd">        #L1.concept_network.nodes[1][&quot;data&quot;].skeleton[0][0][0] = 1</span>
<span class="sd">        #L2.concept_network.remove_node(1)</span>
<span class="sd">        #L2.concept_network.nodes[1][&quot;data&quot;].mesh = L2.concept_network.nodes[1][&quot;data&quot;].mesh.submesh([np.arange(len(L2.concept_network.nodes[1][&quot;data&quot;].mesh.faces)-1)],append=True)</span>

<span class="sd">        #---testing concept_network_directional</span>
<span class="sd">        #L1.concept_network_directional.nodes[1][&quot;data&quot;].skeleton[0][0][0] = 1</span>
<span class="sd">        #L2.concept_network_directional.remove_node(1)</span>
<span class="sd">        #L2.concept_network_directional.nodes[1][&quot;data&quot;].mesh = L2.concept_network.nodes[1][&quot;data&quot;].mesh.submesh([np.arange(len(L2.concept_network.nodes[1][&quot;data&quot;].mesh.faces)-1)],append=True)</span>

<span class="sd">        #----testing current_starting_endpoints</span>
<span class="sd">        #L2.current_starting_endpoints = np.array([[1,2,3],[4,5,6]])</span>

<span class="sd">        #---- testing current_starting_soma</span>
<span class="sd">        #L1.current_starting_soma=10</span>

<span class="sd">        #---- testing current_starting_soma</span>
<span class="sd">        #L2.labels=[&quot;new_labels&quot;]</span>

<span class="sd">        # --- mesh_face_idx</span>

<span class="sd">        #L1.mesh_face_idx= np.array([])</span>

<span class="sd">        #----testing mesh_center</span>
<span class="sd">        #L2.mesh_center = np.array([1,2,3])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#----------comparing the network dictionaries-------------</span>
        <span class="k">def</span> <span class="nf">__compare_concept_network_dicts</span><span class="p">(</span><span class="n">dict1</span><span class="p">,</span><span class="n">dict2</span><span class="p">):</span>
            <span class="n">endpoints_compare</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="n">dict1</span><span class="p">[</span><span class="s2">&quot;starting_endpoints&quot;</span><span class="p">],</span><span class="n">dict2</span><span class="p">[</span><span class="s2">&quot;starting_endpoints&quot;</span><span class="p">])</span>
            <span class="n">starting_node_compare</span> <span class="o">=</span> <span class="n">dict1</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">dict2</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
            <span class="n">starting_soma_compare</span> <span class="o">=</span> <span class="n">dict1</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">dict2</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
            <span class="n">starting_coordinate_compare</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="n">dict1</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">],</span><span class="n">dict2</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">endpoints_compare</span> <span class="ow">and</span> <span class="n">starting_node_compare</span> <span class="ow">and</span> <span class="n">starting_soma_compare</span> <span class="ow">and</span> <span class="n">starting_coordinate_compare</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lengths of all_concept_network_data did not match&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">other_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="n">pairings</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">self_indices</span><span class="p">:</span>
                <span class="n">found_match</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">other_indices</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__compare_concept_network_dicts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                      <span class="n">other</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                        <span class="c1">#if match was found then remove the matching indices from other indices and break</span>
                        <span class="n">other_indices</span> <span class="o">=</span> <span class="n">other_indices</span><span class="p">[</span><span class="n">other_indices</span> <span class="o">!=</span> <span class="n">j</span><span class="p">]</span>
                        <span class="n">pairings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">found_match</span><span class="o">=</span><span class="kc">True</span>
                        <span class="k">break</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">found_match</span><span class="p">:</span>    
                    <span class="c1">#if no match was found then add to the differences list</span>
                    <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No match found for self.all_concept_network_data[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]&quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Dictionary = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="c1">#should have pairings for all all indices</span>
            <span class="c1">#print(f&quot;pairings = {pairings}&quot;)</span>

        <span class="c1">#----------END OF comparing the network dictionaries-------------</span>
        
        
        <span class="c1"># Compare&#39;concept_network&#39;, #networkx graph</span>
        <span class="n">nx_compare_result</span><span class="p">,</span><span class="n">nx_diff_list</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_networks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                                          <span class="n">other</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">return_differences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nx_compare_result</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;concept_network didn&#39;t match&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Differences in compare_networks = </span><span class="si">{</span><span class="n">nx_diff_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
        <span class="c1">#Comparing concept_network_directional</span>
        <span class="n">nx_compare_result</span><span class="p">,</span><span class="n">nx_diff_list</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_networks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                                          <span class="n">other</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">return_differences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nx_compare_result</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;concept_network_directional didn&#39;t match&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Differences compare_networks = </span><span class="si">{</span><span class="n">nx_diff_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="c1">#Compare current_starting_coordinate </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_starting_coordinate didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.current_starting_coordinate = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.current_starting_coordinate = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="c1">#comparing the endpoints</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">current_starting_endpoints</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.endpoints = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_endpoints</span><span class="si">}</span><span class="s2">, other.endpoints = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">current_starting_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
        <span class="c1">#comparing current_starting_node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_node</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_starting_node didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.current_starting_node = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_node</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.current_starting_node = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">current_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
            
        <span class="c1">#comparing the current_starting_soma</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">current_starting_soma</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_starting_soma didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.current_starting_soma = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_starting_soma</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.current_starting_soma = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">current_starting_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
        <span class="c1">#comparing the labels:</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;labels didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.labels = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="si">}</span><span class="s2">, other.labels = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#comparing the meshes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh didn&#39;t match&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.mesh = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
    
        <span class="c1">#comparing the mesh centers    </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_center didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh_center = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="si">}</span><span class="s2">, other.mesh_center = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
        <span class="c1">#print out if face idx was different but not make part of the comparison</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">):</span>
<span class="c1">#             print(&quot;*** Warning: mesh_face_idx didn&#39;t match (but not factored into equality comparison)\n&quot;</span>
<span class="c1">#                  f&quot;set(self.mesh_face_idx) = {self.mesh_face_idx}, set(other.mesh_face_idx) = {other.mesh_face_idx}&quot;)</span>
            <span class="k">pass</span>
        
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Differences List:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">differences</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)   </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
    
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    
    <span class="c1"># ---------- 6/29 To help with navigating the concept network segments</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes_to_exclude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">axon_spines</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">short_thick_endnodes</span><span class="p">])</span></div>
        
        


<div class="viewcode-block" id="Soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Soma">[docs]</a><span class="k">class</span> <span class="nc">Soma</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that will hold one continus skeleton</span>
<span class="sd">    piece that has no branching</span>
<span class="sd">    </span>
<span class="sd">    Properties that are housed:</span>
<span class="sd">     &#39;mesh&#39;,</span>
<span class="sd">     &#39;mesh_center&#39;,</span>
<span class="sd">     &#39;mesh_face_idx&#39;,</span>
<span class="sd">     &#39;sdf&#39;,</span>
<span class="sd">     &#39;side_length_ratios&#39;,</span>
<span class="sd">     &#39;volume_ratio&#39;</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="Soma.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Soma.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh</span><span class="p">,</span><span class="n">mesh_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">volume_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">synapses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#Accounting for the fact that could recieve soma object</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">Soma</span><span class="p">):</span>
            <span class="c1">#print(&quot;Recived Soma object so copying object&quot;)</span>
            <span class="c1"># properties we are copying: [k for k in dir(example_limb) if &quot;__&quot; not in k]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="o">=</span><span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">sdf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">volume_ratio</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">side_length_ratios</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">side_length_ratios</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volume</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">_volume</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_volume</span> <span class="o">=</span> <span class="kc">None</span>
                
                
            <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;synapses&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">return</span> 
        
        <span class="c1">#print(&quot;bypassing soma object initialization&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="o">=</span><span class="n">sdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">mesh_face_idx</span>
        <span class="k">if</span> <span class="n">volume_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">soma_volume_ratio</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                     <span class="c1">#watertight_method=&quot;fill_holes&quot;</span>
                                                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using precomputed volume ratio&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span> <span class="o">=</span> <span class="n">volume_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">side_length_ratios</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">side_length_ratios</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_volume</span> <span class="o">=</span> <span class="n">volume</span>
        
        <span class="k">if</span> <span class="n">synapses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="n">synapses</span>
        
        <span class="k">if</span> <span class="n">volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span></div>
        
    
    <span class="nd">@property</span>          
    <span class="k">def</span> <span class="nf">compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;soma&quot;</span>
        
    <span class="nd">@property</span>          
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">area</span><span class="o">/</span><span class="mi">1_000_000</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">watertight_method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span><span class="n">divisor</span> <span class="o">=</span> <span class="mi">1_000_000_000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will compute the volume of the soma</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_volume</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                         <span class="n">watertight_method</span><span class="o">=</span><span class="n">watertight_method</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_volume</span><span class="o">/</span><span class="n">divisor</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span>
        
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="c1">#print(&quot;inside equality function&quot;)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Computes equality of all members except the face_idx (will print out if not equal)</span>
<span class="sd">        </span>
<span class="sd">        Properties that need to be checked:</span>
<span class="sd">        &#39;mesh&#39;,</span>
<span class="sd">         &#39;mesh_center&#39;,</span>
<span class="sd">         &#39;mesh_face_idx&#39;,</span>
<span class="sd">         &#39;sdf&#39;,</span>
<span class="sd">         &#39;side_length_ratios&#39;,</span>
<span class="sd">         &#39;volume_ratio&#39;</span>
<span class="sd">        </span>
<span class="sd">        Example of How tested it: </span>
<span class="sd">        </span>
<span class="sd">        tu = reload(tu)</span>
<span class="sd">        neuron= reload(neuron)</span>
<span class="sd">        xu = reload(xu)</span>
<span class="sd">        example_soma = double_soma_obj.concept_network.nodes[&quot;S0&quot;][&quot;data&quot;]</span>
<span class="sd">        S1 = neuron.Soma(example_soma)</span>
<span class="sd">        S2 = neuron.Soma(example_soma)</span>

<span class="sd">        #----testing mesh_center</span>
<span class="sd">        S2.mesh_center = np.array([1,2,3])</span>

<span class="sd">        #---- testing side_length_ratios</span>
<span class="sd">        S1.side_length_ratios=[10,19,20]</span>

<span class="sd">        #---- testing current_starting_soma</span>
<span class="sd">        S2.volume_ratio = 14</span>

<span class="sd">        # --- mesh_face_idx</span>
<span class="sd">        S2.mesh_face_idx= np.array([])</span>

<span class="sd">        #----testing mesh_center</span>
<span class="sd">        S2.sdf = 14</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#comparing the meshes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh didn&#39;t match&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.mesh = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_center didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh_center = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="si">}</span><span class="s2">, other.mesh_center = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="c1">#print out if face idx was different but not make part of the comparison</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">):</span>
<span class="c1">#             print(&quot;*** Warning: mesh_face_idx didn&#39;t match (but not factored into equality comparison)&quot;)</span>
            <span class="k">pass</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">sdf</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sdf didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.sdf = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="si">}</span><span class="s2">, other.sdf = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">sdf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">side_length_ratios</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">side_length_ratios</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;side_length_ratios didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.side_length_ratios = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">side_length_ratios</span><span class="si">}</span><span class="s2">, other.side_length_ratios = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">side_length_ratios</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">compare_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">volume_ratio</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;volume_ratio didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.volume_ratio = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">volume_ratio</span><span class="si">}</span><span class="s2">, other.volume_ratio = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">volume_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Differences List:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">differences</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)   </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
    
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="c1">#print(f&quot;self.__eq__(other) = {self.__eq__(other)}&quot;)</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<span class="c1">#from neurd import preprocess_neuron as pn</span>

<div class="viewcode-block" id="Neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron">[docs]</a><span class="k">class</span> <span class="nc">Neuron</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Neuron class docstring: </span>
<span class="sd">    Will </span>
<span class="sd">    </span>
<span class="sd">    Purpose: </span>
<span class="sd">    An object oriented approach to housing the data</span>
<span class="sd">    about a single neuron mesh and the secondary </span>
<span class="sd">    data that can be gleamed from this. For instance</span>
<span class="sd">    - skeleton</span>
<span class="sd">    - compartment labels</span>
<span class="sd">    - soma centers</span>
<span class="sd">    - subdivided mesh into cable pieces</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    </span>
<span class="sd">    1) Create Neuron Object (through __init__)</span>
<span class="sd">    a. Add the small non_soma_list_meshes</span>
<span class="sd">    b. Add whole mesh</span>
<span class="sd">    c. Add soma_to_piece_connectivity as concept graph and it will be turned into a concept map</span>

<span class="sd">    2) Creat the soma meshes</span>
<span class="sd">    a. Create soma mesh objects</span>
<span class="sd">    b. Add the soma objects as [&quot;data&quot;] attribute of all of the soma nodes</span>

<span class="sd">    3) Limb Process: For each limb (use an index to iterate through limb_correspondence,current_mesh_data and limb_concept_network/lables) </span>
<span class="sd">    a. Build all the branches from the </span>
<span class="sd">        - mesh</span>
<span class="sd">        - skeleton</span>
<span class="sd">        - width</span>
<span class="sd">        - branch_face_idx</span>
<span class="sd">    b. Pick the top concept graph (will use to store the nodes)</span>
<span class="sd">    c. Put the branches as &quot;data&quot; in the network</span>
<span class="sd">    d. Get all of the starting coordinates and starting edges and put as member attributes in the limb</span>

<span class="sd">    Example 1:</span>
<span class="sd">    How you could generate completely from mesh to help with debugging:</span>
<span class="sd">    </span>
<span class="sd">    # from mesh_tools import trimesh_utils as tu</span>
<span class="sd">    # mesh_file_path = Path(&quot;/notebooks/test_neurons/multi_soma_example.off&quot;)</span>
<span class="sd">    # mesh_file_path.exists()</span>
<span class="sd">    # current_neuron_mesh = tu.load_mesh_no_processing(str(mesh_file_path.absolute()))</span>

<span class="sd">    # # picking a random segment id</span>
<span class="sd">    # segment_id = 12345</span>
<span class="sd">    # description = &quot;double_soma_meshafterparty&quot;</span>

<span class="sd">    # # --------------------- Processing the Neuron ----------------- #</span>
<span class="sd">    # from neurd import soma_extraction_utils as sm</span>

<span class="sd">    # somas = sm.extract_soma_center(segment_id,</span>
<span class="sd">    #                              current_neuron_mesh.vertices,</span>
<span class="sd">    #                              current_neuron_mesh.faces)</span>

<span class="sd">    # import time</span>
<span class="sd">    # meshparty_time = time.time()</span>
<span class="sd">    # from mesh_tools import compartment_utils as cu</span>
<span class="sd">    # cu = reload(cu)</span>

<span class="sd">    # from mesh_tools import meshparty_skeletonize as m_sk</span>
<span class="sd">    # from neurd import preprocess_neuron as pn</span>
<span class="sd">    # pn = reload(pn)</span>
<span class="sd">    # m_sk = reload(m_sk)</span>

<span class="sd">    # somas = somas</span>

<span class="sd">    # nru = reload(nru)</span>
<span class="sd">    # neuron = reload(neuron)</span>
<span class="sd">    # current_neuron = neuron.Neuron(</span>
<span class="sd">    #     mesh=current_neuron_mesh,</span>
<span class="sd">    #     segment_id=segment_id,</span>
<span class="sd">    #     description=description,</span>
<span class="sd">    #     decomposition_type=&quot;meshafterparty&quot;,</span>
<span class="sd">    #     somas = somas,</span>
<span class="sd">    #     #branch_skeleton_data=branch_skeleton_data,</span>
<span class="sd">    #     suppress_preprocessing_print=False,</span>
<span class="sd">    # )</span>
<span class="sd">    # print(f&quot;Total time for processing: {time.time() - meshparty_time}&quot;)</span>


<span class="sd">    # # ----------------- Calculating the Spines and Width ----------- #</span>
<span class="sd">    # current_neuron.calculate_spines(print_flag=True)</span>
<span class="sd">    # #nviz.plot_spines(current_neuron)</span>

<span class="sd">    # current_neuron.calculate_new_width(no_spines=False,</span>
<span class="sd">    #                                        distance_by_mesh_center=True)</span>

<span class="sd">    # current_neuron.calculate_new_width(no_spines=False,</span>
<span class="sd">    #                                        distance_by_mesh_center=True,</span>
<span class="sd">    #                                        summary_measure=&quot;median&quot;)</span>

<span class="sd">    # current_neuron.calculate_new_width(no_spines=True,</span>
<span class="sd">    #                                        distance_by_mesh_center=True,</span>
<span class="sd">    #                                        summary_measure=&quot;mean&quot;)</span>

<span class="sd">    # current_neuron.calculate_new_width(no_spines=True,</span>
<span class="sd">    #                                        distance_by_mesh_center=True,</span>
<span class="sd">    #                                        summary_measure=&quot;median&quot;)</span>

<span class="sd">    # # ------------------ Saving off the Neuron --------------- #</span>
<span class="sd">    # current_neuron.save_compressed_neuron(output_folder=Path(&quot;/notebooks/test_neurons/meshafterparty_processed/&quot;),</span>
<span class="sd">    #                                      export_mesh=True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Neuron.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nucleus_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">split_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preprocessed_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        
        <span class="n">fill_hole_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="c1"># The old value for the parameter when performing 2000,</span>
        <span class="n">decomposition_type</span><span class="o">=</span><span class="s2">&quot;meshafterparty&quot;</span><span class="p">,</span>
        <span class="n">meshparty_adaptive_correspondence_after_creation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        
        <span class="n">calculate_spines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">widths_to_calculate</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">],</span>
    

        <span class="n">suppress_preprocessing_print</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">computed_attribute_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">branch_skeleton_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        
        
        <span class="n">ignore_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">suppress_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suppress_all_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    
        <span class="n">preprocessing_version</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">limb_to_branch_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        
        <span class="n">glia_faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">glia_meshes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="p">[],</span>
        
        <span class="n">preprocess_neuron_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
        <span class="n">spines_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
        <span class="n">pipeline_products</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
<span class="c1">#                  concept_network=None,</span>
<span class="c1">#                  non_graph_meshes=dict(),</span>
<span class="c1">#                  pre_processed_mesh = dict()</span>
<span class="c1">#                 ):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;here would be calling any super classes inits</span>
<span class="sd">        Ex: Parent.__init(self)</span>
<span class="sd">        </span>
<span class="sd">        Class can act like a dictionary and can d</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1">#covering the scenario where the data was recieved was actually another neuron class</span>
        <span class="c1">#print(f&quot;type of mesh = {mesh.__class__}&quot;)</span>
        <span class="c1">#print(f&quot;type of self = {self.__class__}&quot;)</span>
        
        <span class="k">if</span> <span class="n">pipeline_products</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">glia_meshes</span> <span class="o">=</span> <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;glia_meshes&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nuclei_meshes&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">somas</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">),</span>
                    <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;soma_run_time&quot;</span><span class="p">),</span>
                    <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">),</span>
                <span class="p">]</span>
                
            <span class="k">if</span> <span class="n">segment_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">segment_id</span> <span class="o">=</span> <span class="n">pipeline_products</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;segment_id&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                
        
        <span class="n">neuron_creation_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">glia_meshes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nuclei_meshes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">glia_faces</span><span class="p">,</span><span class="n">nuclei_faces</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">glia_nuclei_faces_from_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span>
                <span class="n">glia_meshes</span><span class="p">,</span>
                <span class="n">nuclei_meshes</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">suppress_output</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_all_output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Processing Neuorn in minimal output mode...please wait&quot;</span><span class="p">)</span>
        
        
        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="n">suppress_output</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>

            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
                <span class="c1">#print(&quot;Recieved another instance of Neuron class in init -- so just copying data&quot;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span><span class="o">=</span><span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">segment_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">preprocessed_data</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">copy_concept_network</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
                
                <span class="c1">#mesh pieces</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">inside_pieces</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">insignificant_limbs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">not_processed_soma_containing_meshes</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">not_processed_soma_containing_meshes</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">glia_faces</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">glia_faces</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span><span class="p">)</span>
                
                
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;decomposition_type&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">decomposition_type</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">decomposition_type</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">decomposition_type</span> <span class="o">=</span> <span class="kc">None</span>
                    
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;original_mesh_idx&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">original_mesh_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="kc">None</span>
                    
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;labels&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">dc</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
                    
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;_mesh_kdtree&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_kdtree</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">_mesh_kdtree</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_kdtree</span> <span class="o">=</span> <span class="kc">None</span>
                    
                    
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;distance_errored_synapses&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">distance_errored_synapses</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="p">[]</span>
                    
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;mesh_errored_synapses&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">mesh_errored_synapses</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="p">[]</span>
                    
                    
                <span class="c1"># ---- 6/11: Adding Nucleus Id --------</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_index</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;split_index&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="n">dc_check</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;align_matrix&quot;</span><span class="p">)</span>
                    
                <span class="c1">#in order to become an iterable</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                
                <span class="n">nru</span><span class="o">.</span><span class="n">recalculate_endpoints_and_order_skeletons_over_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                
                
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_products</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">PipelineProducts</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;pipeline_products&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                    <span class="p">)</span>   
                
                <span class="k">return</span> 
                
                
        
            <span class="k">if</span> <span class="n">ignore_warnings</span><span class="p">:</span> 
                <span class="n">su</span><span class="o">.</span><span class="n">ignore_warnings</span><span class="p">()</span>
                
            <span class="c1">#in order to become an iterable</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="n">original_mesh_idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_kdtree</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">segment_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">segment_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;picking a random 7 digit segment id: </span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s2">&quot;_random_id&quot;</span>
            


            <span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decomposition_type</span> <span class="o">=</span> <span class="n">decomposition_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">nucleus_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_index</span> <span class="o">=</span> <span class="n">split_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_products</span> <span class="o">=</span> <span class="n">pl</span><span class="o">.</span><span class="n">PipelineProducts</span><span class="p">(</span><span class="n">pipeline_products</span><span class="p">)</span>


            <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">preprocessed_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- 0) Having to preprocess the Neuron becuase no preprocessed data</span><span class="se">\n</span><span class="s2">Please wait this could take a while.....&quot;</span><span class="p">)</span>
                
                <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="n">suppress_preprocessing_print</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">fill_hole_size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">vert_holes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertex_groups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                        <span class="n">vert_holes_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vert_holes</span><span class="p">])</span>
                        <span class="n">fill_hole_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">fill_hole_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating max hole filling size as </span><span class="si">{</span><span class="n">fill_hole_size</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

                        
                    <span class="k">if</span> <span class="n">fill_hole_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertex_groups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">max_hole_size</span><span class="o">=</span><span class="n">fill_hole_size</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**** Tried to fill holes but was unable to, just preceeding on*****&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">vert_holes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_vertex_groups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                            <span class="n">vert_holes_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vert_holes</span><span class="p">])</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully filled all holes up to size </span><span class="si">{</span><span class="n">fill_hole_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Still existing holes = </span><span class="si">{</span><span class="n">vert_holes_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the hole filling&quot;</span><span class="p">)</span>
                        
                    <span class="k">if</span> <span class="n">preprocessing_version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;This preprocessing_version (</span><span class="si">{</span><span class="n">preprocessing_version</span><span class="si">}</span><span class="s2">) is no longer supported&quot;</span><span class="p">)</span>
<span class="c1">#                         preprocessed_data = pn.preprocess_neuron(mesh,</span>
<span class="c1">#                                          segment_id=segment_id,</span>
<span class="c1">#                                          description=description,</span>
<span class="c1">#                                           decomposition_type=decomposition_type,</span>
<span class="c1">#                                             mesh_correspondence=mesh_correspondence,</span>
<span class="c1">#                                             distance_by_mesh_center=distance_by_mesh_center,</span>
<span class="c1">#                                             meshparty_segment_size =meshparty_segment_size,</span>
<span class="c1">#                                              meshparty_n_surface_downsampling = meshparty_n_surface_downsampling,</span>
<span class="c1">#                                           somas=somas,</span>
<span class="c1">#                                             branch_skeleton_data=branch_skeleton_data,</span>
<span class="c1">#                                             combine_close_skeleton_nodes = combine_close_skeleton_nodes,</span>
<span class="c1">#                                             combine_close_skeleton_nodes_threshold=combine_close_skeleton_nodes_threshold)</span>
                    <span class="k">elif</span> <span class="n">preprocessing_version</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        
                        <span class="n">preprocessed_data</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">preprocess_neuron</span><span class="p">(</span>
                                                <span class="n">mesh</span><span class="p">,</span>
                                        <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                                         <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
                                          <span class="n">decomposition_type</span><span class="o">=</span><span class="n">decomposition_type</span><span class="p">,</span>
                                        <span class="n">somas</span><span class="o">=</span><span class="n">somas</span><span class="p">,</span> <span class="c1">#the precomputed somas</span>
                                        <span class="n">glia_faces</span><span class="o">=</span><span class="n">glia_faces</span><span class="p">,</span>
                                        <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="n">nuclei_faces</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">preprocess_neuron_kwargs</span><span class="p">)</span>
                        
                    
                    
                    
                    <span class="c1">#print(f&quot;preprocessed_data inside with = {preprocessed_data}&quot;)</span>
                        
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Already have preprocessed data&quot;</span><span class="p">)</span>

                
            <span class="c1">#--- 6/11: adding nuclues id ------</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nucleus_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">split_index</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;split_index&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            
            
            <span class="c1">#print(f&quot;preprocessed_data inside with = {preprocessed_data}&quot;)</span>

            <span class="c1">#this is for if ever you want to copy the neuron from one to another or save it off?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preprocessed_data</span> <span class="o">=</span> <span class="n">preprocessed_data</span>


            <span class="c1">#self.non_graph_meshes = preprocessed_data[&quot;non_graph_meshes&quot;]</span>
            <span class="n">limb_concept_networks</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">]</span>
            <span class="n">limb_correspondence</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">]</span>
            <span class="n">limb_meshes</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">]</span>
            <span class="n">limb_labels</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_labels&quot;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;insignificant_limbs&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">not_processed_soma_containing_meshes</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;not_processed_soma_containing_meshes&quot;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="s2">&quot;glia_faces&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">glia_faces</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;glia_faces&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">glia_faces</span> <span class="o">=</span> <span class="p">[]</span>
                
            <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;inside_pieces&quot;</span><span class="p">]</span>

            <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span>
            <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span>
            <span class="n">soma_sdfs</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="s2">&quot;soma_volumes&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volumes&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">soma_volumes</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volumes&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">soma_volumes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_sdfs</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="s2">&quot;soma_volume_ratios&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No soma volume ratios so computing them now&quot;</span><span class="p">)</span>                                                          
                <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sm</span><span class="o">.</span><span class="n">soma_volume_ratio</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">soma_meshes</span><span class="p">]</span>
                
            <span class="c1"># -------- 6/9 addition: synapses that are saved off--------</span>
            <span class="k">if</span> <span class="s2">&quot;soma_synapses&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">soma_synapses</span> <span class="o">=</span> <span class="p">[</span><span class="n">syu</span><span class="o">.</span><span class="n">exports_to_synapses</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_synapses&quot;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">soma_synapses</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_sdfs</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="s2">&quot;distance_errored_synapses&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">exports_to_synapses</span><span class="p">(</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;distance_errored_synapses&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="p">[]</span>
                
            <span class="k">if</span> <span class="s2">&quot;mesh_errored_synapses&quot;</span> <span class="ow">in</span> <span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">exports_to_synapses</span><span class="p">(</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;mesh_errored_synapses&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="p">[]</span>
                
                
                
            <span class="n">soma_volume_ratios</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span>
                
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 1) Finished unpacking preprocessed materials: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1"># builds the networkx graph where we will store most of the data</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soma_to_piece_connectivity</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">soma_to_piece_connectivity</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">soma_to_piece_connectivity</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">concept_network</span> <span class="o">=</span> <span class="n">convert_soma_to_piece_connectivity_to_graph</span><span class="p">(</span><span class="n">soma_to_piece_connectivity</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">concept_network</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved an incompatible type of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">soma_to_piece_connectivity</span><span class="p">)</span><span class="si">}</span><span class="s2"> for the concept_network&quot;</span><span class="p">)</span>
                
            

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 2) Finished creating neuron connectivity graph: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            2) Creat the soma meshes</span>
<span class="sd">            a. Create soma mesh objects</span>
<span class="sd">            b. Add the soma objects as [&quot;data&quot;] attribute of all of the soma nodes</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="s2">&quot;soma_meshes_face_idx&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">soma_meshes_face_idx</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_meshes_face_idx&quot;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using already existing soma_meshes_face_idx in preprocessed data &quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Having to generate soma_meshes_face_idx because none in preprocessed data&quot;</span><span class="p">)</span>
                <span class="n">soma_meshes_face_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">curr_soma</span> <span class="ow">in</span> <span class="n">soma_meshes</span><span class="p">:</span>
                    <span class="n">curr_soma_meshes_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">curr_soma</span><span class="p">,</span>
                           <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">soma_meshes_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_soma_meshes_face_idx</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 3a) Finshed generating soma_meshes_face_idx: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">curr_soma</span><span class="p">,</span><span class="n">curr_soma_face_idx</span><span class="p">,</span><span class="n">current_sdf</span><span class="p">,</span><span class="n">curr_volume_ratio</span><span class="p">,</span><span class="n">curr_volume</span><span class="p">,</span><span class="n">curr_synapses</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">soma_meshes_face_idx</span><span class="p">,</span><span class="n">soma_sdfs</span><span class="p">,</span><span class="n">soma_volume_ratios</span><span class="p">,</span><span class="n">soma_volumes</span><span class="p">,</span><span class="n">soma_synapses</span><span class="p">)):</span>
                <span class="n">Soma_obj</span> <span class="o">=</span> <span class="n">Soma</span><span class="p">(</span><span class="n">curr_soma</span><span class="p">,</span>
                                <span class="n">mesh_face_idx</span><span class="o">=</span><span class="n">curr_soma_face_idx</span><span class="p">,</span>
                                <span class="n">sdf</span><span class="o">=</span><span class="n">current_sdf</span><span class="p">,</span>
                                <span class="n">volume_ratio</span><span class="o">=</span><span class="n">curr_volume_ratio</span><span class="p">,</span>
                               <span class="n">volume</span><span class="o">=</span><span class="n">curr_volume</span><span class="p">,</span>
                               <span class="n">synapses</span> <span class="o">=</span> <span class="n">curr_synapses</span><span class="p">)</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 3b) Finished soma creation: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
                
                <span class="n">soma_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="c1">#Add the soma object as data in </span>
                
                <span class="c1"># --- 11/21 adaption that accounts for if soma is not in the concept network</span>
                <span class="k">if</span> <span class="n">soma_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                    <span class="n">xu</span><span class="o">.</span><span class="n">set_node_data</span><span class="p">(</span><span class="n">curr_network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                         <span class="n">node_name</span><span class="o">=</span><span class="n">soma_name</span><span class="p">,</span>
                                         <span class="n">curr_data</span><span class="o">=</span><span class="n">Soma_obj</span><span class="p">,</span>
                                         <span class="n">curr_data_label</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not have </span><span class="si">{</span><span class="n">soma_name</span><span class="si">}</span><span class="s2"> in concept network so adding it&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">soma_name</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">Soma_obj</span><span class="p">)</span>
                    
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 3) Finshed generating soma objects and adding them to concept graph: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            3) Add the limbs to the graph:</span>
<span class="sd">            a. Create the limb objects and their associated names</span>
<span class="sd">            (use an index to iterate through limb_correspondence,current_mesh_data and limb_concept_network/lables) </span>
<span class="sd">            b. Add the limbs to the neuron concept graph nodes</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="s2">&quot;limb_mehses_face_idx&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">limb_mehses_face_idx</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_mehses_face_idx&quot;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using already existing limb_mehses_face_idx in preprocessed data &quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">limb_mehses_face_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">limb_meshes</span><span class="p">:</span>
                    <span class="n">curr_limb_meshes_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">curr_limb</span><span class="p">,</span>
                           <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">limb_mehses_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_meshes_face_idx</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 4a) Finshed generating curr_limb_meshes_face_idx: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#         print(&quot;Returning so can debug&quot;)</span>
    <span class="c1">#         return</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">curr_limb_mesh_face_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">limb_meshes</span><span class="p">,</span><span class="n">limb_mehses_face_idx</span><span class="p">)):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                will just find the curr_limb_concept_network, curr_limb_label by indexing</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">curr_limb_correspondence</span> <span class="o">=</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">curr_limb_concept_networks</span> <span class="o">=</span> <span class="n">limb_concept_networks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">curr_limb_label</span> <span class="o">=</span> <span class="n">limb_labels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">limb_to_branch_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">limb_to_branch_objects</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">branch_objects</span> <span class="o">=</span> <span class="n">limb_to_branch_objects</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">branch_objects</span> <span class="o">=</span> <span class="kc">None</span>
                    

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb_concept_networks= </span><span class="si">{</span><span class="n">curr_limb_concept_networks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">Limb_obj</span> <span class="o">=</span> <span class="n">Limb</span><span class="p">(</span>
                                 <span class="n">mesh</span><span class="o">=</span><span class="n">curr_limb_mesh</span><span class="p">,</span>
                                 <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="n">curr_limb_correspondence</span><span class="p">,</span>
                                 <span class="n">concept_network_dict</span><span class="o">=</span><span class="n">curr_limb_concept_networks</span><span class="p">,</span>
                                 <span class="n">mesh_face_idx</span><span class="o">=</span><span class="n">curr_limb_mesh_face_idx</span><span class="p">,</span>
                                 <span class="n">labels</span><span class="o">=</span><span class="n">curr_limb_label</span><span class="p">,</span>
                                <span class="n">branch_objects</span> <span class="o">=</span> <span class="n">branch_objects</span>
                                <span class="p">)</span>


                <span class="n">limb_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="c1">#Add the soma object as data in</span>
                <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span>
                
                <span class="n">xu</span><span class="o">.</span><span class="n">set_node_data</span><span class="p">(</span><span class="n">curr_network</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                     <span class="n">node_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                                     <span class="n">curr_data</span><span class="o">=</span><span class="n">Limb_obj</span><span class="p">,</span>
                                     <span class="n">curr_data_label</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>

                <span class="c1">#xu.set_node_data(self.concept_network,node_name=soma_name,curr_data=Soma_obj,curr_data_label=&quot;data&quot;)</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 4) Finshed generating Limb objects and adding them to concept graph: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            

            <span class="k">if</span> <span class="n">decomposition_type</span> <span class="o">==</span> <span class="s2">&quot;meshparty&quot;</span> <span class="ow">and</span> <span class="n">meshparty_adaptive_correspondence_after_creation</span><span class="p">:</span>
                <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 5) Doing the adaptive mesh correspondence on the meshparty preprocessing ---&quot;</span><span class="p">)</span>
                <span class="n">nru</span><span class="o">.</span><span class="n">apply_adaptive_mesh_correspondence_to_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 5) Finished Doing the adaptive mesh correspondence on the meshparty preprocessing: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 5) SKIPPING Doing the adaptive mesh correspondence on the meshparty preprocessing ---&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">computed_attribute_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">neuron_start_time</span> <span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 6) Using the computed_attribute_dict to populate neuron attributes ---&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_computed_attribute_data</span><span class="p">(</span><span class="n">computed_attribute_dict</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 6) FINISHED Using the computed_attribute_dict to populate neuron attributes: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- 6) SKIPPING Using the computed_attribute_dict to populate neuron attributes ---&quot;</span><span class="p">)</span>
                
            <span class="c1"># printing what concept network looks like </span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;self.n_limbs = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_limbs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                
                
                <span class="k">if</span> <span class="n">calculate_spines</span><span class="p">:</span>
                    <span class="c1">#check to see that spines don&#39;t already exist</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;7) Calculating the spines for the neuorn if do not already exist&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spines_already_computed</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;7a) calculating spines because didn&#39;t exist&quot;</span><span class="p">)</span>
                        <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spines_on_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">spines_kwargs</span><span class="p">)</span>
                        <span class="c1">#self.calculate_spines() the old function for calculating spines</span>
                        

                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths_to_calculate</span><span class="p">:</span>
                    <span class="n">wu</span><span class="o">.</span><span class="n">calculate_new_width_for_neuron_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">width_name</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
                    
                <span class="c1"># ----------- 1/25 Addition that cleans the concept networks ------- #</span>
                <span class="n">nru</span><span class="o">.</span><span class="n">clean_neuron_all_concept_network_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the width and spine calculation because no limbs&quot;</span><span class="p">)</span>
                
            
            
        <span class="n">nru</span><span class="o">.</span><span class="n">recalculate_endpoints_and_order_skeletons_over_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_all_output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for neuron instance creation = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">neuron_creation_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
            
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
    
    
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;__&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;pipeline_products&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pipeline_products</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    
    
<div class="viewcode-block" id="Neuron.calculate_decomposition_products"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.calculate_decomposition_products">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_decomposition_products</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">store_in_obj</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">calculate_decomposition_products</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">store_in_obj</span> <span class="o">=</span> <span class="n">store_in_obj</span><span class="p">,</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="Neuron.calculate_multi_soma_split_suggestions"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.calculate_multi_soma_split_suggestions">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_multi_soma_split_suggestions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">store_in_obj</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="n">ret_result</span> <span class="o">=</span> <span class="n">ssu</span><span class="o">.</span><span class="n">calculate_multi_soma_split_suggestions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">store_in_obj</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        
        <span class="k">return</span> <span class="n">ret_result</span></div>
    
<div class="viewcode-block" id="Neuron.multi_soma_split_execution"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.multi_soma_split_execution">[docs]</a>    <span class="k">def</span> <span class="nf">multi_soma_split_execution</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">store_in_obj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
        
        <span class="k">return</span> <span class="n">ssu</span><span class="o">.</span><span class="n">multi_soma_split_execution</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">store_in_obj</span><span class="o">=</span><span class="n">store_in_obj</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
        
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valid_error_split_points_by_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dummy docstring</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rb_splits</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;red_blue_split_results&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ssu</span><span class="o">.</span><span class="n">limb_red_blue_dict_from_red_blue_splits</span><span class="p">(</span>
            <span class="n">rb_splits</span>     
        <span class="p">)</span>
        
    
<div class="viewcode-block" id="Neuron.get_total_n_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_total_n_branches">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_n_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">li</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">()])</span></div>
    
<div class="viewcode-block" id="Neuron.get_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">get_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">check_connected_component</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_whole_neuron_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">check_connected_component</span><span class="o">=</span><span class="n">check_connected_component</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Neuron.get_attribute_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_attribute_dict">[docs]</a>    <span class="k">def</span> <span class="nf">get_attribute_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">):</span>
        <span class="n">attribute_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1">#for limb_idx,curr_limb in enumerate(self):</span>
        <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">curr_limb</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
            <span class="n">attribute_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_attribute_dict</span><span class="p">(</span><span class="n">attribute_name</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">attribute_dict</span></div>
    
<div class="viewcode-block" id="Neuron.set_attribute_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.set_attribute_dict">[docs]</a>    <span class="k">def</span> <span class="nf">set_attribute_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1">#print(f&quot;Working on Limb {limb_idx}:&quot;)</span>
            <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">attribute_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_attribute_dict</span><span class="p">(</span><span class="n">attribute_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span></div>
                <span class="c1">#print(f&quot;Limb {limb_idx} not in attribute dict so skipping&quot;)</span>
            
<div class="viewcode-block" id="Neuron.set_computed_attribute_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.set_computed_attribute_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_computed_attribute_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">computed_attribute_data</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">computed_attribute_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">computed_attribute_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">        # Old way 1 of Setting </span>
<span class="sd">        width_array_lookup = dict()</span>
<span class="sd">        width_new_lookup = dict()</span>
<span class="sd">        spines_lookup = dict()</span>
<span class="sd">        </span>
<span class="sd">        for limb_idx,ex_limb in self:</span>
<span class="sd">            width_array_lookup = </span>

<span class="sd">        sorted_limb_labels = np.sort(self.get_limb_node_names())</span>
<span class="sd">        for limb_idx in sorted_limb_labels:</span>
<span class="sd">            ex_limb = self.concept_network.nodes[limb_idx][&quot;data&quot;]</span>

<span class="sd">            sorted_branch_labels = np.sort(ex_limb.concept_network.nodes())</span>
<span class="sd">            for branch_idx in sorted_branch_labels:</span>
<span class="sd">                if print_flag:</span>
<span class="sd">                    print(f&quot;---- Working on limb {limb_idx} branch {branch_idx} ------&quot;)</span>
<span class="sd">                ex_branch = ex_limb.concept_network.nodes[branch_idx][&quot;data&quot;]</span>

<span class="sd">                ex_branch.width_array = width_array_lookup[limb_idx][branch_idx] </span>
<span class="sd">                </span>
<span class="sd">                if not spines_lookup[limb_idx][branch_idx] is None:</span>
<span class="sd">                    ex_branch.spines = [ex_branch.submesh([k],append=True,repair=False) for k in spines_lookup[limb_idx][branch_idx]]</span>
<span class="sd">                else:</span>
<span class="sd">                    ex_branch.spines = None</span>
<span class="sd">                </span>
<span class="sd">                ex_branch.width_new = width_new_lookup[limb_idx][branch_idx]</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        # Old Way 2: </span>
<span class="sd">                </span>
<span class="sd">        width_array_lookup = spine_width_data[&quot;width_array_lookup&quot;]</span>
<span class="sd">        width_new_lookup = spine_width_data[&quot;width_new_lookup&quot;]</span>
<span class="sd">        spines_lookup = spine_width_data[&quot;spines_lookup&quot;]</span>
<span class="sd">        </span>
<span class="sd">        set_attribute_dict(&quot;width_array&quot;,width_array_lookup)</span>
<span class="sd">        set_attribute_dict(&quot;width_new&quot;,width_new_lookup)</span>
<span class="sd">        set_attribute_dict(&quot;spines&quot;,spines_lookup)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for spine/width compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Neuron.get_computed_attribute_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_computed_attribute_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_computed_attribute_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">attributes</span> <span class="o">=</span> <span class="n">computed_attribute_list</span><span class="p">,</span>
                                    <span class="n">one_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">lookup_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lookup_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span> 
            <span class="n">current_lookup_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute_dict</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">lookup_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_lookup_value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">one_dict</span><span class="p">:</span>
                <span class="n">lookup_dict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_lookup_value</span>

        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for spine/width compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">        # OLD WAY 1: OF DOING THIS WITHOUT ITERABLE</span>
<span class="sd">        width_array_lookup = dict()</span>
<span class="sd">        width_new_lookup = dict()</span>
<span class="sd">        spines_lookup = dict()</span>

<span class="sd">        sorted_limb_labels = np.sort(self.get_limb_node_names())</span>
<span class="sd">        for limb_idx in sorted_limb_labels:</span>
<span class="sd">            ex_limb = self.concept_network.nodes[limb_idx][&quot;data&quot;]</span>

<span class="sd">            spines_lookup[limb_idx] = dict()</span>
<span class="sd">            width_array_lookup[limb_idx] = dict()</span>
<span class="sd">            width_new_lookup[limb_idx] = dict()</span>

<span class="sd">            sorted_branch_labels = np.sort(ex_limb.concept_network.nodes())</span>
<span class="sd">            for branch_idx in sorted_branch_labels:</span>
<span class="sd">                if print_flag:</span>
<span class="sd">                    print(f&quot;---- Working on limb {limb_idx} branch {branch_idx} ------&quot;)</span>
<span class="sd">                ex_branch = ex_limb.concept_network.nodes[branch_idx][&quot;data&quot;]</span>

<span class="sd">                width_array_lookup[limb_idx][branch_idx] = ex_branch.width_array</span>
<span class="sd">                if not ex_branch.spines is None:</span>
<span class="sd">                    spines_lookup[limb_idx][branch_idx] = [tu.original_mesh_faces_map(ex_branch.mesh,k) for k in ex_branch.spines]</span>
<span class="sd">                else:</span>
<span class="sd">                    spines_lookup[limb_idx][branch_idx] = None</span>
<span class="sd">                width_new_lookup[limb_idx][branch_idx] = ex_branch.width_new</span>
<span class="sd">                </span>
<span class="sd">        # Old Way #2: where not generic</span>
<span class="sd">        width_array_lookup = self.get_attribute_dict(&quot;width_array&quot;)</span>
<span class="sd">        width_new_lookup = self.get_attribute_dict(&quot;width_new&quot;)</span>
<span class="sd">        spines_lookup = self.get_attribute_dict(&quot;spines&quot;)</span>
<span class="sd">        </span>
<span class="sd">        spine_width_data = dict(</span>
<span class="sd">                width_array_lookup = width_array_lookup,</span>
<span class="sd">                width_new_lookup = width_new_lookup,</span>
<span class="sd">                spines_lookup = spines_lookup</span>
<span class="sd">               )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">one_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lookup_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lookup_values</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">check_connected_component</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_whole_neuron_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">check_connected_component</span><span class="o">=</span><span class="n">check_connected_component</span><span class="p">)</span>

        
<div class="viewcode-block" id="Neuron.calculate_new_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.calculate_new_width">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_new_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">wu</span><span class="o">.</span><span class="n">calculate_new_width_for_neuron_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    

    <span class="c1"># ------------ 9/24: Function that will see if spines are already comuted ------------ #</span>
<div class="viewcode-block" id="Neuron.spines_already_computed"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.spines_already_computed">[docs]</a>    <span class="k">def</span> <span class="nf">spines_already_computed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        1) Iterate through all of limbs and branches</span>
<span class="sd">        2) If find one instance where spines not None, return True</span>
<span class="sd">        3) If none found, return False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found_spines</span><span class="o">=</span><span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">limb</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">limb</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">found_spines</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">branch</span> <span class="ow">in</span> <span class="n">limb</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">branch</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1">#print(f&quot;Found non-null branch = {branch.spines}&quot;)</span>
                    <span class="n">found_spines</span><span class="o">=</span><span class="kc">True</span>
                    <span class="k">break</span>
            <span class="n">limb</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">found_spines</span></div>
    <span class="c1">#------------------ some useful built in functions ------------------ #</span>
    
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">newvalue</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newvalue</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">()))</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1">#print(f&quot;Neuron self._index = {self._index}&quot;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span>
        
    
    <span class="c1">#Overloading the Comparison </span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Computes equality of all members of the neuron object</span>
<span class="sd">        </span>
<span class="sd">        Things that need to compare: </span>
<span class="sd">        concept_network</span>
<span class="sd">        segment_id</span>
<span class="sd">        description</span>
<span class="sd">        mesh</span>
<span class="sd">        inside_pieces #we should do these in the same order</span>
<span class="sd">        insignificant_limbs #same order</span>
<span class="sd">        non_soma_touching_meshes #same order</span>
<span class="sd">        </span>
<span class="sd">        Testing: </span>
<span class="sd">        from datasci_tools import numpy_dep as np</span>
<span class="sd">        nru = reload(nru)</span>
<span class="sd">        neuron = reload(neuron)</span>
<span class="sd">        xu = reload(xu)</span>
<span class="sd">        sk = reload(sk)</span>
<span class="sd">        nu= reload(nu)</span>
<span class="sd">        tu = reload(tu)</span>

<span class="sd">        from neurd import soma_extraction_utils as sm</span>
<span class="sd">        sm = reload(sm)</span>

<span class="sd">        obj1 = neuron.Neuron(double_soma_obj,suppress_output=False)</span>
<span class="sd">        obj2 = neuron.Neuron(double_soma_obj,suppress_output=False)</span>

<span class="sd">        #obj1 == obj2</span>

<span class="sd">        #testing the changing of different things</span>
<span class="sd">        #obj1.concept_network.nodes[&quot;S0&quot;][&quot;data&quot;].mesh = obj1.concept_network.nodes[&quot;S0&quot;][&quot;data&quot;].mesh.submesh([np.arange(0,len(obj1.concept_network.nodes[&quot;S0&quot;][&quot;data&quot;].mesh.faces)-5)],append=True)</span>
<span class="sd">        #obj1.concept_network.nodes[&quot;S0&quot;][&quot;data&quot;].sdf = 100</span>
<span class="sd">        #obj1.description = &quot;hello&quot;</span>
<span class="sd">        #obj1.segment_id = 1234567</span>
<span class="sd">        #obj1.inside_pieces = obj1.inside_pieces[:10]</span>
<span class="sd">        #obj2.non_soma_touching_meshes =  obj2.non_soma_touching_meshes[6:17]</span>
<span class="sd">        #curr_mesh = obj1.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;].concept_network.nodes[1][&quot;data&quot;].mesh</span>
<span class="sd">        #obj1.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;].concept_network.nodes[1][&quot;data&quot;].mesh = curr_mesh.submesh([np.arange(5,50)],append=True)</span>
<span class="sd">        </span>
<span class="sd">        au = reload(au)</span>
<span class="sd">        obj1 == obj2</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="p">[]</span>
      
        
        <span class="c1"># Compare&#39;concept_network&#39;, #networkx graph</span>
        <span class="n">nx_compare_result</span><span class="p">,</span><span class="n">nx_diff_list</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_networks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                                          <span class="n">other</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">return_differences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nx_compare_result</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;concept_network didn&#39;t match&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Differences in compare_networks = </span><span class="si">{</span><span class="n">nx_diff_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#comparing the segment_id</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">segment_id</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_id didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.segment_id = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.segment_id = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
        <span class="c1">#comparing the description</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">description</span><span class="p">:</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;description didn&#39;t match: &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.description = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.description = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
        
        <span class="c1">#comparing the meshes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
            <span class="n">differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh didn&#39;t match&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    self.mesh = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">,&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; other.mesh = </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> 
        
        <span class="c1">#comparing the mesh lists</span>
        <span class="n">mesh_lists_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;inside_pieces&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;insignificant_limbs&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;not_processed_soma_containing_meshes&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">]</span>
        
        
        <span class="k">for</span> <span class="n">curr_mesh_attr</span> <span class="ow">in</span> <span class="n">mesh_lists_to_check</span><span class="p">:</span>
            <span class="n">curr_self_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_mesh_attr</span><span class="p">)</span>
            <span class="n">curr_other_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">curr_mesh_attr</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Older method of comparison that did not account for lists of different sizes: </span>
<span class="sd">            mesh_list_comparisons = tu.compare_meshes_by_face_midpoints_list(curr_self_attr,</span>
<span class="sd">                                                                             curr_other_attr)</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">comparison_result</span><span class="p">,</span> <span class="n">comparison_differences</span> <span class="o">=</span> <span class="n">agu</span><span class="o">.</span><span class="n">compare_uneven_groups</span><span class="p">(</span><span class="n">curr_self_attr</span><span class="p">,</span><span class="n">curr_other_attr</span><span class="p">,</span>
                             <span class="n">comparison_func</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">,</span>
                             <span class="n">group_name</span><span class="o">=</span><span class="n">curr_mesh_attr</span><span class="p">,</span>
                             <span class="n">return_differences</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
            
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">comparison_result</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                #didnt account for different size comparisons</span>
<span class="sd">                differences.append(f&quot;{curr_mesh_attr} didn&#39;t match&quot;</span>
<span class="sd">                                   f&quot;\n    self.{curr_mesh_attr} different = {[k for truth,k in zip(mesh_list_comparisons,curr_self_attr) if truth == False]},&quot;</span>
<span class="sd">                                   f&quot; other.{curr_mesh_attr} different = {[k for truth,k in zip(mesh_list_comparisons,curr_other_attr) if truth == False]}&quot;) </span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">differences</span> <span class="o">+=</span> <span class="n">comparison_differences</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">differences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Differences List:&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">diff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">differences</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)   </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
    
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    What visualizations to neuron do: </span>
<span class="sd">    1) Show the soma/limb concept network with colors (or any subset of that)</span>

<span class="sd">    * Be able to pick a </span>
<span class="sd">    2) Show the entire skeleton</span>
<span class="sd">    3) show the entire mesh</span>


<span class="sd">    Ideal: </span>
<span class="sd">    1) get a submesh: By</span>
<span class="sd">    - names </span>
<span class="sd">    - properties</span>
<span class="sd">    - or both</span>
<span class="sd">    2) Be able to describe what feature want to see with them:</span>
<span class="sd">    - skeleton</span>
<span class="sd">    - mesh: </span>
<span class="sd">        branch or limb color specific</span>
<span class="sd">    - concept network </span>
<span class="sd">        directed or undirected</span>
<span class="sd">        branch or limb color specific</span>

<span class="sd">    3) Have some feature of the whole mesh in the background</span>


<span class="sd">    Want to specify certian colors of specific groups</span>

<span class="sd">    Want to give back the colors with the names of the things if did random</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Neuron.get_soma_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_soma_meshes">[docs]</a>    <span class="k">def</span> <span class="nf">get_soma_meshes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the same output that running the soma identifier would</span>
<span class="sd">        </span>
<span class="sd">        Retunrs: a list containing the following elements</span>
<span class="sd">        1) list of soma meshes (N)</span>
<span class="sd">        2) scalar value of time it took to process (dummy 0)</span>
<span class="sd">        3) list of soma sdf values (N)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">())]</span>
        <span class="k">return</span> <span class="n">soma_meshes</span></div>
    
<div class="viewcode-block" id="Neuron.get_somas"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_somas">[docs]</a>    <span class="k">def</span> <span class="nf">get_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the same output that running the soma identifier would</span>
<span class="sd">        </span>
<span class="sd">        Retunrs: a list containing the following elements</span>
<span class="sd">        1) list of soma meshes (N)</span>
<span class="sd">        2) scalar value of time it took to process (dummy 0)</span>
<span class="sd">        3) list of soma sdf values (N)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">())]</span>
        <span class="n">somas_sdfs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sdf</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">())]</span>
        <span class="n">somas</span> <span class="o">=</span><span class="p">[</span><span class="n">soma_meshes</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">somas_sdfs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">somas</span></div>
    
    
<div class="viewcode-block" id="Neuron.get_limb_node_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_limb_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_limb_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_int</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">with_l_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_int</span><span class="p">:</span>
            <span class="n">sorted_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">with_l_names</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_numbers</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">with_l_names</span></div>
        
<div class="viewcode-block" id="Neuron.get_limb_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_limb_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_limb_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_int</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">with_l_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_int</span><span class="p">:</span>
            <span class="n">sorted_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">with_l_names</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_numbers</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">with_l_names</span></div>
        
<div class="viewcode-block" id="Neuron.get_branch_node_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_branch_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_branch_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">limb_idx</span><span class="p">):</span>
        <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span></div>
<div class="viewcode-block" id="Neuron.get_soma_node_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_soma_node_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_soma_node_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">int_label</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">soma_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">int_label</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">soma_names</span></div>
        
<div class="viewcode-block" id="Neuron.get_soma_indexes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_soma_indexes">[docs]</a>    <span class="k">def</span> <span class="nf">get_soma_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">(</span><span class="n">int_label</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Neuron.get_limbs_touching_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_limbs_touching_soma">[docs]</a>    <span class="k">def</span> <span class="nf">get_limbs_touching_soma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To get all of the limb names contacting a certain soma</span>
<span class="sd">        </span>
<span class="sd">        Example:</span>
<span class="sd">        current_neuron.get_limbs_touching_soma(0)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">nru</span><span class="o">.</span><span class="n">soma_label</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">),</span><span class="n">int_label</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Neuron.get_somas_touching_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.get_somas_touching_limbs">[docs]</a>    <span class="k">def</span> <span class="nf">get_somas_touching_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To get all of the limb names contacting a certain soma</span>
<span class="sd">        </span>
<span class="sd">        Example:</span>
<span class="sd">        current_neuron.get_limbs_touching_soma(0)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">soma_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">),</span><span class="n">int_label</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_int</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_neighbors</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">soma_neighbors</span></div>
    
    <span class="c1"># --------------------- For saving the neuron -------------------- #</span>
<div class="viewcode-block" id="Neuron.save_compressed_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.save_compressed_neuron">[docs]</a>    <span class="k">def</span> <span class="nf">save_compressed_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">output_folder</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span><span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">return_file_path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">export_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">suppress_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">file_name_append</span><span class="o">=</span><span class="kc">None</span><span class="p">,):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Will save the neuron in a compressed format:</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Ex: How to save compressed neuron</span>
<span class="sd">        double_neuron_preprocessed.save_compressed_neuron(&quot;/notebooks/test_neurons/preprocessed_neurons/meshafterparty/&quot;,export_mesh=True,</span>
<span class="sd">                                         file_name=f&quot;{double_neuron_preprocessed.segment_id}_{double_neuron_preprocessed.description}_meshAfterParty&quot;,</span>
<span class="sd">                                         return_file_path=True)</span>
<span class="sd">        </span>
<span class="sd">        Ex: How to reload compressed neuron</span>
<span class="sd">        nru.decompress_neuron(filepath=&quot;/notebooks/test_neurons/preprocessed_neurons/meshafterparty/12345_double_soma_meshAfterParty&quot;,</span>
<span class="sd">                     original_mesh=&#39;/notebooks/test_neurons/preprocessed_neurons/meshafterparty/12345_double_soma_meshAfterParty&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">suppress_output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving Neuorn in suppress_output mode...please wait&quot;</span><span class="p">)</span>
        
        
        <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="n">suppress_output</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
            <span class="n">returned_file_path</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">save_compressed_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                       <span class="n">output_folder</span><span class="o">=</span><span class="n">output_folder</span><span class="p">,</span>
                                       <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">,</span>
                                       <span class="n">return_file_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">export_mesh</span><span class="o">=</span><span class="n">export_mesh</span><span class="p">,</span>
                                        <span class="n">file_name_append</span><span class="o">=</span><span class="n">file_name_append</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved File at location: </span><span class="si">{</span><span class="n">returned_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span>  <span class="n">return_file_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">returned_file_path</span></div>
    
    <span class="c1">#how to save neuron object</span>
<div class="viewcode-block" id="Neuron.save_neuron_object"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.save_neuron_object">[docs]</a>    <span class="k">def</span> <span class="nf">save_neuron_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No filename/location given so creating own&quot;</span><span class="p">)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">.pkl&quot;</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving Object at: </span><span class="si">{</span><span class="n">file</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">su</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">file</span><span class="p">)</span></div>
    
<span class="c1">#     def calculate_width_without_spines(self,</span>
<span class="c1">#                                       skeleton_segment_size = 1000,</span>
<span class="c1">#                                        width_segment_size=None,</span>
<span class="c1">#                                       width_name = &quot;no_spine_average&quot;,</span>
<span class="c1">#                                       **kwargs):</span>


<span class="c1">#         for limb_idx in self.get_limb_node_names():</span>
<span class="c1">#             for branch_idx in self.get_branch_node_names(limb_idx):</span>
<span class="c1">#                 print(f&quot;Working on limb {limb_idx} branch {branch_idx}&quot;)</span>
<span class="c1">#                 curr_branch_obj = self.concept_network.nodes[nru.limb_label(limb_idx)][&quot;data&quot;].concept_network.nodes[branch_idx][&quot;data&quot;]</span>
<span class="c1">#                 if &quot;distance_by_mesh_center&quot; not in kwargs.keys():</span>
<span class="c1">#                     if &quot;mesh_center&quot; in width_name:</span>
<span class="c1">#                         distance_by_mesh_center = True</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         distance_by_mesh_center = False</span>
                
                
<span class="c1">#                 current_width_array,current_width = wu.calculate_new_width(curr_branch_obj, </span>
<span class="c1">#                                       skeleton_segment_size=skeleton_segment_size,</span>
<span class="c1">#                                       width_segment_size=width_segment_size, </span>
<span class="c1">#                                       distance_by_mesh_center=distance_by_mesh_center,</span>
<span class="c1">#                                       return_average=True,</span>
<span class="c1">#                                       print_flag=False,</span>
<span class="c1">#                                     **kwargs)</span>


<span class="c1">#                 curr_branch_obj.width_new[width_name] = current_width</span>
<span class="c1">#                 curr_branch_obj.width_array[width_name] = current_width_array</span>
    
    
    
    <span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<div class="viewcode-block" id="Neuron.calculate_spines_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.calculate_spines_old">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_spines_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="c1">#query=&quot;width &gt; 400 and n_faces_branch&gt;100&quot;,</span>
                         <span class="c1">#query=&quot;median_mesh_center &gt; 140 and n_faces_branch&gt;100&quot;,#previous used median_mesh_center &gt; 140</span>
                         <span class="n">query</span><span class="o">=</span><span class="s2">&quot;median_mesh_center &gt; 115 and n_faces_branch&gt;100&quot;</span><span class="p">,</span><span class="c1">#previous used median_mesh_center &gt; 140</span>
                        <span class="n">clusters_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="c1">#2,</span>
                        <span class="n">smoothness_threshold</span><span class="o">=</span><span class="mf">0.12</span><span class="p">,</span><span class="c1">#0.08,</span>
                        <span class="n">shaft_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
                        <span class="n">cgal_path</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./cgal_temp&quot;</span><span class="p">),</span>
                        <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                         <span class="n">filter_by_bounding_box_longest_side_length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">side_length_threshold</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                        <span class="n">filter_out_border_spines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1">#this seemed to cause a lot of misses</span>
                        <span class="n">skeleton_endpoint_nullification</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">skeleton_endpoint_nullification_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                         <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                        <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                        <span class="n">calculate_spine_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         
                         <span class="c1">#-------1/20 Addition --------</span>
                         <span class="n">filter_by_volume</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="mi">19835293</span><span class="p">,</span> <span class="c1">#calculated from experiments</span>
                         
                        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Out-dated function&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;query = </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;smoothness_threshold = </span><span class="si">{</span><span class="n">smoothness_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">():</span>
            <span class="n">functions_list</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="s2">&quot;functions_list&quot;</span><span class="p">]</span>
            <span class="n">current_query</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="s2">&quot;query&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span><span class="s2">&quot;n_faces_branch&quot;</span><span class="p">]</span>
            <span class="n">current_query</span> <span class="o">=</span> <span class="n">query</span>
            
        
        <span class="c1">#check that have calculated the median mesh center if required</span>
        <span class="k">if</span> <span class="s2">&quot;median_mesh_center&quot;</span> <span class="ow">in</span> <span class="n">functions_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">())</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="s2">&quot;median_mesh_center&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The median_mesh_center was requested but has not already been calculated so calculating now.... &quot;</span><span class="p">)</span>
                
                <span class="n">wu</span><span class="o">.</span><span class="n">calculate_new_width_for_neuron_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                      <span class="n">no_spines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">summary_measure</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The median_mesh_center was requested and HAS already been calculated&quot;</span><span class="p">)</span>

        <span class="n">new_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">functions_list</span><span class="o">=</span><span class="n">functions_list</span><span class="p">,</span>
                       <span class="n">query</span><span class="o">=</span><span class="n">current_query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_branch_dict = </span><span class="si">{</span><span class="n">new_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
 
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">limb_idx</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span>
            
            <span class="c1"># ------------- 1/20 Addition that allows you to specify which branches to do ------- #</span>
            <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="k">continue</span>
            
            
            
            <span class="k">if</span> <span class="n">soma_vertex_nullification</span><span class="p">:</span>
                <span class="n">soma_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()])</span>
                <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_verts</span><span class="p">)</span>
            
            <span class="n">curr_limb</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">branch_idx</span><span class="p">,</span><span class="n">curr_branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">):</span>
                <span class="n">already_calculated_volumes</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">new_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                    <span class="c1">#print(f&quot;new_branch_dict[{limb_idx}] = {new_branch_dict[limb_idx]}&quot;)</span>
                    <span class="c1">#print(f&quot;branch_idx = {branch_idx}&quot;)</span>
                    <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">new_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]:</span>
                        
                        <span class="c1"># ------------- 1/20 Addition that allows you to specify which branches to do ------- #</span>
                        <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]:</span>
                                <span class="k">continue</span>

                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1">#calculate the spines</span>
                        
                        <span class="c1">#su.compressed_pickle(curr_branch,&quot;curr_branch_before_spines&quot;)</span>
                        
                        <span class="n">spine_submesh_split</span><span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">get_spine_meshes_unfiltered</span><span class="p">(</span><span class="n">current_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span>
                                                                <span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span>
                                                                <span class="n">branch_idx</span><span class="o">=</span><span class="n">branch_idx</span><span class="p">,</span>
                                                                <span class="n">clusters</span><span class="o">=</span><span class="n">clusters_threshold</span><span class="p">,</span>
                                                                <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness_threshold</span><span class="p">,</span>
                                                                <span class="c1">#cgal_folder = cgal_path,</span>
                                                                <span class="c1">#delete_temp_file=True,</span>
                                                                <span class="n">return_sdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">shaft_threshold</span><span class="o">=</span><span class="n">shaft_threshold</span><span class="p">)</span>
                        
                            
                        <span class="c1">#print(f&quot;curr_branch.mesh = {curr_branch.mesh}&quot;)</span>
<span class="c1">#                         spine_submesh_split = spu.get_spine_meshes_unfiltered_from_mesh(curr_branch.mesh,</span>
<span class="c1">#                                                                 segment_name=f&quot;{limb_idx}_{branch_idx}&quot;,</span>
<span class="c1">#                                                                 clusters=clusters_threshold,</span>
<span class="c1">#                                                                 smoothness=smoothness_threshold,</span>
<span class="c1">#                                                                 cgal_folder = cgal_path,</span>
<span class="c1">#                                                                 delete_temp_file=True,</span>
<span class="c1">#                                                                 return_sdf=False,</span>
<span class="c1">#                                                                 print_flag=False,</span>
<span class="c1">#                                                                 shaft_threshold=shaft_threshold)</span>
                        
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; n_spines found before filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#                 if limb_idx == &quot;L0&quot;:</span>
        <span class="c1">#                     if branch_idx == 0:</span>
        <span class="c1">#                         print(f&quot;spine_submesh_split = {spine_submesh_split}&quot;)</span>

                        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_spine_meshes</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">,</span>
                                                                              <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="n">spine_n_face_threshold</span><span class="p">)</span>
            
                        <span class="k">if</span> <span class="n">filter_by_bounding_box_longest_side_length</span><span class="p">:</span>
                            <span class="n">old_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span>
                            <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_bounding_box_longest_side</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                                                                     <span class="n">side_length_threshold</span><span class="o">=</span><span class="n">side_length_threshold</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">old_length</span><span class="p">:</span>
                                <span class="c1">#print(f&quot;Removed {old_length - len(spine_submesh_split_filtered)} spines because of side length greater than {side_length_threshold}&quot;)</span>
                                <span class="k">pass</span>
        <span class="c1">#                 if limb_idx == &quot;L0&quot;:</span>
        <span class="c1">#                     if branch_idx == 0:</span>
        <span class="c1">#                         print(f&quot;spine_submesh_split_filtered = {spine_submesh_split_filtered}&quot;)</span>
        
                        <span class="k">if</span> <span class="n">filter_out_border_spines</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the filter_out_border_spines option&quot;</span><span class="p">)</span>
                            <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_out_border_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                                                        <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                                                        <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="n">border_percentage_threshold</span><span class="p">,</span>
                                                                                        <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="n">check_spine_border_perc</span><span class="p">,</span>
                                                                                        <span class="n">verbose</span><span class="o">=</span><span class="n">print_flag</span>
                                                                                       <span class="p">)</span>
                        <span class="k">if</span> <span class="n">skeleton_endpoint_nullification</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the skeleton_endpoint_nullification option&quot;</span><span class="p">)</span>
                                
                            
                            <span class="n">curr_branch_end_coords</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                                
                            <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                                        <span class="n">curr_branch_end_coords</span><span class="p">,</span>
                                                                        <span class="n">distance_threshold</span><span class="o">=</span><span class="n">skeleton_endpoint_nullification_distance</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">soma_vertex_nullification</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the soma_vertex_nullification option&quot;</span><span class="p">)</span>
                                
                            <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_out_soma_touching_spines</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                                        <span class="n">soma_kdtree</span><span class="o">=</span><span class="n">soma_kdtree</span><span class="p">)</span>
                        
                        
                        <span class="k">if</span> <span class="n">filter_by_volume</span><span class="p">:</span>
<span class="w">                            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            Pseudocode: </span>
<span class="sd">                            1) Calculate the volumes of all the spines</span>
<span class="sd">                            2) Filter those spines for only those above the volume</span>
<span class="sd">                            </span>
<span class="sd">                            &quot;&quot;&quot;</span>
                            
                            
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                
                                
                                <span class="n">spine_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_submesh_split_filtered</span><span class="p">])</span>
                                <span class="n">volume_kept_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spine_volumes</span> <span class="o">&gt;</span> <span class="n">filter_by_volume_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">spine_submesh_split_filtered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">volume_kept_idx</span><span class="p">]</span>
                                
                                <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spine_volumes</span><span class="p">[</span><span class="n">volume_kept_idx</span><span class="p">])</span>
                                
                                <span class="n">already_calculated_volumes</span> <span class="o">=</span> <span class="kc">True</span>
                                                         
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; n_spines found = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span>
                        
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="kc">None</span>
                
                <span class="c1"># will compute the spine volumes if asked for </span>
                <span class="k">if</span> <span class="n">calculate_spine_volume</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">already_calculated_volumes</span><span class="p">:</span>
                    <span class="n">curr_branch</span><span class="o">.</span><span class="n">compute_spines_volume</span><span class="p">()</span></div>
    <span class="nd">@property</span>          
    <span class="k">def</span> <span class="nf">limb_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
    
    <span class="nd">@property</span>          
    <span class="k">def</span> <span class="nf">soma_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">soma_node_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_node_names</span><span class="p">])</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limb_area</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">area_with_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limb_area</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma_area</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limb_mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">mesh_volume</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">soma_mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">soma_node_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_node_names</span><span class="p">])</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">mesh_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limb_mesh_volume</span>
    
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">mesh_volume_with_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">limb_mesh_volume</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">soma_mesh_volume</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines&quot;</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;boutons&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;synapses&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapse_density_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">web</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;web&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines_volume&quot;</span><span class="p">))</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boutons_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_list_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;boutons_volume&quot;</span><span class="p">)</span>
    
<div class="viewcode-block" id="Neuron.compute_spines_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.compute_spines_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_spines_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">compute_feature_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;spines_volume&quot;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Neuron.compute_boutons_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.compute_boutons_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_boutons_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">compute_feature_over_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;boutons_volume&quot;</span><span class="p">)</span></div>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    @property</span>
<span class="sd">    def spines(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        total_spines = []</span>
<span class="sd">        for b in self:</span>
<span class="sd">            if not b.spines is None:</span>
<span class="sd">                total_spines += b.spines</span>
<span class="sd">        return total_spines</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    @property</span>
<span class="sd">    def spines_volume(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        total_spines_volume = []</span>
<span class="sd">        for b in self:</span>
<span class="sd">            if not b.spines_volume is None:</span>
<span class="sd">                total_spines_volume += b.spines_volume</span>
<span class="sd">        return total_spines_volume</span>
<span class="sd">    </span>
<span class="sd">    def compute_spines_volume(self):</span>
<span class="sd">        self._index = -1</span>
<span class="sd">        for b in self:</span>
<span class="sd">            b.compute_spines_volume()</span>
<span class="sd">    &#39;&#39;&#39;</span>
        
    
<div class="viewcode-block" id="Neuron.plot_soma_limb_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.plot_soma_limb_concept_network">[docs]</a>    <span class="k">def</span> <span class="nf">plot_soma_limb_concept_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                      <span class="n">soma_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                      <span class="n">limb_color</span><span class="o">=</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                                      <span class="n">node_size</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
                                      <span class="n">font_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                                      <span class="n">node_colors</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To plot the connectivity of the soma and the meshes in the neuron</span>
<span class="sd">        </span>
<span class="sd">        How it was developed: </span>
<span class="sd">        </span>
<span class="sd">        from datasci_tools import networkx_utils as xu</span>
<span class="sd">        xu = reload(xu)</span>
<span class="sd">        node_list = xu.get_node_list(my_neuron.concept_network)</span>
<span class="sd">        node_list_colors = [&quot;red&quot; if &quot;S&quot; in n else &quot;blue&quot; for n in node_list]</span>
<span class="sd">        nx.draw(my_neuron.concept_network,with_labels=True,node_color=node_list_colors,</span>
<span class="sd">               font_color=&quot;white&quot;,node_size=500)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_soma_limb_concept_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                              <span class="n">soma_color</span><span class="o">=</span><span class="n">soma_color</span><span class="p">,</span>
                                              <span class="n">limb_color</span><span class="o">=</span><span class="n">limb_color</span><span class="p">,</span>
                                              <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
                                              <span class="n">font_color</span><span class="o">=</span><span class="n">font_color</span><span class="p">,</span>
                                              <span class="n">node_colors</span><span class="o">=</span><span class="n">node_colors</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span>
                                            
                                           <span class="p">)</span></div>
    
<div class="viewcode-block" id="Neuron.axon_classification"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.axon_classification">[docs]</a>    <span class="k">def</span> <span class="nf">axon_classification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">clu</span><span class="o">.</span><span class="n">axon_classification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dendrite_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">dendrite_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">non_axon_like_limb_branch_on_dendrite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">non_axon_like_limb_branch_on_dendrite</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dendrite_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">au</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_on_dendrite_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_on_dendrite_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dendrite_on_axon_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">au</span><span class="o">.</span><span class="n">dendrite_on_axon_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Neuron.label_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.label_limb_branch_dict">[docs]</a>    <span class="k">def</span> <span class="nf">label_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">label</span><span class="p">)</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">apical_shaft_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_shaft_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">apical_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">apical_tuft_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_tuft_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basal_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">basal_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">oblique_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">oblique_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dendrite_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">dendrite_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_starting_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_starting_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_starting_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_starting_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_limb_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ax_limb_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_limb_name</span>
        
        <span class="k">if</span> <span class="n">ax_limb_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">ax_limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_limb_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_limb_name</span>
        <span class="k">if</span> <span class="n">ax_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ax_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_int_name</span><span class="p">(</span><span class="n">ax_name</span><span class="p">)</span>
    
        
<div class="viewcode-block" id="Neuron.plot_limb_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.plot_limb_concept_network">[docs]</a>    <span class="k">def</span> <span class="nf">plot_limb_concept_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">limb_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                 <span class="n">limb_idx</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                  <span class="n">node_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                  <span class="n">directional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">append_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">limb_name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">limb_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Limb name and limb_idx both not specified&quot;</span><span class="p">)</span>
            <span class="n">limb_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span>
            
        <span class="k">if</span> <span class="n">directional</span><span class="p">:</span>
            <span class="n">curr_limb_concept_network_directional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network_directional</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_limb_concept_network_directional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_concept_network</span><span class="p">(</span><span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">curr_limb_concept_network_directional</span><span class="p">,</span>
                            <span class="n">scatter_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
                            <span class="n">show_at_end</span><span class="o">=</span><span class="n">show_at_end</span><span class="p">,</span>
                            <span class="n">append_figure</span><span class="o">=</span><span class="n">append_figure</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    <span class="c1"># ---- 11/20 functions that will help compute statistics of the neuron object ----------</span>
    
    <span class="c1"># -- skeleton and branch data ---</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_error_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_error_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">same_soma_multi_touching_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">multi_soma_touching_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_limbs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_branches_per_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_branches_per_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton_length_per_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_length_per_limb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_limb_skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">max_limb_skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">max_limb_n_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">max_limb_n_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">median_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">median_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    

    <span class="c1"># -- width data --</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">width_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_no_spine_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">width_no_spine_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_90_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">width_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">perc</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width_no_spine_90_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">width_no_spine_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">perc</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
    

    
    <span class="c1"># -- spine entries--</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_spines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines_per_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spines_per_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spine_eligible_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_eligible_branch_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_eligible_branch_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_length_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_density_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_density_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spines_per_branch_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spines_per_branch_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="c1"># ------ spine volume issues ----</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_spine_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_volume_median</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_volume_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume_density_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_volume_density_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume_per_branch_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">spine_volume_per_branch_eligible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_soma_n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">max_soma_n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_soma_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">max_soma_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_soma_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">max_soma_area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axon_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_limb_branch_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
<div class="viewcode-block" id="Neuron.neuron_stats"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.neuron_stats">[docs]</a>    <span class="k">def</span> <span class="nf">neuron_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stats_to_ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">include_centroids</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cell_type_mode</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">neuron_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">stats_to_ignore</span><span class="o">=</span><span class="n">stats_to_ignore</span><span class="p">,</span>
                     <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="n">include_skeletal_stats</span><span class="p">,</span>
                    <span class="n">include_centroids</span><span class="o">=</span> <span class="n">include_centroids</span><span class="p">,</span>
                     <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="n">voxel_adjustment_vector</span><span class="p">,</span>
                     <span class="n">cell_type_mode</span> <span class="o">=</span> <span class="n">cell_type_mode</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Neuron.neuron_stats_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron.Neuron.neuron_stats_old">[docs]</a>    <span class="k">def</span> <span class="nf">neuron_stats_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stats_to_ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">include_centroids</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">cell_type_mode</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cell_type_mode</span><span class="p">:</span>
            <span class="n">stats_to_ignore</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;n_not_processed_soma_containing_meshes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_error_limbs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_same_soma_multi_touching_limbs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_multi_soma_touching_limbs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_somas&quot;</span><span class="p">,</span>
                <span class="s2">&quot;spine_density&quot;</span>
                <span class="p">]</span>
            <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">include_centroids</span><span class="o">=</span> <span class="kc">True</span>
            
            
        <span class="n">stats_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">n_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">,</span>
                        <span class="n">n_faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_faces</span><span class="p">,</span>
            
                        <span class="n">axon_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_length</span><span class="p">,</span>
                        <span class="n">axon_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axon_area</span><span class="p">,</span>
            
                        <span class="n">max_soma_volume</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_soma_volume</span><span class="p">,</span>
                        <span class="n">max_soma_n_faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_soma_n_faces</span><span class="p">,</span>
                        <span class="n">max_soma_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_soma_area</span><span class="p">,</span>
            
            
                        <span class="n">n_not_processed_soma_containing_meshes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">not_processed_soma_containing_meshes</span><span class="p">),</span>
                        <span class="n">n_error_limbs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_error_limbs</span><span class="p">,</span>
                        <span class="n">n_same_soma_multi_touching_limbs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span><span class="p">),</span>
                        <span class="n">n_multi_soma_touching_limbs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span><span class="p">),</span>
                        <span class="n">n_somas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_somas</span><span class="p">,</span>
                        <span class="n">n_limbs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_limbs</span><span class="p">,</span>
                        <span class="n">n_branches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_branches</span><span class="p">,</span>
                        <span class="n">max_limb_n_branches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_limb_n_branches</span><span class="p">,</span>
                       
                        <span class="n">skeletal_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletal_length</span><span class="p">,</span>
                        <span class="n">max_limb_skeletal_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_limb_skeletal_length</span><span class="p">,</span>
                        <span class="n">median_branch_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">median_branch_length</span><span class="p">,</span>

                        <span class="n">width_median</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">width_median</span><span class="p">,</span> <span class="c1">#median width from mesh center without spines removed</span>
                        <span class="n">width_no_spine_median</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">width_no_spine_median</span><span class="p">,</span> <span class="c1">#median width from mesh center with spines removed</span>
                        <span class="n">width_90_perc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">width_90_perc</span><span class="p">,</span> <span class="c1"># 90th percentile for width without spines removed</span>
                        <span class="n">width_no_spine_90_perc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">width_no_spine_90_perc</span><span class="p">,</span>  <span class="c1"># 90th percentile for width with spines removed</span>

                        <span class="n">n_spines</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spines</span><span class="p">,</span>
                        <span class="n">n_boutons</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">,</span>

                        <span class="n">spine_density</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spine_density</span><span class="p">,</span> <span class="c1"># n_spines/ skeletal_length</span>
                        <span class="n">spines_per_branch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spines_per_branch</span><span class="p">,</span>

                        <span class="n">skeletal_length_eligible</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">skeletal_length_eligible</span><span class="p">,</span> <span class="c1"># the skeletal length for all branches searched for spines</span>
                        <span class="n">n_spine_eligible_branches</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span><span class="p">,</span>
                        <span class="n">spine_density_eligible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spine_density_eligible</span><span class="p">,</span>
                        <span class="n">spines_per_branch_eligible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spines_per_branch_eligible</span><span class="p">,</span>

                        <span class="n">total_spine_volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="p">,</span> <span class="c1"># the sum of all spine volume</span>
                        <span class="n">spine_volume_median</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spine_volume_median</span><span class="p">,</span>
                        <span class="n">spine_volume_density</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spine_volume_density</span><span class="p">,</span> <span class="c1">#total_spine_volume/skeletal_length</span>
                        <span class="n">spine_volume_density_eligible</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spine_volume_density_eligible</span><span class="p">,</span> <span class="c1">#total_spine_volume/skeletal_length_eligible</span>
                        <span class="n">spine_volume_per_branch_eligible</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spine_volume_per_branch_eligible</span><span class="p">,</span> <span class="c1">#total_spine_volume/n_spine_eligible_branche</span>
        
        
        
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">stats_to_ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats_to_ignore</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">stats_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">include_skeletal_stats</span><span class="p">:</span>
            <span class="n">sk_dict</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">features_from_neuron_skeleton_and_soma_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">features_to_exclude</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span><span class="s2">&quot;n_branches&quot;</span><span class="p">),</span>
                                                 <span class="p">)</span>
            <span class="n">stats_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sk_dict</span><span class="p">)</span>
            
            
        <span class="k">if</span> <span class="n">include_centroids</span><span class="p">:</span>
            <span class="n">cent_stats</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">centroid_stats_from_neuron_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                           <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="n">voxel_adjustment_vector</span><span class="p">)</span>
            <span class="n">stats_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cent_stats</span><span class="p">)</span>
            
        
        <span class="k">return</span> <span class="n">stats_dict</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_kdtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A kdtree of the original mesh&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mesh_kdtree</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_from_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_mesh_from_branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    
    <span class="c1"># ------- 6/9: The pre and post of the errored meshes</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_mesh_errored_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_errored_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_mesh_errored_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses_pre</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_mesh_errored_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses_post</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_errored_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_errored_synapses</span><span class="p">)</span>
    
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_distance_errored_synapses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance_errored_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_distance_errored_synapses_pre</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses_pre</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_distance_errored_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses_post</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance_errored_synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_post</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_errored_synapses</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_error</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">synapses_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span> 
    <span class="k">def</span> <span class="nf">n_synapses_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses_valid</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">synapses_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_total</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_somas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses_somas</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses_error</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_synapses_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses_total</span><span class="p">)</span>
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">merge_filter_suggestions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a dictionary data structure that stores a list for each merge error filter of merge filter suggestions that would be the minimal cuts that would eliminate all merge errors of that type . </span>
<span class="sd">        Each filter detection is a dictionary storing meta data about the suggestion, with the following as some of the keys:</span>
<span class="sd">            - valid points: coordinates that should belong to the existing neuronal process ( a marker of where the valid mesh is). </span>
<span class="sd">            - error points: coordinates that should belong to incorrect neuronal process resulting from merge errors ( a marker of where the error mesh starts)</span>
<span class="sd">            - coordinate: locations of split points used in the elimination of soma to soma paths</span>

<span class="sd">            The valid and error points can be used as inputs for automatic mesh splitting algorithms in other pipelines (ex: Neuroglancer)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rb_suggestions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_products</span><span class="p">[</span><span class="s2">&quot;auto_proof&quot;</span><span class="p">][</span><span class="s2">&quot;red_blue_suggestions&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">merge_error_red_blue_suggestions_clean</span><span class="p">(</span>
                    <span class="n">rb_suggestions</span>
                <span class="p">)</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">merge_filter_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a nested dictionary datastructure storing the information on where the merge error filters were trigger. </span>
<span class="sd">        The order that the merge error filters was applied matters because the branches that triggered the filter are only those that had not triggered an early applied filter, and thus it was not already filtered away.</span>
<span class="sd">        Note: this product includes all branches that triggered the filter at this stage, regardless if they were downstream of another</span>
<span class="sd">        The datastructure is organized in the following way:</span>

<span class="sd">        merge error filter name: --&gt; dict</span>
<span class="sd">            limb name: </span>
<span class="sd">                list of 2x3 arrays that stores coordinates of the endpoints the skeleton of the branch that triggered the merge error filter (1st coordinate is upstream branch)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pipeline_products</span><span class="p">[</span><span class="s2">&quot;auto_proof&quot;</span><span class="p">][</span><span class="s2">&quot;split_locations_before_filter&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span></div>
        


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">apical_utils</span> <span class="k">as</span> <span class="n">apu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">branch_utils</span> <span class="k">as</span> <span class="n">bu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">classification_utils</span> <span class="k">as</span> <span class="n">clu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocess_neuron</span> <span class="k">as</span> <span class="n">pre</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">soma_extraction_utils</span> <span class="k">as</span> <span class="n">sm</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spine_utils</span> <span class="k">as</span> <span class="n">spu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">width_utils</span> <span class="k">as</span> <span class="n">wu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>

<span class="n">object_name_to_class</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">synapses</span><span class="o">=</span><span class="n">syu</span><span class="o">.</span><span class="n">Synapse</span><span class="p">,</span>
                           <span class="n">spines_obj</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">Spine</span><span class="p">)</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">compartment_utils</span> <span class="k">as</span> <span class="n">cu</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshlab</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">algorithms_utils</span> <span class="k">as</span> <span class="n">agu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">pipeline</span> <span class="k">as</span> <span class="n">pl</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">soma_splitting_utils</span> <span class="k">as</span> <span class="n">ssu</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
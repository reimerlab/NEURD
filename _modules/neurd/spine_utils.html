

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.spine_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.spine_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.spine_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>



<span class="sd">To Do: Want to add how close a spine is to upstream and downstream endpoint</span>



<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">time</span> 
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cgal_Segmentation_Module</span> <span class="k">as</span> <span class="nn">csm</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="n">volume_divisor</span> <span class="o">=</span> <span class="mi">1000_000_000</span>

<span class="n">spine_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mesh_face_idx&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;mesh&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;neck_face_idx&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;head_face_idx&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;neck_sdf&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;head_sdf&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;head_width&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;neck_width&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;volume&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;spine_id&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;sdf&quot;</span><span class="p">,</span>
                    <span class="c1">#features to help with electrical properties</span>
                     <span class="s2">&quot;endpoints_dist&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;upstream_dist&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;downstream_dist&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;coordinate&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;coordinate_border_verts&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;closest_sk_coordinate&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;closest_branch_face_idx&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;closest_face_dist&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;closest_face_coordinate&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;soma_distance&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;soma_distance_euclidean&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;compartment&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;limb_idx&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;branch_idx&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
                    
                    <span class="c1">#attributes for more spine features</span>
                    <span class="s2">&quot;bbox_oriented_side_lengths&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;head_bbox_oriented_side_lengths&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;neck_bbox_oriented_side_lengths&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;head_mesh_splits&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;head_mesh_splits_face_idx&quot;</span><span class="p">,</span>
                    
                    <span class="c1"># attributes from the branch_obj</span>
                    <span class="s2">&quot;compartment&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;branch_width_overall&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;branch_skeletal_length&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;branch_width_at_base&quot;</span><span class="p">,</span>
                     <span class="p">]</span>
<span class="n">head_neck_shaft_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">no_label</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">head</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">neck</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">shaft</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">no_head</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                           <span class="n">bouton</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                           <span class="n">non_bouton</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<div class="viewcode-block" id="spine_labels"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_labels">[docs]</a><span class="k">def</span> <span class="nf">spine_labels</span><span class="p">(</span><span class="n">include_no_label</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">include_no_label</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">head_neck_shaft_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">head_neck_shaft_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;no_label&quot;</span><span class="p">]</span></div>
    

    

<span class="n">head_neck_shaft_dict_inverted</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">head_neck_shaft_dict</span><span class="p">,</span><span class="n">one_to_one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="decode_head_neck_shaft_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.decode_head_neck_shaft_idx">[docs]</a><span class="k">def</span> <span class="nf">decode_head_neck_shaft_idx</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">head_neck_shaft_dict_inverted</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;no_label&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">array</span>
    <span class="p">]</span></div>

<span class="n">neck_color_default</span> <span class="o">=</span> <span class="s2">&quot;gold&quot;</span><span class="c1">#&quot;yellow&quot;#,&quot;pink&quot;#,&quot;yellow&quot;# &quot;aqua&quot;</span>
<span class="n">head_color_default</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
<span class="n">no_head_color_default</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
<span class="n">shaft_color_default</span> <span class="o">=</span> <span class="s2">&quot;lime&quot;</span>
<span class="n">bouton_color_default</span> <span class="o">=</span> <span class="s2">&quot;orange&quot;</span>
<span class="n">base_color_default</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
<span class="n">center_color_default</span> <span class="o">=</span> <span class="s2">&quot;orange&quot;</span>

<span class="n">spine_bouton_labels_colors_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="n">head</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
<span class="n">neck</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
<span class="n">shaft</span> <span class="o">=</span> <span class="s2">&quot;plum&quot;</span><span class="p">,</span>
<span class="n">no_head</span> <span class="o">=</span> <span class="s2">&quot;limegreen&quot;</span><span class="p">,</span>
<span class="n">bouton</span> <span class="o">=</span> <span class="s2">&quot;greenyellow&quot;</span><span class="p">,</span>
<span class="n">non_bouton</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
<span class="n">no_label</span> <span class="o">=</span> <span class="s2">&quot;royalblue&quot;</span>
<span class="p">)</span>

<span class="c1"># ---------- queries for differnt types of spines -----------</span>
<span class="n">spine_volume_to_spine_area_min</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="c1"># slab_query_1_dj = &quot;((shaft_border_area &gt; 0.18) AND (spine_volume &lt; 0.05)) OR (shaft_border_area is NULL)&quot;</span>
<span class="c1"># slab_query_2_dj = f&quot;((NOT (spine_volume is NULL)) AND (spine_volume_to_spine_area &lt; {spine_volume_to_spine_area_min}))&quot;</span>

<span class="n">slab_query_1</span> <span class="o">=</span> <span class="s2">&quot;((shaft_border_area &gt; 0.18) and (spine_volume &lt; 0.05)) or (shaft_border_area != shaft_border_area)&quot;</span>
<span class="n">slab_query_2</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;((spine_volume == spine_volume) and (spine_volume_to_spine_area &lt; </span><span class="si">{</span><span class="n">spine_volume_to_spine_area_min</span><span class="si">}</span><span class="s2">))&quot;</span>
<span class="n">slab_query_3</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(shaft_border_area &gt; 0.5)&quot;</span>
<span class="n">slab_query_4</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(spine_to_shaft_border_area &lt;= 2)&quot;</span>
<span class="n">slab_query_5</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(spine_area_per_faces) &lt; 0.005&quot;</span>
<span class="n">long_merge</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(head_skeletal_length &gt; 2000)&quot;</span>
<span class="n">too_fat_of_neck</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(neck_width_ray_80_perc &gt; 400) and (n_heads &gt; 0)&quot;</span>


<span class="n">measurable_features</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;spine_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spine_n_faces&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spine_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spine_skeletal_length&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spine_width_ray&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spine_width_ray_80_perc&quot;</span><span class="p">,</span>
                      <span class="p">)</span>

<span class="n">n_heads_max</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">min_distance_from_endpt</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">default_spine_restrictions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">f</span><span class="s2">&quot;downstream_dist &gt; </span><span class="si">{</span><span class="n">min_distance_from_endpt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="sa">f</span><span class="s2">&quot;upstream_dist &gt; </span><span class="si">{</span><span class="n">min_distance_from_endpt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="sa">f</span><span class="s2">&quot;n_heads &lt;= </span><span class="si">{</span><span class="n">n_heads_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">spine_synapse_rename_dict</span>  <span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">spine_compartment</span> <span class="o">=</span> <span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span>
            <span class="n">syn_spine_volume</span> <span class="o">=</span> <span class="s2">&quot;spine_volume&quot;</span><span class="p">,</span>
            <span class="n">syn_spine_area</span> <span class="o">=</span> <span class="s2">&quot;spine_area&quot;</span><span class="p">,</span>
            <span class="n">syn_spine_width_ray_80_perc</span> <span class="o">=</span> <span class="s2">&quot;spine_width_ray_80_perc&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="false_positive_queries"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.false_positive_queries">[docs]</a><span class="k">def</span> <span class="nf">false_positive_queries</span><span class="p">(</span>
    <span class="n">table_type</span> <span class="o">=</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span>
    <span class="n">invert</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_axons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">return_queries</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">slab_query_1</span><span class="p">,</span>
        <span class="n">slab_query_2</span><span class="p">,</span>
        <span class="n">slab_query_3</span><span class="p">,</span>
        <span class="n">slab_query_4</span><span class="p">,</span>
        <span class="n">slab_query_5</span><span class="p">,</span>
        <span class="n">long_merge</span><span class="p">,</span>
        <span class="c1">#too_fat_of_neck</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">include_axons</span><span class="p">:</span>
        <span class="n">return_queries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;compartment == &#39;axon&#39;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">return_queries</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;not (</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_queries</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s2">&quot;dj&quot;</span><span class="p">:</span>
        <span class="n">return_queries</span>  <span class="o">=</span> <span class="p">[</span><span class="n">dju</span><span class="o">.</span><span class="n">dj_query_from_pandas_query</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_queries</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">return_queries</span></div>

<div class="viewcode-block" id="spine_table_restriction_high_confidence"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_table_restriction_high_confidence">[docs]</a><span class="k">def</span> <span class="nf">spine_table_restriction_high_confidence</span><span class="p">(</span>
    <span class="n">table_type</span> <span class="o">=</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span>
    <span class="n">include_default_restrictions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_query_str</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="n">false_positive_queries</span><span class="p">(</span><span class="n">table_type</span><span class="p">,</span><span class="n">invert</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_default_restrictions</span><span class="p">:</span>
        <span class="n">additional_queries</span> <span class="o">=</span> <span class="n">default_spine_restrictions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">table_type</span> <span class="o">==</span> <span class="s2">&quot;dj&quot;</span><span class="p">:</span>
            <span class="n">additional_queries</span> <span class="o">=</span> <span class="p">[</span><span class="n">dju</span><span class="o">.</span><span class="n">dj_query_from_pandas_query</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">additional_queries</span><span class="p">]</span>
        <span class="n">return_value</span> <span class="o">+=</span> <span class="n">additional_queries</span>
        
    <span class="k">if</span> <span class="n">return_query_str</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query_str_from_list</span><span class="p">(</span><span class="n">return_value</span><span class="p">,</span><span class="n">table_type</span> <span class="o">=</span> <span class="n">table_type</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>
    
<div class="viewcode-block" id="filter_for_high_confidence_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_for_high_confidence_df">[docs]</a><span class="k">def</span> <span class="nf">filter_for_high_confidence_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">apply_default_restrictions</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">return_df</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_away_fp_from_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">apply_default_restrictions</span><span class="p">:</span>
        <span class="n">return_df</span> <span class="o">=</span>  <span class="n">return_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">spine_table_restriction_high_confidence</span><span class="p">(</span><span class="n">table_type</span><span class="o">=</span><span class="s1">&#39;pandas&#39;</span><span class="p">,</span><span class="n">return_query_str</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">return_df</span></div>

<div class="viewcode-block" id="filter_away_fp_from_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_away_fp_from_df">[docs]</a><span class="k">def</span> <span class="nf">filter_away_fp_from_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">fp_queries</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.000001</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempting to filter away fp&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">fp_queries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fp_queries</span> <span class="o">=</span> <span class="n">false_positive_queries</span><span class="p">()</span>
        
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_volume_to_spine_area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_volume&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_area&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_to_shaft_border_area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_area&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;shaft_border_area&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_area_per_faces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_area&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_n_faces&quot;</span><span class="p">]</span>
    
    <span class="n">return_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query_table_from_list</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">restrictions</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;not (</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fp_queries</span><span class="p">],</span>
        <span class="n">verbose_filtering</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span> 
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_df</span></div>

<div class="viewcode-block" id="colors_from_spine_bouton_labels"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.colors_from_spine_bouton_labels">[docs]</a><span class="k">def</span> <span class="nf">colors_from_spine_bouton_labels</span><span class="p">(</span><span class="n">spine_bouton_labels</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spine_bouton_labels_colors_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_bouton_labels</span><span class="p">]</span></div>

<div class="viewcode-block" id="spine_bouton_labels_to_plot"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_bouton_labels_to_plot">[docs]</a><span class="k">def</span> <span class="nf">spine_bouton_labels_to_plot</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">spine_bouton_labels_colors_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="Spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine">[docs]</a><span class="k">class</span> <span class="nc">Spine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classs that will hold information about a spine extracted from a neuron</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh_face_idx: a list of face indices of the branch that belong to the spine mesh</span>
<span class="sd">    mesh: the submesh of the branch that represent the spine (mesh_face_idx indexed into the branch mesh</span>
<span class="sd">    neck_face_idx: a list of face indices of the spine’s mesh that were classified as the neck (can be empty if not detected)</span>
<span class="sd">    head_face_idx:  list of face indices of the spine’s mesh that were classified as the head (can be empty if not detected)</span>
<span class="sd">    neck_sdf: the sdf value of the neck submesh from the clustering algorithm used to segment the head from the neck </span>
<span class="sd">    head_sdf: the sdf value of the head submesh from the clustering algorithm used to segment the head from the neck </span>
<span class="sd">    head_width: a width approximation using ray tracing of the head submesh</span>
<span class="sd">    neck_width:  a width approximation using ray tracing of the head submesh</span>
<span class="sd">    volume: volume of entire mesh</span>
<span class="sd">    spine_id: unique identifier for spine</span>
<span class="sd">    sdf:  the sdf value of the spine submesh from the clustering algorithm used to segment the spine from the branch mesh</span>
<span class="sd">    endpoints_dist: skeletal walk distance of the skeletal point closest to the start of the spine protrusion to the branch skeletal endpoints</span>
<span class="sd">    upstream_dist: skeletal walk distance of the skeletal point closest to the start of the spine protrusion to the upstream branch skeletal endpoint</span>
<span class="sd">    downstream_dist: skeletal walk distance of the skeletal point closest to the start of the spine protrusion to the downstream branch skeletal endpoint</span>
<span class="sd">    coordinate_border_verts: </span>
<span class="sd">    coordinate: one coordinate of the border vertices to be used for spine locations</span>
<span class="sd">    bbox_oriented_side_lengths</span>
<span class="sd">    head_bbox_oriented_side_lengths</span>
<span class="sd">    neck_bbox_oriented_side_lengths</span>
<span class="sd">    head_mesh_splits</span>
<span class="sd">    head_mesh_splits_face_idx</span>
<span class="sd">    branch_width_overall</span>
<span class="sd">    branch_skeletal_length</span>
<span class="sd">    branch_width_at_base</span>
<span class="sd">    skeleton: surface skeleton over the spine mesh</span>
<span class="sd">    skeletal_length: length of spine skeleton</span>

<span class="sd">    # -- attributes similar to those of spine attribute</span>
<span class="sd">    closest_branch_face_idx</span>
<span class="sd">    closest_sk_coordinate: 3D location in space of closest skeletal point on branch for which spine is located</span>
<span class="sd">    closest_face_coordinate: center coordinate of closest mesh face  on branch for which spine is located</span>
<span class="sd">    closest_face_dist: distance from synapse coordinate to closest_face_coordinate</span>
<span class="sd">    soma_distance: skeletal walk distance from synapse to soma</span>
<span class="sd">    soma_distance_euclidean: straight path distance from synapse to soma center</span>
<span class="sd">    compartment: the compartment of the branch that the spine is located on</span>
<span class="sd">    limb_idx: the limb identifier that the spine is located on</span>
<span class="sd">    branch_idx: the branch identifier that the spine is located on</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Spine.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">calculate_spine_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="o">==</span> <span class="n">spu</span><span class="o">.</span><span class="n">Spine</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">export</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1">#setattr(self,k,v)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> 
            
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">spine_attributes</span><span class="p">:</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="c1">#if synapse_dict is not None:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_attributes</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">calculate_spine_attributes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_spine_attributes</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">=</span><span class="n">branch_obj</span><span class="p">)</span></div>
            
                
<div class="viewcode-block" id="Spine.calculate_spine_attributes"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.calculate_spine_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_spine_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">branch_obj</span><span class="o">=</span><span class="n">branch_obj</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="Spine.export"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>  
        <span class="n">attributes_to_skip</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attributes_to_add</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">export</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">attributes_to_skip</span><span class="o">=</span><span class="n">attributes_to_skip</span><span class="p">,</span>
            <span class="n">attributes_to_add</span><span class="o">=</span><span class="n">attributes_to_add</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span></div>
        
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_coordinate_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_coordinate_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_coordinate_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_coordinate</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bbox_oriented_side_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox_oriented_side_lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bbox_oriented_side_lengths</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">bounding_box_side_lengths_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bbox_oriented_side_lengths</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_oriented_side_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_bbox_oriented_side_lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_head_bbox_oriented_side_lengths</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">bounding_box_side_lengths_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_mesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_bbox_oriented_side_lengths</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_oriented_side_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">neck_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neck_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neck_bbox_oriented_side_lengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_neck_bbox_oriented_side_lengths</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">bounding_box_side_lengths_sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neck_mesh</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_neck_bbox_oriented_side_lengths</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_oriented_side_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">bbox_oriented_side_max</span> <span class="o">=</span> <span class="n">spine_bbox_oriented_side_max</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_oriented_side_middle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">bbox_oriented_side_middle</span> <span class="o">=</span> <span class="n">spine_bbox_oriented_side_middle</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_oriented_side_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">bbox_oriented_side_min</span> <span class="o">=</span> <span class="n">spine_bbox_oriented_side_min</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_oriented_side_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_oriented_side_middle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_oriented_side_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_oriented_side_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neck_bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_oriented_side_middle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neck_bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_oriented_side_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neck_bbox_oriented_side_lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
<span class="c1">#     def head_mesh_splits(</span>
<span class="c1">#         self,</span>
<span class="c1">#         n_faces_threshold = 10):</span>
<span class="c1">#         if self.n_faces_head == 0:</span>
<span class="c1">#             return []</span>
<span class="c1">#         else:</span>
<span class="c1">#             return tu.split_significant_pieces(</span>
<span class="c1">#                 self.head_mesh,</span>
<span class="c1">#                 significance_threshold=n_faces_threshold,</span>
<span class="c1">#                 connectivity=&quot;vertices&quot;</span>
<span class="c1">#             )</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_mesh_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits_face_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">split_head_mesh</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits</span> 
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_mesh_splits_face_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits_face_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits_face_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">split_head_mesh</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
            <span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits_face_idx</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_heads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_mesh_splits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_mesh_splits</span><span class="p">)</span>
    
<div class="viewcode-block" id="Spine.head_mesh_splits_from_index"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.head_mesh_splits_from_index">[docs]</a>    <span class="k">def</span> <span class="nf">head_mesh_splits_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_mesh_splits_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_mesh_splits_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_mesh_splits_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_mesh_splits_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_mesh_splits_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_heads</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_faces_head</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_face_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_faces_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">neck_face_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neck_face_idx</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">neck_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">area</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no_head_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">no_head_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_exist</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no_head_face_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head_exist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neck_face_idx</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_skeleton</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeletal_length</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_skeleton</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton</span>
    
<div class="viewcode-block" id="Spine.calculate_head_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.calculate_head_neck">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_head_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">neck_face_idx</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">head_sdf</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">neck_sdf</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">head_width</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">neck_width</span><span class="p">)</span> <span class="o">=</span> <span class="n">spine_head_neck</span><span class="p">(</span>
            <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">no_head_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_border_verts</span><span class="p">,</span>
            <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_head_mesh_splits</span> <span class="o">=</span> <span class="kc">None</span></div>
<div class="viewcode-block" id="Spine.calculate_face_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.calculate_face_idx">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_face_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">original_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_face_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                   <span class="n">original_mesh</span><span class="o">=</span><span class="n">original_mesh</span><span class="p">,</span>
                                                   <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="Spine.plot_head_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.plot_head_neck">[docs]</a>    <span class="k">def</span> <span class="nf">plot_head_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">plot_head_neck</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Spine.calculate_closest_mesh_sk_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.calculate_closest_mesh_sk_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_closest_mesh_sk_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">branch_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_obj_mesh_skeleton_coordinates</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Spine.calculate_volume"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.calculate_volume">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">volume_from_spine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Spine.calculate_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.Spine.calculate_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">skeleton_from_spine</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skeletal_length</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span></div>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">centroid</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mesh_center_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sdf_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sdf_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median_sdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sdf_90_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sdf_70_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sdf</span><span class="p">,</span><span class="mi">70</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endpoint_dist_0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nd">@property</span>   
    <span class="k">def</span> <span class="nf">endpoint_dist_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area_of_border_verts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">area_of_border_verts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">coordinate_border_verts_area</span> <span class="o">=</span> <span class="n">area_of_border_verts</span>
    <span class="n">border_area</span> <span class="o">=</span> <span class="n">area_of_border_verts</span>
    <span class="n">shaft_border_area</span> <span class="o">=</span> <span class="n">area_of_border_verts</span>
    
    <span class="c1">#--- Mesh Attribute Functions for spine -----</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_width_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">width_ray_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_width_ray_80_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">width_ray_80_perc_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">area_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">volume_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">skeletal_length_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_min_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_x_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_min_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_y_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_min_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_z_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_max_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_x_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_max_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_y_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spine_bbox_max_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_z_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;spine&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">#--- Mesh Attribute Functions for head -----</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_width_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">width_ray_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_width_ray_80_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">width_ray_80_perc_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">area_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">volume_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">skeletal_length_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_min_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_x_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_min_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_y_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_min_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_z_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_max_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_x_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_max_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_y_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">head_bbox_max_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_z_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">#--- Mesh Attribute Functions for neck -----</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_width_ray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">width_ray_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_width_ray_80_perc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">width_ray_80_perc_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">area_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">volume_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_skeletal_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">skeletal_length_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_min_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_x_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_min_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_y_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_min_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_min_z_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_max_x_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_x_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_max_y_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_y_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">neck_bbox_max_z_nm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">bbox_max_z_nm_from_compartment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">compartment</span> <span class="o">=</span> <span class="s1">&#39;neck&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
    
<span class="n">computed_attributes_to_export</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;area&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sdf_mean&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_faces&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_faces_head&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_faces_neck&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mesh_center&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sdf_mean&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sdf_90_perc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sdf_70_perc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_oriented_side_max&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_oriented_side_middle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_oriented_side_min&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_heads&quot;</span><span class="p">,</span>
        <span class="s2">&quot;endpoint_dist_0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;endpoint_dist_1&quot;</span>
<span class="p">)</span>
    
    
<div class="viewcode-block" id="calculate_soma_distance_euclidean"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_soma_distance_euclidean">[docs]</a><span class="k">def</span> <span class="nf">calculate_soma_distance_euclidean</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">soma_center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">soma_center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_obj</span><span class="o">.</span><span class="n">soma_distance_euclidean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">soma_center</span> <span class="o">-</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="calculate_soma_distance_skeletal"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_soma_distance_skeletal">[docs]</a><span class="k">def</span> <span class="nf">calculate_soma_distance_skeletal</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">upstream_skeletal_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">upstream_skeletal_length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">upstream_dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">spine_obj</span><span class="o">.</span><span class="n">soma_distance</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">upstream_dist</span> <span class="o">+</span> <span class="n">upstream_skeletal_length</span> </div>
    
    

<div class="viewcode-block" id="calculate_branch_width_at_base"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_branch_width_at_base">[docs]</a><span class="k">def</span> <span class="nf">calculate_branch_width_at_base</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">branch_obj</span><span class="p">):</span>
    <span class="n">spine_obj</span><span class="o">.</span><span class="n">branch_width_at_base</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">width_array_value_closest_to_coordinate</span><span class="p">(</span>
                <span class="n">branch_obj</span><span class="p">,</span>
                <span class="n">spine_obj</span><span class="o">.</span><span class="n">base_coordinate</span>
    <span class="p">)</span></div>
    
<span class="n">branch_overall_features_for_spine</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;width_overall&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span><span class="c1">#branch_width_at_base</span>
<div class="viewcode-block" id="calculate_branch_overall_features"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_branch_overall_features">[docs]</a><span class="k">def</span> <span class="nf">calculate_branch_overall_features</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">branch_obj</span><span class="p">,</span>
    <span class="n">branch_features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">branch_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_features</span> <span class="o">=</span> <span class="n">branch_overall_features_for_spine</span>

    <span class="n">branch_features</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">branch_features</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">branch_features</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">feat</span><span class="p">)):</span>
            <span class="n">curr_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">feat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_value</span> <span class="o">=</span> <span class="n">feat</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;branch_</span><span class="si">{</span><span class="n">feat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">curr_value</span><span class="p">)</span></div>
        
    
        
    
<div class="viewcode-block" id="calculate_spine_attributes"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spine_attributes">[docs]</a><span class="k">def</span> <span class="nf">calculate_spine_attributes</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">calculate_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">calculate_head_neck</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">branch_shaft_mesh_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">branch_features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    Given a spine mesh (and potentially the branch object it resides on) calculates descriptive statistics</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) calculates the volume</span>
<span class="sd">    2) calculates the bounding box side lengths</span>
<span class="sd">    3) calculates branch relative statistics:</span>
<span class="sd">        a) closest mesh/skeleton coordinate</span>
<span class="sd">        b) distance of spine base to each skeleton endpoint</span>
<span class="sd">        c) width of branch obj at the base of the spine</span>
<span class="sd">    4) Optionally calculates the head and neck clusters and statistics. spu.calculate_head_neck</span>

<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ------------------------</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spine_obj : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    branch_obj : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    calculate_coordinates : bool, optional</span>
<span class="sd">        _description_, by default True</span>
<span class="sd">    calculate_head_neck : bool, optional</span>
<span class="sd">        _description_, by default False</span>
<span class="sd">    branch_shaft_mesh_face_idx : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    soma_center : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    upstream_skeletal_length : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    branch_features : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    verbose_time : bool, optional</span>
<span class="sd">        _description_, by default False</span>
<span class="sd">    mesh : _type_, optional</span>
<span class="sd">        _description_, by default None</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">spine_obj</span><span class="o">.</span><span class="n">skeleton</span>
    
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for skeleton = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">spine_obj</span><span class="o">.</span><span class="n">calculate_volume</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for volume = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">spine_obj</span><span class="o">.</span><span class="n">bbox_oriented_side_lengths</span>
    <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for bbox = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">calculate_coordinates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spine_obj</span><span class="o">.</span><span class="n">calculate_closest_mesh_sk_coordinates</span><span class="p">(</span>
                <span class="n">branch_obj</span><span class="p">,</span>
                <span class="n">verbose_time</span><span class="o">=</span><span class="n">verbose_time</span><span class="p">,</span>
                <span class="n">branch_shaft_mesh_face_idx</span><span class="o">=</span><span class="n">branch_shaft_mesh_face_idx</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for closest_coordinate = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">spu</span><span class="o">.</span><span class="n">calculate_endpoints_dist</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">spine_obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for calculate_endpoints_dist = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoints_upstream_downstream_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">spu</span><span class="o">.</span><span class="n">calculate_upstream_downstream_dist_from_up_idx</span><span class="p">(</span>
                    <span class="n">spine_obj</span><span class="p">,</span>
                    <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoints_upstream_downstream_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for calculate_upstream_downstream_dist_from_up_idx = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    
                <span class="n">calculate_branch_width_at_base</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">branch_obj</span><span class="p">)</span>
            
            
    
    <span class="k">if</span> <span class="n">calculate_head_neck</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">spine_obj</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_obj_mesh_skeleton_coordinates</span><span class="p">(</span>
            <span class="n">spine_obj</span><span class="o">=</span><span class="n">spine_obj</span><span class="p">,</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">spine_obj</span><span class="o">.</span><span class="n">calculate_head_neck</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for calculate_head_neck = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh_splits</span>
        <span class="k">if</span> <span class="n">verbose_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for head_mesh_splits = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
    
    <span class="n">calculate_soma_distance_euclidean</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">soma_center</span><span class="p">)</span>
    <span class="n">calculate_soma_distance_skeletal</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">upstream_skeletal_length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">calculate_branch_overall_features</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">branch_features</span><span class="o">=</span><span class="n">branch_features</span><span class="p">,)</span>
    
    <span class="k">return</span> <span class="n">spine_obj</span></div>

<div class="viewcode-block" id="mesh_minus_spine_objs"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.mesh_minus_spine_objs">[docs]</a><span class="k">def</span> <span class="nf">mesh_minus_spine_objs</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the shaft mesh of a branch</span>
<span class="sd">    given a list of spines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">]</span>
                                      <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="calculate_spine_attributes_for_list"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spine_attributes_for_list">[docs]</a><span class="k">def</span> <span class="nf">calculate_spine_attributes_for_list</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">branch_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">calculate_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">calculate_head_neck</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">calculate_coordinates</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">branch_shaft_mesh_face_idx</span> <span class="o">=</span> <span class="n">mesh_minus_spine_objs</span><span class="p">(</span>
            <span class="n">spine_objs</span><span class="p">,</span>
            <span class="n">branch_obj</span><span class="o">=</span><span class="n">branch_obj</span><span class="p">,</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
            <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branch_shaft_mesh_face_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_attributes</span><span class="p">(</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="p">,</span>
        <span class="n">calculate_coordinates</span><span class="o">=</span><span class="n">calculate_coordinates</span><span class="p">,</span>
        <span class="n">calculate_head_neck</span><span class="o">=</span><span class="n">calculate_head_neck</span><span class="p">,</span>
        <span class="n">verbose_time</span><span class="o">=</span><span class="n">verbose_time</span><span class="p">,</span>
        <span class="n">branch_shaft_mesh_face_idx</span><span class="o">=</span><span class="n">branch_shaft_mesh_face_idx</span><span class="p">,</span>
        <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">]</span></div>
    
        
<div class="viewcode-block" id="is_spine_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.is_spine_obj">[docs]</a><span class="k">def</span> <span class="nf">is_spine_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="c1">#return str(type(obj)) == str(spu.Spine)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">spu</span><span class="o">.</span><span class="n">Spine</span></div>
        
<div class="viewcode-block" id="calculate_face_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_face_idx">[docs]</a><span class="k">def</span> <span class="nf">calculate_face_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span>
                      <span class="n">original_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the original faces </span>
<span class="sd">    of the spine to a reference mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">original_mesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">original_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Either original_mesh or original_mesh_kdtree needs to be non None&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="p">,</span>
                                     <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">,</span>
                                     <span class="n">submesh</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                      <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="plot_head_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_head_neck">[docs]</a><span class="k">def</span> <span class="nf">plot_head_neck</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span>
                   <span class="n">neck_color</span> <span class="o">=</span> <span class="n">neck_color_default</span><span class="p">,</span>
                    <span class="n">head_color</span> <span class="o">=</span> <span class="n">head_color_default</span><span class="p">,</span>
                   <span class="n">no_head_color</span> <span class="o">=</span> <span class="n">no_head_color_default</span><span class="p">,</span>
                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">neck_mesh</span> <span class="o">=</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">neck_mesh</span>
    <span class="n">head_mesh</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh</span>
    <span class="n">no_head_mesh</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">no_head_mesh</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_mesh (</span><span class="si">{</span><span class="n">head_color</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">head_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_mesh (</span><span class="si">{</span><span class="n">neck_color</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">neck_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no_head_mesh (</span><span class="si">{</span><span class="n">no_head_color</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">no_head_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">neck_mesh</span><span class="p">,</span><span class="n">head_mesh</span><span class="p">,</span><span class="n">no_head_mesh</span><span class="p">],</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="n">neck_color</span><span class="p">,</span><span class="n">head_color</span><span class="p">,</span><span class="n">no_head_color</span><span class="p">])</span></div>
    
    
<div class="viewcode-block" id="mesh_from_name_or_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.mesh_from_name_or_idx">[docs]</a><span class="k">def</span> <span class="nf">mesh_from_name_or_idx</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">largest_component</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;face_idx&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_face_idx&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span>  <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">largest_component</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">largest_conn_comp</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">mesh</span></div>
    
<div class="viewcode-block" id="head_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.head_mesh">[docs]</a><span class="k">def</span> <span class="nf">head_mesh</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh_from_name_or_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;head&quot;</span><span class="p">)</span></div>
<div class="viewcode-block" id="neck_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.neck_mesh">[docs]</a><span class="k">def</span> <span class="nf">neck_mesh</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh_from_name_or_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;neck&quot;</span><span class="p">,</span><span class="n">largest_component</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>
<div class="viewcode-block" id="no_head_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.no_head_mesh">[docs]</a><span class="k">def</span> <span class="nf">no_head_mesh</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh_from_name_or_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;no_head&quot;</span><span class="p">)</span></div>
<div class="viewcode-block" id="head_mesh_splits_face_idx_by_index"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.head_mesh_splits_face_idx_by_index">[docs]</a><span class="k">def</span> <span class="nf">head_mesh_splits_face_idx_by_index</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh_splits_face_idx</span> <span class="o">==</span> <span class="n">index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span></div>
<div class="viewcode-block" id="head_mesh_splits_from_index"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.head_mesh_splits_from_index">[docs]</a><span class="k">def</span> <span class="nf">head_mesh_splits_from_index</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh_from_name_or_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">idx</span> <span class="o">=</span> <span class="n">head_mesh_splits_face_idx_by_index</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">index</span><span class="p">))</span></div>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def head_mesh(spine_obj):</span>
<span class="sd">    if spine_obj.head_face_idx is None or len(spine_obj.head_face_idx) == 0:</span>
<span class="sd">        return tu.empty_mesh()</span>
<span class="sd">    else:</span>
<span class="sd">        return spine_obj.mesh.submesh([spine_obj.head_face_idx],append=True)</span>
<span class="sd">    </span>
<span class="sd">def neck_mesh(spine_obj):</span>
<span class="sd">    if spine_obj.neck_face_idx is None:</span>
<span class="sd">        return tu.empty_mesh()</span>
<span class="sd">    else:</span>
<span class="sd">        return spine_obj.mesh.submesh([spine_obj.neck_face_idx],append=True)</span>
<span class="sd">    </span>
<span class="sd">def no_head_mesh(spine_obj):</span>
<span class="sd">    if spine_obj.no_head_face_idx is None or len(spine_obj.no_head_face_idx) == 0:</span>
<span class="sd">        return tu.empty_mesh()</span>
<span class="sd">    else:</span>
<span class="sd">        return spine_obj.mesh.submesh([spine_obj.no_head_face_idx],append=True)</span>
<span class="sd">&quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="head_exist"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.head_exist">[docs]</a><span class="k">def</span> <span class="nf">head_exist</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">head_face_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="export"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.export">[docs]</a><span class="k">def</span> <span class="nf">export</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">attributes_to_skip</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attributes_to_add</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">suppress_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_attributes</span> <span class="o">=</span> <span class="n">spine_attributes</span>
        <span class="k">if</span> <span class="n">attributes_to_skip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_skip</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">attributes_to_skip</span><span class="p">)</span>
            <span class="n">curr_attributes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_attributes</span><span class="p">,</span><span class="n">attributes_to_skip</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attributes_to_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">attributes_to_add</span><span class="o">=</span><span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">attributes_to_add</span><span class="p">)</span>
            <span class="n">curr_attributes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">curr_attributes</span><span class="p">,</span><span class="n">attributes_to_add</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_attributes</span> <span class="o">=</span> <span class="n">attributes</span>

    <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_attributes</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">default_value</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">suppress_errors</span><span class="p">:</span>
                <span class="n">curr_value</span> <span class="o">=</span> <span class="n">default_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                
        <span class="n">return_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_value</span>
    <span class="k">return</span> <span class="n">return_dict</span></div>
        
    <span class="c1">#return {k:getattr(spine_obj,k,None) for k in curr_attributes}</span>
    




<div class="viewcode-block" id="set_branch_spines_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_branch_spines_obj">[docs]</a><span class="k">def</span> <span class="nf">set_branch_spines_obj</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                               <span class="n">calculate_mesh_face_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To set the spine 0bj</span>
<span class="sd">    attribute for a branch</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) store the spine mesh and the volume</span>
<span class="sd">    2) calculate the neck face idx and sdf</span>
<span class="sd">    2) optional: calculate the mesh face_idx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span>
    <span class="n">curr_spines_vol</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_volume</span>
    
    <span class="k">if</span> <span class="n">curr_spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> 

    <span class="n">spines_obj</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">branch_kd</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_kdtree_face</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_off_tqdm</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_on_tqdm</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">vol</span> <span class="ow">in</span> <span class="n">tqu</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">curr_spines</span><span class="p">,</span><span class="n">curr_spines_vol</span><span class="p">)):</span>
        <span class="n">sp_obj</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">Spine</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">volume</span><span class="o">=</span><span class="n">vol</span><span class="p">)</span>
        <span class="n">sp_obj</span><span class="o">.</span><span class="n">calculate_head_neck</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">calculate_mesh_face_idx</span><span class="p">:</span>
            <span class="n">sp_obj</span><span class="o">.</span><span class="n">calculate_face_idx</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                      <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">branch_kd</span><span class="p">)</span>
        <span class="n">spines_obj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_obj</span><span class="p">)</span>

    <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="n">spines_obj</span></div>
    
<div class="viewcode-block" id="set_neuron_spine_attribute"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_neuron_spine_attribute">[docs]</a><span class="k">def</span> <span class="nf">set_neuron_spine_attribute</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">func</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To set the spines obj</span>
<span class="sd">    for all branches in the neuron obj</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">b_idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- branch </span><span class="si">{</span><span class="n">b_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">b_idx</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="set_neuron_spines_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_neuron_spines_obj">[docs]</a><span class="k">def</span> <span class="nf">set_neuron_spines_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">spu</span><span class="o">.</span><span class="n">set_neuron_spine_attribute</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">set_branch_spines_obj</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

            
<div class="viewcode-block" id="set_branch_head_neck_shaft_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_branch_head_neck_shaft_idx">[docs]</a><span class="k">def</span> <span class="nf">set_branch_head_neck_shaft_idx</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                  <span class="n">plot_face_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">add_no_head_label</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">branch_obj</span><span class="o">.</span><span class="n">head_neck_shaft_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_idx_from_branch</span><span class="p">(</span>
                    <span class="n">branch_obj</span><span class="p">,</span>
                    <span class="n">plot_face_idx</span>  <span class="o">=</span> <span class="n">plot_face_idx</span><span class="p">,</span>
                    <span class="n">add_no_head_label</span> <span class="o">=</span> <span class="n">add_no_head_label</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="set_neuron_head_neck_shaft_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_neuron_head_neck_shaft_idx">[docs]</a><span class="k">def</span> <span class="nf">set_neuron_head_neck_shaft_idx</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">add_no_head_label</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">set_neuron_spine_attribute</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">set_branch_head_neck_shaft_idx</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="set_branch_synapses_head_neck_shaft"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_branch_synapses_head_neck_shaft">[docs]</a><span class="k">def</span> <span class="nf">set_branch_synapses_head_neck_shaft</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To use the head_neck_shaft_idx</span>
<span class="sd">    of the branch objects to give the </span>
<span class="sd">    synapses of a branch the head_neck_shaft label</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    If the branch has any </span>
<span class="sd">    1) Build a KDTree of the branch mesh</span>
<span class="sd">    2) find which faces are the closest for the coordinates of all the synapses</span>
<span class="sd">    3) Assign the closest face and the head_neck_shaft to the synapse objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spines_obj</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span>
    <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">mesh_kd</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_kdtree_face</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

        <span class="n">synapse_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">syu</span><span class="o">.</span><span class="n">synapses_to_coordinates</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">mesh_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">synapse_coords</span><span class="p">)</span>
 
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">closest_branch_face_idx</span> <span class="o">=</span> <span class="n">closest_face</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">s</span><span class="o">.</span><span class="n">head_neck_shaft</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">head_neck_shaft_idx</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">closest_branch_face_idx</span><span class="p">]</span></div>
            
<div class="viewcode-block" id="set_neuron_synapses_head_neck_shaft"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_neuron_synapses_head_neck_shaft">[docs]</a><span class="k">def</span> <span class="nf">set_neuron_synapses_head_neck_shaft</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">set_neuron_spine_attribute</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">set_branch_synapses_head_neck_shaft</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_head_neck_shaft_spine_objs"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.add_head_neck_shaft_spine_objs">[docs]</a><span class="k">def</span> <span class="nf">add_head_neck_shaft_spine_objs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">add_synapse_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">filter_spines_for_size</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                   <span class="n">add_distance_attributes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will do the additionaly processing that</span>
<span class="sd">    adds the spine objects to a neuron and then</span>
<span class="sd">    creates the head_neck_shaft_idx for the branches </span>
<span class="sd">    </span>
<span class="sd">    Application: Can be used later to map synapses</span>
<span class="sd">    to the accurate label</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">filter_spines_for_size</span><span class="p">:</span>
        
        <span class="n">neuron_obj</span><span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_spines_by_size</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for fitlering spines by size </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">spu</span><span class="o">.</span><span class="n">set_neuron_spines_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for set_neuron_spines_obj </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">spu</span><span class="o">.</span><span class="n">set_neuron_head_neck_shaft_idx</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for set_neuron_head_neck_shaft_idx </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">add_synapse_labels</span><span class="p">:</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">set_neuron_synapses_head_neck_shaft</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for set_neuron_synapses_head_neck_shaft </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
    <span class="k">if</span> <span class="n">add_distance_attributes</span><span class="p">:</span>
        <span class="n">neuron_obj</span><span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_obj_attr_for_neuron</span><span class="p">(</span>
                <span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for calculate_spine_obj_attr_for_neuron </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">neuron_obj</span></div>
            
    
<div class="viewcode-block" id="spines_head_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines_head_meshes">[docs]</a><span class="k">def</span> <span class="nf">spines_head_meshes</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">head_mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">]</span></div>
<div class="viewcode-block" id="spines_neck_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines_neck_meshes">[docs]</a><span class="k">def</span> <span class="nf">spines_neck_meshes</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">neck_mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">]</span></div>
<div class="viewcode-block" id="spines_no_head_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines_no_head_meshes">[docs]</a><span class="k">def</span> <span class="nf">spines_no_head_meshes</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">no_head_mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">]</span></div>

<div class="viewcode-block" id="spines"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines">[docs]</a><span class="k">def</span> <span class="nf">spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    <span class="k">return</span> <span class="n">curr_spines</span></div>

<div class="viewcode-block" id="spines_head"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines_head">[docs]</a><span class="k">def</span> <span class="nf">spines_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_spines</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">head_exist</span><span class="p">]</span></div>
<div class="viewcode-block" id="spines_no_head"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines_no_head">[docs]</a><span class="k">def</span> <span class="nf">spines_no_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_spines</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="o">.</span><span class="n">head_exist</span><span class="p">]</span></div>
<div class="viewcode-block" id="spines_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spines_neck">[docs]</a><span class="k">def</span> <span class="nf">spines_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">spines_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_spines"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_spines">[docs]</a><span class="k">def</span> <span class="nf">n_spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">spu</span><span class="o">.</span><span class="n">spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span></div>
<div class="viewcode-block" id="n_spines_head"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_spines_head">[docs]</a><span class="k">def</span> <span class="nf">n_spines_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">spu</span><span class="o">.</span><span class="n">spines_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span></div>
<div class="viewcode-block" id="n_spines_no_head"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_spines_no_head">[docs]</a><span class="k">def</span> <span class="nf">n_spines_no_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">spu</span><span class="o">.</span><span class="n">spines_no_head</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span></div>
<div class="viewcode-block" id="n_spines_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_spines_neck">[docs]</a><span class="k">def</span> <span class="nf">n_spines_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">spu</span><span class="o">.</span><span class="n">spines_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span></div>


<div class="viewcode-block" id="plot_spines_head_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spines_head_neck">[docs]</a><span class="k">def</span> <span class="nf">plot_spines_head_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">head_color</span> <span class="o">=</span> <span class="n">head_color_default</span><span class="p">,</span>
                         <span class="n">neck_color</span> <span class="o">=</span> <span class="n">neck_color_default</span><span class="p">,</span>
                          <span class="n">no_head_color</span> <span class="o">=</span> <span class="n">no_head_color_default</span><span class="p">,</span>
                          <span class="n">bouton_color</span> <span class="o">=</span> <span class="n">bouton_color_default</span><span class="p">,</span>
                          <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">combine_meshes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="p">):</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_lite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">spine_heads</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spines_head_meshes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">meshes_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">head_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_heads</span><span class="p">)</span>
    
    <span class="n">spine_necks</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spines_neck_meshes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">meshes_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">neck_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_necks</span><span class="p">)</span>
    
    <span class="n">spine_no_heads</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spines_no_head_meshes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">meshes_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">no_head_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_no_heads</span><span class="p">)</span>
    
    <span class="n">boutons</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">boutons</span>
    <span class="n">meshes_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">bouton_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">boutons</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of spine_heads = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_heads</span><span class="p">)</span><span class="si">}</span><span class="s2">, # of spine_necks= </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_necks</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_no_heads</span><span class="p">)</span><span class="si">}</span><span class="s2">, # of spine_no_heads = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_no_heads</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">combine_meshes</span><span class="p">:</span>
        <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">head_color</span><span class="p">,</span><span class="n">neck_color</span><span class="p">,</span><span class="n">no_head_color</span><span class="p">,</span><span class="n">bouton_color</span><span class="p">]</span>
        <span class="n">spine_heads</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">spine_heads</span><span class="p">)]</span>
        <span class="n">spine_necks</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">spine_necks</span><span class="p">)]</span>
        <span class="n">spine_no_heads</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">spine_no_heads</span><span class="p">)]</span>
        <span class="n">boutons</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">boutons</span><span class="p">)]</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_heads</span><span class="o">+</span><span class="n">spine_necks</span><span class="o">+</span><span class="n">spine_no_heads</span><span class="o">+</span><span class="n">boutons</span>
        
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                     <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
                     <span class="n">show_at_end</span><span class="o">=</span><span class="n">show_at_end</span><span class="p">,)</span></div>
    
<span class="c1"># -------------- End of Spines Obj -------------- #</span>
    
    
<span class="n">connectivity</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span>

<span class="sd">&quot;&quot;&quot;   DON&#39;T NEED THIS FUNCTION ANYMORE BECAUSE REPLACED BY TRIMESH_UTILS MESH_SEGMENTATION</span>
<span class="sd">def cgal_segmentation(written_file_location,</span>
<span class="sd">                      clusters=2,</span>
<span class="sd">                      smoothness=0.03,</span>
<span class="sd">                      return_sdf=True,</span>
<span class="sd">                     print_flag=False,</span>
<span class="sd">                     delete_temp_file=True):</span>
<span class="sd">    </span>
<span class="sd">    if written_file_location[-4:] == &quot;.off&quot;:</span>
<span class="sd">        cgal_mesh_file = written_file_location[:-4]</span>
<span class="sd">    else:</span>
<span class="sd">        cgal_mesh_file = written_file_location</span>
<span class="sd">    if print_flag:</span>
<span class="sd">        print(f&quot;Going to run cgal segmentation with:&quot;</span>
<span class="sd">             f&quot;\nFile: {cgal_mesh_file} \nclusters:{clusters} \nsmoothness:{smoothness}&quot;)</span>

<span class="sd">    csm.cgal_segmentation(cgal_mesh_file,clusters,smoothness)</span>

<span class="sd">    #read in the csv file</span>
<span class="sd">    cgal_output_file = Path(cgal_mesh_file + &quot;-cgal_&quot; + str(np.round(clusters,2)) + &quot;_&quot; + &quot;{:.2f}&quot;.format(smoothness) + &quot;.csv&quot; )</span>
<span class="sd">    cgal_output_file_sdf = Path(cgal_mesh_file + &quot;-cgal_&quot; + str(np.round(clusters,2)) + &quot;_&quot; + &quot;{:.2f}&quot;.format(smoothness) + &quot;_sdf.csv&quot; )</span>

<span class="sd">    cgal_data = np.genfromtxt(str(cgal_output_file.absolute()), delimiter=&#39;\n&#39;)</span>
<span class="sd">    cgal_sdf_data = np.genfromtxt(str(cgal_output_file_sdf.absolute()), delimiter=&#39;\n&#39;)</span>
<span class="sd">    </span>
<span class="sd">    if delete_temp_file:</span>
<span class="sd">        cgal_output_file.unlink()</span>
<span class="sd">        cgal_output_file_sdf.unlink()</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    if return_sdf:</span>
<span class="sd">        return cgal_data,cgal_sdf_data</span>
<span class="sd">    else:</span>
<span class="sd">        return cgal_data&quot;&quot;&quot;</span>

<div class="viewcode-block" id="split_mesh_into_spines_shaft_old"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.split_mesh_into_spines_shaft_old">[docs]</a><span class="k">def</span> <span class="nf">split_mesh_into_spines_shaft_old</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                           <span class="n">segment_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                           <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">smoothness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./cgal_temp&quot;</span><span class="p">),</span>
                          <span class="n">delete_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    if not cgal_folder.exists():</span>
<span class="sd">        cgal_folder.mkdir(parents=True,exist_ok=False)</span>

<span class="sd">    file_to_write = cgal_folder / Path(f&quot;segment_{segment_name}.off&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # ------- 1/14 Additon: Going to make sure mesh has no degenerate faces --- #</span>
<span class="sd">    if filter_away_degenerate_faces:</span>
<span class="sd">        mesh_to_segment,faces_kept = tu.connected_nondegenerate_mesh(current_mesh,</span>
<span class="sd">                                                                     return_kept_faces_idx=True,</span>
<span class="sd">                                                                     return_removed_faces_idx=False)</span>


<span class="sd">        written_file_location = tu.write_neuron_off(mesh_to_segment,file_to_write)</span>
<span class="sd">    else:</span>
<span class="sd">        written_file_location = tu.write_neuron_off(current_mesh,file_to_write)</span>
<span class="sd">    </span>
<span class="sd">    cgal_data_pre_filt,cgal_sdf_data_pre_filt = cgal_segmentation(written_file_location,</span>
<span class="sd">                                             clusters,</span>
<span class="sd">                                             smoothness,</span>
<span class="sd">                                             return_sdf=True,</span>
<span class="sd">                                               delete_temp_file=delete_temp_file)</span>
<span class="sd">    </span>
<span class="sd">    if filter_away_degenerate_faces:</span>
<span class="sd">        cgal_data = np.ones(len(current_mesh.faces))*(np.max(cgal_data_pre_filt)+1)</span>
<span class="sd">        cgal_data[faces_kept] = cgal_data_pre_filt</span>

<span class="sd">        cgal_sdf_data = np.zeros(len(current_mesh.faces))</span>
<span class="sd">        cgal_sdf_data[faces_kept] = cgal_sdf_data_pre_filt</span>
<span class="sd">    else:</span>
<span class="sd">        cgal_data = cgal_data_pre_filt</span>
<span class="sd">        cgal_sdf_data = cgal_sdf_data_pre_filt</span>
<span class="sd">        </span>
<span class="sd">    #print(f&quot;file_to_write = {file_to_write.absolute()}&quot;)</span>
<span class="sd">    if delete_temp_file:</span>
<span class="sd">        #print(&quot;attempting to delete file&quot;)</span>
<span class="sd">        file_to_write.unlink()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters_threshold_global</span>
    
    <span class="k">if</span> <span class="n">smoothness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smoothness</span> <span class="o">=</span> <span class="n">smoothness_threshold_global</span>
        
    <span class="k">if</span> <span class="n">shaft_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="n">shaft_threshold_global</span>
    
    

    <span class="c1">#print(f&quot;plot_segmentation= {plot_segmentation}&quot;)</span>
    <span class="n">cgal_data</span><span class="p">,</span><span class="n">cgal_sdf_data</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                                                  <span class="n">cgal_folder</span><span class="o">=</span><span class="n">cgal_folder</span><span class="p">,</span>
                                                   <span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span>
                                                   <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">,</span>
                                                   <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">delete_temp_files</span><span class="o">=</span><span class="n">delete_temp_file</span><span class="p">,</span>
                                                   <span class="n">return_meshes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">return_ordered_by_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="n">plot_segmentation</span><span class="p">,</span>
                                                  <span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; 1/14: Need to adjust for the degenerate faces removed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    <span class="c1">#get a look at how many groups and what distribution:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Counter of data = </span><span class="si">{</span><span class="n">Counter</span><span class="p">(</span><span class="n">cgal_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#gets the meshes that are split using the cgal labels</span>
    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">cgal_data</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    
    
    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There was only one mesh found from the spine process and mesh split, returning empty array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[]</span>
        
    
<span class="c1">#     # How to identify just one shaft</span>
<span class="c1">#     shaft_index = -1</span>
<span class="c1">#     shaft_total = -1</span>
<span class="c1">#     for k,v in split_meshes.items():</span>
<span class="c1">#         curr_length = len(v.faces)</span>
<span class="c1">#         if  curr_length &gt; shaft_total:</span>
<span class="c1">#             shaft_index = k</span>
<span class="c1">#             shaft_total = curr_length</span>
    
<span class="c1">#     shaft_mesh = split_meshes.pop(shaft_index)</span>
<span class="c1">#     shaft_mesh_idx = split_meshes_idx.pop(shaft_index)</span>
    
<span class="c1">#     print(f&quot;shaft_index = {shaft_index}&quot;)</span>
    
    <span class="n">shaft_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shaft_meshes_idx</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">spine_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spine_meshes_idx</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#Applying a length threshold to get all other possible shaft meshes</span>
    <span class="k">for</span> <span class="n">spine_id</span><span class="p">,</span><span class="n">spine_mesh</span> <span class="ow">in</span> <span class="n">split_meshes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">shaft_threshold</span><span class="p">:</span>
            <span class="n">spine_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">)</span>
            <span class="n">spine_meshes_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_meshes_idx</span><span class="p">[</span><span class="n">spine_id</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shaft_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">)</span>
            <span class="n">shaft_meshes_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split_meshes_idx</span><span class="p">[</span><span class="n">spine_id</span><span class="p">])</span>
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No shaft meshes detected&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[]</span>
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No spine meshes detected&quot;</span><span class="p">)</span>
            

    <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_meshes</span><span class="p">,</span><span class="n">spine_meshes_idx</span><span class="p">,</span><span class="n">shaft_meshes</span><span class="p">,</span><span class="n">shaft_meshes_idx</span><span class="p">,</span><span class="n">cgal_sdf_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_meshes</span><span class="p">,</span><span class="n">spine_meshes_idx</span><span class="p">,</span><span class="n">shaft_meshes</span><span class="p">,</span><span class="n">shaft_meshes_idx</span></div>
    
    
<div class="viewcode-block" id="get_spine_meshes_unfiltered_from_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.get_spine_meshes_unfiltered_from_mesh">[docs]</a><span class="k">def</span> <span class="nf">get_spine_meshes_unfiltered_from_mesh</span><span class="p">(</span>
    <span class="n">current_mesh</span><span class="p">,</span>
    <span class="n">segment_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">smoothness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shaft_expansion_method</span> <span class="o">=</span> <span class="s2">&quot;path_to_all_shaft_mesh&quot;</span><span class="p">,</span>
    <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./cgal_temp&quot;</span><span class="p">),</span>
    <span class="n">delete_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_sdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_mesh_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">shaft_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ensure_mesh_conn_comp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_shaft</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    First initial spine mesh detection on a branch mesh</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>

<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters_threshold_global</span>
    
    <span class="k">if</span> <span class="n">smoothness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smoothness</span> <span class="o">=</span> <span class="n">smoothness_threshold_global</span>
        
    <span class="k">if</span> <span class="n">shaft_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="n">shaft_threshold_global</span>
    
    
    <span class="k">if</span> <span class="n">segment_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segment_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="c1">#print(f&quot;segment_name before cgal = {segment_name}&quot;)</span>
    <span class="p">(</span><span class="n">spine_meshes</span><span class="p">,</span>
     <span class="n">spine_meshes_idx</span><span class="p">,</span>
     <span class="n">shaft_meshes</span><span class="p">,</span>
     <span class="n">shaft_meshes_idx</span><span class="p">,</span>
    <span class="n">cgal_sdf_data</span><span class="p">)</span> <span class="o">=</span> <span class="n">spine_data_returned</span><span class="o">=</span> <span class="n">split_mesh_into_spines_shaft</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                               <span class="n">segment_name</span><span class="o">=</span><span class="n">segment_name</span><span class="p">,</span>
                               <span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span>
                              <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">,</span>
                              <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">cgal_folder</span><span class="p">,</span>
                              <span class="n">delete_temp_file</span><span class="o">=</span><span class="n">delete_temp_file</span><span class="p">,</span>
                              <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                              <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                              <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="n">shaft_threshold</span><span class="p">,</span>
                              <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="n">plot_segmentation</span><span class="p">,</span>
                            <span class="n">plot_shaft</span><span class="o">=</span><span class="n">plot_shaft</span><span class="p">,</span>
                                                                      <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">return_sdf</span> <span class="ow">and</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
            <span class="k">return</span>  <span class="p">[],[],[]</span>
        <span class="k">elif</span> <span class="n">return_sdf</span> <span class="ow">or</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_mesh_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;s</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)]</span>
        <span class="n">shaft_mesh_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;b</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shaft_meshes</span><span class="p">)]</span>

        <span class="n">total_meshes</span> <span class="o">=</span> <span class="n">spine_meshes</span> <span class="o">+</span> <span class="n">shaft_meshes</span>
        <span class="n">total_meshes_idx</span> <span class="o">=</span> <span class="n">spine_meshes_idx</span> <span class="o">+</span> <span class="n">shaft_meshes_idx</span>
        <span class="n">total_names</span> <span class="o">=</span> <span class="n">spine_mesh_names</span> <span class="o">+</span> <span class="n">shaft_mesh_names</span>

        <span class="n">total_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">curr_mesh</span><span class="p">,</span><span class="n">curr_mesh_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">total_meshes</span><span class="p">,</span><span class="n">total_meshes_idx</span><span class="p">)):</span>
            <span class="n">touching_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span>
                            <span class="n">main_mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span>
                            <span class="n">central_piece</span><span class="o">=</span><span class="n">curr_mesh_idx</span><span class="p">,</span>
                            <span class="n">periphery_pieces</span><span class="o">=</span><span class="n">total_meshes_idx</span><span class="p">,</span>
                            <span class="n">connectivity</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">touching_meshes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;j = </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="s2">&quot;current_mesh&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_mesh_idx</span><span class="p">,</span><span class="s2">&quot;curr_mesh_idx&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_meshes_idx</span><span class="p">,</span><span class="s2">&quot;total_meshes_idx&quot;</span><span class="p">)</span>
                <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_names</span><span class="p">,</span><span class="s2">&quot;total_names&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;didn&#39;t do remove&quot;</span><span class="p">)</span>
                
            <span class="c1">#construct the edges</span>
            <span class="n">curr_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">total_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">total_names</span><span class="p">[</span><span class="n">h</span><span class="p">]]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">touching_meshes</span><span class="p">]</span>
            <span class="n">total_edges</span> <span class="o">+=</span> <span class="n">curr_edges</span>

        <span class="n">spine_graph</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_selfloops</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">total_edges</span><span class="p">))</span>
        <span class="c1">#nx.draw(spine_graph,with_labels=True)</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        How to determine whih parts that are the shaft</span>
<span class="sd">        1) start with biggest shaft</span>
<span class="sd">        2) Find the shoftest paths to all shaft parts</span>
<span class="sd">        3) add all the nodes that aren&#39;t already in the shaft category to the shaft category</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#find the biggest shaft</span>
        
        <span class="n">biggest_shaft</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;b</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">shaft_meshes</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">non_biggest_shaft</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shaft_mesh_names</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">biggest_shaft</span><span class="p">]</span>

        <span class="n">final_shaft_mesh_names</span> <span class="o">=</span> <span class="n">shaft_mesh_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_biggest_shaft</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#find all shortest paths from biggest shaft to non_biggest_shaft</span>
            
            <span class="c1">#shaft_shortest_paths = [nx.shortest_path(spine_graph,</span>
            <span class="c1">#source=biggest_shaft,target=curr_shaft) for curr_shaft in non_biggest_shaft]</span>
            
            <span class="n">shaft_shortest_paths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">shaft_expansion_method</span> <span class="o">==</span> <span class="s2">&quot;path_to_largest_shaft_mesh&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">curr_shaft</span> <span class="ow">in</span> <span class="n">non_biggest_shaft</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">c_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">spine_graph</span><span class="p">,</span>
                                                         <span class="n">source</span><span class="o">=</span><span class="n">biggest_shaft</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">curr_shaft</span><span class="p">)</span> 
                    <span class="k">except</span><span class="p">:</span>
                        <span class="c1">#print(f&quot;Mesh {curr_shaft} Seems to be not connected to mesh&quot;)</span>
                        <span class="n">shaft_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">curr_shaft</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">shaft_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_path</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">shaft_expansion_method</span> <span class="o">==</span> <span class="s2">&quot;path_to_all_shaft_mesh&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">shaft_1</span> <span class="ow">in</span> <span class="n">shaft_mesh_names</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">shaft_2</span> <span class="ow">in</span> <span class="n">shaft_mesh_names</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">shaft_1</span> <span class="o">!=</span> <span class="n">shaft_2</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">c_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">spine_graph</span><span class="p">,</span>
                                        <span class="n">source</span><span class="o">=</span><span class="n">shaft_1</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">shaft_2</span><span class="p">)</span> 
                            <span class="k">except</span><span class="p">:</span>
                                <span class="c1">#print(f&quot;{shaft_1} and {shaft_2} not connected on the same mesh&quot;)</span>
                                <span class="n">shaft_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">shaft_1</span><span class="p">,</span><span class="n">shaft_2</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">shaft_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                            
            

            <span class="n">new_shaft_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">shaft_shortest_paths</span><span class="p">))</span> <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
            <span class="c1">#print(f&quot;new_shaft_meshes = {new_shaft_meshes}&quot;)</span>
            <span class="n">final_shaft_mesh_names</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">shaft_shortest_paths</span><span class="p">))</span> <span class="k">if</span> <span class="s2">&quot;s&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">final_shaft_meshes</span> <span class="o">=</span> <span class="n">shaft_meshes</span> <span class="o">+</span> <span class="p">[</span><span class="n">spine_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_shaft_meshes</span><span class="p">]</span>
            <span class="n">final_shaft_meshes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">shaft_meshes_idx</span> <span class="o">+</span> <span class="p">[</span><span class="n">spine_meshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_shaft_meshes</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_shaft_meshes</span> <span class="o">=</span> <span class="n">shaft_meshes</span>
            <span class="n">final_shaft_meshes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">shaft_meshes_idx</span><span class="p">))</span>

        <span class="n">final_shaft_mesh_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">final_shaft_mesh_names</span><span class="p">)</span>

        <span class="n">final_spine_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final_shaft_meshes_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #Old way of getting all of the spines: by just dividing the mesh using disconnected components</span>
<span class="sd">        #after subtracting the shaft mesh</span>

<span class="sd">        spine_submesh = current_mesh.submesh([final_spine_faces_idx],append=True)</span>
<span class="sd">        spine_submesh_split = spine_submesh.split(only_watertight=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        #New way of extracting the spines using graphical methods</span>

<span class="sd">        Pseudocode:</span>
<span class="sd">        1) remove the shaft meshes from the graph</span>
<span class="sd">        2) get the connected components</span>
<span class="sd">        3) assemble the connected components total face_idx:</span>
<span class="sd">        a. get the sdf values that correspond to those</span>
<span class="sd">        b. get the submesh that corresponds to those</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spine_graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">final_shaft_mesh_names</span><span class="p">)</span>

        <span class="n">spine_submesh_split</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">spine_submesh_split_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spine_submesh_split_sdf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sp_list</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">spine_graph</span><span class="p">)):</span>
            <span class="n">curr_spine_face_idx_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">spine_meshes_idx</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">sp_list</span> <span class="p">])</span>
            <span class="n">spine_submesh_split_sdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cgal_sdf_data</span><span class="p">[</span><span class="n">curr_spine_face_idx_split</span><span class="p">])</span>
            <span class="n">spine_submesh_split_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_spine_face_idx_split</span><span class="p">)</span>
            <span class="n">spine_submesh_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">curr_spine_face_idx_split</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>


        <span class="k">if</span> <span class="n">print_flag</span> <span class="ow">or</span> <span class="n">plot</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Total Number of Spines Found = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1">#sort the list by size</span>
        <span class="n">spine_length_orders</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_submesh_split</span><span class="p">]</span>
        <span class="n">greatest_to_least</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">spine_length_orders</span><span class="p">))</span>
        <span class="n">spines_greatest_to_least</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">)[</span><span class="n">greatest_to_least</span><span class="p">]</span>
        <span class="n">spines_sdf_greatest_to_least</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spine_submesh_split_sdf</span><span class="p">)[</span><span class="n">greatest_to_least</span><span class="p">]</span>
        <span class="n">spine_submesh_split_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spine_submesh_split_idx</span><span class="p">)[</span><span class="n">greatest_to_least</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- plotting shaft meshes after graph fix -- &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spines_greatest_to_least</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">meshes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">meshes</span> <span class="o">=</span> <span class="n">spines_greatest_to_least</span>
            
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                <span class="n">current_mesh</span><span class="p">,</span>
                <span class="n">meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spines_greatest_to_least</span><span class="p">),</span>
                <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">ensure_mesh_conn_comp</span><span class="p">:</span>
            <span class="n">spines_greatest_to_least_new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">spine_submesh_split_idx_new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sdf_new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">k_idx</span><span class="p">,</span><span class="n">k_sdf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">spines_greatest_to_least</span><span class="p">,</span>
                <span class="n">spine_submesh_split_idx</span><span class="p">,</span>
                <span class="n">spines_sdf_greatest_to_least</span><span class="p">):</span>
                <span class="n">sp_mesh</span><span class="p">,</span><span class="n">sp_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">largest_conn_comp</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">spines_greatest_to_least_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_mesh</span><span class="p">)</span>
                <span class="n">spine_submesh_split_idx_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k_idx</span><span class="p">[</span><span class="n">sp_idx</span><span class="p">])</span>
                <span class="n">sdf_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k_sdf</span><span class="p">[</span><span class="n">sp_idx</span><span class="p">])</span>
                
            <span class="n">spines_greatest_to_least</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spines_greatest_to_least_new</span><span class="p">)</span>
            <span class="n">spine_submesh_split_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spine_submesh_split_idx_new</span><span class="p">)</span>
            <span class="n">spines_sdf_greatest_to_least</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sdf_new</span><span class="p">)</span>
            
                
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_sdf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spines_greatest_to_least</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">spines_greatest_to_least</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spines_sdf_greatest_to_least</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_mesh_idx</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine_submesh_split_idx</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="get_spine_meshes_unfiltered"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.get_spine_meshes_unfiltered">[docs]</a><span class="k">def</span> <span class="nf">get_spine_meshes_unfiltered</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                 <span class="n">limb_idx</span><span class="p">,</span>
                <span class="n">branch_idx</span><span class="p">,</span>
                <span class="n">clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="c1">#2,</span>
                <span class="n">smoothness</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="c1">#0.05,</span>
                <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./cgal_temp&quot;</span><span class="p">),</span>
                <span class="n">delete_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_sdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">shaft_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
                               <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    
    <span class="n">current_mesh</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
    
    <span class="k">return</span> <span class="n">get_spine_meshes_unfiltered_from_mesh</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                                        <span class="n">segment_name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                        <span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span>
                                        <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">,</span>
                                        <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">cgal_folder</span><span class="p">,</span>
                                        <span class="n">delete_temp_file</span><span class="o">=</span><span class="n">delete_temp_file</span><span class="p">,</span>
                                        <span class="n">return_sdf</span><span class="o">=</span><span class="n">return_sdf</span><span class="p">,</span>
                                        <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                                        <span class="n">shaft_threshold</span><span class="o">=</span><span class="n">shaft_threshold</span><span class="p">)</span></div>
<span class="w">    </span>
<span class="w">        </span>
<span class="w">        </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">These filters didn&#39;t seem to work very well...</span>

<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="sdf_median_mean_difference"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.sdf_median_mean_difference">[docs]</a><span class="k">def</span> <span class="nf">sdf_median_mean_difference</span><span class="p">(</span><span class="n">sdf_values</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sdf_values</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sdf_values</span><span class="p">))</span> </div>

<div class="viewcode-block" id="apply_sdf_filter"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.apply_sdf_filter">[docs]</a><span class="k">def</span> <span class="nf">apply_sdf_filter</span><span class="p">(</span><span class="n">sdf_values</span><span class="p">,</span><span class="n">sdf_median_mean_difference_threshold</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
                    <span class="n">return_not_passed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">pass_filter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">not_pass_filter</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_sdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sdf_values</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sdf_median_mean_difference</span><span class="p">(</span><span class="n">curr_sdf</span><span class="p">)</span><span class="o">&lt;</span> <span class="n">sdf_median_mean_difference_threshold</span><span class="p">:</span>
            <span class="n">pass_filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_pass_filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_not_passed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">not_pass_filter</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pass_filter</span></div>

<div class="viewcode-block" id="surface_area_to_volume"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.surface_area_to_volume">[docs]</a><span class="k">def</span> <span class="nf">surface_area_to_volume</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method to try and differentiate false from true spines</span>
<span class="sd">    conclusion: didn&#39;t work</span>
<span class="sd">    </span>
<span class="sd">    Even when dividing by the number of faces</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">volume</span><span class="o">/</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">area</span></div>


<div class="viewcode-block" id="filter_spine_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_spine_meshes">[docs]</a><span class="k">def</span> <span class="nf">filter_spine_meshes</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">,</span>
                        <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">spine_sk_length_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spine_n_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_n_face_threshold</span> <span class="o">=</span> <span class="n">spine_n_face_threshold_global</span>
    <span class="k">if</span> <span class="n">spine_sk_length_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="n">spine_sk_length_threshold_global</span>
        
    <span class="n">keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">spine_n_face_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_n_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_meshes</span><span class="p">])</span>
        <span class="n">keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">keep_idx</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spine_n_faces</span> <span class="o">&gt;=</span> <span class="n">spine_n_face_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After face threshold </span><span class="si">{</span><span class="n">spine_n_face_threshold</span><span class="si">}</span><span class="s2">, keep_idx = </span><span class="si">{</span><span class="n">keep_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spine_sk_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spu</span><span class="o">.</span><span class="n">spine_length</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_meshes</span><span class="p">])</span>
        <span class="n">keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">keep_idx</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spine_lens</span> <span class="o">&gt;=</span> <span class="n">spine_sk_length_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After sk length threshold </span><span class="si">{</span><span class="n">spine_sk_length_threshold</span><span class="si">}</span><span class="s2">, keep_idx = </span><span class="si">{</span><span class="n">keep_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span></div>


<span class="c1">#------------ 9/23 Addition -------------- #</span>
<div class="viewcode-block" id="filter_out_border_spines"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_out_border_spines">[docs]</a><span class="k">def</span> <span class="nf">filter_out_border_spines</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">spine_submeshes</span><span class="p">,</span>
                            <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                                    
                             <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Filter away spines by their percentage overlap with parent border vertices </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">border_percentage_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">border_percentage_threshold</span> <span class="o">=</span> <span class="n">border_percentage_threshold_global</span>
        
    <span class="k">if</span> <span class="n">check_spine_border_perc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check_spine_border_perc</span> <span class="o">=</span> <span class="n">check_spine_border_perc_global</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_away_border_touching_submeshes_by_group</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">spine_submeshes</span><span class="p">,</span>
                                                             <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="n">border_percentage_threshold</span><span class="p">,</span>
                                                             <span class="n">inverse_border_percentage_threshold</span><span class="o">=</span><span class="n">check_spine_border_perc</span><span class="p">,</span>
                                                             <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                             <span class="n">return_meshes</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">return_idx</span><span class="p">,</span>
                                                            <span class="p">)</span></div>

<div class="viewcode-block" id="filter_out_soma_touching_spines"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_out_soma_touching_spines">[docs]</a><span class="k">def</span> <span class="nf">filter_out_soma_touching_spines</span><span class="p">(</span>
    <span class="n">spine_submeshes</span><span class="p">,</span>
    <span class="n">soma_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter the spines that are touching the somae</span>
<span class="sd">    Because those are generally false positives picked up </span>
<span class="sd">    by cgal segmentation</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode</span>
<span class="sd">    1) Create a KDTree from the soma vertices</span>
<span class="sd">    2) For each spine:</span>
<span class="sd">    a) Do a query against the KDTree with vertices</span>
<span class="sd">    b) If any of the vertices have - distance then nullify</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">soma_kdtree</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">soma_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_vertices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">soma_kdtree</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">soma_verties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Neither a soma kdtree or soma vertices were given&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of spines before soma border filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submeshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">final_spines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">final_spines_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sp_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine_submeshes</span><span class="p">):</span>
        <span class="n">sp_dist</span><span class="p">,</span><span class="n">sp_closest</span> <span class="o">=</span> <span class="n">soma_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sp_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">n_match_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sp_dist</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">n_match_vertices</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">final_spines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_mesh</span><span class="p">)</span>
            <span class="n">final_spines_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spine </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> was removed because had </span><span class="si">{</span><span class="n">n_match_vertices</span><span class="si">}</span><span class="s2"> border vertices&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of spines before soma border filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">final_spines</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_spines_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_spines</span></div>


<div class="viewcode-block" id="spine_head_neck"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_head_neck">[docs]</a><span class="k">def</span> <span class="nf">spine_head_neck</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">cluster_options</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
    <span class="n">smoothness</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.15,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">head_ray_trace_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#240,</span>
    <span class="n">head_face_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#10,</span>
    <span class="n">default_head_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
    <span class="n">default_head_sdf</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    
    <span class="c1">#for filtering away head meshes that have the following coordinate</span>
    <span class="n">stop_segmentation_after_first_success</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">no_head_coordinates</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">only_allow_one_connected_component_neck</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">plot_head_neck</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_width</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    To determine the head and neck face indices clustering of a mesh representing a spine</span>


<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    for clusters [2,3]:</span>
<span class="sd">    1) Run the segmentation algorithm (using cluster and smoothness thresholds)</span>
<span class="sd">    2) Filter meshes for all those with a value above the face count above threshold and above the ray trace percentage width value</span>
<span class="sd">    3) Store the meshes not face as neck and store sdf value as weighted average</span>
<span class="sd">    4a) If none then continue</span>
<span class="sd">    4b) If at least one, concatenate the faces of all of the spine heads into one array (and do weighted average of the sdf)</span>
<span class="sd">    5) Break if found a head</span>
<span class="sd">    6) Optionally plot the spine neck and head</span>

<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    head_smoothness:</span>
<span class="sd">        the cgal segmentation smoothness parameter for clustering a spine mesh into a head and neck</span>

<span class="sd">    head_ray_trace_min: float</span>
<span class="sd">        minimum width approximation (units) as a percentile of the ray trace values for a submesh to be in consideration as a spine head submesh </span>

<span class="sd">    head_face_min: int</span>
<span class="sd">        minimum number of faces for a submesh to be in consideration as a spine head submesh </span>

<span class="sd">    only_allow_one_connected_component_neck: bool</span>
<span class="sd">        whether to allow for the neck submesh to be multiple connected components (aka disconnected) or not</span>



<span class="sd">    Can optionally return:</span>
<span class="sd">    1) Meshes instead of face idx</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    curr_idx = 38</span>
<span class="sd">    sp_mesh = curr_branch.spines[curr_idx]</span>
<span class="sd">    spu.spine_head_neck(sp_mesh,</span>
<span class="sd">                        cluster_options=(2,3,4),</span>
<span class="sd">                        smoothness=0.15,</span>
<span class="sd">                        verbose = True,</span>
<span class="sd">                        plot_segmentation=True,</span>
<span class="sd">                       plot_head_neck=True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">head_ray_trace_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">head_ray_trace_min</span> <span class="o">=</span> <span class="n">head_ray_trace_min_global</span>
        
    <span class="k">if</span> <span class="n">smoothness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smoothness</span> <span class="o">=</span> <span class="n">head_smoothness_global</span>
        
    <span class="k">if</span> <span class="n">head_face_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">head_face_min</span> <span class="o">=</span> <span class="n">head_face_min_global</span>
        
    <span class="k">if</span> <span class="n">only_allow_one_connected_component_neck</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">only_allow_one_connected_component_neck</span> <span class="o">=</span> <span class="n">only_allow_one_connected_component_neck_global</span>
    

    <span class="n">neck_face_idx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">head_face_idx</span> <span class="o">=</span> <span class="n">default_head_face_idx</span>

    <span class="n">neck_sdf</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">head_sdf</span> <span class="o">=</span> <span class="n">default_head_sdf</span>
    <span class="n">head_width</span> <span class="o">=</span> <span class="n">default_head_sdf</span>

    <span class="n">winning_n_heads</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">neck_face_idx_win</span> <span class="o">=</span> <span class="n">neck_sdf_win</span> <span class="o">=</span> <span class="n">neck_width_win</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">head_face_idx_win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">head_sdf_win</span> <span class="o">=</span> <span class="n">default_head_sdf</span>
    <span class="n">head_width_win</span> <span class="o">=</span> <span class="n">default_head_sdf</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_options</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using clusters </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">meshes</span><span class="p">,</span><span class="n">sdfs</span><span class="p">,</span><span class="n">mesh_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                    <span class="n">clusters</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span>
                                                    <span class="n">smoothness</span> <span class="o">=</span> <span class="n">smoothness</span><span class="p">,</span>
                                           <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                           <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">plot_segmentation</span><span class="o">=</span><span class="n">plot_segmentation</span><span class="p">,</span>
                                          <span class="n">return_ordered_by_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">return_mesh_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">ray_trace_perc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">])</span>
        <span class="n">mesh_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sdfs=</span><span class="si">{</span><span class="n">sdfs</span><span class="si">}</span><span class="s2">, ray_trace_perc = </span><span class="si">{</span><span class="n">ray_trace_perc</span><span class="si">}</span><span class="s2">, mesh_sizes = </span><span class="si">{</span><span class="n">mesh_sizes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Thresholds: head_ray_trace_min = </span><span class="si">{</span><span class="n">head_ray_trace_min</span><span class="si">}</span><span class="s2">, head_face_min = </span><span class="si">{</span><span class="n">head_face_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">head_obj_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">ray_trace_perc</span> <span class="o">&gt;</span> <span class="n">head_ray_trace_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mesh_sizes</span> <span class="o">&gt;</span> <span class="n">head_face_min</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_obj_idx = </span><span class="si">{</span><span class="n">head_obj_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">        --------</span>
<span class="sd">        Want to delete any meshes that have the border coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">no_head_coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head_obj_idx_final</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hm</span> <span class="ow">in</span> <span class="n">head_obj_idx</span><span class="p">:</span>
                <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">[</span><span class="n">hm</span><span class="p">]</span>
                <span class="n">closest_dist</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_distance_to_coordinates_fast</span><span class="p">(</span>
                    <span class="n">curr_mesh</span><span class="p">,</span>
                    <span class="n">coordinates</span> <span class="o">=</span><span class="n">no_head_coordinates</span><span class="p">,</span>
                    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                    <span class="n">stop_after_0_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                
                <span class="k">if</span> <span class="n">closest_dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">head_obj_idx_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hm</span><span class="p">)</span>
                    
            <span class="n">head_obj_idx</span> <span class="o">=</span> <span class="n">head_obj_idx_final</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After filtering for no_head_coordinates: head_obj_idx = </span><span class="si">{</span><span class="n">head_obj_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">neck_obj_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">head_obj_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">        --------</span>
<span class="sd">        Ensure there is a neck submesh and optionally only one neck submesh (if more than one then negate the head segmentation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neck_obj_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">neck_obj_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">))</span>
            <span class="n">head_obj_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">only_allow_one_connected_component_neck</span><span class="p">:</span>
            <span class="n">n_neck_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">connected_components_from_face_idx</span><span class="p">(</span>
                <span class="n">mesh</span><span class="p">,</span><span class="n">face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">mesh_idx</span><span class="p">[</span><span class="n">neck_obj_idx</span><span class="p">]),</span><span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_neck_components = </span><span class="si">{</span><span class="n">n_neck_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span>  <span class="n">n_neck_components</span><span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one neck connected component so not valid&quot;</span><span class="p">)</span>
                <span class="n">neck_obj_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">))</span>
                <span class="n">head_obj_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_obj_idx = </span><span class="si">{</span><span class="n">head_obj_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_obj_idx= </span><span class="si">{</span><span class="n">neck_obj_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose:</span>
<span class="sd">        --------</span>
<span class="sd">        Calculate the weighted average head and neck sdf and width values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># save off the neck face idx</span>
        <span class="n">neck_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">mesh_idx</span><span class="p">[</span><span class="n">neck_obj_idx</span><span class="p">])</span>
        <span class="n">neck_sdf</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">sdfs</span><span class="p">[</span><span class="n">neck_obj_idx</span><span class="p">],</span><span class="n">mesh_sizes</span><span class="p">[</span><span class="n">neck_obj_idx</span><span class="p">])</span>
        <span class="n">neck_width</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">ray_trace_perc</span><span class="p">[</span><span class="n">neck_obj_idx</span><span class="p">],</span><span class="n">mesh_sizes</span><span class="p">[</span><span class="n">neck_obj_idx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_face_idx= </span><span class="si">{</span><span class="n">neck_face_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_sdf = </span><span class="si">{</span><span class="n">neck_sdf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_width = </span><span class="si">{</span><span class="n">neck_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">head_obj_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neck_face_idx_win</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">neck_face_idx_win</span> <span class="o">=</span> <span class="n">neck_face_idx</span>
                <span class="n">neck_sdf_win</span> <span class="o">=</span> <span class="n">neck_sdf</span>
                <span class="n">neck_width_win</span> <span class="o">=</span> <span class="n">neck_width</span>
            <span class="k">continue</span>

        <span class="n">head_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">mesh_idx</span><span class="p">[</span><span class="n">head_obj_idx</span><span class="p">])</span>
        <span class="n">head_sdf</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">sdfs</span><span class="p">[</span><span class="n">head_obj_idx</span><span class="p">],</span><span class="n">mesh_sizes</span><span class="p">[</span><span class="n">head_obj_idx</span><span class="p">])</span>
        <span class="n">head_width</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">ray_trace_perc</span><span class="p">[</span><span class="n">head_obj_idx</span><span class="p">],</span><span class="n">mesh_sizes</span><span class="p">[</span><span class="n">head_obj_idx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_face_idx= </span><span class="si">{</span><span class="n">head_face_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_sdf = </span><span class="si">{</span><span class="n">head_sdf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_width = </span><span class="si">{</span><span class="n">head_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">n_heads</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">connected_components_from_face_idx</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span><span class="n">face_idx</span> <span class="o">=</span> <span class="n">head_face_idx</span><span class="p">,</span><span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">n_heads</span> <span class="o">&gt;</span> <span class="n">winning_n_heads</span><span class="p">:</span>
            <span class="n">winning_n_heads</span> <span class="o">=</span> <span class="n">n_heads</span>
            
            <span class="n">neck_face_idx_win</span> <span class="o">=</span> <span class="n">neck_face_idx</span>
            <span class="n">neck_sdf_win</span> <span class="o">=</span> <span class="n">neck_sdf</span>
            <span class="n">neck_width_win</span> <span class="o">=</span> <span class="n">neck_width</span>
            
            <span class="n">head_face_idx_win</span> <span class="o">=</span> <span class="n">head_face_idx</span>
            <span class="n">head_sdf_win</span> <span class="o">=</span> <span class="n">head_sdf</span>
            <span class="n">head_width_win</span> <span class="o">=</span> <span class="n">head_width</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New winning number of heads = </span><span class="si">{</span><span class="n">winning_n_heads</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">stop_segmentation_after_first_success</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># Filtering away the heads that are </span>
<span class="c1">#     if no_head_coordinates is not None:</span>
<span class="c1">#         if len(head_face_idx) &gt; 0:</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;Attempting to filter head synapses close to coordinates&quot;)</span>
<span class="c1">#             head_face_idx = tu.filter_away_connected_comp_in_face_idx_with_minimum_vertex_distance_to_coordinates(</span>
<span class="c1">#                 mesh = mesh,</span>
<span class="c1">#                 face_idx = head_face_idx,</span>
<span class="c1">#                 coordinates = no_head_coordinates,</span>
<span class="c1">#                 verbose = verbose,</span>
<span class="c1">#                 plot = False,</span>
<span class="c1">#             )</span>
            
<span class="c1">#             if len(head_face_idx) &gt; 0:</span>
<span class="c1">#                 head_face_idx = np.hstack(head_face_idx)</span>
                
<span class="c1">#             neck_face_idx = np.delete(np.arange(len(mesh.faces)),head_face_idx)</span>
            
    <span class="n">neck_face_idx</span> <span class="o">=</span> <span class="n">neck_face_idx_win</span>
    <span class="n">neck_sdf</span> <span class="o">=</span> <span class="n">neck_sdf_win</span>
    <span class="n">neck_width</span> <span class="o">=</span> <span class="n">neck_width_win</span>

    <span class="n">head_face_idx</span> <span class="o">=</span> <span class="n">head_face_idx_win</span>
    <span class="n">head_sdf</span> <span class="o">=</span> <span class="n">head_sdf_win</span>
    <span class="n">head_width</span> <span class="o">=</span> <span class="n">head_width_win</span>       
            
    <span class="n">neck_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">neck_face_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">head_face_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">head_mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">head_face_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">head_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()</span>
        
    
    
    <span class="k">if</span> <span class="n">plot_head_neck</span><span class="p">:</span>
        <span class="n">neck_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span>
        <span class="n">head_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_mesh (</span><span class="si">{</span><span class="n">head_color</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">head_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_mesh (</span><span class="si">{</span><span class="n">neck_color</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">neck_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">neck_mesh</span><span class="p">,</span><span class="n">head_mesh</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="n">neck_color</span><span class="p">,</span><span class="n">head_color</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">return_meshes</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">=</span> <span class="p">[</span><span class="n">head_mesh</span><span class="p">,</span><span class="n">neck_mesh</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">head_face_idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span><span class="n">neck_face_idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)]</span>
        
    <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">head_sdf</span><span class="p">,</span><span class="n">neck_sdf</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">return_width</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">head_width</span><span class="p">,</span><span class="n">neck_width</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>



<div class="viewcode-block" id="bouton_non_bouton_idx_from_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bouton_non_bouton_idx_from_branch">[docs]</a><span class="k">def</span> <span class="nf">bouton_non_bouton_idx_from_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                     <span class="n">plot_branch_boutons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">plot_face_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add axon labels to the branch</span>

<span class="sd">    Ex: </span>
<span class="sd">    return_face_idx = spu.bouton_non_bouton_idx_from_branch(branch_obj = neuron_obj[0][0],</span>
<span class="sd">    plot_branch_boutons = False,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    plot_face_idx = True,</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_branch_boutons</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_branches_with_boutons</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">)</span>

    <span class="n">head_neck_shaft_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;non_bouton&quot;</span><span class="p">]</span>

    <span class="n">boutons</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">boutons</span>
    <span class="k">if</span> <span class="n">boutons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">boutons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">boutons_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">convert_meshes_to_face_idxes</span><span class="p">(</span><span class="n">boutons</span><span class="p">,</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">boutons_idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> bouton faces&quot;</span><span class="p">)</span>

        <span class="n">head_neck_shaft_idx</span><span class="p">[</span><span class="n">boutons_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;bouton&quot;</span><span class="p">]</span>


    <span class="k">if</span> <span class="n">plot_face_idx</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_mesh_face_idx</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">head_neck_shaft_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">head_neck_shaft_idx</span></div>

<div class="viewcode-block" id="head_neck_shaft_idx_from_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.head_neck_shaft_idx_from_branch">[docs]</a><span class="k">def</span> <span class="nf">head_neck_shaft_idx_from_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
    <span class="n">plot_face_idx</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">add_no_head_label</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">process_axon_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create an array</span>
<span class="sd">    mapping the mesh face idx of the branch to a</span>
<span class="sd">    label of head/neck/shaft</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Create an array the size of branch mesh </span>
<span class="sd">    initialized to shaft</span>
<span class="sd">    2) iterate through all of the spine objects of the branch</span>
<span class="sd">        a) set all head index to head</span>
<span class="sd">        b) set all neck index to neck</span>
<span class="sd">        </span>
<span class="sd">    Ex: </span>
<span class="sd">    spu.head_neck_shaft_idx_from_branch(branch_obj = neuron_obj_exc_syn[0][6],</span>
<span class="sd">    plot_face_idx  = True,</span>
<span class="sd">    verbose = True,)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">process_axon_branches</span> <span class="ow">and</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To add axon labels to the branch</span>
<span class="sd">        </span>
<span class="sd">        Psuedocode: </span>
<span class="sd">        1) </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head_neck_shaft_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">bouton_non_bouton_idx_from_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;# of bouton faces = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">head_neck_shaft_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;bouton&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;# of non_bouton faces = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">head_neck_shaft_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;non_bouton&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">head_neck_shaft_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;shaft&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sp_obj</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">add_no_head_label</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sp_obj</span><span class="o">.</span><span class="n">head_exist</span><span class="p">):</span>
                    <span class="n">head_neck_shaft_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">neck_face_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;no_head&quot;</span><span class="p">]</span>
                    <span class="n">head_neck_shaft_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">head_neck_shaft_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">]</span>
                    <span class="n">head_neck_shaft_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="n">sp_obj</span><span class="o">.</span><span class="n">neck_face_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;neck&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;# of shaft faces = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">head_neck_shaft_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;shaft&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;# of head faces = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">head_neck_shaft_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;# of neck faces = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">head_neck_shaft_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;neck&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;# of no_head faces = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">head_neck_shaft_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spu</span><span class="o">.</span><span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="s2">&quot;no_head&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_face_idx</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                  <span class="n">head_neck_shaft_idx</span><span class="p">,</span>
                                  <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">),</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">head_neck_shaft_idx</span></div>

<div class="viewcode-block" id="spine_density"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_density">[docs]</a><span class="k">def</span> <span class="nf">spine_density</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">um</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    n_spine / skeletal length (um)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">skeletal_length</span>
    <span class="k">if</span> <span class="n">um</span><span class="p">:</span>
        <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">skeletal_length</span><span class="o">/</span><span class="mi">1000</span>
        
    <span class="k">if</span> <span class="n">skeletal_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">)</span><span class="o">/</span><span class="n">skeletal_length</span></div>
    
<div class="viewcode-block" id="spine_volume_density"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_volume_density">[docs]</a><span class="k">def</span> <span class="nf">spine_volume_density</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">um</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sum spine volume (um**3) / skeletal length (um)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">skeletal_length</span>
    <span class="k">if</span> <span class="n">um</span><span class="p">:</span>
        <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">skeletal_length</span><span class="o">/</span><span class="mi">1000</span>
    
    <span class="k">if</span> <span class="n">skeletal_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">volume</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">])</span><span class="o">/</span><span class="n">skeletal_length</span></div>


<div class="viewcode-block" id="spine_density_over_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_density_over_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">spine_density_over_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">synapse_type</span> <span class="o">=</span> <span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                                    <span class="n">multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="n">return_skeletal_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the </span>
<span class="sd">    spine density over lmb branch</span>

<span class="sd">    Application: To be used for cell type (E/I)</span>
<span class="sd">    classification</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Restrict the neuron branches to be processed</span>
<span class="sd">    for spine density</span>
<span class="sd">    2) Calculate the skeletal length over the limb branch</span>
<span class="sd">    3) Find the number of spines over limb branch</span>
<span class="sd">    4) Compute postsynaptic density</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_length</span> <span class="o">=</span> <span class="n">n_synapses</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                                         <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>

    <span class="n">n_spines</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                                         <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;n_spines&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">density</span> <span class="o">=</span> <span class="n">n_spines</span><span class="o">/</span><span class="n">sk_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">density</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">density</span> <span class="o">=</span> <span class="n">density</span><span class="o">*</span><span class="n">multiplier</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_length = </span><span class="si">{</span><span class="n">sk_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of spines = </span><span class="si">{</span><span class="n">n_spines</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Density = </span><span class="si">{</span><span class="n">density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_skeletal_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">density</span><span class="p">,</span><span class="n">sk_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">density</span></div>
    
<div class="viewcode-block" id="update_spines_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.update_spines_obj">[docs]</a><span class="k">def</span> <span class="nf">update_spines_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will update all of the spine objects in a neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">spu</span><span class="o">.</span><span class="n">Spine</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">]</span></div>
                
<div class="viewcode-block" id="spine_str_label"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_str_label">[docs]</a><span class="k">def</span> <span class="nf">spine_str_label</span><span class="p">(</span><span class="n">spine_label</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    spu.spine_str_label(-2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spine_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;no_label&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spine_label</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">spine_label</span> <span class="o">=</span>  <span class="n">head_neck_shaft_dict_inverted</span><span class="p">[</span><span class="n">spine_label</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">spine_label</span></div>

<div class="viewcode-block" id="spine_int_label"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_int_label">[docs]</a><span class="k">def</span> <span class="nf">spine_int_label</span><span class="p">(</span><span class="n">spine_label</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">spine_label</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">spine_label</span> <span class="o">=</span>  <span class="n">head_neck_shaft_dict</span><span class="p">[</span><span class="n">spine_label</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">spine_label</span></div>

<div class="viewcode-block" id="set_soma_synapses_spine_label"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_soma_synapses_spine_label">[docs]</a><span class="k">def</span> <span class="nf">set_soma_synapses_spine_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">soma_spine_label</span> <span class="o">=</span> <span class="s2">&quot;no_label&quot;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span>
            <span class="n">syn</span><span class="o">.</span><span class="n">head_neck_shaft</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_int_label</span><span class="p">(</span><span class="n">soma_spine_label</span><span class="p">)</span></div>


<span class="c1"># -------------- 12/6: Doing the spine calculation ----------------</span>
<div class="viewcode-block" id="calculate_spines_on_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spines_on_branch">[docs]</a><span class="k">def</span> <span class="nf">calculate_spines_on_branch</span><span class="p">(</span>
    <span class="n">branch</span><span class="p">,</span>
    
    <span class="c1"># arguments for the intial segmentation</span>
    <span class="n">clusters_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#2,</span>
    <span class="n">smoothness_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_before_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1350,</span>
    <span class="n">plot_spines_after_face_threshold</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="n">filter_by_bounding_box_longest_side_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">side_length_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_bbox_threshold</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="n">filter_out_border_spines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#this seemed to cause a lot of misses</span>
    <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_border_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="n">skeleton_endpoint_nullification</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton_endpoint_nullification_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_skeleton_endpt_nullification</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_verts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_soma_nullification</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    

    <span class="c1">#-------1/20 Addition --------</span>
    <span class="n">filter_by_volume</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">calculate_spine_volume</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#calculated from experiments</span>
    <span class="n">plot_spines_after_volume_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -------</span>
<span class="sd">    Will calculate the spines on a branch object</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) spu.get_spine_meshes_unfiltered_from_mesh</span>
<span class="sd">    2) filters spine meshes by minimum number of faces (spine_n_face_threshold) and minimum skeletal length (spine_sk_length_threshold)</span>
<span class="sd">    3) if requested (filter_by_bounding_box_longest_side_length), filters the meshes to have less than a certain length (side_length_threshold) for the longest side of their oriented bounding box. </span>
<span class="sd">    To prevent false positive spines from long axon fragment merges</span>
<span class="sd">    4) if requested (filter_out_border_spines), filter out meshes that have:</span>
<span class="sd">        a) higher than a certain percentage (border_percentage_threshold) of the submesh vertices overlapping with border vertices (certices adjacent to open spaces in the mesh) on the parent mesh  </span>
<span class="sd">        b) higher than certain percentage (check_spine_border_perc_global) of the parent mesh’s border vertices overlapping with the submesh vertices</span>

<span class="sd">    5) if requested (skeleton_endpoint_nullification), filter away spines that are within a certain distance (skeleton_endpoint_nullification_distance) from the branch skeleton endpoints in order to avoid a high false positive class.</span>
<span class="sd">    6) if requested (soma_vertex_nullification), filter out spines that have vertices overlapping with vertices of the soma</span>
<span class="sd">    7) Creates a spine object for each of the spine meshes remaining after filtering:</span>
<span class="sd">        a) spu.calculate_spine_attributes</span>
<span class="sd">        </span>
<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    spine_n_face_threshold: int</span>
<span class="sd">        minimum number of mesh faces for a submesh to be in consideration for the spine classification</span>

<span class="sd">    # -- size filtering</span>
<span class="sd">    spine_sk_length_threshold: int</span>
<span class="sd">        minimum length (unit) of the surface skeleton of the submesh for it to be in consideration for the spine classification</span>

<span class="sd">    # -- bounding box filtering</span>
<span class="sd">    filter_by_bounding_box_longest_side_length: </span>

<span class="sd">    side_length_threshold: </span>

<span class="sd">    # -- border filtering</span>
<span class="sd">    filter_out_border_spines: bool</span>
<span class="sd">        whether to be perform spine filtering by considering how much spine submesh vertices overlap with border vertices of barents</span>

<span class="sd">    border_percentage_threshold: float</span>
<span class="sd">        maximum percentage a submesh vertices can overlap with border vertices (certices adjacent to open spaces in the mesh) on the parent mesh and still be in consideration for spine label  </span>

<span class="sd">    check_spine_border_perc_global: float</span>
<span class="sd">        maximum percentage that a the parent mesh’s border vertices can overlapping with the submesh vertices and that submesh still be in consideration for spine label  </span>
<span class="sd">    # -- skeleton filtering</span>
<span class="sd">    skeleton_endpoint_nullification: bool</span>

<span class="sd">    skeleton_endpoint_nullification_distance_global: float</span>
<span class="sd">        minimum distance</span>

<span class="sd">    # -- soma filtering</span>
<span class="sd">    soma_vertex_nullification: bool</span>


<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    curr_limb = neuron_obj[2]</span>
<span class="sd">    soma_verts = np.concatenate([neuron_obj[f&quot;S{k}&quot;].mesh.vertices for k in curr_limb.touching_somas()])</span>

<span class="sd">    branch = neuron_obj[2][7]</span>
<span class="sd">    sp_filt,sp_vol, spine_submesh_split_filtered_not = calculate_spines_on_branch(</span>
<span class="sd">        branch,</span>

<span class="sd">        shaft_threshold = 500,</span>
<span class="sd">        smoothness_threshold = 0.08,</span>


<span class="sd">        plot_spines_before_filter = False,</span>
<span class="sd">        plot_spines_after_face_threshold=False,</span>

<span class="sd">        plot_spines_after_bbox_threshold = True,</span>
<span class="sd">        plot_spines_after_border_filter = True,</span>

<span class="sd">        soma_verts = soma_verts,</span>
<span class="sd">        plot_spines_after_skeleton_endpt_nullification = True,</span>
<span class="sd">        plot_spines_after_soma_nullification = True,</span>
<span class="sd">        plot_spines_after_volume_filter = True,</span>

<span class="sd">        print_flag=True,</span>

<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">clusters_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clusters_threshold</span> <span class="o">=</span> <span class="n">clusters_threshold_global</span>
        
    <span class="k">if</span> <span class="n">smoothness_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smoothness_threshold</span> <span class="o">=</span> <span class="n">smoothness_threshold_global</span>
        
    <span class="k">if</span> <span class="n">shaft_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="n">shaft_threshold_global</span>
        
    <span class="k">if</span> <span class="n">calculate_spine_volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">calculate_spine_volume</span> <span class="o">=</span> <span class="n">calculate_spine_volume_global</span>
    
    <span class="k">if</span> <span class="n">spine_n_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_n_face_threshold</span> <span class="o">=</span> <span class="n">spine_n_face_threshold_global</span>
        
    <span class="k">if</span> <span class="n">spine_sk_length_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="n">spine_sk_length_threshold_global</span>
        
    <span class="k">if</span> <span class="n">filter_by_bounding_box_longest_side_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_by_bounding_box_longest_side_length</span> <span class="o">=</span> <span class="n">filter_by_bounding_box_longest_side_length_global</span>
        
    <span class="k">if</span> <span class="n">side_length_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">side_length_threshold</span> <span class="o">=</span> <span class="n">side_length_threshold_global</span>
        
    <span class="k">if</span> <span class="n">filter_out_border_spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_out_border_spines</span> <span class="o">=</span> <span class="n">filter_out_border_spines_global</span>
        
    <span class="k">if</span> <span class="n">skeleton_endpoint_nullification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_endpoint_nullification</span> <span class="o">=</span> <span class="n">skeleton_endpoint_nullification_global</span>
        
    <span class="k">if</span> <span class="n">skeleton_endpoint_nullification_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_endpoint_nullification_distance</span> <span class="o">=</span> <span class="n">skeleton_endpoint_nullification_distance_global</span>
        
    <span class="k">if</span> <span class="n">soma_vertex_nullification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="n">soma_vertex_nullification_global</span>
        
    <span class="k">if</span> <span class="n">border_percentage_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">border_percentage_threshold</span> <span class="o">=</span> <span class="n">border_percentage_threshold_global</span>
        
    <span class="k">if</span> <span class="n">check_spine_border_perc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check_spine_border_perc</span> <span class="o">=</span> <span class="n">check_spine_border_perc_global</span>
        
    <span class="k">if</span> <span class="n">filter_by_volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_by_volume</span> <span class="o">=</span> <span class="n">filter_by_volume_global</span>
        
    <span class="k">if</span> <span class="n">filter_by_volume_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="n">filter_by_volume_threshold_global</span>
    
    <span class="n">cgal_path</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./cgal_temp&quot;</span><span class="p">)</span>
    
    <span class="c1"># Step 1: Initial segmentation to get unfiltered spines</span>
    <span class="n">spine_submesh_split</span><span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">get_spine_meshes_unfiltered_from_mesh</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                                   <span class="n">segment_name</span><span class="o">=</span><span class="s2">&quot;no_name&quot;</span><span class="p">,</span>
                                                                <span class="n">clusters</span><span class="o">=</span><span class="n">clusters_threshold</span><span class="p">,</span>
                                                                <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness_threshold</span><span class="p">,</span>
                                                                <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">cgal_path</span><span class="p">,</span>
                                                                <span class="n">delete_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">return_sdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">shaft_threshold</span><span class="o">=</span><span class="n">shaft_threshold</span><span class="p">,</span>
                                                                  <span class="n">plot_segmentation</span><span class="o">=</span><span class="n">plot_segmentation</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; n_spines found before filtering = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_spines_before_filter</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_before_filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
        
    <span class="c1"># Step 2: Filter Spines by Face length</span>
    <span class="k">if</span> <span class="n">spine_n_face_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">spine_sk_length_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering away by face and skeletal length&quot;</span><span class="p">)</span>
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_spine_meshes</span><span class="p">(</span><span class="n">spine_submesh_split</span><span class="p">,</span>
                                                            <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="n">spine_n_face_threshold</span><span class="p">,</span>
                                                          <span class="n">spine_sk_length_threshold</span><span class="o">=</span><span class="n">spine_sk_length_threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spine_submesh_split</span>
    
    
    <span class="k">if</span> <span class="n">plot_spines_after_face_threshold</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_face_threshold and sk_length_threshold: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
        
    <span class="c1"># Step 3: Filter Spines by Bounding Box</span>
    <span class="k">if</span> <span class="n">filter_by_bounding_box_longest_side_length</span><span class="p">:</span>
        <span class="n">old_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span>
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_bounding_box_longest_side</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                                                 <span class="n">side_length_threshold</span><span class="o">=</span><span class="n">side_length_threshold</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">plot_spines_after_bbox_threshold</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_bbox_threshold: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">filter_out_border_spines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the filter_out_border_spines option&quot;</span><span class="p">)</span>
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_out_border_spines</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                                    <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                                    <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="n">border_percentage_threshold</span><span class="p">,</span>
                                                                    <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="n">check_spine_border_perc</span><span class="p">,</span>
                                                                    <span class="n">verbose</span><span class="o">=</span><span class="n">print_flag</span>
                                                                   <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plot_spines_after_border_filter</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_bbox_threshold: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">skeleton_endpoint_nullification</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the skeleton_endpoint_nullification option&quot;</span><span class="p">)</span>


        <span class="n">curr_branch_end_coords</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                    <span class="n">curr_branch_end_coords</span><span class="p">,</span>
                                                    <span class="n">distance_threshold</span><span class="o">=</span><span class="n">skeleton_endpoint_nullification_distance</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plot_spines_after_skeleton_endpt_nullification</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_skeleton_endpt_nullification: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            
    
    
    <span class="k">if</span> <span class="n">soma_vertex_nullification</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">soma_verts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_verts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">soma_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Requested endpoint nullification but no soma information given&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the soma_vertex_nullification option&quot;</span><span class="p">)</span>

        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_out_soma_touching_spines</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                    <span class="n">soma_kdtree</span><span class="o">=</span><span class="n">soma_kdtree</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plot_spines_after_soma_nullification</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_soma_nullification: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            
            
    <span class="k">if</span> <span class="n">calculate_spine_volume</span> <span class="ow">or</span> <span class="n">filter_by_volume</span><span class="p">:</span> 
        <span class="n">spine_volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_submesh_split_filtered</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">filter_by_volume</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        1) Calculate the volumes of all the spines</span>
<span class="sd">        2) Filter those spines for only those above the volume</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">volume_kept_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spine_volumes</span> <span class="o">&gt;</span> <span class="n">filter_by_volume_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of spines filtered away by volume = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_volumes</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">volume_kept_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1">#spine_submesh_split_filtered_not = [spine_submesh_split_filtered[k] for k in range(len(spine_volumes)) if k not in volume_kept_idx]</span>
            <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">spine_submesh_split_filtered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">volume_kept_idx</span><span class="p">]</span>
            
            <span class="n">spine_volumes</span> <span class="o">=</span> <span class="n">spine_volumes</span><span class="p">[</span><span class="n">volume_kept_idx</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">plot_spines_after_volume_filter</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_volume_filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">calculate_spine_volume</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span><span class="n">spine_volumes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_submesh_split_filtered</span></div>
    
<div class="viewcode-block" id="calculate_spines_on_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spines_on_neuron">[docs]</a><span class="k">def</span> <span class="nf">calculate_spines_on_neuron</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1">#---arguments for the query restriction -----</span>
    <span class="c1">#query=&quot;width &gt; 400 and n_faces_branch&gt;100&quot;,</span>
    <span class="c1">#query=&quot;median_mesh_center &gt; 140 and n_faces_branch&gt;100&quot;,#previous used median_mesh_center &gt; 140</span>
    <span class="n">query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#previous used median_mesh_center &gt; 140</span>
    <span class="n">plot_query</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># limb specific arguments for spine calculation:</span>
    <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1">#---- arguments for the spine calculation on a branch ----</span>
    
    <span class="c1">#-- arguments for volume -- </span>
    <span class="n">calculate_spine_volume</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">limb_branch_dict_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will calculate spines over a neuron object</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) Calculates a limb_branch_dict over which to perform spine detection if not already given. Which branches are included are determined by:</span>
<span class="sd">        a) Generates width calculations if not already performed</span>
<span class="sd">        b) performs the search with the query to get the limb branch dict</span>
<span class="sd">    2) Iterates over all limbs in limb branch:</span>
<span class="sd">        a) Generates the soma touching vertices and creates a kdtree for them</span>
<span class="sd">        b) Iterates over all branches:</span>
<span class="sd">            i) spu.calculate_spines_on_branch → returns spines and spine volumes</span>
<span class="sd">            </span>
<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    query: str</span>
<span class="sd">        the query to restrict branches searched</span>


<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    spu.calculate_spines_on_neuron(</span>
<span class="sd">        recovered_neuron,</span>
<span class="sd">        plot_query = False,</span>
<span class="sd">        print_flag = True,</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    nviz.plot_spines(recovered_neuron)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">query_global</span>
    
    <span class="k">if</span> <span class="n">calculate_spine_volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">calculate_spine_volume</span> <span class="o">=</span> <span class="n">calculate_spine_volume_global</span>
    
    <span class="k">if</span> <span class="n">soma_vertex_nullification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="n">soma_vertex_nullification_global</span>
    
    
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">query_global</span>
    
    <span class="c1"># --- Step 1: Applies query to see which branches to calculate spines over ---</span>
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">functions_list</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="s2">&quot;functions_list&quot;</span><span class="p">]</span>
            <span class="n">current_query</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="s2">&quot;query&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span><span class="s2">&quot;n_faces_branch&quot;</span><span class="p">]</span>
            <span class="n">current_query</span> <span class="o">=</span> <span class="n">query</span>


        <span class="c1">#check that have calculated the median mesh center if required</span>
        <span class="k">if</span> <span class="s2">&quot;median_mesh_center&quot;</span> <span class="ow">in</span> <span class="n">functions_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">())</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="s2">&quot;median_mesh_center&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The median_mesh_center was requested but has not already been calculated so calculating now.... &quot;</span><span class="p">)</span>

                <span class="n">wu</span><span class="o">.</span><span class="n">calculate_new_width_for_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                      <span class="n">no_spines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">summary_measure</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The median_mesh_center was requested and HAS already been calculated&quot;</span><span class="p">)</span>

        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">functions_list</span><span class="o">=</span><span class="n">functions_list</span><span class="p">,</span>
                           <span class="n">query</span><span class="o">=</span><span class="n">current_query</span><span class="p">,</span>
                                         <span class="n">plot_limb_branch_dict</span><span class="o">=</span><span class="n">plot_query</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">plot_query</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict = </span><span class="si">{</span><span class="n">limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="c1"># --- Step 2: Calculating the Spines over ---</span>
        
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">soma_vertex_nullification</span><span class="p">:</span>
            <span class="n">soma_verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()])</span>
            <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_verts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">limb_branch_dict_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict_exclude</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict_exclude</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because in limb_branch exclude&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
            
            <span class="n">curr_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
            <span class="k">if</span> <span class="n">calculate_spine_volume</span><span class="p">:</span>
                <span class="n">branch_spines</span><span class="p">,</span><span class="n">branch_spines_vol</span>  <span class="o">=</span> <span class="n">calculate_spines_on_branch</span><span class="p">(</span>
                    <span class="n">curr_branch</span><span class="p">,</span>
                    <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">soma_kdtree</span><span class="p">,</span>
                    <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                    <span class="n">calculate_spine_volume</span> <span class="o">=</span><span class="n">calculate_spine_volume</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">branch_spines_vol</span><span class="p">)</span>
                <span class="n">already_calculated_volumes</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">branch_spines</span>  <span class="o">=</span> <span class="n">calculate_spines_on_branch</span><span class="p">(</span>
                    <span class="n">curr_branch</span><span class="p">,</span>
                    <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">soma_kdtree</span><span class="p">,</span>
                    <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                    <span class="n">calculate_spine_volume</span> <span class="o">=</span><span class="n">calculate_spine_volume</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="n">already_calculated_volumes</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">branch_spines</span><span class="p">)</span>
            
            
            <span class="k">if</span> <span class="n">calculate_spine_volume</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">already_calculated_volumes</span><span class="p">:</span>
                <span class="n">curr_branch</span><span class="o">.</span><span class="n">compute_spines_volume</span><span class="p">()</span></div>
                
                
<span class="c1"># --------------- for filtering spines: 1/25 ------------</span>
<div class="viewcode-block" id="print_filter_spine_thresholds"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.print_filter_spine_thresholds">[docs]</a><span class="k">def</span> <span class="nf">print_filter_spine_thresholds</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_n_face_threshold_global = </span><span class="si">{</span><span class="n">spine_n_face_threshold_global</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_by_volume_threshold_global = </span><span class="si">{</span><span class="n">filter_by_volume_threshold_global</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_sk_length_threshold_global = </span><span class="si">{</span><span class="n">spine_sk_length_threshold_global</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="filter_spines_by_size_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_spines_by_size_branch">[docs]</a><span class="k">def</span> <span class="nf">filter_spines_by_size_branch</span><span class="p">(</span>
    <span class="n">branch_obj</span><span class="p">,</span>
    <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_sk_length_threshold</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">assign_back_to_obj</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">calculate_spines_length_on_whole_neuron</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away any of the </span>
<span class="sd">    spines according to the size thresholds</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spine_n_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_n_face_threshold</span><span class="o">=</span> <span class="n">spine_n_face_threshold_global</span>
    <span class="k">if</span> <span class="n">filter_by_volume_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="n">filter_by_volume_threshold_global</span>
    <span class="k">if</span> <span class="n">spine_sk_length_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="n">spine_sk_length_threshold_global</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spines before filtering away: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">s_objs_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_obj</span> <span class="k">for</span> <span class="n">s_obj</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span>
                              <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">s_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">spine_n_face_threshold</span><span class="p">)</span>
                               <span class="ow">and</span> <span class="p">(</span><span class="n">s_obj</span><span class="o">.</span><span class="n">volume</span> <span class="o">&gt;</span> <span class="n">filter_by_volume_threshold</span><span class="p">)</span>
                                 <span class="ow">and</span> <span class="p">(</span><span class="n">s_obj</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="o">&gt;</span> <span class="n">spine_sk_length_threshold</span><span class="p">))</span>
                              <span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Spines before filtering away: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">s_objs_keep</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">assign_back_to_obj</span><span class="p">:</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="n">s_objs_keep</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s_objs_keep</span><span class="p">]</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">volume</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">s_objs_keep</span><span class="p">]</span>

        <span class="n">return_value</span> <span class="o">=</span> <span class="n">s_objs_keep</span>
    <span class="k">elif</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_spines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_spines_volume</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spine_mesh</span><span class="p">,</span><span class="n">spine_vol</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span><span class="p">,</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_volume</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">spine_n_face_threshold</span><span class="p">)</span> 
                <span class="ow">and</span> <span class="p">(</span><span class="n">spine_vol</span> <span class="o">&gt;=</span> <span class="n">filter_by_volume_threshold</span><span class="p">)</span>
               <span class="ow">and</span> <span class="p">(</span><span class="n">spine_length</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">spine_sk_length_threshold</span><span class="p">)):</span>
                <span class="n">new_spines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">)</span>
                <span class="n">new_spines_volume</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine_vol</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">assign_back_to_obj</span><span class="p">:</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="n">new_spines</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="n">new_spines_volume</span>
        
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">new_spines</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">if</span> <span class="n">calculate_spines_length_on_whole_neuron</span><span class="p">:</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">calculate_spines_skeletal_length</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>
    
<div class="viewcode-block" id="filter_spines_by_size"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_spines_by_size">[docs]</a><span class="k">def</span> <span class="nf">filter_spines_by_size</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_obj</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">branch_obj</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">:</span>
            <span class="n">spu</span><span class="o">.</span><span class="n">filter_spines_by_size_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span>
                                <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for spine filtering: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">neuron_obj</span></div>


<span class="c1"># ------------- 2/7 adjustments -----------------</span>
<div class="viewcode-block" id="adjust_obj_with_face_offset"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.adjust_obj_with_face_offset">[docs]</a><span class="k">def</span> <span class="nf">adjust_obj_with_face_offset</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">face_offset</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To adjust the spine properties that</span>
<span class="sd">    would be affected by a different face idx</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    b_test = neuron_obj[0][18]</span>
<span class="sd">    sp_obj = b_test.spines_obj[0]</span>
<span class="sd">    sp_obj.export()</span>

<span class="sd">    spu.adjust_spine_obj_with_face_offset(</span>
<span class="sd">        sp_obj,</span>
<span class="sd">        face_offset = face_offset,</span>
<span class="sd">        verbose = True</span>
<span class="sd">    ).export()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">export</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s2">&quot;face_idx&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
            
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;head_face_idx&quot;</span><span class="p">,</span><span class="s2">&quot;neck_face_idx&quot;</span><span class="p">]:</span>
            <span class="k">continue</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adjusting </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> because face_idx and not None&quot;</span><span class="p">)</span>
            
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="o">+</span> <span class="n">face_offset</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">v</span> <span class="o">+</span> <span class="n">face_offset</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">new_obj</span></div>

<div class="viewcode-block" id="spine_length"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_length">[docs]</a><span class="k">def</span> <span class="nf">spine_length</span><span class="p">(</span>
    <span class="n">spine_mesh</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">surface_skeleton_method</span> <span class="o">=</span> <span class="s2">&quot;slower&quot;</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_spine_obj</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">):</span>
        <span class="n">spine_mesh</span> <span class="o">=</span> <span class="n">spine_mesh</span><span class="o">.</span><span class="n">mesh</span>
        
    <span class="c1">#spine_mesh = tu.largest_conn_comp(spine_mesh)</span>
    
    <span class="k">if</span> <span class="n">surface_skeleton_method</span> <span class="o">==</span> <span class="s2">&quot;meshparty&quot;</span><span class="p">:</span>
        <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">surface_skeleton</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">generate_surface_skeleton_slower</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">)</span>
        
    <span class="n">curr_sk_length</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_sk</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal length = </span><span class="si">{</span><span class="n">curr_sk_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">spine_mesh</span><span class="p">,</span><span class="n">curr_sk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">curr_sk_length</span></div>

<div class="viewcode-block" id="complete_spine_processing"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.complete_spine_processing">[docs]</a><span class="k">def</span> <span class="nf">complete_spine_processing</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compute_initial_spines</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compute_no_spine_width</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compute_spine_objs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">limb_branch_dict_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will redo all of the spine processing</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Redo the spines</span>
<span class="sd">    2) Redo the spine widthing</span>
<span class="sd">    3) Redo the spine calculation</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    import time</span>
<span class="sd">    spu.set_global_parameters_and_attributes_by_data_type(data_type)</span>
<span class="sd">    spu.complete_spine_processing(</span>
<span class="sd">        neuron_obj,</span>
<span class="sd">        verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">global_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">compute_initial_spines</span><span class="p">:</span> 
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spines_on_neuron</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">limb_branch_dict_exclude</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for compute_initial_spines = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">compute_no_spine_width</span><span class="p">:</span> 
        <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">width_utils</span> <span class="k">as</span> <span class="n">wu</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">widths_to_calculate</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths_to_calculate</span><span class="p">:</span>
            <span class="n">wu</span><span class="o">.</span><span class="n">calculate_new_width_for_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">width_name</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for compute_no_spine_width = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">compute_spine_objs</span><span class="p">:</span> 
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">add_head_neck_shaft_spine_objs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                                                                      <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for compute_spine_objs = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">plot_spines_head_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">neuron_obj</span></div>

<span class="c1"># -------------- for other properties per spine obj -------------</span>

<div class="viewcode-block" id="calculate_spine_obj_mesh_skeleton_coordinates_for_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spine_obj_mesh_skeleton_coordinates_for_branch">[docs]</a><span class="k">def</span> <span class="nf">calculate_spine_obj_mesh_skeleton_coordinates_for_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch_obj</span>
    <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_obj_mesh_skeleton_coordinates</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">]</span> 
    <span class="k">return</span> <span class="n">branch_obj</span></div>

<div class="viewcode-block" id="calculate_spine_obj_mesh_skeleton_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spine_obj_mesh_skeleton_coordinates">[docs]</a><span class="k">def</span> <span class="nf">calculate_spine_obj_mesh_skeleton_coordinates</span><span class="p">(</span>
    <span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coordinate_method</span> <span class="o">=</span> <span class="s1">&#39;first_coordinate&#39;</span><span class="p">,</span><span class="c1">#&quot;mean&quot;,</span>
    <span class="n">plot_intersecting_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_closest_skeleton_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">spine_objs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">branch_shaft_mesh_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will compute a lot of the properties of </span>
<span class="sd">    spine objects that are equivalent to those</span>
<span class="sd">    computed in syu.add_valid_synapses_to_neuron_obj</span>

<span class="sd">    The attributes include</span>

<span class="sd">    &quot;endpoints_dist&quot;,</span>
<span class="sd">    &quot;upstream_dist&quot;,</span>
<span class="sd">    &quot;downstream_dist&quot;,</span>
<span class="sd">    &quot;coordinate&quot;,</span>
<span class="sd">    &quot;closest_sk_coordinate&quot;,</span>
<span class="sd">    &quot;closest_face_idx&quot;,</span>
<span class="sd">    &quot;closest_branch_face_idx&quot;,</span>
<span class="sd">    &quot;closest_face_dist&quot;,</span>
<span class="sd">    &quot;closest_face_coordinate&quot;,</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Make sure the branches have upstream and downstream set</span>
<span class="sd">    2) Find intersection of vertices between branch and shaft</span>
<span class="sd">    3) Find average vertices that make up the coordinate</span>
<span class="sd">    4) Find the closest mesh coordinate</span>
<span class="sd">    5) Find the closest skeeleton point</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Old method</span>
<span class="sd">    try:</span>
<span class="sd">        </span>
<span class="sd">        overlap_verts= tu.find_border_vertices(</span>
<span class="sd">            spine_obj.mesh,</span>
<span class="sd">            return_coordinates=True)</span>
<span class="sd">    except:</span>
<span class="sd">        branch_obj_minus_spine = tu.subtract_mesh(</span>
<span class="sd">            branch_obj.mesh,</span>
<span class="sd">            spine_obj.mesh,</span>
<span class="sd">        )</span>
<span class="sd">        overlap_verts = nu.intersect2d(</span>
<span class="sd">            spine_obj.mesh.vertices,</span>
<span class="sd">            branch_obj_minus_spine.vertices</span>
<span class="sd">        )</span>
<span class="sd">        </span>


<span class="sd">    if len(overlap_verts) == 0:</span>
<span class="sd">#         overlap_verts = spine_obj.mesh.vertices[0].reshape(-1,3)</span>
<span class="sd">#         if verbose:</span>
<span class="sd">#             print(f&quot;Using first spine vertex as coordinate because no overlapping&quot;)</span>
<span class="sd">        overlap_verts = tu.closest_mesh_vertex_to_other_mesh(</span>
<span class="sd">            spine_obj.mesh,</span>
<span class="sd">            branch_obj.mesh_shaft,</span>
<span class="sd">            plot = False,</span>
<span class="sd">            verbose = False,</span>
<span class="sd">        ).reshape(-1,3)</span>



<span class="sd">    #3) Find average vertices that make up the coordinate    </span>
<span class="sd">    if coordinate_method == &quot;mean&quot;:</span>
<span class="sd">        coordinate = np.mean(overlap_verts,axis = 0)</span>
<span class="sd">    else:</span>
<span class="sd">        coordinate = overlap_verts[0]</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;coordinate = {coordinate}&quot;)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">attr_to_set</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;coordinate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;closest_branch_face_idx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;closest_face_dist&quot;</span><span class="p">,</span>
        <span class="s2">&quot;closest_face_coordinate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;coordinate_border_verts&quot;</span>
    <span class="p">]</span>
    
    <span class="k">if</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span>
    
    
    <span class="k">if</span> <span class="n">spine_objs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">meshes_to_minus</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meshes_to_minus</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="c1"># find the overlapping vertices</span>
    <span class="k">if</span> <span class="n">branch_shaft_mesh_face_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlapping_vertices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">overlapping_vertices_from_face_lists</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">face_lists</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_shaft_mesh_face_idx</span><span class="p">,</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">],</span>
            <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlapping_vertices</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="c1">#print(f&quot;overlapping_vertices = {overlapping_vertices}&quot;)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coordinate</span><span class="p">,</span><span class="n">coordinate_border_verts</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">coordinate_on_mesh_mesh_border</span><span class="p">(</span>
            <span class="n">mesh</span><span class="o">=</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">mesh_border</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">meshes_to_minus</span> <span class="o">=</span> <span class="n">meshes_to_minus</span><span class="p">,</span>
            <span class="n">coordinate_method</span> <span class="o">=</span> <span class="n">coordinate_method</span><span class="p">,</span><span class="c1">#&quot;mean&quot;,</span>
            <span class="n">overlapping_vertices</span><span class="o">=</span><span class="n">overlapping_vertices</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">verbose_time</span><span class="o">=</span><span class="n">verbose_time</span><span class="p">,</span>
            <span class="n">return_winning_coordinate_group</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_coordinate_to_other_mesh</span><span class="p">(</span>
            <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">mesh</span>
        <span class="p">)</span>
        
        <span class="n">coordinate_border_verts</span> <span class="o">=</span> <span class="n">coordinate</span>
    

    <span class="k">if</span> <span class="n">plot_intersecting_vertices</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_intersecting_vertices&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">],</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">overlap_verts</span><span class="p">,</span><span class="n">coordinate</span><span class="p">],</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span><span class="s1">&#39;blue&#39;</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1">#4) Find the closest mesh coordinate</span>
    <span class="n">closest_branch_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_face_to_coordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="n">closest_face_coordinate</span><span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[</span><span class="n">closest_branch_face_idx</span><span class="p">]</span>
    <span class="n">closest_face_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coordinate</span> <span class="o">-</span> <span class="n">closest_face_coordinate</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_branch_face_idx = </span><span class="si">{</span><span class="n">closest_branch_face_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_face_coordinate = </span><span class="si">{</span><span class="n">closest_face_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_face_dist = </span><span class="si">{</span><span class="n">closest_face_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#5) Find the closest skeeleton point</span>
    <span class="n">closest_sk_coordinate</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">closest_sk_coordinate</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">closest_skeleton_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="p">,</span>
                                    <span class="n">closest_face_coordinate</span><span class="p">)</span>
        <span class="n">attr_to_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;closest_sk_coordinate&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_sk_coordinate= </span><span class="si">{</span><span class="n">closest_sk_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_closest_skeleton_coordinate</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_closest_skeleton_coordinate&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">skeleton</span><span class="p">,</span>
                         <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">],</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">closest_sk_coordinate</span><span class="p">],</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;blue&#39;</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attr_to_set</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="nb">eval</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">spine_obj</span></div>

<div class="viewcode-block" id="id_from_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.id_from_idx">[docs]</a><span class="k">def</span> <span class="nf">id_from_idx</span><span class="p">(</span>
    <span class="n">limb_idx</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">spine_idx</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_int_name</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
    <span class="n">name_as_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">spine_idx</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">name_as_string</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="calculate_spine_obj_attr_for_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_spine_obj_attr_for_neuron">[docs]</a><span class="k">def</span> <span class="nf">calculate_spine_obj_attr_for_neuron</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">create_id</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To set all of the</span>
<span class="sd">    neuron_obj spine attributes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    for limbs</span>
<span class="sd">        for branches</span>
<span class="sd">            1) calculate the mesh and skeleton info</span>
<span class="sd">            2) calculate_branch_attr_soma_distances_on_limb</span>

<span class="sd">    calculate the soma distance</span>
<span class="sd">    </span>
<span class="sd">    Ex: neuron_obj= spu.calculate_spine_obj_attr_for_neuron(neuron_obj,verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     Branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
            <span class="c1">#1) calculate the mesh and skeleton info</span>
            <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_obj_mesh_skeleton_coordinates_for_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">create_id</span> <span class="ow">and</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s_idx</span><span class="p">,</span><span class="n">sp_ogj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">):</span>
                    <span class="n">branch_obj</span><span class="o">.</span><span class="n">spine_id</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">id_from_idx</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">s_idx</span><span class="p">)</span>

        <span class="c1">#2) calculate_branch_attr_soma_distances_on_limb</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">bau</span><span class="o">.</span><span class="n">calculate_branch_attr_soma_distances_on_limb</span><span class="p">(</span>
            <span class="n">limb_obj</span><span class="p">,</span>
            <span class="n">branch_attr</span><span class="o">=</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">,</span>
            <span class="n">calculate_endpoints_dist_if_empty</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_obj</span>
        
        

<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;Working on calculate_neuron_soma_distance&quot;)</span>
<span class="c1">#     bau.calculate_neuron_soma_distance(neuron_obj,branch_attr=&quot;spines_obj&quot;)   </span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on calculate_neuron_soma_distance_euclidean&quot;</span><span class="p">)</span>
    <span class="n">bau</span><span class="o">.</span><span class="n">calculate_neuron_soma_distance_euclidean</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">branch_attr</span><span class="o">=</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">)</span>
    <span class="n">bau</span><span class="o">.</span><span class="n">set_limb_branch_idx_to_attr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">branch_attr</span><span class="o">=</span><span class="s2">&quot;spines_obj&quot;</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">neuron_obj</span></div>

<div class="viewcode-block" id="calculate_endpoints_dist"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_endpoints_dist">[docs]</a><span class="k">def</span> <span class="nf">calculate_endpoints_dist</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="n">bau</span><span class="o">.</span><span class="n">calculate_endpoints_dist</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">spine_obj</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="calculate_upstream_downstream_dist_from_up_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.calculate_upstream_downstream_dist_from_up_idx">[docs]</a><span class="k">def</span> <span class="nf">calculate_upstream_downstream_dist_from_up_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">up_idx</span><span class="p">):</span>
    <span class="n">bau</span><span class="o">.</span><span class="n">calculate_upstream_downstream_dist_from_up_idx</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">up_idx</span><span class="o">=</span><span class="n">up_idx</span><span class="p">)</span></div>
    
    
<span class="c1"># ------- for calculating properties of spines ----</span>
<div class="viewcode-block" id="skeleton_from_spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.skeleton_from_spine">[docs]</a><span class="k">def</span> <span class="nf">skeleton_from_spine</span><span class="p">(</span><span class="n">spine</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;trimesh&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">spine</span><span class="p">)):</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">spine</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">spine</span><span class="o">.</span><span class="n">mesh</span>
        
    <span class="n">spine_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">surface_skeleton</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spine_sk</span></div>

<div class="viewcode-block" id="skeletal_length_from_spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.skeletal_length_from_spine">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_from_spine</span><span class="p">(</span><span class="n">spine</span><span class="p">,</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">spu</span><span class="o">.</span><span class="n">skeleton_from_spine</span><span class="p">(</span><span class="n">spine</span><span class="p">))</span></div>

<div class="viewcode-block" id="volume_from_spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.volume_from_spine">[docs]</a><span class="k">def</span> <span class="nf">volume_from_spine</span><span class="p">(</span><span class="n">spine</span><span class="p">,</span><span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">spine</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_value</span></div>


<span class="c1"># ---------------------- 11/3: Calculating the spines with all of the information  -----</span>
<div class="viewcode-block" id="spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_branch_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_branch_obj">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_branch_obj</span><span class="p">(</span>
    <span class="n">branch_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ensure_mesh_conn_comp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_spines_before_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="n">filter_out_border_spines</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">border_percentage_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_border_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">skeleton_endpoint_nullification</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">skeleton_endpoint_nullification_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_skeleton_endpt_nullification</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_verts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_spines_after_soma_nullification</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    Performs spine detection on a branch object or a branch mesh (optionally with a skeleton) and then apply filtering before creating official Spine objects from each individually detected spine.</span>

<span class="sd">    Purpose Detailed</span>
<span class="sd">    -----------------------</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) Generate initial spine mesh detection</span>
<span class="sd">    2) Filter out border spines:</span>
<span class="sd">        if requested (filter_out_border_spines), filter out meshes that have:</span>
<span class="sd">            a) higher than a certain percentage (border_percentage_threshold) of the submesh vertices overlapping with border vertices (certices adjacent to open spaces in the mesh) on the parent mesh  </span>
<span class="sd">            b) higher than certain percentage (check_spine_border_perc_global) of the parent mesh’s border vertices overlapping with the submesh vertices</span>
<span class="sd">    3) skeleton endpoint filtering:</span>
<span class="sd">        if requested (skeleton_endpoint_nullification), filter away spines that are within a certain distance (skeleton_endpoint_nullification_distance) from the branch skeleton endpoints in order to avoid a high false positive class.</span>
<span class="sd">    4) some vertex nullification:</span>
<span class="sd">        if requested (soma_vertex_nullification), filter out spines that have vertices overlapping with vertices of the soma</span>
<span class="sd">    5) Creates spine objects from all the remaining spine objects (will do head/neck segmentaiton)</span>

<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    # -- border filtering</span>
<span class="sd">    filter_out_border_spines: bool</span>
<span class="sd">        whether to be perform spine filtering by considering how much spine submesh vertices overlap with border vertices of shaft submesh</span>

<span class="sd">    border_percentage_threshold: float</span>
<span class="sd">        maximum percentage a submesh vertices can overlap with border vertices (vertices adjacent to open spaces in the mesh) on the parent mesh and still be in consideration for spine label  </span>

<span class="sd">    # -- skeleton filtering</span>
<span class="sd">    skeleton_endpoint_nullification: bool</span>
<span class="sd">        whether to filter away spines that are within a certain distance (skeleton_endpoint_nullification_distance) from the branch skeleton endpoints in order to avoid a high false positive class.</span>

<span class="sd">    skeleton_endpoint_nullification_distance_global: float</span>
<span class="sd">        minimum distance a spine mesh can be from the branch skeleton endpoints and not be filtered away when the skeleton_endpoint_nullification flag is set</span>

<span class="sd">    # -- soma filtering</span>
<span class="sd">    soma_vertex_nullification: bool</span>
<span class="sd">        when true will filter out spines that have vertices overlapping with vertices of the soma</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">filter_out_border_spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_out_border_spines</span> <span class="o">=</span> <span class="n">filter_out_border_spines_global</span>
        
    <span class="k">if</span> <span class="n">border_percentage_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">border_percentage_threshold</span> <span class="o">=</span> <span class="n">border_percentage_threshold_global</span>
        
    <span class="k">if</span> <span class="n">skeleton_endpoint_nullification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_endpoint_nullification</span> <span class="o">=</span> <span class="n">skeleton_endpoint_nullification_global</span>
        
    <span class="k">if</span> <span class="n">skeleton_endpoint_nullification_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_endpoint_nullification_distance</span> <span class="o">=</span> <span class="n">skeleton_endpoint_nullification_distance_global</span>
        
    <span class="k">if</span> <span class="n">soma_vertex_nullification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="n">soma_vertex_nullification_global</span>

    
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
        
        

    <span class="p">(</span><span class="n">spines</span><span class="p">,</span>
     <span class="n">spines_sdf</span><span class="p">,</span>
     <span class="n">spines_mesh_idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">get_spine_meshes_unfiltered_from_mesh</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">delete_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_mesh_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_segmentation</span><span class="o">=</span><span class="n">plot_segmentation</span><span class="p">,</span>
        <span class="n">ensure_mesh_conn_comp</span><span class="o">=</span><span class="n">ensure_mesh_conn_comp</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose:</span>
<span class="sd">    -------</span>
<span class="sd">    if requested (filter_by_bounding_box_longest_side_length), filters the meshes to have less than a certain length (side_length_threshold) for the longest side of their oriented bounding box. To prevent false positive spines from long axon fragment merges</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">plot_spines_before_filter</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_before_filter: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spines</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">meshes</span> <span class="o">=</span> <span class="n">spines</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        



    <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spines</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_submesh_split_filtered</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -------</span>
<span class="sd">    if requested (filter_out_border_spines), filter out meshes that have:</span>
<span class="sd">        a) higher than a certain percentage (border_percentage_threshold) of the submesh vertices overlapping with border vertices (certices adjacent to open spaces in the mesh) on the parent mesh  </span>
<span class="sd">        b) higher than certain percentage (check_spine_border_perc_global) of the parent mesh’s border vertices overlapping with the submesh vertices</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filter_out_border_spines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the filter_out_border_spines option&quot;</span><span class="p">)</span>
        <span class="n">spine_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_out_border_spines</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
            <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="n">border_percentage_threshold</span><span class="p">,</span>
            <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="n">check_spine_border_perc</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>
        <span class="n">spines_sdf</span><span class="o">=</span><span class="n">spines_sdf</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>
        <span class="n">spines_mesh_idx</span> <span class="o">=</span> <span class="n">spines_mesh_idx</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot_spines_after_border_filter</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_bbox_threshold: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                    <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                    <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After filter_out_border_spines: # of spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filter_out_border_spines</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_submesh_split_filtered</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -------</span>
<span class="sd">    if requested (skeleton_endpoint_nullification), filter away spines that are within a certain distance (skeleton_endpoint_nullification_distance) from the branch skeleton endpoints in order to avoid a high false positive class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">skeleton_endpoint_nullification</span> <span class="ow">and</span> <span class="p">(</span><span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the skeleton_endpoint_nullification option&quot;</span><span class="p">)</span>


        <span class="n">curr_branch_end_coords</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">spine_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span>
            <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
            <span class="n">curr_branch_end_coords</span><span class="p">,</span>
            <span class="n">distance_threshold</span><span class="o">=</span><span class="n">skeleton_endpoint_nullification_distance</span><span class="p">,</span>
            <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>
        <span class="n">spines_sdf</span><span class="o">=</span><span class="n">spines_sdf</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>
        <span class="n">spines_mesh_idx</span> <span class="o">=</span> <span class="n">spines_mesh_idx</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot_spines_after_skeleton_endpt_nullification</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_skeleton_endpt_nullification: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After skeleton_endpoint_nullification: # of spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_submesh_split_filtered</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose:</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    if requested (soma_vertex_nullification), filter out spines that have vertices overlapping with vertices of the soma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">soma_vertex_nullification</span> <span class="ow">and</span> <span class="p">(</span><span class="n">soma_kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">soma_kdtree</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">soma_verts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_verts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">soma_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Requested soma vertex but no soma information given&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the soma_vertex_nullification option&quot;</span><span class="p">)</span>

        <span class="n">spine_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_out_soma_touching_spines</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                                                    <span class="n">soma_kdtree</span><span class="o">=</span><span class="n">soma_kdtree</span><span class="p">,</span>
                                                       <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="n">spine_submesh_split_filtered</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>
        <span class="n">spines_sdf</span><span class="o">=</span><span class="n">spines_sdf</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>
        <span class="n">spines_mesh_idx</span> <span class="o">=</span> <span class="n">spines_mesh_idx</span><span class="p">[</span><span class="n">spine_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot_spines_after_soma_nullification</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_spines_after_soma_nullification: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">meshes</span> <span class="o">=</span> <span class="n">spine_submesh_split_filtered</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After soma_vertex_nullification: # of spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose:</span>
<span class="sd">    --------</span>
<span class="sd">    Creates spine objects from all the remaining spine objects (will do head/neck segmentaiton)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Creating the spine objects</span>
    <span class="n">spine_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">spu</span><span class="o">.</span><span class="n">Spine</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span>
        <span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">k_idx</span><span class="p">,</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">s</span>
    <span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">k_idx</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spine_submesh_split_filtered</span><span class="p">,</span><span class="n">spines_mesh_idx</span><span class="p">,</span><span class="n">spines_sdf</span><span class="p">,)]</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Number of Spine Objects = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">spine_objs</span></div>


<div class="viewcode-block" id="spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_mesh">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_branch_obj</span><span class="p">(</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="df_from_spine_objs"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.df_from_spine_objs">[docs]</a><span class="k">def</span> <span class="nf">df_from_spine_objs</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">attributes_to_skip</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;mesh_face_idx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mesh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;neck_face_idx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;head_face_idx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sdf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">attributes_to_add</span> <span class="o">=</span> <span class="n">computed_attributes_to_export</span><span class="p">,</span>
    <span class="n">columns_at_front</span> <span class="o">=</span> <span class="n">computed_attributes_to_export</span><span class="p">,</span>
    <span class="n">columns_at_back</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">add_volume_to_area_ratio</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_loop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: make a spine attribute</span>
<span class="sd">    dataframe from a list of spines</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">spine_objs</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">)</span>
    
    <span class="n">dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose_loop</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">export</span><span class="p">(</span>
            <span class="n">attributes_to_skip</span><span class="o">=</span><span class="n">attributes_to_skip</span><span class="p">,</span>
            <span class="n">attributes_to_add</span><span class="o">=</span><span class="n">attributes_to_add</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">add_volume_to_area_ratio</span><span class="p">:</span>
            <span class="n">curr_dict</span><span class="p">[</span><span class="s2">&quot;spine_volume_to_spine_area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_volume_to_spine_area</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">curr_dict</span>
        <span class="p">)</span>
        
        
    
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">(</span><span class="n">dicts</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">order_columns</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">columns_at_front</span><span class="o">=</span><span class="n">columns_at_front</span><span class="p">,</span>
            <span class="n">columns_at_back</span><span class="o">=</span><span class="n">columns_at_back</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for generating df </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="plot_spine_objs"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_objs">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_objs</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">branch_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_mesh_centers</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">spine_color</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
    

    <span class="k">if</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
        
    <span class="n">scatters</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">plot_mesh_centers</span><span class="p">:</span>
        <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">mesh_center</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">],</span>
        <span class="n">meshes_colors</span> <span class="o">=</span> <span class="n">spine_color</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
        <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
    <span class="p">)</span></div>
<div class="viewcode-block" id="filter_spine_objs_from_restrictions"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_spine_objs_from_restrictions">[docs]</a><span class="k">def</span> <span class="nf">filter_spine_objs_from_restrictions</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">restrictions</span><span class="p">,</span>
    <span class="n">spine_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">joiner</span> <span class="o">=</span> <span class="s2">&quot;AND&quot;</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to filter the spines with</span>
<span class="sd">    a list of queries</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">spine_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_df</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">df_from_spine_objs</span><span class="p">(</span>
            <span class="n">spine_objs</span><span class="p">,</span>
            <span class="n">add_volume_to_area_ratio</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
    
        
    <span class="n">idx</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query_table_from_list</span><span class="p">(</span>
        <span class="n">spine_df</span><span class="p">,</span>
        <span class="n">restrictions</span><span class="o">=</span><span class="n">restrictions</span><span class="p">,</span>
        <span class="n">verbose_filtering</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
        <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">joiner</span><span class="o">=</span><span class="n">joiner</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="n">spine_objs_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">spine_objs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">idx</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_spine_objs</span><span class="p">(</span><span class="n">spine_objs_new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spine_objs_new</span></div>

<span class="n">query_spine_objs</span> <span class="o">=</span> <span class="n">filter_spine_objs_from_restrictions</span>


<div class="viewcode-block" id="example_comparing_mesh_segmentation_vs_spine_head_segmentation"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.example_comparing_mesh_segmentation_vs_spine_head_segmentation">[docs]</a><span class="k">def</span> <span class="nf">example_comparing_mesh_segmentation_vs_spine_head_segmentation</span><span class="p">(</span>
    <span class="n">spine_mesh</span><span class="p">,</span>
    <span class="p">):</span>


    <span class="n">cluster_idx</span> <span class="o">=</span> <span class="n">meshu</span><span class="o">.</span><span class="n">segment_mesh</span><span class="p">(</span>
        <span class="n">spine_mesh</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">mesh_dict</span><span class="p">,</span><span class="n">mesh_face_dict</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span>
        <span class="n">spine_mesh</span><span class="p">,</span>
        <span class="n">cluster_idx</span><span class="p">,</span>
        <span class="n">check_connect_comp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span>

    <span class="n">spu</span><span class="o">.</span><span class="n">spine_head_neck</span><span class="p">(</span>
        <span class="n">spine_mesh</span><span class="p">,</span>
        <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_spine_objs_on_branch"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_objs_on_branch">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_objs_on_branch</span><span class="p">(</span>
    <span class="n">spines_obj</span><span class="p">,</span>
    <span class="n">branch_obj</span><span class="p">,</span>
    <span class="n">plot_spines_individually</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">spines_obj</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">spines_obj</span><span class="p">)</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spines_obj</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">plot_spines_individually</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        <span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
        <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">centroid</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes</span><span class="p">]</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="spine_volume_to_spine_area"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_volume_to_spine_area">[docs]</a><span class="k">def</span> <span class="nf">spine_volume_to_spine_area</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">volume</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">volume</span><span class="o">/</span><span class="n">spu</span><span class="o">.</span><span class="n">volume_divisor</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">area</span><span class="o">/</span><span class="n">spu</span><span class="o">.</span><span class="n">area_divisor</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_spine_objs_by_size_bare_minimum"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_spine_objs_by_size_bare_minimum">[docs]</a><span class="k">def</span> <span class="nf">filter_spine_objs_by_size_bare_minimum</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">spine_n_face_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#6,</span>
    <span class="n">spine_sk_length_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#306.6,</span>
    <span class="n">filter_by_volume_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#900496.186,</span>
    <span class="n">bbox_oriented_side_max_min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#300,</span>
    <span class="n">sdf_mean_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0,</span>
    <span class="n">spine_volume_to_spine_area_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    Filters the spine objects for minimum feature requirements.</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) Apply a list of simple attribute “greater than” queries to filter down the spine objects.</span>


<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    spine_n_face_threshold_bare_min: </span>
<span class="sd">        minimum number of faces for a valid spine mesh</span>

<span class="sd">    spine_sk_length_threshold_bare_min: </span>
<span class="sd">        minimum surface skeletal length (units) of a valid spine mesh</span>

<span class="sd">    filter_by_volume_threshold_bare_min:</span>
<span class="sd">        minimum volume (units) of a valid spine mesh</span>

<span class="sd">    bbox_oriented_side_max_min_bare_min:</span>
<span class="sd">        minimum side length (uints) of the oriented bounding box surrounding the spine mesh for valid spines</span>

<span class="sd">    sdf_mean_min_bare_min: </span>
<span class="sd">        minimum mean sdf value (computed in the shaft/spine clustering step performed by the cgal clustering algorithm) for valid spine meshes</span>

<span class="sd">    spine_volume_to_spine_area_min_bare_min:</span>
<span class="sd">        minimum ratio of mesh volume (units^3) to mesh area (units^2) for valid spine meshes</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">    1) Visualize the spines after these filtering</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spine_objs : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    spine_n_face_threshold : int, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    spine_sk_length_threshold : float, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    filter_by_volume_threshold : float, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    bbox_oriented_side_max_min : int, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    sdf_mean_min : float, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    spine_volume_to_spine_area_min : float, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        _description_, by default False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_objs</span>
    
    <span class="k">if</span> <span class="n">spine_n_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_n_face_threshold</span> <span class="o">=</span> <span class="n">spine_n_face_threshold_bare_min_global</span>
        
    <span class="k">if</span> <span class="n">spine_sk_length_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="n">spine_sk_length_threshold_bare_min_global</span>
        
    <span class="k">if</span> <span class="n">filter_by_volume_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="n">filter_by_volume_threshold_bare_min_global</span>
        
    <span class="k">if</span> <span class="n">bbox_oriented_side_max_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bbox_oriented_side_max_min</span> <span class="o">=</span> <span class="n">bbox_oriented_side_max_min_bare_min_global</span>
        
    <span class="k">if</span> <span class="n">sdf_mean_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sdf_mean_min</span> <span class="o">=</span> <span class="n">sdf_mean_min_bare_min_global</span>
        
    <span class="k">if</span> <span class="n">spine_volume_to_spine_area_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_volume_to_spine_area_min</span> <span class="o">=</span> <span class="n">spine_volume_to_spine_area_min_bare_min_global</span>
        
        
    <span class="c1">#print(f&quot;filter_by_volume_threshold = {filter_by_volume_threshold}&quot;)</span>
    <span class="n">sp_objs_filt</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_spine_objs_from_restrictions</span><span class="p">(</span>
        <span class="n">spine_objs</span><span class="p">,</span>
        <span class="n">restrictions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;n_faces &gt;= </span><span class="si">{</span><span class="n">spine_n_face_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;(skeletal_length &gt;= </span><span class="si">{</span><span class="n">spine_sk_length_threshold</span><span class="si">}</span><span class="s2">) or (skeletal_length != skeletal_length)&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;(volume &gt;= </span><span class="si">{</span><span class="n">filter_by_volume_threshold</span><span class="si">}</span><span class="s2">) or (volume != volume)&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;sdf_mean &gt; </span><span class="si">{</span><span class="n">sdf_mean_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;bbox_oriented_side_max &gt; </span><span class="si">{</span><span class="n">bbox_oriented_side_max_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;spine_volume_to_spine_area &gt;= </span><span class="si">{</span><span class="n">spine_volume_to_spine_area_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">sp_objs_filt</span></div>
    
    
<div class="viewcode-block" id="example_trying_to_skeletonize_spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.example_trying_to_skeletonize_spine">[docs]</a><span class="k">def</span> <span class="nf">example_trying_to_skeletonize_spine</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshparty_skeletonize</span> <span class="k">as</span> <span class="n">m_sk</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">coordinate</span>
    <span class="n">invalidation_d</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">sk_meshparty_obj</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize_mesh_largest_component</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
        <span class="n">filter_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">invalidation_d</span><span class="o">=</span><span class="n">invalidation_d</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="p">(</span><span class="n">segment_branches_filtered</span><span class="p">,</span> <span class="c1">#skeleton branches</span>
    <span class="n">divided_submeshes</span><span class="p">,</span> <span class="n">divided_submeshes_idx</span><span class="p">,</span> <span class="c1">#mesh correspondence (mesh and indices)</span>
    <span class="n">segment_widths_median_filtered</span><span class="p">)</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeleton_obj_to_branches</span><span class="p">(</span>
        <span class="n">sk_meshparty_obj</span><span class="p">,</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">meshparty_n_surface_downsampling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">meshparty_segment_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">filter_end_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_end_node_length</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">segment_branches_filtered</span><span class="p">)</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="split_head_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.split_head_mesh">[docs]</a><span class="k">def</span> <span class="nf">split_head_mesh</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">return_face_idx_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: want to divide mesh into connected</span>
<span class="sd">    components and optionally return the mask</span>
<span class="sd">    of mapping fae to component</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">head_meshes</span><span class="p">,</span><span class="n">head_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">connected_components_from_mesh</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh</span><span class="p">,</span>
        <span class="n">return_face_idx_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="n">plot</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_face_idx_map</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">head_meshes</span><span class="p">,</span><span class="n">head_face_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">head_meshes</span></div>
    
<div class="viewcode-block" id="spine_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_mesh">[docs]</a><span class="k">def</span> <span class="nf">spine_mesh</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span></div>
    
<div class="viewcode-block" id="mesh_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.mesh_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">mesh_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">):</span>
    
    <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;head&quot;</span><span class="p">:</span>
        <span class="n">mesh_func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">head_mesh_splits_from_index</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;neck&quot;</span><span class="p">:</span>
        <span class="n">mesh_func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">neck_mesh</span>
    <span class="k">elif</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s1">&#39;spine&#39;</span><span class="p">:</span>
        <span class="n">mesh_func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_mesh</span>
    <span class="k">elif</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s1">&#39;no_head&#39;</span><span class="p">:</span>
        <span class="n">mesh_func</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">neck_mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    
        
    <span class="k">return</span> <span class="n">mesh_func</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="o">**</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="mesh_attribute_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.mesh_attribute_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">mesh_attribute_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">attribute_func</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">shaft_default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attribute_func</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">attribute_func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tu.</span><span class="si">{</span><span class="n">attribute_func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">compartment</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">compartment</span><span class="p">,</span><span class="n">index</span> <span class="o">=</span> <span class="n">compartment_index_from_id</span><span class="p">(</span><span class="n">compartment</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;shaft&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shaft_default_value</span>
    
    <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">mesh_from_compartment</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">compartment</span><span class="o">=</span><span class="n">compartment</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">curr_mesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">attribute_func</span><span class="p">(</span>
        <span class="n">curr_mesh</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="width_ray_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.width_ray_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">width_ray_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">default_value_if_empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">width_ray_trace_perc</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span>
        <span class="n">default_value_if_empty</span><span class="o">=</span><span class="n">default_value_if_empty</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="width_ray_80_perc_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.width_ray_80_perc_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">width_ray_80_perc_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">default_value_if_empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">width_ray_trace_perc</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">percentile</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
        <span class="n">default_value_if_empty</span><span class="o">=</span><span class="n">default_value_if_empty</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="area_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.area_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">area_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
    

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">area</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="n_faces"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_faces">[docs]</a><span class="k">def</span> <span class="nf">n_faces</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">my_func</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="volume_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.volume_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">volume_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.skeletal_length_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">skeletal_length_from_mesh</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="n">bbox_oriented</span> <span class="o">=</span> <span class="kc">False</span>
<div class="viewcode-block" id="bbox_min_x_nm_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bbox_min_x_nm_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">bbox_min_x_nm_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">bbox_min_x</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="n">bbox_oriented</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="bbox_min_y_nm_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bbox_min_y_nm_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">bbox_min_y_nm_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">bbox_min_y</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="n">bbox_oriented</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="bbox_min_z_nm_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bbox_min_z_nm_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">bbox_min_z_nm_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">bbox_min_z</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="n">bbox_oriented</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="bbox_max_x_nm_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bbox_max_x_nm_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">bbox_max_x_nm_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">bbox_max_x</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="n">bbox_oriented</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="bbox_max_y_nm_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bbox_max_y_nm_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">bbox_max_y_nm_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">bbox_max_y</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="n">bbox_oriented</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="bbox_max_z_nm_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.bbox_max_z_nm_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">bbox_max_z_nm_from_compartment</span><span class="p">(</span>
    <span class="n">spine_obj</span><span class="p">,</span>
    <span class="n">compartment</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="k">return</span> <span class="n">mesh_attribute_from_compartment</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="p">,</span>
        <span class="n">attribute_func</span><span class="o">=</span><span class="n">tu</span><span class="o">.</span><span class="n">bbox_max_z</span><span class="p">,</span>
        <span class="n">compartment</span> <span class="o">=</span> <span class="n">compartment</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">oriented</span><span class="o">=</span><span class="n">bbox_oriented</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="spine_compartment_mesh_functions"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_compartment_mesh_functions">[docs]</a><span class="k">def</span> <span class="nf">spine_compartment_mesh_functions</span><span class="p">(</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;spine&quot;</span><span class="p">,</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s1">&#39;neck&#39;</span><span class="p">,),</span>
    <span class="n">stats_functions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;width_ray_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;width_ray_80_perc_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;area_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;volume_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;skeletal_length_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_faces&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_min_x_nm_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_min_y_nm_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_min_z_nm_from_compartment&quot;</span><span class="p">,</span>
        
        <span class="s2">&quot;bbox_max_x_nm_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_max_y_nm_from_compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_max_z_nm_from_compartment&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate the size </span>
<span class="sd">    functions for all compartments: spine,head,neck,</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Iterate through all compartments</span>
<span class="sd">    2) print out the formatted function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">function_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">function_declaration_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
        <span class="n">function_declaration_str</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;#--- Mesh Attribute Functions for </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2"> -----</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stats_functions</span><span class="p">:</span> 
            <span class="n">func_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">st</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_from_compartment&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">function_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span>
            <span class="n">function_declaration_str</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;@property</span><span class="se">\n</span><span class="s2">def </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">(self,**kwargs):</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    return </span><span class="si">{</span><span class="n">st</span><span class="si">}</span><span class="s2">(self,compartment = &#39;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&#39;,**kwargs)</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function_declaration_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">function_names</span></div>

<div class="viewcode-block" id="spine_compartment_mesh_functions_dict"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_compartment_mesh_functions_dict">[docs]</a><span class="k">def</span> <span class="nf">spine_compartment_mesh_functions_dict</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute the statistics for a spine obj</span>
<span class="sd">    </span>
<span class="sd">    spu.spine_compartment_mesh_functions_dict(spine_obj)</span>
<span class="sd">    Output: </span>
<span class="sd">    {&#39;spine_width&#39;: 262.76843376430315,</span>
<span class="sd">     &#39;spine_width_80_perc&#39;: 433.6109345474601,</span>
<span class="sd">     &#39;spine_area&#39;: 4458314.872099194,</span>
<span class="sd">     &#39;spine_volume&#39;: 1442177510.8208666,</span>
<span class="sd">     &#39;spine_skeletal_length&#39;: 4518.759601841594,</span>
<span class="sd">     &#39;head_width&#39;: 385.4437561195757,</span>
<span class="sd">     &#39;head_width_80_perc&#39;: 452.5942823041014,</span>
<span class="sd">     &#39;head_area&#39;: 1848904.3472918314,</span>
<span class="sd">     &#39;head_volume&#39;: 198657361.45833808,</span>
<span class="sd">     &#39;head_skeletal_length&#39;: 1580.07824623045,</span>
<span class="sd">     &#39;neck_width&#39;: 110.51452991062567,</span>
<span class="sd">     &#39;neck_width_80_perc&#39;: 145.0012250999968,</span>
<span class="sd">     &#39;neck_area&#39;: 1378146.4731119499,</span>
<span class="sd">     &#39;neck_volume&#39;: 258763454.06805038,</span>
<span class="sd">     &#39;neck_skeletal_length&#39;: 2600.629272237006</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_funcs</span> <span class="o">=</span> <span class="n">spine_compartment_mesh_functions</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,)</span>
    <span class="n">globs</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_obj.</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">globs</span><span class="p">,</span><span class="n">locs</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_funcs</span><span class="p">}</span></div>
    
<div class="viewcode-block" id="plot_spines_objs_with_head_neck_and_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spines_objs_with_head_neck_and_coordinates">[docs]</a><span class="k">def</span> <span class="nf">plot_spines_objs_with_head_neck_and_coordinates</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">head_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">neck_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
    <span class="n">no_head_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="n">base_coordinate_color</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
    <span class="n">center_coordinate_color</span> <span class="o">=</span> <span class="s2">&quot;orange&quot;</span><span class="p">,</span>
    <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to plot from a list of spines</span>
<span class="sd">    all of the head,necks, centroids and </span>
<span class="sd">    coordinates of spines</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each spine:</span>
<span class="sd">    a) get the head/neck and put into mesh lists</span>
<span class="sd">    b) Get the coordinates and mesh_center and put into scatter</span>
<span class="sd">    3) Plot all  with the branch mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
        
    <span class="n">head_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neck_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">no_head_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">base_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">center_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spine_objs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">n_heads</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">no_head_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">no_head_mesh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">head_mesh</span><span class="p">)</span>
            <span class="n">neck_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">neck_mesh</span><span class="p">)</span>
        <span class="n">center_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">base_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span>
        
    <span class="c1">#print(f&quot;head_meshes = {head_meshes}&quot;)</span>

    <span class="n">base_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">base_coords</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">center_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center_coords</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># concatenating the meshes</span>
    <span class="n">head_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">head_meshes</span><span class="p">)]</span>
    <span class="n">neck_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">neck_meshes</span><span class="p">)]</span>
    <span class="n">no_head_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">no_head_meshes</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;head_meshes = </span><span class="si">{</span><span class="n">head_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neck_meshes = </span><span class="si">{</span><span class="n">neck_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no_head_meshes = </span><span class="si">{</span><span class="n">no_head_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">colors</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">[</span><span class="n">head_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">head_meshes</span><span class="p">)</span> <span class="o">+</span>
        <span class="p">[</span><span class="n">neck_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">neck_meshes</span><span class="p">)</span> <span class="o">+</span> 
        <span class="p">[</span><span class="n">no_head_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">no_head_meshes</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">head_meshes</span> <span class="o">+</span> <span class="n">neck_meshes</span> <span class="o">+</span> <span class="n">no_head_meshes</span><span class="p">,</span>
        <span class="n">meshes_colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">base_coords</span><span class="p">,</span><span class="n">center_coords</span><span class="p">],</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="n">base_coordinate_color</span><span class="p">,</span><span class="n">center_coordinate_color</span><span class="p">],</span>
        <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="spine_objs_bare_minimum_filt_with_attr_from_branch_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_bare_minimum_filt_with_attr_from_branch_obj">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_bare_minimum_filt_with_attr_from_branch_obj</span><span class="p">(</span>
    <span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_verts_on_limb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_kdtree_on_limb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_unfiltered_spines</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_filtered_spines</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#for calculatin distance of spine</span>
    <span class="n">soma_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1">#for branch features</span>
    <span class="n">branch_features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    Performs spine detection on a branch object or a branch mesh (optionally with a skeleton)</span>

<span class="sd">    Purpose Detailed</span>
<span class="sd">    -----------------------</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) Generates spine objects</span>
<span class="sd">    2) Calculate spine attributes for each spine object</span>
<span class="sd">    3) Apply bare minimum spine attribute filtering (filter_spine_objs_by_size_bare_minimum)</span>

<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    Analysis Roadmap</span>
<span class="sd">    ----------------</span>
<span class="sd">    spu.spine_objs_bare_minimum_filt_with_attr_from_branch_obj</span>
<span class="sd">        spu.spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_branch_obj</span>
<span class="sd">        </span>
<span class="sd">            spu.get_spine_meshes_unfiltered_from_mesh</span>
<span class="sd">                spu.get_spine_meshes_unfiltered_from_mesh</span>
<span class="sd">                    spu.split_mesh_into_spines_shaft:</span>
<span class="sd">                        tu.mesh_segmentation</span>
<span class="sd">                            VISUALIZATION: visualization that enough chopped up</span>
<span class="sd">                            PARAMETER CHANGE:</span>
<span class="sd">                                smoothness_threshold</span>
<span class="sd">                                clusters_threshold</span>

<span class="sd">                        spu.restrict_meshes_to_shaft_meshes_without_coordinates</span>
<span class="sd">                            VISUALIZATION: look at initial shaft seaparation (c)</span>
<span class="sd">                            PARAMETER CHANGE:</span>
<span class="sd">                                shaft_close_hole_area_top_2_mean_max</span>
<span class="sd">                                shaft_mesh_volume_max</span>
<span class="sd">                                shaft_mesh_n_faces_min</span>

<span class="sd">                VISUALIZATION: individual spines prior to individual spine filtering</span>

<span class="sd">            VISUALIZATION: spines after filtering (or each step after filtering)</span>
<span class="sd">            PARAMETER CHANGE:</span>
<span class="sd">                # -- border filtering</span>
<span class="sd">                filter_out_border_spines</span>
<span class="sd">                border_percentage_threshold</span>
<span class="sd">                # -- skeleton filtering</span>
<span class="sd">                skeleton_endpoint_nullification</span>
<span class="sd">                skeleton_endpoint_nullification_distance</span>
<span class="sd">                # -- soma filtering</span>
<span class="sd">                soma_vertex_nullification: bool</span>


<span class="sd">        filter_spine_objs_by_size_bare_minimum</span>
<span class="sd">            VISUALIZATION: spines before and after substitution</span>
<span class="sd">            PARAMETER CHANGE:                </span>
<span class="sd">                spine_n_face_threshold_bare_min</span>
<span class="sd">                spine_sk_length_threshold_bare_min</span>
<span class="sd">                filter_by_volume_threshold_bare_min</span>
<span class="sd">                bbox_oriented_side_max_min_bare_min</span>
<span class="sd">                sdf_mean_min_bare_min</span>
<span class="sd">                spine_volume_to_spine_area_min_bare_min</span>
<span class="sd">                </span>
<span class="sd">        spu.calculate_spine_attributes_for_list</span>
<span class="sd">            spu.calculate_spine_attributes:</span>
<span class="sd">                spu.calculate_head_neck:</span>
<span class="sd">                    VISUALIZATION: spine head/neck subdivision</span>
<span class="sd">                    PARAMETER CHANGE:</span>
<span class="sd">                        head_smoothness</span>
<span class="sd">                        head_ray_trace_min</span>
<span class="sd">                        head_face_min</span>
<span class="sd">                        only_allow_one_connected_component_neck</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">branch_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span>
    
    <span class="k">if</span> <span class="n">soma_kdtree_on_limb</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">soma_verts_on_limb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_kdtree_on_limb</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_verts_on_limb</span><span class="p">)</span>
    <span class="n">sp_objs</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_objs_with_border_sk_endpoint_and_soma_filter_from_scratch_on_branch_obj</span><span class="p">(</span>
        <span class="n">branch_obj</span><span class="o">=</span><span class="n">branch_obj</span><span class="p">,</span>
        <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">soma_kdtree_on_limb</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_unfiltered_spines</span><span class="p">,</span>
        <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">skeleton</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="c1">#raise Exception(&quot;&quot;)</span>

    <span class="n">sp_objs</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_attributes_for_list</span><span class="p">(</span>
        <span class="n">sp_objs</span><span class="p">,</span>
        <span class="n">calculate_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before filtering len(sp_objs) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_objs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#filters the spine objects</span>
    <span class="n">sp_objs_filt</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">filter_spine_objs_by_size_bare_minimum</span><span class="p">(</span><span class="n">sp_objs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER filtering len(sp_objs_filt) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_objs_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#calculates the center and closest face idx</span>
    <span class="n">sp_objs_filt</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_attributes_for_list</span><span class="p">(</span>
        <span class="n">sp_objs_filt</span><span class="p">,</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="p">,</span>
        <span class="n">calculate_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">calculate_head_neck</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose_time</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">soma_center</span><span class="o">=</span><span class="n">soma_center</span><span class="p">,</span>
        <span class="n">upstream_skeletal_length</span><span class="o">=</span><span class="n">upstream_skeletal_length</span><span class="p">,</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_filtered_spines</span><span class="p">:</span>
        <span class="n">spu</span><span class="o">.</span><span class="n">plot_spines_objs_with_head_neck_and_coordinates</span><span class="p">(</span>
            <span class="n">sp_objs_filt</span><span class="p">,</span>
            <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="p">,</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="p">)</span>

        
    <span class="k">return</span> <span class="n">sp_objs_filt</span></div>

<div class="viewcode-block" id="spine_objs_near_endpoints"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_near_endpoints">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_near_endpoints</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="mi">4_000</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">query_spine_objs</span><span class="p">(</span>
        <span class="n">output_spine_objs</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;(endpoint_dist_0 &lt; </span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">) or (endpoint_dist_1 &lt; </span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="id_from_compartment_index"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.id_from_compartment_index">[docs]</a><span class="k">def</span> <span class="nf">id_from_compartment_index</span><span class="p">(</span>
    <span class="n">compartment</span><span class="p">,</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;shaft&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">3</span>
    <span class="k">elif</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;no_head&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;neck&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">compartment</span> <span class="o">==</span> <span class="s2">&quot;head&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="compartment_index_from_id"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.compartment_index_from_id">[docs]</a><span class="k">def</span> <span class="nf">compartment_index_from_id</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;shaft&quot;</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;no_head&quot;</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;neck&quot;</span><span class="p">,</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="nb">id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="compartment_idx_for_mesh_face_idx_of_spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.compartment_idx_for_mesh_face_idx_of_spine">[docs]</a><span class="k">def</span> <span class="nf">compartment_idx_for_mesh_face_idx_of_spine</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Create a face map for that spines mesh_face_idx</span>
<span class="sd">    from the head,neck, and no_label </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    spine_obj = output_spine_objs[5]</span>
<span class="sd">    spu.plot_head_neck(spine_obj)</span>
<span class="sd">    tu.split_mesh_into_face_groups(</span>
<span class="sd">        spine_obj.mesh,</span>
<span class="sd">        spu.compartment_idx_for_mesh_face_idx_of_spine(spine_obj),</span>
<span class="sd">        plot=True,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">empty_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">n_heads</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">empty_array</span> <span class="o">*</span> <span class="n">id_from_compartment_index</span><span class="p">(</span><span class="s2">&quot;no_head&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">empty_array</span> <span class="o">*</span> <span class="n">id_from_compartment_index</span><span class="p">(</span><span class="s2">&quot;neck&quot;</span><span class="p">)</span>
        <span class="n">curr_idx</span><span class="p">[</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">head_face_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh_splits_face_idx</span>
        <span class="k">return</span> <span class="n">curr_idx</span></div>
    
<div class="viewcode-block" id="face_idx_map_from_spine_objs"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.face_idx_map_from_spine_objs">[docs]</a><span class="k">def</span> <span class="nf">face_idx_map_from_spine_objs</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">branch_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="n">no_spine_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: from a branch</span>
<span class="sd">    mesh and spine objs on that branch mesh</span>
<span class="sd">    create an array (N,2) that maps every face to the shaft</span>
<span class="sd">    or a spine index and the compartment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>


    <span class="n">face_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">no_spine_index</span>
    <span class="n">face_map</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">id_from_compartment_index</span><span class="p">(</span><span class="s2">&quot;shaft&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">):</span>
        <span class="n">face_map</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">face_map</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">compartment_idx_for_mesh_face_idx_of_spine</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">face_map</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">face_map</span></div>

<div class="viewcode-block" id="plot_spine_objs_and_syn_from_syn_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_objs_and_syn_from_syn_df">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_objs_and_syn_from_syn_df</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">syn_df</span><span class="p">,</span>
    <span class="n">spine_idxs_to_plot</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">spine_idxs_to_plot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_idxs</span> <span class="o">=</span> <span class="n">spine_idxs_to_plot</span>
    <span class="n">spine_objs_restr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output_spine_objs</span><span class="p">)[</span><span class="n">spine_idxs</span><span class="p">]</span>
    <span class="n">syn_df_restr</span> <span class="o">=</span> <span class="n">syn_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_id in </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">spine_idxs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">syn_df_restr</span><span class="p">[[</span><span class="s2">&quot;volume&quot;</span><span class="p">,</span><span class="s2">&quot;spine_id&quot;</span><span class="p">,</span><span class="s2">&quot;spine_compartment&quot;</span><span class="p">]])</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_objs_restr</span><span class="p">],</span>
        <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">syu</span><span class="o">.</span><span class="n">synapse_coordinates_from_synapse_df</span><span class="p">(</span><span class="n">syn_df_restr</span><span class="p">)]</span>
    <span class="p">)</span></div>
    

<div class="viewcode-block" id="synapse_df_with_spine_match"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.synapse_df_with_spine_match">[docs]</a><span class="k">def</span> <span class="nf">synapse_df_with_spine_match</span><span class="p">(</span>
    <span class="n">branch_obj</span><span class="p">,</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">plot_face_idx_map</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">attributes_to_append</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;volume&quot;</span><span class="p">,</span>
    <span class="s2">&quot;width_ray_80_perc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;area&quot;</span>
    <span class="p">),</span>

    <span class="n">attribute_rename_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="s2">&quot;spine_volume&quot;</span>
    <span class="p">),</span>
    <span class="n">spine_id_column</span> <span class="o">=</span> <span class="s2">&quot;spine_id&quot;</span><span class="p">,</span>
    <span class="n">spine_compartment_column</span> <span class="o">=</span><span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1">#filter_away_non_spine_synapses = True,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Create a dataframe that maps all</span>
<span class="sd">    syanpses on the branch to the spine id and</span>
<span class="sd">    size of the spine id</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Creae an array the same size as # of faces</span>
<span class="sd">    of branch where the values are (spine_id, comp #)</span>
<span class="sd">    2) Use the synapse objects of branch</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">face_idx_map</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">face_idx_map_from_spine_objs</span><span class="p">(</span>
        <span class="n">spine_objs</span> <span class="o">=</span> <span class="n">spine_objs</span><span class="p">,</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_face_idx_map</span><span class="p">,</span>
    <span class="p">)</span>


    <span class="n">syn_df</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_df</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># mapping synapses to spines</span>
        <span class="n">syn_df</span><span class="p">[[</span><span class="n">spine_id_column</span><span class="p">,</span><span class="n">spine_compartment_column</span><span class="p">]]</span> <span class="o">=</span> <span class="n">face_idx_map</span><span class="p">[</span>
            <span class="n">syn_df</span><span class="p">[</span><span class="s2">&quot;closest_branch_face_idx&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

        <span class="n">syn_df</span> <span class="o">=</span> <span class="n">syn_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">spine_compartment_column</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">spu</span><span class="o">.</span><span class="n">id_from_compartment_index</span><span class="p">(</span><span class="s1">&#39;shaft&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># appending features to spines</span>
            <span class="k">if</span> <span class="n">attributes_to_append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">attributes_to_append</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">attributes_to_append</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes_to_append</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Working on adding </span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2"> to synapse df&quot;</span><span class="p">)</span>
                    <span class="n">syn_df</span><span class="p">[</span><span class="n">attribute_rename_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">att</span><span class="p">,</span><span class="n">att</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">spu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">_from_compartment&quot;</span><span class="p">)(</span>
                        <span class="n">spine_obj</span> <span class="o">=</span> <span class="n">spine_objs</span><span class="p">[</span><span class="n">sp_idx</span><span class="p">],</span>
                        <span class="n">compartment</span> <span class="o">=</span> <span class="n">comp</span><span class="p">,</span>
                    <span class="p">)</span> <span class="k">for</span> <span class="n">sp_idx</span><span class="p">,</span><span class="n">comp</span> <span class="ow">in</span> <span class="n">syn_df</span><span class="p">[[</span><span class="n">spine_id_column</span><span class="p">,</span><span class="n">spine_compartment_column</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span>


            

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of synases = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">syn_df</span></div>

<div class="viewcode-block" id="example_syn_df_spine_correlations"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.example_syn_df_spine_correlations">[docs]</a><span class="k">def</span> <span class="nf">example_syn_df_spine_correlations</span><span class="p">(</span><span class="n">syn_df</span><span class="p">):</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">syn_df</span><span class="p">,</span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;volume&quot;</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">syn_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_compartment &gt;= 0&quot;</span><span class="p">),</span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;volume&quot;</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;spine_volume&quot;</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">syn_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_compartment &gt;= 0&quot;</span><span class="p">),</span><span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;volume&quot;</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;width_ray_80_perc&quot;</span><span class="p">)</span></div>
    


                        
<div class="viewcode-block" id="spine_objs_and_synapse_df_computed_from_branch_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_and_synapse_df_computed_from_branch_idx">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_and_synapse_df_computed_from_branch_idx</span><span class="p">(</span>
    <span class="n">branch_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_verts_on_limb</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_kdtree_on_limb</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_branch_mesh_before_spine_detection</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#spine detection phase:</span>
    <span class="n">plot_unfiltered_spines</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_filtered_spines</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#branch features</span>
    <span class="n">branch_features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_computation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: from a branch object</span>
<span class="sd">    will generate spine objects and the</span>
<span class="sd">    synapse df of synaspes onto spines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose_computation</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_off_tqdm</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">limb_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">branch_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_skeletal_length</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">total_upstream_skeletal_length</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot_branch_mesh_before_spine_detection</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">soma_kdtree_on_limb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">soma_verts_on_limb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">soma_verts_on_limb</span> <span class="o">=</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span>
        <span class="n">soma_kdtree_on_limb</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_verts_on_limb</span><span class="p">)</span>

    <span class="c1">#raise Exception(&quot;&quot;)</span>
    <span class="n">output_spine_objs</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_objs_bare_minimum_filt_with_attr_from_branch_obj</span><span class="p">(</span>
        <span class="n">branch_obj</span><span class="p">,</span>
        <span class="n">soma_kdtree_on_limb</span> <span class="o">=</span><span class="n">soma_kdtree_on_limb</span><span class="p">,</span>
        <span class="n">plot_unfiltered_spines</span> <span class="o">=</span> <span class="n">plot_unfiltered_spines</span><span class="p">,</span>
        <span class="n">plot_filtered_spines</span> <span class="o">=</span> <span class="n">plot_filtered_spines</span><span class="p">,</span>
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">soma_verts_on_limb</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">upstream_skeletal_length</span><span class="o">=</span><span class="n">upstream_skeletal_length</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose_computation</span><span class="p">,</span>
        <span class="n">branch_features</span><span class="o">=</span><span class="n">branch_features</span><span class="p">,</span>
    <span class="p">)</span>


    <span class="n">syn_df</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">synapse_df_with_spine_match</span><span class="p">(</span>
        <span class="n">branch_obj</span><span class="p">,</span>
        <span class="n">spine_objs</span> <span class="o">=</span> <span class="n">output_spine_objs</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose_computation</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of output spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">output_spine_objs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of spine_synapses = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">verbose_computation</span><span class="p">:</span>
        <span class="n">tqu</span><span class="o">.</span><span class="n">turn_on_tqdm</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">output_spine_objs</span><span class="p">,</span><span class="n">syn_df</span></div>

<div class="viewcode-block" id="spine_id_from_limb_branch_spine_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_id_from_limb_branch_spine_idx">[docs]</a><span class="k">def</span> <span class="nf">spine_id_from_limb_branch_spine_idx</span><span class="p">(</span>
    <span class="n">limb_idx</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">spine_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Defines the method used for creating the spine id</span>
<span class="sd">    [limb,2][branches,4][spine,4]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_idx</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">spine_idx</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="spine_id_range_from_limb_branch_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_id_range_from_limb_branch_idx">[docs]</a><span class="k">def</span> <span class="nf">spine_id_range_from_limb_branch_idx</span><span class="p">(</span>
    <span class="n">limb_idx</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to come up with a spine id range </span>
<span class="sd">    given a limb and branch</span>

<span class="sd">    Pseudocode: </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spine_id_min</span> <span class="o">=</span> <span class="n">limb_idx</span><span class="o">*</span><span class="mi">10_000</span><span class="o">*</span><span class="mi">10_000</span> <span class="o">+</span> <span class="n">branch_idx</span><span class="o">*</span><span class="mi">10_000</span>
    <span class="n">spine_id_max</span> <span class="o">=</span> <span class="n">spine_id_min</span> <span class="o">+</span> <span class="mi">9999</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_id_min= </span><span class="si">{</span><span class="n">spine_id_min</span><span class="si">}</span><span class="s2">, spine_id_max = </span><span class="si">{</span><span class="n">spine_id_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spine_id_min</span><span class="o">=</span><span class="n">spine_id_min</span><span class="p">,</span><span class="n">spine_id_max</span> <span class="o">=</span> <span class="n">spine_id_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spine_id_min</span><span class="p">,</span><span class="n">spine_id_max</span></div>

<div class="viewcode-block" id="spine_id_add_from_limb_branch_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_id_add_from_limb_branch_idx">[docs]</a><span class="k">def</span> <span class="nf">spine_id_add_from_limb_branch_idx</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">spine_id_from_limb_branch_spine_idx</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="spine_objs_and_synapse_df_computed_from_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_and_synapse_df_computed_from_neuron_obj">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_and_synapse_df_computed_from_neuron_obj</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_branch_dict_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>


    <span class="c1"># -- cycling through all of the branches to compute the spines</span>
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>

    <span class="n">global_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">soma_center</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>

    <span class="n">limb_branch_spine_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx_on_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>

<span class="c1">#         if soma_vertex_nullification:</span>
<span class="c1">#             soma_verts = np.concatenate([neuron_obj[f&quot;S{k}&quot;].mesh.vertices for k in curr_limb.touching_somas()])</span>
<span class="c1">#             soma_kdtree = KDTree(soma_verts)</span>
<span class="c1">#         else:</span>
<span class="c1">#             soma_kdtree = None</span>

        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]:</span>

            <span class="k">if</span> <span class="n">limb_branch_dict_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict_exclude</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_branch_dict_exclude</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because in limb_branch exclude&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>


    <span class="c1">#         if verbose:</span>
    <span class="c1">#             print(f&quot;Working on limb {limb_idx} branch {branch_idx}&quot;)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   ---- branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">spine_objs_computed</span><span class="p">,</span><span class="n">syn_df_computed</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_objs_and_synapse_df_computed_from_branch_idx</span><span class="p">(</span>
                <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">],</span>
                <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="n">additive_id</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_id_add_from_limb_branch_idx</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spine_objs_computed</span><span class="p">):</span>
                <span class="n">s</span><span class="o">.</span><span class="n">spine_id</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">additive_id</span>
                <span class="n">s</span><span class="o">.</span><span class="n">limb_idx</span> <span class="o">=</span> <span class="n">limb_idx</span>
                <span class="n">s</span><span class="o">.</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_df_computed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">syn_df_computed</span><span class="p">[</span><span class="s2">&quot;spine_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">syn_df_computed</span><span class="p">[</span><span class="s2">&quot;spine_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">additive_id</span>

            <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_spine_info</span><span class="p">:</span>
                <span class="n">limb_branch_spine_info</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">limb_branch_spine_info</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">spine_objs</span> <span class="o">=</span> <span class="n">spine_objs_computed</span><span class="p">,</span><span class="n">syn_df</span> <span class="o">=</span> <span class="n">syn_df_computed</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       -&gt; time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for all spine computation = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">limb_branch_spine_info</span></div>

<span class="n">spine_compartments</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;spine_head&quot;</span><span class="p">,</span><span class="s2">&quot;spine_neck&quot;</span><span class="p">,</span><span class="s2">&quot;spine_no_head&quot;</span><span class="p">,</span><span class="s2">&quot;shaft&quot;</span><span class="p">)</span>
<span class="n">spine_compartments_no_prefix</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;spine_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_compartments</span><span class="p">]</span>
<div class="viewcode-block" id="plot_spine_face_idx_dict"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_face_idx_dict">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_face_idx_dict</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">spine_head_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_neck_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_no_head_face_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shaft_face_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">head_color</span> <span class="o">=</span> <span class="n">head_color_default</span><span class="p">,</span>
    <span class="n">neck_color</span> <span class="o">=</span> <span class="n">neck_color_default</span><span class="p">,</span>
    <span class="n">no_head_color</span> <span class="o">=</span> <span class="n">no_head_color_default</span><span class="p">,</span>
    <span class="n">shaft_color</span> <span class="o">=</span> <span class="n">shaft_color_default</span><span class="p">,</span>
    <span class="n">mesh_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">synapse_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">show_at_end</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">mesh_to_plot</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compartment_meshes_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">scatters</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">mesh_to_plot</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_to_plot</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">spine_compartments</span><span class="p">:</span>
        <span class="n">curr_val</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="si">}</span><span class="s2">_face_idx&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">curr_val</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">curr_color</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;spine_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_color&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">curr_color</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">meshes_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_color</span><span class="p">)</span>
            
    <span class="c1">#return meshes</span>
    <span class="n">curr_show_at_end</span> <span class="o">=</span> <span class="n">show_at_end</span>
    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">curr_show_at_end</span> <span class="o">=</span> <span class="n">synapse_dict</span> <span class="ow">is</span> <span class="kc">None</span>
        
    <span class="k">if</span> <span class="n">compartment_meshes_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">total_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span>
        <span class="n">comp_meshes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comp_colors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span><span class="n">comp_mesh</span> <span class="ow">in</span> <span class="n">compartment_meshes_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_comp_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">comp_mesh</span><span class="p">,</span><span class="n">total_mesh</span><span class="p">,</span><span class="n">exact_match</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">comp_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_comp_mesh</span><span class="p">)</span>
            <span class="n">comp_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">apu</span><span class="o">.</span><span class="n">colors_from_compartments</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
            
        <span class="n">meshes</span> <span class="o">+=</span> <span class="n">comp_meshes</span>
        <span class="n">meshes_colors</span> <span class="o">+=</span> <span class="n">comp_colors</span>
        
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">mesh_to_plot</span><span class="p">,</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
        <span class="n">meshes_colors</span> <span class="o">=</span> <span class="n">meshes_colors</span><span class="p">,</span>
        <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
        <span class="n">show_at_end</span> <span class="o">=</span> <span class="n">curr_show_at_end</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
        <span class="n">scatters_colors</span> <span class="o">=</span> <span class="n">scatters_colors</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">synapse_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plot_spine_synapse_coords_dict</span><span class="p">(</span>
        <span class="n">synapse_dict</span> <span class="o">=</span> <span class="n">synapse_dict</span><span class="p">,</span>
        <span class="n">append_figure</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">show_at_end</span><span class="o">=</span><span class="n">show_at_end</span><span class="p">,</span>
        <span class="p">)</span></div>
    

<div class="viewcode-block" id="plot_spine_synapse_coords_dict"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_synapse_coords_dict">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_synapse_coords_dict</span><span class="p">(</span>
    <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">synapse_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_head_synapse_coords</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_neck_synapse_coords</span><span class="o">=</span>  <span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_no_head_synapse_coords</span><span class="o">=</span>  <span class="kc">None</span><span class="p">,</span>
    <span class="n">shaft_synapse_coords</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">head_color</span> <span class="o">=</span> <span class="n">head_color_default</span><span class="p">,</span>
    <span class="n">neck_color</span> <span class="o">=</span> <span class="n">neck_color_default</span><span class="p">,</span>
    <span class="n">no_head_color</span> <span class="o">=</span> <span class="n">no_head_color_default</span><span class="p">,</span>
    <span class="n">shaft_color</span> <span class="o">=</span> <span class="n">shaft_color_default</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">scatter_size</span> <span class="o">=</span> <span class="mf">0.08</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">synapse_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">synapse_dict</span><span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
    <span class="n">default_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="n">scatters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">spine_compartments</span><span class="p">:</span>
        <span class="n">curr_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="si">}</span><span class="s2">_synapse_coords&quot;</span>
        <span class="n">curr_val</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">curr_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_val</span> <span class="o">=</span> <span class="n">synapse_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">curr_name</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">curr_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scatters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_val</span><span class="p">)</span>
            <span class="n">curr_color</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;spine_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">_color&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">curr_color</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">scatters_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_color</span><span class="p">)</span>
                
    <span class="c1">#return meshes</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">scatters</span> <span class="o">=</span> <span class="n">scatters</span><span class="p">,</span>
        <span class="n">scatters_colors</span> <span class="o">=</span> <span class="n">scatters_colors</span><span class="p">,</span>
        <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="spine_compartments_face_idx_for_neuron_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_compartments_face_idx_for_neuron_mesh">[docs]</a><span class="k">def</span> <span class="nf">spine_compartments_face_idx_for_neuron_mesh</span><span class="p">(</span>
    <span class="n">limb_branch_spine_dict</span><span class="p">,</span>
    <span class="n">limb_branch_face_dict</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;neck&quot;</span><span class="p">,</span><span class="s2">&quot;no_head&quot;</span><span class="p">),</span>
    <span class="n">compute_shaft_face_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">n_faces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">add_n_faces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compile the face_idx of a compartment from</span>
<span class="sd">    spine objs knowing the branch_face_idx corresponding</span>
<span class="sd">    to the larger mesh</span>

<span class="sd">    Example: </span>
<span class="sd">    spine_compartment_masks = spu.spine_compartments_face_idx_for_neuron_mesh(</span>
<span class="sd">        limb_branch_face_dict=limb_branch_face_dict,</span>
<span class="sd">        limb_branch_spine_dict = limb_branch_spine_info_ret,</span>
<span class="sd">        mesh = decimated_mesh,</span>
<span class="sd">        plot = True,</span>
<span class="sd">        mesh_alpha = 1</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">comp_face_idx_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_info</span> <span class="ow">in</span> <span class="n">limb_branch_spine_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b_idx</span><span class="p">,</span><span class="n">b_spine_dict</span> <span class="ow">in</span> <span class="n">branch_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">branch_face_idx</span> <span class="o">=</span> <span class="n">limb_branch_face_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">b_idx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
                <span class="n">branch_comp_face_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_face_idx&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)]</span>
                                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_face_idx&quot;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[]</span>
                                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">b_spine_dict</span><span class="p">[</span><span class="s2">&quot;spine_objs&quot;</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_comp_face_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">branch_comp_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">branch_comp_face_idx</span><span class="p">)</span>

                <span class="n">branch_comp_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_comp_face_idx</span><span class="p">)</span>
                <span class="n">comp_face_idx_dict</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_face_idx</span><span class="p">[</span><span class="n">branch_comp_face_idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)])</span>

    <span class="n">comp_face_idx_dict_final</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
        <span class="n">curr_arrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">comp_face_idx_dict</span><span class="p">[</span><span class="n">comp</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_arrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">curr_arrays</span><span class="p">)</span>
        <span class="n">comp_face_idx_dict_final</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spine_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_arrays</span>

    <span class="k">if</span> <span class="n">compute_shaft_face_idx</span> <span class="ow">and</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">comp_face_idx_dict_final</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">comp_face_idx_dict_final</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;shaft_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_faces</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">add_n_faces</span><span class="p">:</span>
        <span class="n">comp_face_idx_dict_final</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_n_faces&quot;</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">comp_face_idx_dict_final</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_spine_face_idx_dict</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="o">**</span><span class="n">comp_face_idx_dict_final</span><span class="p">,</span><span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">comp_face_idx_dict_final</span></div>

<div class="viewcode-block" id="spine_objs_and_synapse_df_total_from_limb_branch_spine_dict"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_objs_and_synapse_df_total_from_limb_branch_spine_dict">[docs]</a><span class="k">def</span> <span class="nf">spine_objs_and_synapse_df_total_from_limb_branch_spine_dict</span><span class="p">(</span>
    <span class="n">limb_branch_spine_dict</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To extract all spine objects and </span>
<span class="sd">    synapse dfs and concatenate from</span>
<span class="sd">    a limb_branch_spine_dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spine_objs_total</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">syn_df_total</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_data</span> <span class="ow">in</span> <span class="n">limb_branch_spine_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b_idx</span><span class="p">,</span><span class="n">spine_data</span> <span class="ow">in</span> <span class="n">branch_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">spine_objs</span> <span class="o">=</span> <span class="n">spine_data</span><span class="p">[</span><span class="s2">&quot;spine_objs&quot;</span><span class="p">]</span>
            <span class="n">syn_df</span> <span class="o">=</span> <span class="n">spine_data</span><span class="p">[</span><span class="s2">&quot;syn_df&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">syn_df_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span>
            <span class="n">spine_objs_total</span> <span class="o">+=</span> <span class="n">spine_objs</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_df_total</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">syn_df_total</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">syn_df_total</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syn_df_total</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">empty_df</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total # of spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_objs_total</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total # of synapses on spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">syn_df_total</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">spine_objs_total</span><span class="p">,</span><span class="n">syn_df_total</span></div>

<div class="viewcode-block" id="features_to_export_for_db"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.features_to_export_for_db">[docs]</a><span class="k">def</span> <span class="nf">features_to_export_for_db</span><span class="p">():</span>
    <span class="n">total_features</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;spine_id&quot;</span><span class="p">,</span>

        <span class="c1">#coordinates</span>
        <span class="s2">&quot;base_coordinate_x_nm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;base_coordinate_y_nm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;base_coordinate_z_nm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mesh_center_x_nm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mesh_center_y_nm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mesh_center_z_nm&quot;</span><span class="p">,</span>
        
        <span class="c1">#head features</span>
        <span class="s2">&quot;n_heads&quot;</span><span class="p">,</span>
        <span class="s2">&quot;shaft_border_area&quot;</span><span class="p">,</span>
    
        
        <span class="c1">#distances from things</span>
        <span class="s2">&quot;downstream_dist&quot;</span><span class="p">,</span>
        <span class="s2">&quot;upstream_dist&quot;</span><span class="p">,</span>
        <span class="s2">&quot;soma_distance_euclidean&quot;</span><span class="p">,</span>
        <span class="s2">&quot;soma_distance&quot;</span><span class="p">,</span>
        
        <span class="c1">#branch features</span>
        <span class="s2">&quot;compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;branch_width_overall&quot;</span><span class="p">,</span>
        <span class="s2">&quot;branch_skeletal_length&quot;</span><span class="p">,</span>
        <span class="s2">&quot;branch_width_at_base&quot;</span><span class="p">,</span>
        
    <span class="p">]</span>

    <span class="c1">#spine size features (and repeat for head/neck)</span>
    <span class="n">size_features</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;area&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_faces&quot;</span><span class="p">,</span>
        <span class="s2">&quot;volume&quot;</span><span class="p">,</span>
        <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
        <span class="s2">&quot;width_ray&quot;</span><span class="p">,</span>
        <span class="s2">&quot;width_ray_80_perc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_oriented_side_max&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_oriented_side_middle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bbox_oriented_side_min&quot;</span><span class="p">,</span>
<span class="c1">#         &quot;bbox_min_x_nm&quot;,</span>
<span class="c1">#         &quot;bbox_min_y_nm&quot;,</span>
<span class="c1">#         &quot;bbox_min_z_nm&quot;,</span>
<span class="c1">#         &quot;bbox_max_x_nm&quot;,</span>
<span class="c1">#         &quot;bbox_max_y_nm&quot;,</span>
<span class="c1">#         &quot;bbox_max_z_nm&quot;,</span>
    <span class="p">]</span>
    
    <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;spine&quot;</span><span class="p">,</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;neck&quot;</span><span class="p">]:</span>
        <span class="n">total_features</span><span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">size_features</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">total_features</span></div>

<div class="viewcode-block" id="spine_df_for_db_from_spine_objs"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_df_for_db_from_spine_objs">[docs]</a><span class="k">def</span> <span class="nf">spine_df_for_db_from_spine_objs</span><span class="p">(</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_loop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>

    <span class="k">return</span> <span class="n">spu</span><span class="o">.</span><span class="n">df_from_spine_objs</span><span class="p">(</span>
        <span class="n">spine_objs</span><span class="p">,</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="n">features_to_export_for_db</span><span class="p">(),</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">verbose_loop</span> <span class="o">=</span> <span class="n">verbose_loop</span><span class="p">,</span>
    <span class="p">)</span></div>
<div class="viewcode-block" id="example_plot_coordinates_from_spine_df_idx"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.example_plot_coordinates_from_spine_df_idx">[docs]</a><span class="k">def</span> <span class="nf">example_plot_coordinates_from_spine_df_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">spine_objs</span><span class="p">):</span>
    <span class="n">spine_obj</span> <span class="o">=</span> <span class="n">spine_objs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">head_mesh</span><span class="p">,</span><span class="n">spine_obj</span><span class="o">.</span><span class="n">neck_mesh</span><span class="p">],</span>
        <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">],</span>
        <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">spine_df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_bbox_min_</span><span class="si">{</span><span class="n">ax</span><span class="si">}</span><span class="s2">_nm&quot;</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
            <span class="n">spine_df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_bbox_max_</span><span class="si">{</span><span class="n">ax</span><span class="si">}</span><span class="s2">_nm&quot;</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()])</span>
                 <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;head&#39;</span><span class="p">,</span><span class="s1">&#39;neck&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">spine_df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">ax</span><span class="si">}</span><span class="s2">_nm&quot;</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">]]]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;base_coordinate&quot;</span><span class="p">,</span><span class="s2">&quot;mesh_center&quot;</span><span class="p">]],</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">,</span><span class="s2">&quot;black&quot;</span><span class="p">,</span><span class="s2">&quot;purple&quot;</span><span class="p">],</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="examle_plot_spines_from_spine_df_query"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.examle_plot_spines_from_spine_df_query">[docs]</a><span class="k">def</span> <span class="nf">examle_plot_spines_from_spine_df_query</span><span class="p">(</span>
    <span class="n">spine_df</span><span class="p">,</span>
    <span class="n">spine_objs</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">spine_df_filt</span> <span class="o">=</span> <span class="n">spine_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(neck_skeletal_length &gt; 6000) and (n_heads &lt; 2)&quot;</span><span class="p">)</span>

    <span class="n">spu</span><span class="o">.</span><span class="n">plot_spine_objs</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spine_objs</span><span class="p">)[</span><span class="n">spine_df_filt</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)],</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">decimated_mesh</span><span class="p">,</span>
        <span class="n">spine_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>
    
<span class="c1"># ---- function ofr extracting new spine_objs from neuron_obj ---</span>
<div class="viewcode-block" id="limb_branch_dict_to_search_for_spines"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.limb_branch_dict_to_search_for_spines">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_to_search_for_spines</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">query</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">query_global</span>
    
    <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
        <span class="s2">&quot;n_faces_branch&quot;</span>
    <span class="p">]</span>

    
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
           <span class="n">functions_list</span><span class="o">=</span><span class="n">functions_list</span><span class="p">,</span>
           <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
            <span class="n">plot_limb_branch_dict</span><span class="o">=</span><span class="n">plot</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict_spine_candidates = </span><span class="se">\n</span><span class="si">{</span><span class="n">limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_branch_dict</span></div>


<div class="viewcode-block" id="spine_and_syn_df_computed_from_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_and_syn_df_computed_from_neuron_obj">[docs]</a><span class="k">def</span> <span class="nf">spine_and_syn_df_computed_from_neuron_obj</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">restrict_to_proofread_filtered_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">decimated_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">proofread_faces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_spine_compartmenets_face_idxs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">add_neuron_compartments</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compartment_faces_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the spine df and synase</span>
<span class="sd">    df corresponding to these spines from segment id</span>
<span class="sd">    and split index,</span>

<span class="sd">    dataframes can then be written to datajoint</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Download the neuron object</span>
<span class="sd">    2) Get the typical limb branch to search </span>
<span class="sd">    3) Get the limb branch dict for faces after proofreading</span>
<span class="sd">    and the mesh face idx for the branches</span>
<span class="sd">    4) Generate the new spine objects and corresponding synapse df</span>
<span class="sd">    5) Generate the spine statistics dataframe from spine objects</span>
<span class="sd">    6) If the spine_face_idx is requested:</span>
<span class="sd">    - generate the spine face idxs from the limb_branch_face_dict</span>
<span class="sd">    and spine objs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">limb_branch_dict_to_search_for_spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="c1"># 3) Get the limb branch dict for faces after proofreading</span>
    <span class="c1"># and the mesh face idx for the branches</span>
    <span class="k">if</span> <span class="n">restrict_to_proofread_filtered_branches</span> <span class="ow">or</span> <span class="n">return_spine_compartmenets_face_idxs</span><span class="p">:</span>
        <span class="n">limb_branch_face_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_face_idx_dict_from_neuron_obj_overlap_with_face_idx_on_reference_mesh</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">faces_idx</span> <span class="o">=</span> <span class="n">proofread_faces</span><span class="p">,</span>
            <span class="n">mesh_reference</span> <span class="o">=</span> <span class="n">decimated_mesh</span><span class="p">,</span>
            <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">curr_limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_face_dict</span>
        
        <span class="k">if</span> <span class="n">add_neuron_compartments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">compartment_faces_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;compartment_faces_dict is None and requested compartments&quot;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">apical_utils</span> <span class="k">as</span> <span class="n">apu</span>
            <span class="n">limb_branch_compartment_dict</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">limb_branch_compartment_dict_from_limb_branch_face_and_compartment_faces_dict</span><span class="p">(</span>
                <span class="n">limb_branch_face_dict</span><span class="p">,</span>
                <span class="n">compartment_faces_dict</span><span class="o">=</span><span class="n">compartment_faces_dict</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict</span>
        
    <span class="c1">#</span>

    <span class="c1">#4) Generate the new spine objects and corresponding synapse df</span>
    <span class="n">limb_branch_spine_info_ret</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_objs_and_synapse_df_computed_from_neuron_obj</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">limb_branch_dict</span><span class="o">=</span> <span class="n">curr_limb_branch_dict</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>

    <span class="p">)</span>
    
    <span class="c1">#adding the neuron compartment labels</span>
    <span class="k">if</span> <span class="n">add_neuron_compartments</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_info</span> <span class="ow">in</span> <span class="n">limb_branch_spine_info_ret</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">branch_idx</span><span class="p">,</span><span class="n">spines_syn</span> <span class="ow">in</span> <span class="n">branch_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">branch_spines</span> <span class="o">=</span> <span class="n">spines_syn</span><span class="p">[</span><span class="s2">&quot;spine_objs&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sp_obj</span> <span class="ow">in</span> <span class="n">branch_spines</span><span class="p">:</span>
                    <span class="n">sp_obj</span><span class="o">.</span><span class="n">compartment</span> <span class="o">=</span> <span class="n">limb_branch_compartment_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">]</span>

        
                            

    <span class="n">spine_objs_total</span><span class="p">,</span><span class="n">syn_df_total</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_objs_and_synapse_df_total_from_limb_branch_spine_dict</span><span class="p">(</span>
        <span class="n">limb_branch_spine_info_ret</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span>
    
    

    <span class="n">spine_df</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_df_for_db_from_spine_objs</span><span class="p">(</span>
        <span class="n">spine_objs_total</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">verbose_loop</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>


    <span class="k">if</span> <span class="n">return_spine_compartmenets_face_idxs</span><span class="p">:</span>
        <span class="n">spine_compartment_masks</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_compartments_face_idx_for_neuron_mesh</span><span class="p">(</span>
            <span class="n">limb_branch_face_dict</span><span class="o">=</span><span class="n">limb_branch_face_dict</span><span class="p">,</span>
            <span class="n">limb_branch_spine_dict</span> <span class="o">=</span> <span class="n">limb_branch_spine_info_ret</span><span class="p">,</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">decimated_mesh</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">return_value</span> <span class="o">=</span> <span class="n">spine_df</span><span class="p">,</span><span class="n">syn_df_total</span><span class="p">,</span><span class="n">spine_compartment_masks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">spine_df</span><span class="p">,</span><span class="n">syn_df_total</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for spine_obj and syn_df from neuron obj = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="plot_spine_coordinates_from_spine_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_coordinates_from_spine_df">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_coordinates_from_spine_df</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">spine_df</span><span class="p">,</span>
    <span class="n">coordinate_types</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;base_coordinate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mesh_center&quot;</span><span class="p">,</span>
        <span class="s2">&quot;head_bbox_max&quot;</span><span class="p">,</span>
        <span class="s2">&quot;head_bbox_min&quot;</span><span class="p">,</span>
        <span class="s2">&quot;neck_bbox_max&quot;</span><span class="p">,</span>
        <span class="s2">&quot;neck_bbox_min&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    scats = spu.plot_spine_coordinates_from_spine_df(</span>
<span class="sd">        mesh = neuron_obj.mesh,</span>
<span class="sd">        spine_df=spine_df,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">pu</span><span class="o">.</span><span class="n">coordinates_from_df</span><span class="p">(</span>
        <span class="n">spine_df</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">filter_away_nans</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> 
        <span class="n">coordinate_types</span>
    <span class="p">]</span>
    
    
    <span class="c1">#return scatters</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span>
            <span class="n">base_color_default</span><span class="p">,</span>
            <span class="n">center_color_default</span><span class="p">,</span>
            <span class="n">head_color_default</span><span class="p">,</span>
            <span class="n">head_color_default</span><span class="p">,</span>
            <span class="n">neck_color_default</span><span class="p">,</span>
            <span class="n">neck_color_default</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="example_plot_small_volume_spines_from_spine_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.example_plot_small_volume_spines_from_spine_df">[docs]</a><span class="k">def</span> <span class="nf">example_plot_small_volume_spines_from_spine_df</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">spine_df</span><span class="p">):</span>

    <span class="n">spine_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_volume &lt; </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">spine_df</span><span class="o">.</span><span class="n">spine_volume</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span><span class="mi">95</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">spine_volume</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="n">curr_df</span> <span class="o">=</span> <span class="n">spine_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_volume &lt; 10000000&quot;</span><span class="p">)</span>
    
    <span class="n">scats</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">plot_spine_coordinates_from_spine_df</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">spine_df</span><span class="o">=</span><span class="n">curr_df</span><span class="p">,</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="synapse_spine_match_df_filtering"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.synapse_spine_match_df_filtering">[docs]</a><span class="k">def</span> <span class="nf">synapse_spine_match_df_filtering</span><span class="p">(</span>
    <span class="n">syn_df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To map columns and </span>
<span class="sd">    filter away columns of synapse df</span>
<span class="sd">    for database write</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">syn_df</span>
    
    <span class="n">syn_df_renamed</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">map_column_with_dict_slow</span><span class="p">(</span>
        <span class="n">syn_df</span><span class="p">,</span>
        <span class="n">column</span> <span class="o">=</span> <span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span>
        <span class="n">dict_map</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="s2">&quot;shaft&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="s2">&quot;no_head&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="s1">&#39;neck&#39;</span><span class="p">},</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">in_place</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    
    <span class="n">syn_df_renamed</span> <span class="o">=</span> <span class="n">syn_df_renamed</span><span class="p">[[</span><span class="s2">&quot;syn_id&quot;</span><span class="p">,</span><span class="s2">&quot;spine_id&quot;</span><span class="p">,</span><span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span><span class="s2">&quot;spine_volume&quot;</span><span class="p">,</span><span class="s2">&quot;area&quot;</span><span class="p">,</span><span class="s2">&quot;width_ray_80_perc&quot;</span><span class="p">]]</span>
    <span class="n">syn_df_renamed</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">rename_columns</span><span class="p">(</span>
        <span class="n">syn_df_renamed</span><span class="p">,</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">syn_id</span> <span class="o">=</span> <span class="s2">&quot;synapse_id&quot;</span><span class="p">,</span>
             <span class="n">area</span> <span class="o">=</span> <span class="s2">&quot;spine_area&quot;</span><span class="p">,</span>
            <span class="n">width_ray_80_perc</span> <span class="o">=</span> <span class="s2">&quot;spine_width_ray_80_perc&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">syn_df_renamed</span></div>

<span class="n">area_divisor</span> <span class="o">=</span> <span class="mi">1_000_000</span>
<span class="n">scale_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1_000_000_000</span><span class="p">,</span>
    <span class="n">area</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1_000_000</span>
<span class="p">)</span>
<div class="viewcode-block" id="scale_stats_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.scale_stats_df">[docs]</a><span class="k">def</span> <span class="nf">scale_stats_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">scale_dict</span> <span class="o">=</span> <span class="n">scale_dict_default</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to scale certain columns</span>
<span class="sd">    of dataframe by divisors if have keyword</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">scale</span> <span class="ow">in</span> <span class="n">scale_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span>
                
                
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="filter_and_scale_spine_syn_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_and_scale_spine_syn_df">[docs]</a><span class="k">def</span> <span class="nf">filter_and_scale_spine_syn_df</span><span class="p">(</span><span class="n">spine_df</span><span class="p">,</span><span class="n">syn_df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To reduce the number of columns of the synapse table</span>
<span class="sd">    and to scale the area and volume values in both the synapse and spine table so in um^2 and um^3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">syn_df_filt</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">synapse_spine_match_df_filtering</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span>
    <span class="n">syn_df_scaled</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">scale_stats_df</span><span class="p">(</span><span class="n">syn_df_filt</span><span class="p">)</span>
    <span class="n">spine_df_scaled</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">scale_stats_df</span><span class="p">(</span><span class="n">spine_df</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spine_df_scaled</span><span class="p">,</span><span class="n">syn_df_scaled</span></div>

<div class="viewcode-block" id="spine_counts_from_spine_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_counts_from_spine_df">[docs]</a><span class="k">def</span> <span class="nf">spine_counts_from_spine_df</span><span class="p">(</span><span class="n">spine_df</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">n_spine_one_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">n_spine_no_head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">n_spine_multi_head</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">n_spine_one_head</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_heads == 1&quot;</span><span class="p">)),</span>
            <span class="n">n_spine_no_head</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_heads == 0&quot;</span><span class="p">)),</span>
            <span class="n">n_spine_multi_head</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_heads &gt; 1&quot;</span><span class="p">)),</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="spine_features_to_print"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_features_to_print">[docs]</a><span class="k">def</span> <span class="nf">spine_features_to_print</span><span class="p">():</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_heads&quot;</span><span class="p">,</span><span class="s2">&quot;shaft_border_area&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;spine&quot;</span><span class="p">,</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;neck&quot;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">,</span><span class="s2">&quot;n_faces&quot;</span><span class="p">,</span><span class="s2">&quot;volume&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span><span class="s2">&quot;width_ray&quot;</span><span class="p">,</span><span class="s2">&quot;width_ray_80_perc&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;bbox_oriented_side_max&quot;</span><span class="p">,</span><span class="s2">&quot;bbox_oriented_side_middle&quot;</span><span class="p">,</span><span class="s2">&quot;bbox_oriented_side_min&quot;</span><span class="p">]:</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">features</span></div>

<div class="viewcode-block" id="seg_split_spine"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.seg_split_spine">[docs]</a><span class="k">def</span> <span class="nf">seg_split_spine</span><span class="p">(</span>
    <span class="n">df</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">segment_id</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">split_index</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_id</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_dicts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Get segment,split_index and spine_ids</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    spu.seg_split_spine(spine_df_trans_umap)</span>

<span class="sd">    spu.seg_split_spine(</span>
<span class="sd">        segment_id = 864691135730167737,</span>
<span class="sd">        split_index = 0,</span>
<span class="sd">        spine_id = [0,11],</span>
<span class="sd">        df = None,</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;segment_id&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">segment_id</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;split_index&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">split_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">split_index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;spine_id&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">spine_id</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">spine_id</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>
    <span class="n">split_index</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">split_index</span><span class="p">)</span>
    <span class="n">spine_id</span><span class="o">=</span><span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">spine_id</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_id</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_id</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">split_index</span> <span class="o">=</span> <span class="n">split_index</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_dicts</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">segment_id</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">split_index</span> <span class="o">=</span> <span class="n">sp</span><span class="p">,</span><span class="n">spine_id</span> <span class="o">=</span> <span class="n">spi</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="n">spi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span><span class="n">split_index</span><span class="p">,</span><span class="n">spine_id</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">segment_id</span><span class="p">,</span><span class="n">split_index</span><span class="p">,</span><span class="n">spine_id</span></div>

<span class="n">seg_split_spine_from_df</span> <span class="o">=</span> <span class="n">seg_split_spine</span>

<div class="viewcode-block" id="area_of_border_verts"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.area_of_border_verts">[docs]</a><span class="k">def</span> <span class="nf">area_of_border_verts</span><span class="p">(</span><span class="n">spine_obj</span><span class="p">,</span><span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">spine_obj</span><span class="o">.</span><span class="n">coordinate_border_verts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_value</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">area_of_vertex_boundary</span><span class="p">(</span>
        <span class="n">spine_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">spine_obj</span><span class="o">.</span><span class="n">coordinate_border_verts</span>
    <span class="p">)</span></div>

<span class="c1"># ----- new shaft filtering function --------------</span>
<div class="viewcode-block" id="restrict_meshes_to_shaft_meshes_without_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.restrict_meshes_to_shaft_meshes_without_coordinates">[docs]</a><span class="k">def</span> <span class="nf">restrict_meshes_to_shaft_meshes_without_coordinates</span><span class="p">(</span>
    <span class="n">meshes</span><span class="p">,</span>
    <span class="n">close_hole_area_top_2_mean_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#110_000,</span>
    <span class="n">mesh_volume_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.3e9,</span>
    <span class="c1">#n_faces_max = 500,</span>
    <span class="n">n_faces_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_all_shaft_if_none</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    To restrict a list of meshes to those with a high probability of being a shaft mesh</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ------------</span>
<span class="sd">    1) restricts meshes to those greater than a certain volume (shaft_mesh_volume_max) or greater than a certain mean top 2 hole area (shaft_close_hole_area_top_2_mean_max) because both could be indicative of a shaft mesh</span>
<span class="sd">        functions used: trimesh_utils.close_hole_area_top_2_mean, trimesh_utils.mesh_volume</span>
<span class="sd">    2) restricts meshes to face threshold (shaft_mesh_n_faces_min)</span>
<span class="sd">    3) Returns the indices of the meshes remaining after filtering</span>

<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    shaft_close_hole_area_top_2_mean_max: float</span>
<span class="sd">        a minimum mesh area (nm^2)  threshold for the mean of the top 2 holes (ideally the connecting ends of the tube like shaft sections from the mesh cluster (from the CGAL algorithm) to be potentially considered a part of the neuron shaft. (The max refers to a max suffix is in reference to spines)</span>

<span class="sd">    shaft_mesh_volume_max: int</span>
<span class="sd">        the minimum mesh volume (nm^3) for a mesh cluster (from the CGAL algorithm) to be potentially considered a part of the neuron shaft. (The max refers to a max suffix is in reference to spines)</span>

<span class="sd">    shaft_mesh_n_faces_min: int</span>
<span class="sd">        A minimum number of faces on a submesh cluster early in the pipeline to be potentially considered a part of the neuron shaft.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">close_hole_area_top_2_mean_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">close_hole_area_top_2_mean_max</span> <span class="o">=</span> <span class="n">shaft_close_hole_area_top_2_mean_max_global</span>
    <span class="k">if</span> <span class="n">mesh_volume_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_volume_max</span> <span class="o">=</span> <span class="n">shaft_mesh_volume_max_global</span>
    <span class="k">if</span> <span class="n">n_faces_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_faces_min</span> <span class="o">=</span> <span class="n">shaft_mesh_n_faces_min_global</span>
    
    <span class="n">query</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;(close_hole_area_top_2_mean &gt; </span><span class="si">{</span><span class="n">close_hole_area_top_2_mean_max</span><span class="si">}</span><span class="s2">) or (mesh_volume &gt; </span><span class="si">{</span><span class="n">mesh_volume_max</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="c1">#f&quot;(close_hole_area_top_2_mean &gt; {close_hole_area_top_2_mean_max}) or (n_faces &gt; {n_faces_max})&quot;,</span>
        <span class="sa">f</span><span class="s2">&quot;(n_faces &gt; </span><span class="si">{</span><span class="n">n_faces_min</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="p">]</span>

    <span class="n">shaft_meshes_idx</span><span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">query_meshes_from_stats</span><span class="p">(</span>
        <span class="n">meshes</span><span class="p">,</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;close_hole_area_top_2_mean&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_faces&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mesh_volume&quot;</span>
        <span class="p">],</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
        <span class="n">return_idx</span> <span class="o">=</span> <span class="n">return_idx</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_meshes_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">return_all_shaft_if_none</span><span class="p">:</span>
        <span class="n">shaft_meshes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">shaft_meshes_idx</span></div>

<div class="viewcode-block" id="split_mesh_into_spines_shaft"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.split_mesh_into_spines_shaft">[docs]</a><span class="k">def</span> <span class="nf">split_mesh_into_spines_shaft</span><span class="p">(</span>
    <span class="n">current_mesh</span><span class="p">,</span>
    <span class="n">segment_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">clusters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">smoothness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cgal_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./cgal_temp&quot;</span><span class="p">),</span>
    <span class="n">delete_temp_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
     <span class="n">return_sdf</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_shaft</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_shaft_buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>
<span class="sd">    -----------</span>
<span class="sd">    Determine the final classification of shaft submeshes and then return all connected components (floating islands) of the submesh after the shaft has been removed as individual spine meshes. In other words, generates the meshes for each individual spine (prior to individual spine filtering steps).</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    ----------------</span>
<span class="sd">    1) runs a segmentation on the mesh with given clusters and smoothness.	</span>
<span class="sd">    a) generates a mapping of the clusters the sdf values for each face</span>
<span class="sd">    2) splits the segmentation into separate meshes</span>
<span class="sd">    3) spu.restrict_meshes_to_shaft_meshes_without_coordinates</span>
<span class="sd">    4) Divide the meshes into spine meshes and shaft meshes (first pass)</span>
<span class="sd">    5) Given first pass of the shaft and spine classification, reclassifies some spine meshes as shaft meshes to ensure complete graph connectivity between all shaft submeshes using the following algorithm</span>
<span class="sd">            1) start with biggest shaft</span>
<span class="sd">            2) Find the shortest paths to all shaft parts</span>
<span class="sd">            3) add all the submeshes that aren&#39;t already in the shaft category to the shaft category</span>
<span class="sd">    6) Creates a total spine submesh by removing all of the shaft submeshes from the original mesh, divides up this total spine submesh into connected components (separate islands) as separate meshes so each mesh represents a single spine</span>
<span class="sd">    7)  Sorts the spine meshes from largest (number of faces) to smallest</span>
<span class="sd">    8) Returns spine meshes and the sdf values (generated in the segmentation step) associated with them</span>



<span class="sd">    Global Parameters to Set</span>
<span class="sd">    ----------------</span>
<span class="sd">    smoothness_threshold: </span>
<span class="sd">        The smoothness parameter for the cgal mesh segmentation algorithm used as an initial intermediate over-segmentation step in the spine detection. The smaller the smoothness value, generally the more number of underlying clusters on the mesh identified and the more spines that can be potentially identified at the higher risk of false positives (although the spine algorithm attempts to filter away false positives from the underlying mesh segmentation). Source: https://doc.cgal.org/4.6/Surface_mesh_segmentation/index.html</span>

<span class="sd">    clusters_threshold:</span>
<span class="sd">        The clusters parameter for the cgal mesh segmentation algorithm used as an initial intermediate over-segmentation step in the spine detection. The larger the number of clusters the more spines can be potentially identified at the higher risk of false positives (although the spine algorithm attempts to filter away false positives from the underlying mesh segmentation). Source: https://doc.cgal.org/4.6/Surface_mesh_segmentation/index.html</span>



<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    current_mesh : _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    segment_name : str, optional</span>
<span class="sd">        _description_, by default &quot;&quot;</span>
<span class="sd">    clusters : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    smoothness : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    cgal_folder : _type_, optional</span>
<span class="sd">        _description_, by default Path(&quot;./cgal_temp&quot;)</span>
<span class="sd">    delete_temp_file : bool, optional</span>
<span class="sd">        _description_, by default True</span>
<span class="sd">    shaft_threshold : _type_, optional</span>
<span class="sd">        _description_, by default None</span>
<span class="sd">    return_sdf : bool, optional</span>
<span class="sd">        _description_, by default True</span>
<span class="sd">    print_flag : bool, optional</span>
<span class="sd">        _description_, by default False</span>
<span class="sd">    plot_segmentation : bool, optional</span>
<span class="sd">        _description_, by default False</span>
<span class="sd">    plot_shaft : bool, optional</span>
<span class="sd">        _description_, by default False</span>
<span class="sd">    plot_shaft_buffer : int, optional</span>
<span class="sd">        _description_, by default 0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters_threshold_global</span>
    
    <span class="k">if</span> <span class="n">smoothness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">smoothness</span> <span class="o">=</span> <span class="n">smoothness_threshold_global</span>
        
    <span class="k">if</span> <span class="n">shaft_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shaft_threshold</span> <span class="o">=</span> <span class="n">shaft_threshold_global</span>
    
    

    <span class="c1">#print(f&quot;plot_segmentation= {plot_segmentation}&quot;)</span>
    <span class="n">cgal_data</span><span class="p">,</span><span class="n">cgal_sdf_data</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                                                  <span class="n">cgal_folder</span><span class="o">=</span><span class="n">cgal_folder</span><span class="p">,</span>
                                                   <span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span>
                                                   <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">,</span>
                                                   <span class="n">return_sdf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">delete_temp_files</span><span class="o">=</span><span class="n">delete_temp_file</span><span class="p">,</span>
                                                   <span class="n">return_meshes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">return_ordered_by_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">plot_segmentation</span> <span class="o">=</span> <span class="n">plot_segmentation</span><span class="p">,</span>
                                                  <span class="p">)</span>
    
    <span class="c1">#get a look at how many groups and what distribution:</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Counter of data = </span><span class="si">{</span><span class="n">Counter</span><span class="p">(</span><span class="n">cgal_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#gets the meshes that are split using the cgal labels</span>
    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">cgal_data</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">check_connect_comp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    
    
    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_idx</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There was only one mesh found from the spine process and mesh split, returning empty array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[]</span>
        
    
    
<span class="c1">#     #Applying a length threshold to get all other possible shaft meshes</span>
<span class="c1">#     for spine_id,spine_mesh in split_meshes.items():</span>
<span class="c1">#         if len(spine_mesh.faces) &lt; shaft_threshold:</span>
<span class="c1">#             spine_meshes.append(spine_mesh)</span>
<span class="c1">#             spine_meshes_idx.append(split_meshes_idx[spine_id])</span>
<span class="c1">#         else:</span>
<span class="c1">#             shaft_meshes.append(spine_mesh)</span>
<span class="c1">#             shaft_meshes_idx.append(split_meshes_idx[spine_id])</span>

    <span class="n">meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">split_meshes</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">meshes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">split_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    
    <span class="c1">#return meshes</span>
    
    <span class="n">sh_idx</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">restrict_meshes_to_shaft_meshes_without_coordinates</span><span class="p">(</span>
        <span class="n">meshes</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    
    <span class="n">shaft_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sh_idx</span><span class="p">]</span>
    <span class="n">shaft_meshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_meshes_idx</span><span class="p">[</span><span class="n">meshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sh_idx</span><span class="p">]</span>
    
    <span class="n">sp_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">)),</span><span class="n">sh_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">spine_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sp_idx</span><span class="p">]</span>
    <span class="n">spine_meshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_meshes_idx</span><span class="p">[</span><span class="n">meshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sp_idx</span><span class="p">]</span>
    
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No shaft meshes detected&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[]</span>
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No spine meshes detected&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">plot_shaft</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- initial shaft meshes before graph fixing&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">current_mesh</span><span class="p">,</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="n">shaft_meshes</span><span class="p">,</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="n">plot_shaft_buffer</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_sdf</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_meshes</span><span class="p">,</span><span class="n">spine_meshes_idx</span><span class="p">,</span><span class="n">shaft_meshes</span><span class="p">,</span><span class="n">shaft_meshes_idx</span><span class="p">,</span><span class="n">cgal_sdf_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spine_meshes</span><span class="p">,</span><span class="n">spine_meshes_idx</span><span class="p">,</span><span class="n">shaft_meshes</span><span class="p">,</span><span class="n">shaft_meshes_idx</span></div>

    
<div class="viewcode-block" id="synapse_attribute_dict_from_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.synapse_attribute_dict_from_synapse_df">[docs]</a><span class="k">def</span> <span class="nf">synapse_attribute_dict_from_synapse_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;synapse_coords&quot;</span><span class="p">,</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To extract the coordinates of </span>
<span class="sd">    all the spine categories from a synapse_spine_df</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    Iterate through all of the spine categories</span>
<span class="sd">    1) Restrict the dataframe to just categories</span>
<span class="sd">    2) Extract coordinates</span>
<span class="sd">    3) Put in dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">coordinate_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_compartments</span><span class="p">:</span>
        <span class="n">curr_cat</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_compartment==&#39;</span><span class="si">{</span><span class="n">curr_cat</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="p">[]</span>
            
        <span class="k">if</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;synapse_coords&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">coordinates_from_df</span><span class="p">(</span><span class="n">curr_df</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;synapse&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attribute</span> <span class="o">==</span> <span class="s2">&quot;synapse_id&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">curr_df</span><span class="p">[</span><span class="s2">&quot;synapse_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
        <span class="n">coordinate_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cat</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">coordinate_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">coordinate_dict</span></div>

<div class="viewcode-block" id="synapse_coords_from_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.synapse_coords_from_synapse_df">[docs]</a><span class="k">def</span> <span class="nf">synapse_coords_from_synapse_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,):</span>
    
    <span class="n">return_d</span> <span class="o">=</span>  <span class="n">synapse_attribute_dict_from_synapse_df</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;synapse_coords&quot;</span><span class="p">,</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">return_d</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div>

<div class="viewcode-block" id="synapse_ids_from_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.synapse_ids_from_synapse_df">[docs]</a><span class="k">def</span> <span class="nf">synapse_ids_from_synapse_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,):</span>
    
    <span class="n">return_d</span> <span class="o">=</span>  <span class="n">synapse_attribute_dict_from_synapse_df</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;synapse_id&quot;</span><span class="p">,</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">return_d</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span></div>
    
    

<div class="viewcode-block" id="plot_spine_embeddings_kde"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_embeddings_kde">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_embeddings_kde</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">embeddings</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;umap_0&quot;</span><span class="p">,</span><span class="s2">&quot;umap_1&quot;</span><span class="p">],</span>
    <span class="n">rotation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">hue</span> <span class="o">=</span> <span class="s2">&quot;e_i_predicted&quot;</span><span class="p">,</span>
    <span class="n">excitatory_color</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">seaborn_orange</span><span class="p">,</span>
    <span class="n">inhibitory_color</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">seaborn_blue</span><span class="p">,</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span><span class="c1">#0.5,</span>
    <span class="n">levels</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="n">df_to_plot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">rotation_embeddings</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_rotated&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">embeddings</span><span class="p">]</span>
    <span class="n">df_to_plot</span><span class="p">[</span><span class="n">rotation_embeddings</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="n">df_to_plot</span><span class="p">[</span><span class="n">embeddings</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span>
    <span class="c1">#     data = pu.randomly_sample_classes_from_df(</span>
    <span class="c1">#         spine_df_trans_umap,</span>
    <span class="c1">#         column=hue,</span>
    <span class="c1">#         n_samples=50,</span>
    <span class="c1">#         seed = 1000,</span>
    <span class="c1">#     ),</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">df_to_plot</span><span class="p">,</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">rotation_embeddings</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">rotation_embeddings</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">palette</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">inhibitory</span> <span class="o">=</span> <span class="n">inhibitory_color</span><span class="p">,</span>
            <span class="n">excitatory</span> <span class="o">=</span> <span class="n">excitatory_color</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span><span class="p">,</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">,</span><span class="c1">#0.5,</span>
        <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span>
        <span class="n">legend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">,</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span>
        <span class="n">linestyles</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">mu</span><span class="o">.</span><span class="n">set_axes_font_size</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">mu</span><span class="o">.</span><span class="n">set_axes_tick_font_size</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
    <span class="c1">#mu.set_legend_size(ax,100)</span>

    <span class="k">return</span> <span class="n">mu</span><span class="o">.</span><span class="n">set_axes_outside_seaborn</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span></div>


<div class="viewcode-block" id="spine_compartment_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_compartment_synapses">[docs]</a><span class="k">def</span> <span class="nf">spine_compartment_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">compartment</span><span class="p">):</span>
    <span class="n">compartment</span><span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">compartment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_compartment in </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">compartment</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_spine_compartment_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_spine_compartment_synapses">[docs]</a><span class="k">def</span> <span class="nf">n_spine_compartment_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">compartment</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_compartment_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">compartment</span><span class="p">))</span></div>
<div class="viewcode-block" id="shaft_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.shaft_synapses">[docs]</a><span class="k">def</span> <span class="nf">shaft_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">spine_compartment_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;shaft&quot;</span><span class="p">)</span></div>
<div class="viewcode-block" id="n_shaft_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.n_shaft_synapses">[docs]</a><span class="k">def</span> <span class="nf">n_shaft_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">))</span></div>

<div class="viewcode-block" id="set_shaft_synapses_from_spine_query"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.set_shaft_synapses_from_spine_query">[docs]</a><span class="k">def</span> <span class="nf">set_shaft_synapses_from_spine_query</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Receiving a synapse table</span>
<span class="sd">    with spine information associated with it</span>
<span class="sd">    and filters of which spines to actually keep,</span>
<span class="sd">    will flip the current spine compartment</span>
<span class="sd">    label of the synapses</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) invert the filter to get a filter for all spines</span>
<span class="sd">    that should not be spines</span>
<span class="sd">    2) Use the query to set the spine compartment as shaft</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


    <span class="n">query_str</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query_str_from_list</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="n">table_type</span><span class="o">=</span><span class="s2">&quot;pandas&quot;</span><span class="p">)</span>
    <span class="n">query_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;not (</span><span class="si">{</span><span class="n">query_str</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft query = </span><span class="si">{</span><span class="n">query_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before filter # of shaft synapses = </span><span class="si">{</span><span class="n">spu</span><span class="o">.</span><span class="n">n_shaft_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">pu</span><span class="o">.</span><span class="n">set_column_subset_value_by_query</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">query_str</span><span class="p">,</span>
        <span class="n">column</span> <span class="o">=</span> <span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span>
        <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;shaft&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER filter # of shaft synapses = </span><span class="si">{</span><span class="n">spu</span><span class="o">.</span><span class="n">n_shaft_synapses</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># --------- exporting the stats --------------</span>

<div class="viewcode-block" id="spine_synapse_stats_from_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_synapse_stats_from_synapse_df">[docs]</a><span class="k">def</span> <span class="nf">spine_synapse_stats_from_synapse_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">grouping_features</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;compartment&quot;</span><span class="p">,</span>
        <span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="n">grouping_features_backup</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;spine_compartment&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;spine_area&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_n_faces&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_skeletal_length&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_volume&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_width_ray&#39;</span><span class="p">,</span>
        <span class="s1">&#39;syn_spine_area&#39;</span><span class="p">,</span>
        <span class="s1">&#39;syn_spine_volume&#39;</span><span class="p">,</span>
        <span class="s1">&#39;syn_spine_width_ray_80_perc&#39;</span><span class="p">,</span>
        <span class="s1">&#39;synapse_size&#39;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;syn&quot;</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">synapse_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;postsyn&#39;</span><span class="p">,),</span>
    
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate a dictionary/df</span>
<span class="sd">    parsing down the categories of a spine</span>
<span class="sd">    df into the averages and counts for different</span>
<span class="sd">    - neuron compartments</span>
<span class="sd">    - spine compartments</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    - limit to only postsyn</span>

<span class="sd">    - For specified features</span>
<span class="sd">    1) groupby spine compartment and compartment</span>
<span class="sd">    - reduce by average</span>
<span class="sd">    - reduce by count</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">synapse_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">synapse_types</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">synapse_types</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;synapse_type in </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">synapse_types</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>
    
    <span class="n">all_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">gf</span> <span class="ow">in</span> <span class="p">[</span><span class="n">grouping_features</span><span class="p">,</span><span class="n">grouping_features_backup</span><span class="p">]:</span>
        <span class="n">gf</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gf</span><span class="p">)</span>

        <span class="n">df_lite</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">gf</span> <span class="o">+</span> <span class="n">features</span><span class="p">]</span>
        <span class="n">spine_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">features</span> <span class="k">if</span> <span class="s2">&quot;spine&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        <span class="n">df_lite</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">set_column_subset_value_by_query</span><span class="p">(</span>
            <span class="n">df_lite</span><span class="p">,</span>
            <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;spine_compartment == &#39;shaft&#39;&quot;</span><span class="p">,</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">spine_columns</span><span class="p">,</span>
            <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="p">)</span>


        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">group_df_for_count_and_average</span><span class="p">(</span>
            <span class="n">df_lite</span><span class="p">,</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">gf</span><span class="p">,</span>
            <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">return_one_row_df</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="n">all_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats</span><span class="p">)</span>
        
    <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">all_dfs</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_unique_counts&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="s1">&#39;_unique_counts&#39;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">else</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="n">column_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df_stats</span> <span class="k">if</span> <span class="s2">&quot;_n_&quot;</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">and</span> <span class="s2">&quot;face&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">df_stats</span><span class="p">[</span><span class="n">column_ints</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_stats</span><span class="p">[</span><span class="n">column_ints</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">df_to_dicts</span><span class="p">(</span><span class="n">df_stats</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df_stats</span></div>

<span class="n">spine_features_no_head</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;spine_area&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_n_faces&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_skeletal_length&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_volume&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_width_ray&#39;</span><span class="p">,</span>
        <span class="p">)</span>

<span class="n">spine_features_head_neck</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;head_area&#39;</span><span class="p">,</span>
        <span class="s1">&#39;head_n_faces&#39;</span><span class="p">,</span>
        <span class="s1">&#39;head_skeletal_length&#39;</span><span class="p">,</span>
        <span class="s1">&#39;head_volume&#39;</span><span class="p">,</span>
        <span class="s1">&#39;head_width_ray&#39;</span><span class="p">,</span>
        <span class="s1">&#39;head_width_ray_80_perc&#39;</span><span class="p">,</span>
        
        <span class="s1">&#39;neck_area&#39;</span><span class="p">,</span>
        <span class="s1">&#39;neck_n_faces&#39;</span><span class="p">,</span>
        <span class="s1">&#39;neck_skeletal_length&#39;</span><span class="p">,</span>
        <span class="s1">&#39;neck_volume&#39;</span><span class="p">,</span>
        <span class="s1">&#39;neck_width_ray&#39;</span><span class="p">,</span>
        <span class="s1">&#39;neck_width_ray_80_perc&#39;</span><span class="p">,</span>
        <span class="p">)</span>

<span class="n">spine_features_n_syn_no_head</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;spine_n_no_head_syn&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_max_no_head_syn_size&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_max_no_head_sp_vol&#39;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">spine_features_n_syn_head_neck</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;spine_n_head_syn&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_n_neck_syn&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_max_head_syn_size&#39;</span><span class="p">,</span>
        <span class="s1">&#39;spine_max_neck_syn_size&#39;</span><span class="p">,</span>
       <span class="s1">&#39;spine_max_head_sp_vol&#39;</span><span class="p">,</span>
       <span class="s1">&#39;spine_max_neck_sp_vol&#39;</span><span class="p">,</span>
<span class="p">)</span>

<div class="viewcode-block" id="spine_stats_from_spine_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.spine_stats_from_spine_df">[docs]</a><span class="k">def</span> <span class="nf">spine_stats_from_spine_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">grouping_features</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;compartment&quot;</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="n">features_no_head</span> <span class="o">=</span> <span class="n">spine_features_no_head</span><span class="p">,</span>
    <span class="n">features_head_neck</span> <span class="o">=</span> <span class="n">spine_features_head_neck</span><span class="p">,</span>
    <span class="n">features_n_syn_no_head</span> <span class="o">=</span> <span class="n">spine_features_n_syn_no_head</span><span class="p">,</span>
    <span class="n">features_n_syn_head_neck</span> <span class="o">=</span> <span class="n">spine_features_n_syn_head_neck</span><span class="p">,</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;sp&quot;</span><span class="p">,</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to export spine statistics</span>
<span class="sd">    grouped by compartment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n_heads</span><span class="p">,</span><span class="n">pre</span><span class="p">,</span><span class="n">features</span><span class="p">,</span><span class="n">n_syn_features</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;no_head&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="n">features_head_neck</span><span class="p">,</span><span class="n">features_no_head</span><span class="p">,],</span>
            <span class="p">[</span><span class="n">features_n_syn_head_neck</span><span class="p">,</span><span class="n">features_n_syn_no_head</span><span class="p">,],</span>
        <span class="p">):</span>
        <span class="n">features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">n_syn_features</span><span class="p">)</span>
        <span class="n">grouping_features</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouping_features</span><span class="p">)</span>

        <span class="n">df_lite</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_heads == </span><span class="si">{</span><span class="n">n_heads</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_lite</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="n">df_lite</span> <span class="o">=</span> <span class="n">df_lite</span><span class="p">[</span><span class="n">grouping_features</span> <span class="o">+</span> <span class="n">features</span><span class="p">]</span>
   
        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">group_df_for_count_and_average</span><span class="p">(</span>
            <span class="n">df_lite</span><span class="p">,</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">grouping_features</span><span class="p">,</span>
            <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">return_one_row_df</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_unique_counts&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                 <span class="k">if</span> <span class="s1">&#39;_unique_counts&#39;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">else</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pre</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            
        <span class="n">all_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats</span><span class="p">)</span>
        
        <span class="c1"># ---- want to calculate the stats without aggregating across columns ----</span>
        <span class="n">df_feat</span> <span class="o">=</span> <span class="n">df_lite</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="n">df_feat</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pre</span><span class="si">}</span><span class="s2">_number&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_lite</span><span class="p">)</span>
        <span class="n">all_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_feat</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dfs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pu</span><span class="o">.</span><span class="n">empty_df</span><span class="p">()</span>
    
    <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">all_dfs</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="n">column_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df_stats</span> <span class="k">if</span> <span class="s2">&quot;_n_&quot;</span> <span class="ow">in</span> <span class="n">c</span> <span class="ow">and</span> <span class="s2">&quot;face&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span>
                  <span class="ow">and</span> <span class="s2">&quot;syn&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_ints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">df_stats</span><span class="p">[</span><span class="n">column_ints</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_stats</span><span class="p">[</span><span class="n">column_ints</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">df_to_dicts</span><span class="p">(</span><span class="n">df_stats</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df_stats</span></div>

<div class="viewcode-block" id="add_spine_densities_to_spine_stats_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.add_spine_densities_to_spine_stats_df">[docs]</a><span class="k">def</span> <span class="nf">add_spine_densities_to_spine_stats_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">head_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;no_head&quot;</span><span class="p">,</span><span class="s2">&quot;head&quot;</span><span class="p">],</span>
    <span class="n">skeletal_length_divisor</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Compute spine densities from</span>
<span class="sd">    spine_stats_df</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">dendrite_compartment_labels</span><span class="p">()</span>
        
    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_spine_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;sp_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_n_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">head_types</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeletal_length&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">skeletal_length_divisor</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;total_spine_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;sp_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_n_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">head_types</span><span class="p">]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">]))]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">/</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;dendrite_skeletal_length&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">skeletal_length_divisor</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="add_synapse_densities_to_spine_synapse_stats_df"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.add_synapse_densities_to_spine_synapse_stats_df">[docs]</a><span class="k">def</span> <span class="nf">add_synapse_densities_to_spine_synapse_stats_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">spine_compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeletal_length_divisor</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.000001</span><span class="p">,</span>
    <span class="n">return_features</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">max_value_to_set_to_zero</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to compute the synapse densities</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


    <span class="n">forgotten_labels</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;syn_n_apical_shaft_neck&quot;</span><span class="p">,</span>
        <span class="s2">&quot;syn_n_apical_tuft_neck&quot;</span><span class="p">,]</span>

    <span class="n">features_generated</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">forgotten_labels</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">dendrite_compartment_labels</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">spine_compartments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spine_compartments</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_compartments_no_prefix</span>

    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spine_compartments</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;syn_n_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;dendrite_skeletal_length&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">skeletal_length_divisor</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
        <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;spine_synapse_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;neck&quot;</span><span class="p">,</span><span class="s2">&quot;no_head&quot;</span><span class="p">]]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_synapse_density&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;synapse_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;neck&quot;</span><span class="p">,</span><span class="s2">&quot;no_head&quot;</span><span class="p">,</span><span class="s2">&quot;shaft&quot;</span><span class="p">]]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;synapse_density&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;syn_n_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spine_compartments</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeletal_length&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">skeletal_length_divisor</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
        <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_spine_synapse_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;syn_n_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;neck&quot;</span><span class="p">,</span><span class="s2">&quot;no_head&quot;</span><span class="p">]]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span>
            <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeletal_length&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">skeletal_length_divisor</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
        <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_spine_synapse_density&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spine_compartments</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;syn_n_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeletal_length&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">skeletal_length_divisor</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
            <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">_synapse_density&quot;</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;soma_syn_area_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;syn_n_soma_shaft&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;max_soma_area&quot;</span><span class="p">]</span>
    <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;soma_syn_area_density&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;soma_syn_volume_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;syn_n_soma_shaft&quot;</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;max_soma_volume&quot;</span><span class="p">]</span>
    <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;soma_syn_volume_density&quot;</span><span class="p">)</span>
    
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;shaft_to_spine_synapse_density_ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;shaft_synapse_density&quot;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_synapse_density&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
    <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;shaft_to_spine_synapse_density_ratio&quot;</span><span class="p">)</span>
    
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;shaft_syn_to_spine_syn_density_ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;shaft_synapse_density&quot;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;spine_synapse_density&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">eta</span><span class="p">)</span>
    
    <span class="n">features_generated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;shaft_syn_to_spine_syn_density_ratio&quot;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="n">max_value_to_set_to_zero</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features_generated</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">set_column_subset_value_by_query</span><span class="p">(</span>
                <span class="n">df</span><span class="p">,</span>
                <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> &gt;= </span><span class="si">{</span><span class="n">max_value_to_set_to_zero</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">f</span><span class="p">,</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
            
    
            
    <span class="k">if</span> <span class="n">return_features</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span><span class="p">,</span><span class="n">features_generated</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="plot_feature_histograms_with_ct_overlay"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_feature_histograms_with_ct_overlay">[docs]</a><span class="k">def</span> <span class="nf">plot_feature_histograms_with_ct_overlay</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">features</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,):</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> 
            <span class="p">[</span><span class="s2">&quot;segment_id&quot;</span><span class="p">,</span><span class="s2">&quot;split_index&quot;</span><span class="p">,</span><span class="s2">&quot;min_skeletal_length&quot;</span><span class="p">,</span><span class="s2">&quot;cell_type&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;gnn&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        
    <span class="n">spine_stats_df</span> <span class="o">=</span> <span class="n">df</span>
    <span class="n">exc_df</span> <span class="o">=</span> <span class="n">spine_stats_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gnn_cell_type_coarse == &#39;excitatory&#39;&quot;</span><span class="p">)</span>
    <span class="n">inh_df</span> <span class="o">=</span> <span class="n">spine_stats_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gnn_cell_type_coarse == &#39;inhibitory&#39;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----- </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> -----&quot;</span><span class="p">)</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="s2">&quot;both&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;dendrite&quot;</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">cell_type</span> <span class="o">=</span> <span class="s2">&quot;inhibitory&quot;</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">apu</span><span class="o">.</span><span class="n">dendrite_compartment_labels</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;dendrite&quot;</span> <span class="o">==</span> <span class="n">comp</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">cell_type</span> <span class="o">=</span> <span class="s2">&quot;excitatory&quot;</span>
                <span class="k">break</span>


        <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s1">&#39;excitatory&#39;</span><span class="p">:</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">exc_df</span>
            <span class="n">hue_order</span> <span class="o">=</span> <span class="n">ctu</span><span class="o">.</span><span class="n">allen_cell_type_fine_classifier_labels_exc</span>
        <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;inhibitory&quot;</span><span class="p">:</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">inh_df</span>
            <span class="n">hue_order</span> <span class="o">=</span> <span class="n">ctu</span><span class="o">.</span><span class="n">allen_cell_type_fine_classifier_labels_inh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">spine_stats_df</span>
            <span class="n">hue_order</span> <span class="o">=</span> <span class="n">ctu</span><span class="o">.</span><span class="n">allen_cell_type_fine_classifier_labels</span>


        <span class="n">curr_df</span> <span class="o">=</span> <span class="n">curr_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_df</span> <span class="o">=</span> <span class="n">curr_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> &lt;= </span><span class="si">{</span><span class="n">max_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">mu</span><span class="o">.</span><span class="n">histograms_overlayed</span><span class="p">(</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">curr_df</span><span class="p">,</span>
            <span class="n">column</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">hue</span> <span class="o">=</span> <span class="s2">&quot;gnn_cell_type_fine&quot;</span><span class="p">,</span>
            <span class="n">density</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">hue_order</span> <span class="o">=</span> <span class="n">hue_order</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="feature_summed_over_compartments"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.feature_summed_over_compartments">[docs]</a><span class="k">def</span> <span class="nf">feature_summed_over_compartments</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">feature</span><span class="p">,</span>
    <span class="n">final_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">head_prefix</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;head&quot;</span><span class="p">,</span><span class="s2">&quot;no_head&quot;</span><span class="p">],</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">dendrite_compartment_labels</span><span class="p">()</span>
        
    <span class="n">head_prefix</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">head_prefix</span><span class="p">)</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">compartments</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    
    <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="sa">f</span><span class="s2">&quot;sp_</span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">feature</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">head_prefix</span><span class="p">]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">]))</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="sa">f</span><span class="s2">&quot;sp_</span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s2">_n_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">head_prefix</span><span class="p">]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;columns = </span><span class="si">{</span><span class="n">columns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;weights = </span><span class="si">{</span><span class="n">weights</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#return columns</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">*</span><span class="n">df</span><span class="p">[</span><span class="n">weights</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()),</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">weights</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">#val = (df[columns]*df[weights]).mean(axis = 1)</span>
    
    <span class="k">if</span> <span class="n">final_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">final_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span></div>

    

<div class="viewcode-block" id="plot_spine_feature_hist"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_feature_hist">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_feature_hist</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">x</span><span class="p">,</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">x_multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">y_multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">title_fontsize</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">axes_label_fontsize</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">axes_tick_fontsize</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
    <span class="n">palette</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hue</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">legend</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">xlabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ylabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">percentile_upper</span> <span class="o">=</span> <span class="mi">99</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_correlation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">show_at_end</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_type</span> <span class="o">=</span> <span class="s2">&quot;histplot&quot;</span><span class="p">,</span>
    <span class="n">kde_thresh</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">kde_levels</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">text_box_x</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
    <span class="n">text_box_y</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">text_box_horizontalalignment</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
    <span class="n">text_box_verticalalignment</span> <span class="o">=</span> <span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
    <span class="n">text_box_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    
    
    <span class="c1"># --- plotting correlation textbox ---</span>
    <span class="n">plot_correlation_box</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">correlation_type</span> <span class="o">=</span> <span class="s2">&quot;corr_pearson&quot;</span><span class="p">,</span>
    <span class="n">text_box_fontsize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    
    
    <span class="c1"># --- lim ---</span>
    <span class="n">xlim</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ylim</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1"># --- legend arguments ---</span>
    <span class="n">legend_title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">legend_fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>
    
    <span class="n">edge_df_sp_filt</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&gt;=</span><span class="si">{</span><span class="n">min_x</span><span class="si">}</span><span class="s2">) and (</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&gt;=</span><span class="si">{</span><span class="n">min_y</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span> 
    <span class="n">edge_df_sp_filt</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">filter_df_by_column_percentile</span><span class="p">(</span>
        <span class="n">edge_df_sp_filt</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span>
        <span class="n">percentile_lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">percentile_upper</span><span class="o">=</span><span class="n">percentile_upper</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">edge_df_sp_filt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">x_multiplier</span>
    <span class="n">edge_df_sp_filt</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">y_multiplier</span>
    
    
    <span class="n">corr_dict</span> <span class="o">=</span> <span class="n">stu</span><span class="o">.</span><span class="n">correlation_scores_all</span><span class="p">(</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">,</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">print_correlation</span><span class="p">,</span>
            <span class="n">return_p_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
        

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="n">figsize</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_type</span><span class="o">==</span><span class="s2">&quot;histplot&quot;</span> <span class="ow">or</span> <span class="s2">&quot;dis&quot;</span> <span class="ow">in</span> <span class="n">plot_type</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">,</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span><span class="p">,</span>
            <span class="n">palette</span> <span class="o">=</span> <span class="n">palette</span><span class="p">,</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span>
            <span class="c1">#kind = &quot;reg&quot;,</span>
            <span class="n">legend</span> <span class="o">=</span> <span class="n">legend</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;jointplot&quot;</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">,</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span><span class="p">,</span>
            <span class="n">palette</span> <span class="o">=</span> <span class="n">palette</span><span class="p">,</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span>
            <span class="c1">#kind = &quot;reg&quot;,</span>
            <span class="n">legend</span> <span class="o">=</span> <span class="n">legend</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s2">&quot;scatterplot&quot;</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">,</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span><span class="p">,</span>
            <span class="n">palette</span> <span class="o">=</span> <span class="n">palette</span><span class="p">,</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span>
            <span class="c1">#kind = &quot;reg&quot;,</span>
            <span class="n">legend</span> <span class="o">=</span> <span class="n">legend</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;kdeplot&#39;</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="p">,</span><span class="c1">#.query(f&quot;{column}==&#39;{k}&#39;&quot;),</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span><span class="c1">#features_to_plot[1],</span>
            <span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span><span class="p">,</span>
            <span class="n">common_norm</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">kde_thresh</span><span class="p">,</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">kde_levels</span><span class="p">,</span>
            <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
    <span class="n">ax</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">ax_main</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">title_fontsize</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="n">xlabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">axes_label_fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">axes_label_fontsize</span><span class="p">)</span>
    <span class="n">mu</span><span class="o">.</span><span class="n">set_axes_tick_font_size</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">axes_tick_fontsize</span><span class="p">)</span>


    
    <span class="k">if</span> <span class="n">plot_correlation_box</span><span class="p">:</span>
<span class="c1">#         curr_value = corr_dict[correlation_type]</span>
<span class="c1">#         corr_str = (f&quot;Corr = {curr_value[&#39;correlation&#39;]:.3f}&quot;</span>
<span class="c1">#             f&quot;\n(P = {curr_value[&#39;pvalue&#39;]:.2f})&quot;)</span>
<span class="c1">#         mu.text_box_on_ax(</span>
<span class="c1">#             ax,</span>
<span class="c1">#             x = text_box_x,</span>
<span class="c1">#             y = text_box_y,</span>
<span class="c1">#             horizontalalignment = text_box_horizontalalignment,</span>
<span class="c1">#             verticalalignment = text_box_verticalalignment,</span>
<span class="c1">#             text =corr_str,</span>
<span class="c1">#             fontsize = text_box_fontsize,</span>
<span class="c1">#             alpha = text_box_alpha</span>
<span class="c1">#         )</span>
        
        <span class="n">mu</span><span class="o">.</span><span class="n">add_correlation_text_box</span><span class="p">(</span>
            <span class="n">ax</span><span class="p">,</span>
            <span class="n">corr_dict</span> <span class="o">=</span> <span class="n">corr_dict</span><span class="p">,</span>
            <span class="n">text_box_fontsize</span> <span class="o">=</span> <span class="n">text_box_fontsize</span><span class="p">,</span>
            <span class="n">correlation_type</span> <span class="o">=</span> <span class="n">correlation_type</span><span class="p">,</span>
            <span class="n">text_box_x</span> <span class="o">=</span> <span class="n">text_box_x</span><span class="p">,</span>
            <span class="n">text_box_y</span> <span class="o">=</span> <span class="n">text_box_y</span><span class="p">,</span>
            <span class="n">text_box_horizontalalignment</span> <span class="o">=</span> <span class="n">text_box_horizontalalignment</span><span class="p">,</span>
            <span class="n">text_box_verticalalignment</span> <span class="o">=</span> <span class="n">text_box_verticalalignment</span><span class="p">,</span>
            <span class="n">text_box_alpha</span> <span class="o">=</span> <span class="n">text_box_alpha</span><span class="p">,</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">xlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ylim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">legend_title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_title</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="s2">&quot;Cell Type&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">legend_fontsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_fontsizes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">legend_fontsize</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="plot_connetion_type_head_vs_spine_size_by_conn_type_kde"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_connetion_type_head_vs_spine_size_by_conn_type_kde">[docs]</a><span class="k">def</span> <span class="nf">plot_connetion_type_head_vs_spine_size_by_conn_type_kde</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;head_volume&quot;</span><span class="p">,</span>
    <span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;synapse_size_um&quot;</span><span class="p">,</span>
    <span class="n">hue</span> <span class="o">=</span> <span class="s2">&quot;connection_type&quot;</span><span class="p">,</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>
    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Syn Size vs Spine Head Volume&quot;</span><span class="p">,</span>
    <span class="n">title_fontsize</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Spine Head Volume ($\mu m^3$)&quot;</span><span class="p">,</span>
    <span class="n">ylabel</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Synapse Cleft Volume ($\mu m^3$)&quot;</span><span class="p">,</span>
    <span class="n">axes_label_fontsize</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">axes_tick_fontsize</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
    <span class="n">palette</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">kde_thresh</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">kde_levels</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">hue_options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">legend_title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">legend_fontsize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="n">edge_df_sp_filt</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">filter_df_by_column_percentile</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span>
        <span class="n">percentile_lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">percentile_upper</span><span class="o">=</span><span class="mf">99.5</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">edge_df_sp_filt_head</span> <span class="o">=</span> <span class="n">edge_df_sp_filt</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_compartment == &#39;head&#39;&quot;</span><span class="p">)</span>
    

    <span class="n">edge_df_sp_filt_head</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_df_sp_filt_head</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
    <span class="n">edge_df_sp_filt_head</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_df_sp_filt_head</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span> <span class="o">=</span> <span class="n">figsize</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">nature_paper_plotting</span> <span class="k">as</span> <span class="n">npp</span>
        <span class="n">palette</span> <span class="o">=</span> <span class="n">npp</span><span class="o">.</span><span class="n">exc_inh_combination_palette</span>
    
    <span class="k">if</span> <span class="n">hue_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edge_df_sp_filt_head</span> <span class="o">=</span> <span class="n">edge_df_sp_filt_head</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hue</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">hue_options</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">ax</span> <span class="o">=</span>  <span class="n">sns</span><span class="o">.</span><span class="n">kdeplot</span><span class="p">(</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">edge_df_sp_filt_head</span><span class="p">,</span><span class="c1">#.query(f&quot;{column}==&#39;{k}&#39;&quot;),</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span><span class="c1">#features_to_plot[1],</span>
        <span class="n">hue</span> <span class="o">=</span> <span class="n">hue</span><span class="p">,</span>
        <span class="n">common_norm</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">thresh</span><span class="o">=</span><span class="n">kde_thresh</span><span class="p">,</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">kde_levels</span><span class="p">,</span>
        <span class="n">palette</span><span class="o">=</span><span class="n">palette</span><span class="p">,</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">title_fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">axes_label_fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">axes_label_fontsize</span><span class="p">)</span>
    <span class="n">mu</span><span class="o">.</span><span class="n">set_axes_tick_font_size</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">axes_tick_fontsize</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">legend_title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">legend_title</span> <span class="o">=</span> <span class="n">hue</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
    <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_title</span><span class="p">(</span>
        <span class="n">ax</span><span class="p">,</span><span class="n">legend_title</span>
    <span class="p">)</span>
    
    <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_fontsizes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">legend_fontsize</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="filter_spine_df_samples"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.filter_spine_df_samples">[docs]</a><span class="k">def</span> <span class="nf">filter_spine_df_samples</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">syn_max</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">sp_comp_max</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">restrictions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">restrictions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">restrictions</span><span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">restrictions</span> <span class="o">+=</span> <span class="p">[</span>
        <span class="s2">&quot;n_heads == 1&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;spine_n_spine_total_syn &lt;= </span><span class="si">{</span><span class="n">syn_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;spine_n_head_syn &lt;= </span><span class="si">{</span><span class="n">sp_comp_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;spine_n_neck_syn &lt;= </span><span class="si">{</span><span class="n">sp_comp_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;gnn_cell_type_coarse&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">restrictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gnn_cell_type_coarse == cell_type&quot;</span><span class="p">)</span>
    
    <span class="n">df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">query_table_from_list</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">restrictions</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="number_of_columns"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.number_of_columns">[docs]</a><span class="k">def</span> <span class="nf">number_of_columns</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s2">&quot;_n_&quot;</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">or</span> <span class="n">k</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n_&#39;</span><span class="p">]</span></div>
<div class="viewcode-block" id="convert_number_of_columns_to_dtype"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.convert_number_of_columns_to_dtype">[docs]</a><span class="k">def</span> <span class="nf">convert_number_of_columns_to_dtype</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="n">number_of_columns</span><span class="p">(</span><span class="n">df</span><span class="p">)]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">number_of_columns</span><span class="p">(</span><span class="n">df</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>
<div class="viewcode-block" id="plot_spine_attribute_vs_category_from_spine_df_samples"><a class="viewcode-back" href="../../neurd.html#neurd.spine_utils.plot_spine_attribute_vs_category_from_spine_df_samples">[docs]</a><span class="k">def</span> <span class="nf">plot_spine_attribute_vs_category_from_spine_df_samples</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">spine_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spine_n_head_syn&quot;</span><span class="p">,</span><span class="s2">&quot;spine_n_spine_total_syn&quot;</span><span class="p">],</span>
    <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;cell_type&quot;</span><span class="p">,</span>
    <span class="n">legend_dict_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">spine_n_head_syn</span> <span class="o">=</span>  <span class="s2">&quot;Spine Head&quot;</span><span class="p">,</span>
        <span class="n">spine_n_spine_total_syn</span> <span class="o">=</span> <span class="s2">&quot;All Spine&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">title_append</span> <span class="o">=</span> <span class="s2">&quot;(MICrONS)&quot;</span><span class="p">,</span>
    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cell Type vs. Average Number</span><span class="se">\n</span><span class="s2"> of Syn on Spine&quot;</span><span class="p">,</span>
    <span class="n">x_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Average # of Synapses&quot;</span><span class="p">,</span>
    <span class="n">legend_title</span> <span class="o">=</span> <span class="s2">&quot;Syn Type&quot;</span><span class="p">,</span>
    <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;MICrONS&quot;</span><span class="p">,</span>
    <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Postsyn Cell Type&quot;</span><span class="p">,</span>
    <span class="n">title_fontsize</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">axes_label_fontsize</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">axes_tick_fontsize</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
    <span class="n">legend_fontsize</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">set_legend_outside</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">legend_loc</span> <span class="o">=</span> <span class="s2">&quot;best&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a sampling of the spine</span>
<span class="sd">    and to plot the average number of synapses</span>
<span class="sd">    on each spine vs the cell type</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">total_dfs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">spine_attributes</span><span class="p">:</span>
        <span class="n">df_samp_n_head</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">category</span><span class="p">,</span><span class="n">x</span><span class="p">]]</span>
        <span class="n">df_samp_n_head</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">df_samp_n_head</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">rename_columns</span><span class="p">(</span><span class="n">df_samp_n_head</span><span class="p">,{</span><span class="n">x</span><span class="p">:</span><span class="s2">&quot;value&quot;</span><span class="p">})</span>
        <span class="n">total_dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_samp_n_head</span><span class="p">)</span>

    <span class="n">all_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">total_dfs</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">legend_dict_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">map_column_with_dict</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span><span class="n">column</span> <span class="o">=</span> <span class="s2">&quot;category&quot;</span><span class="p">,</span><span class="n">dict_map</span> <span class="o">=</span> <span class="n">legend_dict_map</span><span class="p">,</span>
                                            <span class="n">use_default_value</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">all_df</span><span class="p">,</span>
        <span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">category</span><span class="p">,</span>
        <span class="n">hue</span> <span class="o">=</span> <span class="s2">&quot;category&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">title_append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span><span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">title_append</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
        <span class="n">title</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">title_fontsize</span>
    <span class="p">)</span>
    <span class="c1">#ax.set_xlabel(&quot;Spine Head Volume ($\mu m^3$)&quot;,fontsize = axes_label_fontsize)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">axes_label_fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ylabel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">fontsize</span> <span class="o">=</span> <span class="n">axes_label_fontsize</span><span class="p">)</span>
    <span class="n">mu</span><span class="o">.</span><span class="n">set_axes_tick_font_size</span><span class="p">(</span>
        <span class="n">ax</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="n">axes_tick_fontsize</span><span class="p">,</span>
        <span class="n">y_rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">x_rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">y_tick_alignment</span><span class="o">=</span><span class="s2">&quot;center&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">set_legend_outside</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_outside_seaborn</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_location_seaborn</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">legend_loc</span><span class="p">)</span>
<span class="c1">#     if legend_dict_map is not None:</span>
<span class="c1">#         print(f&quot;Trying to set labels&quot;)</span>
<span class="c1">#         ax = mu.set_legend_labels_with_dict(</span>
<span class="c1">#             ax,</span>
<span class="c1">#             legend_dict_map</span>
<span class="c1">#         )</span>
    
    <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_size</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">legend_fontsize</span><span class="p">)</span>
    <span class="n">mu</span><span class="o">.</span><span class="n">set_legend_title</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span><span class="n">legend_title</span><span class="p">)</span>
    

    
    <span class="k">return</span> <span class="n">ax</span></div>
<span class="c1"># ----------------- Parameters ------------------------</span>

<span class="n">global_parameters_dict_default_spine_identification</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">query</span><span class="o">=</span><span class="s2">&quot;median_mesh_center &gt; 115 and n_faces_branch&gt;100&quot;</span><span class="p">,</span><span class="c1">#previous used median_mesh_center &gt; 140</span>
    <span class="n">calculate_spine_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>

    <span class="n">clusters_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="c1">#3,#2,</span>
    <span class="n">smoothness_threshold</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span><span class="c1">#0.12,#0.08,</span>
    <span class="n">shaft_close_hole_area_top_2_mean_max</span> <span class="o">=</span> <span class="mi">110_000</span><span class="p">,</span>
    <span class="n">shaft_mesh_volume_max</span> <span class="o">=</span> <span class="mf">0.3e9</span><span class="p">,</span>
    <span class="n">shaft_mesh_n_faces_min</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">shaft_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    
    <span class="c1"># --- the new bare minimum thresholds ----</span>
    <span class="n">spine_n_face_threshold_bare_min</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">spine_sk_length_threshold_bare_min</span> <span class="o">=</span> <span class="mf">306.6</span><span class="p">,</span>
    <span class="n">filter_by_volume_threshold_bare_min</span> <span class="o">=</span> <span class="mf">900496.186</span><span class="p">,</span>
    <span class="n">bbox_oriented_side_max_min_bare_min</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
    <span class="n">spine_volume_to_spine_area_min_bare_min</span> <span class="o">=</span> <span class="mf">0.008</span><span class="p">,</span>
    <span class="n">sdf_mean_min_bare_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
    <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="mi">1_000</span><span class="p">,</span>
    <span class="n">filter_by_bounding_box_longest_side_length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">side_length_threshold</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">filter_out_border_spines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1">#this seemed to cause a lot of misses</span>
    <span class="n">skeleton_endpoint_nullification</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">skeleton_endpoint_nullification_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">soma_vertex_nullification</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">border_percentage_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">check_spine_border_perc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>

    <span class="c1">#-------1/20 Addition --------</span>
    <span class="n">filter_by_volume</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="mi">19_835_293</span><span class="p">,</span> <span class="c1">#calculated from experiments   </span>
    
<span class="p">)</span>

<span class="n">global_parameters_dict_default_head_neck_shaft</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">head_smoothness</span> <span class="o">=</span> <span class="mf">0.09</span><span class="p">,</span><span class="c1">#0.15,</span>
    <span class="n">head_ray_trace_min</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
    <span class="n">head_face_min</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">only_allow_one_connected_component_neck</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
<span class="p">)</span>

<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_default_spine_identification</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_head_neck_shaft</span>
    
<span class="p">])</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="p">)</span>    

<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">global_parameters_dict_h01_spine_identification</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">spine_n_face_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">spine_sk_length_threshold</span> <span class="o">=</span> <span class="mi">1_000</span><span class="p">,</span>
    <span class="n">filter_by_volume_threshold</span> <span class="o">=</span> <span class="mi">50_000_000</span><span class="p">,</span><span class="c1">#19835293, #calculated from experiments   </span>
    
    <span class="n">clusters_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">smoothness_threshold</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span><span class="c1">#0.12,#0.08,</span>
    <span class="n">shaft_close_hole_area_top_2_mean_max</span> <span class="o">=</span> <span class="mi">260_000</span><span class="p">,</span>
    <span class="n">shaft_mesh_volume_max</span> <span class="o">=</span> <span class="mf">0.6e9</span><span class="p">,</span>
    <span class="n">shaft_mesh_n_faces_min</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    
    <span class="c1"># bare minimum filters </span>
    <span class="n">spine_volume_to_spine_area_min_bare_min</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">spine_n_face_threshold_bare_min</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    
<span class="p">)</span>
<span class="n">global_parameters_dict_h01_head_neck_shaft</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_h01_spine_identification</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_head_neck_shaft</span>
    
<span class="p">])</span>


<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>

<span class="c1"># modules_to_set = [spu]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">apical_utils</span> <span class="k">as</span> <span class="n">apu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">branch_attr_utils</span> <span class="k">as</span> <span class="n">bau</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">branch_utils</span> <span class="k">as</span> <span class="n">bu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">cell_type_utils</span> <span class="k">as</span> <span class="n">ctu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">width_utils</span> <span class="k">as</span> <span class="n">wu</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">dj_utils</span> <span class="k">as</span> <span class="n">dju</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">mesh_utils</span> <span class="k">as</span> <span class="n">meshu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">statistics_utils</span> <span class="k">as</span> <span class="n">stu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">tqdm_utils</span> <span class="k">as</span> <span class="n">tqu</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spine_utils</span> <span class="k">as</span> <span class="n">spu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
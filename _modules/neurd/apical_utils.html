<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.apical_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.apical_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.apical_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Module for helping to classify the different compartments</span>

<span class="sd">Compartment List and Description</span>
<span class="sd">-----------------------</span>
<span class="sd">axon:</span>
<span class="sd">soma:</span>
<span class="sd">apical_shaft (only excitatory): </span>
<span class="sd">    the first protrusion of the apical neurite from the soma (the shaft generally projects upward towards the top of the volume as a single lined entity</span>
<span class="sd">apical (only excitatory): </span>
<span class="sd">    all branches downstream of the first apical shaft protrusion (includes apical_shaft,apical_tuft,oblique). This compartment includes offshoots of the apical shaft that were not close to a 90 degree protrusion angle with respect to the the apical shaft trajectory</span>
<span class="sd">apical_tuft (only excitatory): </span>
<span class="sd">    the branches downstream of the point at which the apical shaft terminates its striaght upward trajectory and a branching point of 2 or more offshoots with a non straight upward trajectory</span>
<span class="sd">oblique (only excitatory):</span>
<span class="sd">    offshoots of the apical shaft (before the apical_tuft section) that were close to a 90 degree protrusion angle with respect to the the apical shaft trajectory</span>
<span class="sd">dendrite (only inhibitory):</span>
<span class="sd">    any non-axon neurites on an inhibitory cell</span>
<span class="sd">basal (only excitatory):</span>
<span class="sd">    any non-apical neurites on an excitatory cell</span>


<span class="sd">Good neuron to show off for classification</span>

<span class="sd">old_seg_id  = 864691135099943968</span>
<span class="sd">neuron_obj = du.decomposition_with_spine_recalculation(old_seg_id,0)</span>
<span class="sd">from . import apical_utils as apu</span>
<span class="sd">apu.apical_classification(neuron_obj,</span>
<span class="sd">                          plot_labels=True,</span>
<span class="sd">                          verbose = True</span>
<span class="sd">                         )</span>




<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>


<span class="n">compartment_colors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="n">apical</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
<span class="n">apical_shaft</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
<span class="n">apical_tuft</span> <span class="o">=</span> <span class="s2">&quot;purple&quot;</span><span class="p">,</span>
<span class="n">basal</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span><span class="c1">#&quot;yellow&quot;,</span>
<span class="n">axon</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
<span class="n">oblique</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
<span class="c1">#dendrite = &quot;lightsteelblue&quot;,</span>
<span class="n">dendrite</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
<span class="n">apical_total</span> <span class="o">=</span> <span class="s2">&quot;magenta&quot;</span><span class="p">,</span>
<span class="n">soma</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>

<span class="p">)</span>

<div class="viewcode-block" id="colors_from_compartments"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.colors_from_compartments">[docs]</a><span class="k">def</span> <span class="nf">colors_from_compartments</span><span class="p">(</span><span class="n">compartments</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">compartments</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">compartment_colors</span><span class="p">[</span><span class="n">compartments</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">compartment_colors</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compartments</span> <span class="p">]</span></div>

<span class="n">compartment_name_to_int_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="n">no_label</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="n">axon</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="n">basal</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="n">apical</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="n">apical_tuft</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="n">apical_shaft</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="n">oblique</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="n">soma</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">coarse_fine_compartment_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="n">no_label</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span>
<span class="n">dendrite</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span>
<span class="n">axon</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span>
<span class="n">basal</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;basal&quot;</span><span class="p">),</span>
<span class="n">apical</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;apical&quot;</span><span class="p">),</span>
<span class="n">apical_tuft</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;apical_tuft&quot;</span><span class="p">),</span>
<span class="n">apical_shaft</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">),</span>
<span class="n">oblique</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;oblique&quot;</span><span class="p">),</span>
<span class="n">soma</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">compartment_importance_rankings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coarse_fine_compartment_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="compartment_from_branch"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_from_branch">[docs]</a><span class="k">def</span> <span class="nf">compartment_from_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">):</span>
    <span class="n">curr_label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_importance_rankings</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>
        
    <span class="k">return</span> <span class="n">curr_label</span></div>

<span class="n">specific_apicals</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">,</span><span class="s2">&quot;apical_tuft&quot;</span><span class="p">,</span><span class="s2">&quot;oblique&quot;</span><span class="p">]</span>
<span class="n">apical_total</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;apical&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">specific_apicals</span>
<span class="n">dendrite_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">apical_total</span>

<span class="n">default_compartment_order</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;apical_tuft&quot;</span><span class="p">,</span>
              <span class="s2">&quot;apical_shaft&quot;</span><span class="p">,</span>
              <span class="s2">&quot;oblique&quot;</span><span class="p">,</span>
              <span class="s2">&quot;apical&quot;</span><span class="p">,</span>
              <span class="s2">&quot;basal&quot;</span><span class="p">,</span>
              <span class="s2">&quot;axon&quot;</span><span class="p">,]</span>
<div class="viewcode-block" id="compartments_to_plot"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartments_to_plot">[docs]</a><span class="k">def</span> <span class="nf">compartments_to_plot</span><span class="p">(</span><span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="s2">&quot;excitatory&quot;</span>
        
    <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_compartment_order</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="s2">&quot;dendrite&quot;</span><span class="p">]</span></div>
<span class="n">compartments_from_cell_type</span> <span class="o">=</span> <span class="n">compartments_to_plot</span>
    
<span class="n">default_compartment_label</span> <span class="o">=</span> <span class="s2">&quot;dendrite&quot;</span>

<div class="viewcode-block" id="dendrite_compartment_labels"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.dendrite_compartment_labels">[docs]</a><span class="k">def</span> <span class="nf">dendrite_compartment_labels</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coarse_fine_compartment_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="s2">&quot;no_label&quot;</span><span class="p">,</span><span class="s2">&quot;soma&quot;</span><span class="p">]]</span></div>

<div class="viewcode-block" id="compartment_labels_for_stats"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_labels_for_stats">[docs]</a><span class="k">def</span> <span class="nf">compartment_labels_for_stats</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coarse_fine_compartment_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;no_label&quot;</span><span class="p">,</span><span class="s2">&quot;soma&quot;</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;apical_total&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="compartment_labels_for_synapses_stats"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_labels_for_synapses_stats">[docs]</a><span class="k">def</span> <span class="nf">compartment_labels_for_synapses_stats</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coarse_fine_compartment_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;no_label&quot;</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;apical_total&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="compartment_labels_for_externals"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_labels_for_externals">[docs]</a><span class="k">def</span> <span class="nf">compartment_labels_for_externals</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coarse_fine_compartment_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;no_label&quot;</span><span class="p">,</span><span class="s2">&quot;soma&quot;</span><span class="p">]]</span></div>


<div class="viewcode-block" id="coarse_fine_compartment_from_label"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.coarse_fine_compartment_from_label">[docs]</a><span class="k">def</span> <span class="nf">coarse_fine_compartment_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coarse_fine_compartment_map</span><span class="p">[</span><span class="n">label</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="add_compartment_coarse_fine_to_df"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.add_compartment_coarse_fine_to_df">[docs]</a><span class="k">def</span> <span class="nf">add_compartment_coarse_fine_to_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">compartment_column</span> <span class="o">=</span> <span class="s2">&quot;compartment&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add compartment coarse and fine to a </span>
<span class="sd">    dataframe with a compartment column</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">coarse_fine_compartment_from_label</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> 
     <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">apu</span><span class="o">.</span><span class="n">coarse_fine_compartment_map</span> <span class="k">else</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">compartment_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()])</span>

    <span class="n">df_new</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">df_new</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;compartment_coarse&#39;</span><span class="p">,</span><span class="s2">&quot;compartment_fine&quot;</span><span class="p">]</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span><span class="n">df_new</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="compartment_label_to_all_labels"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_label_to_all_labels">[docs]</a><span class="k">def</span> <span class="nf">compartment_label_to_all_labels</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;dendrite&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dendrite_compartment_labels</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;apical_total&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">apical_total</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="spine_labels_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.spine_labels_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">spine_labels_from_compartment</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;bouton&quot;</span><span class="p">,</span><span class="s2">&quot;non_bouton&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;soma&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;no_label&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">spu</span><span class="o">.</span><span class="n">spine_labels</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bouton&quot;</span><span class="p">,</span><span class="s2">&quot;non_bouton&quot;</span><span class="p">]]</span></div>
    
<div class="viewcode-block" id="syn_type_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.syn_type_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">syn_type_from_compartment</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">dendrite_compartment_labels</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;postsyn&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;presyn&quot;</span><span class="p">,</span><span class="s2">&quot;postsyn&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="apical_shaft_like_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_shaft_like_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">apical_shaft_like_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">candidate</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">limbs_to_process</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">max_upward_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#30,</span>
                                       <span class="n">min_upward_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3000,</span>
                                        <span class="n">min_upward_per_match</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.8,</span>
                                     <span class="n">min_upward_length_backup</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#20000, </span>
                                     <span class="n">min_upward_per_match_backup</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.5,</span>
                                         <span class="n">width_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#140,</span>
                                       <span class="n">plot_shaft_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        
                                      <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will filter the limb branch for those that</span>
<span class="sd">    are apical shaft like</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_upward_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_upward_angle</span> <span class="o">=</span> <span class="n">max_upward_angle_shaft_like_global</span>
    <span class="k">if</span> <span class="n">min_upward_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upward_length</span> <span class="o">=</span> <span class="n">min_upward_length_shaft_like_global</span>
    <span class="k">if</span> <span class="n">min_upward_per_match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upward_per_match</span> <span class="o">=</span> <span class="n">min_upward_per_match_shaft_like_global</span>
    <span class="k">if</span> <span class="n">min_upward_length_backup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upward_length_backup</span> <span class="o">=</span> <span class="n">min_upward_length_backup_shaft_like_global</span>
    <span class="k">if</span> <span class="n">min_upward_per_match_backup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upward_per_match_backup</span> <span class="o">=</span> <span class="n">min_upward_per_match_backup_shaft_like_global</span>
    <span class="k">if</span> <span class="n">width_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_min</span> <span class="o">=</span> <span class="n">width_min_shaft_like_global</span>
    
    
    
    
    <span class="k">if</span> <span class="n">candidate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span>
    
    <span class="n">ap_shaft_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
               <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">skeleton_dist_match_ref_vector</span><span class="p">,</span>
                               <span class="n">ns</span><span class="o">.</span><span class="n">skeleton_perc_match_ref_vector</span><span class="p">,</span>
                              <span class="n">ns</span><span class="o">.</span><span class="n">width_new</span><span class="p">],</span>
               <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">reference_vector</span><span class="o">=</span><span class="n">mcu</span><span class="o">.</span><span class="n">top_of_layer_vector</span><span class="p">,</span>
                                   <span class="n">max_angle</span><span class="o">=</span><span class="n">max_upward_angle</span><span class="p">),</span>
               <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;(((skeleton_dist_match_ref_vector &gt; </span><span class="si">{</span><span class="n">min_upward_length</span><span class="si">}</span><span class="s2">) and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot; (skeleton_perc_match_ref_vector &gt; </span><span class="si">{</span><span class="n">min_upward_per_match</span><span class="si">}</span><span class="s2">)) &quot;</span>
                   <span class="sa">f</span><span class="s2">&quot; or ((skeleton_dist_match_ref_vector &gt; </span><span class="si">{</span><span class="n">min_upward_length_backup</span><span class="si">}</span><span class="s2">)  and &quot;</span>
                                           <span class="sa">f</span><span class="s2">&quot;(skeleton_perc_match_ref_vector &gt; </span><span class="si">{</span><span class="n">min_upward_per_match_backup</span><span class="si">}</span><span class="s2">))) and&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;(width_new &gt; </span><span class="si">{</span><span class="n">width_min</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
               <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                <span class="n">limbs_to_process</span><span class="o">=</span><span class="n">limbs_to_process</span><span class="p">,</span>
               <span class="n">plot_limb_branch_dict</span><span class="o">=</span><span class="n">plot_shaft_branches</span><span class="p">,</span>
                                           <span class="c1">#return_dataframe = True</span>
               <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ap_shaft_limb_branch= </span><span class="si">{</span><span class="n">ap_shaft_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ap_shaft_limb_branch</span></div>


<div class="viewcode-block" id="apical_shaft_classification_old"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_shaft_classification_old">[docs]</a><span class="k">def</span> <span class="nf">apical_shaft_classification_old</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">candidate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_shaft_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#for determining the shaft candidates</span>
    <span class="n">max_distance_from_soma_for_start_node</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
    <span class="n">plot_shaft_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#for filling in and filtering the candidates</span>
    <span class="n">skip_distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">plot_filtered_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#for picking final shaft</span>
    <span class="n">plot_final_shaft</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">return_limb_branch_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find apical shaft on apical candidates</span>

<span class="sd">    Psueodocode: </span>
<span class="sd">    1) Find the apical shaft query </span>
<span class="sd">    2) If there are shaft branches, divide them into candidates</span>
<span class="sd">    3) For each candidate filter into non-branching branch list</span>

<span class="sd">    4) Pick the largest candidate as winner</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import apical_utils as apu</span>
<span class="sd">    apu.apical_shaft_classification(neuron_obj,</span>
<span class="sd">                               candidate=apical_candidates[0],</span>
<span class="sd">                               verbose = True,</span>
<span class="sd">                               plot_shaft_branches=True,</span>
<span class="sd">                               plot_shaft_candidates=True,</span>
<span class="sd">                                plot_filtered_candidates = True,</span>
<span class="sd">                               plot_final_shaft=True,</span>

<span class="sd">                                skip_distance = 100000,</span>
<span class="sd">                                   )</span>


<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">apical_branches</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#1) Find the apical shaft query </span>
    <span class="n">shaft_limb_branch</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_shaft_like_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">candidate</span><span class="o">=</span><span class="n">candidate</span><span class="p">,</span>
                                            <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                                                             <span class="c1">#max_upward_angle=50,</span>
                                        <span class="n">plot_shaft_branches</span><span class="o">=</span><span class="n">plot_shaft_branches</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_limb_branch = </span><span class="si">{</span><span class="n">shaft_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_limb_branch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_limb_branch_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">apical_branches</span>
        
    <span class="c1">#2) If there are shaft branches, divide them into candidates</span>
    <span class="n">shaft_candidates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">candidate_groups_from_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                            <span class="n">shaft_limb_branch</span><span class="p">,</span>
                                                             <span class="n">plot_candidates</span> <span class="o">=</span> <span class="n">plot_shaft_candidates</span><span class="p">,</span>
                                                             <span class="n">max_distance_from_soma_for_start_node</span><span class="o">=</span><span class="n">max_distance_from_soma_for_start_node</span><span class="p">,</span>
                                                            <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_candidates = </span><span class="si">{</span><span class="n">shaft_candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_limb_branch_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">apical_branches</span>
        
    <span class="c1">#3) Filter all candidates into non-branching list</span>
    <span class="n">shaft_candidate_limb_branch</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cand</span> <span class="ow">in</span> <span class="n">shaft_candidates</span><span class="p">:</span>
        <span class="n">limb_name</span> <span class="o">=</span> <span class="n">cand</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]</span>
        <span class="n">curr_branch_lists</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">fill_in_and_filter_branch_groups_from_upstream_without_branching</span><span class="p">(</span>
                    <span class="n">limb_obj</span> <span class="o">=</span>  <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">],</span>
                    <span class="n">branches</span> <span class="o">=</span> <span class="n">cand</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">],</span>
                    <span class="n">start_branch</span> <span class="o">=</span> <span class="n">cand</span><span class="p">[</span><span class="s2">&quot;start_node&quot;</span><span class="p">],</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">skip_distance</span><span class="p">,</span>
                    <span class="n">plot_filtered_branches</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="p">)</span>
        <span class="n">shaft_candidate_limb_branch</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">limb_name</span><span class="p">:</span><span class="n">curr_branch_lists</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_candidate_limb_branch = </span><span class="si">{</span><span class="n">shaft_candidate_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_filtered_candidates</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting the filled_in_and_filtered candidates&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict_multiple</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                            <span class="n">shaft_candidate_limb_branch</span><span class="p">,</span>
                                            <span class="n">mesh_color_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">#4) Pick the largest candidate as winner</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_candidate_limb_branch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sk_lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_limb_branch</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shaft_candidate_limb_branch</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skeletal lengths for candidates = </span><span class="si">{</span><span class="n">sk_lens</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">winning_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">sk_lens</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">winning_idx</span> <span class="o">=</span> <span class="mi">0</span> 
        
    <span class="n">winning_limb_branch_dict</span> <span class="o">=</span> <span class="n">shaft_candidate_limb_branch</span><span class="p">[</span><span class="n">winning_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot_final_shaft</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting final shaft: </span><span class="si">{</span><span class="n">winning_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">winning_limb_branch_dict</span>
                                  <span class="p">)</span>
        
    
    <span class="k">if</span> <span class="n">return_limb_branch_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">winning_limb_branch_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">winning_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;More than one limb for shaft&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">winning_limb_branch_dict</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>
    
<div class="viewcode-block" id="filter_apical_candidates"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.filter_apical_candidates">[docs]</a><span class="k">def</span> <span class="nf">filter_apical_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">candidates</span><span class="p">,</span>
                             <span class="n">min_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#10_000,#30000,#50000,</span>
                            <span class="n">min_distance_above_soma</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#10_000,#30000,#100000,</span>
                             <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">print_node_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">plot_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">min_skeletal_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_skeletal_length</span> <span class="o">=</span> <span class="n">min_skeletal_length_filter_apical_global</span>
    <span class="k">if</span> <span class="n">min_distance_above_soma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_distance_above_soma</span> <span class="o">=</span> <span class="n">min_distance_above_soma_filter_apical_global</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="si">}</span><span class="s2"> apical shaft candidates&quot;</span><span class="p">)</span>
        
    <span class="n">objs_after_query</span><span class="p">,</span><span class="n">node_df</span>  <span class="o">=</span> <span class="n">flu</span><span class="o">.</span><span class="n">filter_candidates_by_query</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">candidates</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">,</span>
                              <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_over_candidate</span><span class="p">,</span>
                                                   <span class="n">name</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">),</span>
                                             <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">max_layer_distance_above_soma_over_candidate</span><span class="p">,</span>
                                                 <span class="n">name</span><span class="o">=</span><span class="s2">&quot;distance_above_soma&quot;</span><span class="p">)],</span>
                              <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(skeletal_length &gt; </span><span class="si">{</span><span class="n">min_skeletal_length</span><span class="si">}</span><span class="s2">) &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;and (distance_above_soma &gt; </span><span class="si">{</span><span class="n">min_distance_above_soma</span><span class="si">}</span><span class="s2">)&quot;</span>
                                   <span class="p">),</span>
                                                      <span class="n">return_df_before_query</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_node_attributes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node_df</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finish filtering with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">objs_after_query</span><span class="p">)</span><span class="si">}</span><span class="s2"> apical shaft candidates&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">plot_candidates</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting candidates after filter_apical_candidates&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">objs_after_query</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">objs_after_query</span></div>

<div class="viewcode-block" id="non_upward_skeletal_distance_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.non_upward_skeletal_distance_upstream">[docs]</a><span class="k">def</span> <span class="nf">non_upward_skeletal_distance_upstream</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">candidate</span><span class="p">,</span>
                                         <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                        <span class="n">min_angle</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the amount of non-upward facing</span>
<span class="sd">    skeletal lengths upstream of a certain candidate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_dist_match_ref_vector_sum_over_branches_upstream</span><span class="p">(</span>
    <span class="n">limb_obj</span> <span class="o">=</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]],</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">],</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="n">max_angle</span><span class="p">,</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="n">min_angle</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="filter_apical_candidates_to_one"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.filter_apical_candidates_to_one">[docs]</a><span class="k">def</span> <span class="nf">filter_apical_candidates_to_one</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">candidates</span><span class="p">,</span>
                                    <span class="n">non_upward_skeletal_distance_upstream_buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#-10000,</span>
                                    <span class="n">soma_diff_buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#-50000,</span>
                                    <span class="n">downstream_vector_diff_buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#-30000,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">default_tie_breaker</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#&quot;skeletal_length&quot;,</span>
                                    <span class="n">plot_final_candidate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">print_df_for_filter_to_one</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will filter down the remaining candidates to just one optimal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">non_upward_skeletal_distance_upstream_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">non_upward_skeletal_distance_upstream_buffer</span> <span class="o">=</span> <span class="n">non_upward_skeletal_distance_upstream_buffer_filter_apical_one_global</span>
    <span class="k">if</span> <span class="n">soma_diff_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_diff_buffer</span> <span class="o">=</span> <span class="n">soma_diff_buffer_filter_apical_one_global</span>
    <span class="k">if</span> <span class="n">downstream_vector_diff_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_vector_diff_buffer</span> <span class="o">=</span> <span class="n">downstream_vector_diff_buffer_filter_apical_one_global</span>
    <span class="k">if</span> <span class="n">default_tie_breaker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">default_tie_breaker</span> <span class="o">=</span> <span class="n">default_tie_breaker_filter_apical_one_global</span>
    
    
    <span class="n">shaft_candidates_filtered</span> <span class="o">=</span> <span class="n">candidates</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_candidates_filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">winning_shaft_candidate</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_candidates_filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">winning_shaft_candidate</span> <span class="o">=</span> <span class="n">shaft_candidates_filtered</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_candidates_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Has to apply graph filters to narrow down multiple candidates&quot;</span><span class="p">)</span>
        <span class="n">winning_candidates</span><span class="p">,</span> <span class="n">return_win_df</span>  <span class="o">=</span> <span class="n">flu</span><span class="o">.</span><span class="n">filter_candidates_to_one_by_query</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                             <span class="n">shaft_candidates_filtered</span><span class="p">,</span>
                                             <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">max_layer_distance_above_soma_over_candidate</span><span class="p">,</span>
                                                         <span class="n">name</span><span class="o">=</span><span class="s2">&quot;distance_above_soma&quot;</span><span class="p">),</span>
                                                            <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">downstream_dist_match_ref_vector_over_candidate</span><span class="p">,</span>
                                                                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;downstream_dist_match_ref_vector&quot;</span><span class="p">,</span>
                                                                <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">max_angle</span><span class="o">=</span><span class="mi">70</span><span class="p">)),</span>
                                                            <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">apu</span><span class="o">.</span><span class="n">non_upward_skeletal_distance_upstream</span><span class="p">)],</span>
                                            <span class="n">functions_list_graph</span><span class="o">=</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">flu</span><span class="o">.</span><span class="n">distance_above_soma_diff_from_max</span><span class="p">),</span>
                                                                 <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">flu</span><span class="o">.</span><span class="n">diff_from_max</span><span class="p">,</span>
                                                                      <span class="n">name</span><span class="o">=</span><span class="s2">&quot;downstream_vector_diff&quot;</span><span class="p">,</span>
                                                                      <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;downstream_dist_match_ref_vector&quot;</span><span class="p">)),</span>
                                                                  <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">flu</span><span class="o">.</span><span class="n">diff_from_min</span><span class="p">,</span>
                                                                      <span class="n">name</span><span class="o">=</span><span class="s2">&quot;upstream_non_upward_diff&quot;</span><span class="p">,</span>
                                                                      <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;non_upward_skeletal_distance_upstream&quot;</span><span class="p">))</span>
                                                                     <span class="p">],</span>
                                             <span class="n">queries</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;upstream_non_upward_diff &gt; </span><span class="si">{</span><span class="n">non_upward_skeletal_distance_upstream_buffer</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                                      <span class="sa">f</span><span class="s2">&quot;distance_above_soma_diff_from_max &gt; </span><span class="si">{</span><span class="n">soma_diff_buffer</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                                     <span class="sa">f</span><span class="s2">&quot;downstream_vector_diff &gt; </span><span class="si">{</span><span class="n">downstream_vector_diff_buffer</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
                                                                                 <span class="n">return_df_before_query</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_df_for_filter_to_one</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">return_win_df</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">winning_candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">winning_shaft_candidate</span> <span class="o">=</span> <span class="n">winning_candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using default tie breaker method </span><span class="si">{</span><span class="n">default_tie_breaker</span><span class="si">}</span><span class="s2"> because still </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">winning_candidates</span><span class="p">)</span><span class="si">}</span><span class="s2"> candidates&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">default_tie_breaker</span> <span class="o">==</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">:</span>
                <span class="n">candidate_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">winning_candidates</span><span class="p">]</span>
                <span class="n">winning_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">candidate_values</span><span class="p">)</span>
                <span class="n">winning_shaft_candidate</span> <span class="o">=</span> <span class="n">winning_candidates</span><span class="p">[</span><span class="n">winning_idx</span><span class="p">]</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented Type of tie breaker: </span><span class="si">{</span><span class="n">default_tie_breaker</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_shaft_candidate = </span><span class="si">{</span><span class="n">winning_shaft_candidate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_candidate</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting final candidate&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">winning_shaft_candidate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No winning candidate found&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">candidates</span><span class="o">=</span><span class="p">[</span><span class="n">winning_shaft_candidate</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">winning_shaft_candidate</span></div>


<div class="viewcode-block" id="expand_candidate_branches_to_soma"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.expand_candidate_branches_to_soma">[docs]</a><span class="k">def</span> <span class="nf">expand_candidate_branches_to_soma</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">candidate</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="n">plot_candidate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">candidate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="n">candidate</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">start_node</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;start_node&quot;</span><span class="p">]</span>
    <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]]</span>
    
    <span class="n">path_to_start</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_start_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">start_node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_to_start = </span><span class="si">{</span><span class="n">path_to_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">],</span><span class="n">path_to_start</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_candidate</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting final candidate&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">candidate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No winning candidate found&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">candidates</span><span class="o">=</span><span class="p">[</span><span class="n">candidate</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">candidate</span></div>


<div class="viewcode-block" id="apical_shaft_direct_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_shaft_direct_downstream">[docs]</a><span class="k">def</span> <span class="nf">apical_shaft_direct_downstream</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">downstream_buffer_from_soma</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
                                   <span class="n">plot_limb_branch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find those branches that come directly off the apical shaft</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.apical_shaft_direct_downstream(n_test,</span>
<span class="sd">                              plot_limb_branch=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">apical_starters</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                 <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">,</span>
                                                <span class="n">ns</span><span class="o">.</span><span class="n">upstream_node_is_apical_shaft</span><span class="p">,</span>
                                                 <span class="n">ns</span><span class="o">.</span><span class="n">labels_restriction</span>
                                                <span class="p">],</span>
                                  <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;(upstream_node_is_apical_shaft == True) and &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;(labels_restriction == True)&quot;</span><span class="p">),</span>
                                 <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">not_matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">]),</span>
                                 <span class="n">plot_limb_branch_dict</span><span class="o">=</span><span class="n">plot_limb_branch</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;apical_shaft_direct_downstream = </span><span class="si">{</span><span class="n">apical_starters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">apical_starters</span></div>

    

<div class="viewcode-block" id="apical_classification"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_classification">[docs]</a><span class="k">def</span> <span class="nf">apical_classification</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>

    <span class="c1">#filtering limbs</span>
    <span class="n">soma_angle_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_filtered_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">multi_apical_height</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1"># shaft-like limb branch</span>
    <span class="n">plot_shaft_like_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># finding shaft candidates</span>
    <span class="n">plot_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">candidate_connected_component_radius</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#5000,</span>
    <span class="n">multi_apical_possible</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1">#for base filtering</span>
    <span class="n">plot_base_filtered_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_base_filtered_df</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#filter to one candidate</span>
    <span class="n">plot_winning_candidate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_df_for_filter_to_one</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#expanding winning candidate</span>
    <span class="n">plot_winning_candidate_expanded</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># identifying entire apical</span>
    <span class="n">plot_apical_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">label_basal</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">label_apical_tuft</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">label_oblique</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    
    <span class="c1">#plotting the final labels</span>
    <span class="n">plot_labels</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">apply_synapse_compartment_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">rotation_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">unrotation_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_rotated_function</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will identify the limb branch</span>
<span class="sd">    that represents the apical shaft </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Filter the limbs that are being considered to have the shaft</span>
<span class="sd">    2) Find the shalft like limb branch</span>
<span class="sd">    3) Divide the shaft like limb branch into candidates</span>
<span class="sd">    4) Filter the shaft candidates for bare minimum requirements</span>
<span class="sd">    5) Filter shaft candidates to one winner</span>
<span class="sd">    6) If a winner was found --&gt; expand the shaft candidate to connect to soma</span>
<span class="sd">    7) Convert the winning candidate into a limb branch dict</span>
<span class="sd">    8) Find the limb branch dict of all the apical</span>
<span class="sd">    9) Add the apical_shaft and apical labels</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apical_limb_branch_dict = apu.apical_classification(n_test,</span>
<span class="sd">                            plot_labels = True,</span>
<span class="sd">                           verbose = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">soma_angle_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_angle_max</span> <span class="o">=</span> <span class="n">soma_angle_to_apical_global</span>
    <span class="k">if</span> <span class="n">multi_apical_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">multi_apical_height</span> <span class="o">=</span> <span class="n">multi_apical_height_global</span>
    <span class="k">if</span> <span class="n">rotation_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rotation_function</span> <span class="o">=</span> <span class="n">align_neuron_obj</span>
    <span class="k">if</span> <span class="n">unrotation_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unrotation_function</span> <span class="o">=</span> <span class="n">unalign_neuron_obj</span>
        
    <span class="k">if</span> <span class="n">candidate_connected_component_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">candidate_connected_component_radius</span> <span class="o">=</span> <span class="n">candidate_connected_component_radius_apical_global</span>
        
    <span class="k">if</span> <span class="n">multi_apical_possible</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">multi_apical_possible</span> <span class="o">=</span> <span class="n">multi_apical_possible_apical_global</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">rotation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">unrotation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">rotation_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_rotated_function</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_lite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="c1">#1) Filter the limbs that are being considered to have the shaft</span>
    <span class="k">if</span> <span class="n">soma_angle_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">filter_limbs_by_soma_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">soma_angle</span> <span class="o">=</span> <span class="n">soma_angle_max</span><span class="p">,</span>
                                                <span class="n">angle_less_than</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                               <span class="n">return_int_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Part 0: possible_apical_limbs = </span><span class="si">{</span><span class="n">possible_apical_limbs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_filtered_limbs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting filtered apical limbs&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_subset_neuron_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">possible_apical_limbs</span><span class="p">)</span>
        
    <span class="n">soma_layer_height</span> <span class="o">=</span> <span class="n">mcu</span><span class="o">.</span><span class="n">coordinates_to_layer_height</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_layer_height = </span><span class="si">{</span><span class="n">soma_layer_height</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">soma_layer_height</span> <span class="o">&gt;</span> <span class="n">multi_apical_height</span><span class="p">)</span> <span class="ow">and</span> <span class="n">multi_apical_possible</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Doing the multi apical solution&quot;</span><span class="p">)</span>
        <span class="n">apical_limb_branch</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_classification_high_soma_center</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                          <span class="n">plot_final_apical</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#2) Find the shalft like limb branch</span>
        <span class="n">apical_shaft_limb_branch</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_shaft_like_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limbs_to_process</span><span class="o">=</span><span class="n">possible_apical_limbs</span><span class="p">,</span>
                                        <span class="n">plot_shaft_branches</span><span class="o">=</span><span class="n">plot_shaft_like_limb_branch</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;apical_shaft_limb_branch = </span><span class="si">{</span><span class="n">apical_shaft_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#3) Grouping limb branch into candidates</span>
        <span class="n">shaft_candidates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">candidate_groups_from_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                <span class="n">apical_shaft_limb_branch</span><span class="p">,</span>
                                                                <span class="n">connected_component_method</span><span class="o">=</span><span class="s2">&quot;local_radius&quot;</span><span class="p">,</span>
                                                                <span class="n">radius</span> <span class="o">=</span> <span class="n">candidate_connected_component_radius</span><span class="p">,</span>
                                                                 <span class="n">plot_candidates</span><span class="o">=</span><span class="n">plot_candidates</span>
                                                                <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_candidates (before filtering): </span><span class="si">{</span><span class="n">shaft_candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        --------- Old Way of doing the filtering -------------</span>

<span class="sd">        shaft_candidates_filtered = apu.filter_candidates(neuron_obj,</span>
<span class="sd">                                                      filters = (&quot;skeletal_length&quot;,),    </span>
<span class="sd">                         candidates=shaft_candidates,</span>
<span class="sd">                         verbose = verbose)</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;\nshaft_candidates_filtered = {shaft_candidates_filtered}&quot;)</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#4) Filter the shaft candidates for bare minimum requirements</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shaft_candidates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shaft_candidates_filtered</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">filter_apical_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">shaft_candidates</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">print_node_attributes</span><span class="o">=</span><span class="n">plot_base_filtered_df</span><span class="p">,</span>
                                        <span class="n">plot_candidates</span> <span class="o">=</span> <span class="n">plot_base_filtered_candidates</span>
                                                                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_candidates_filtered = </span><span class="si">{</span><span class="n">shaft_candidates_filtered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#5) Filter shaft candidates to one winner</span>
            <span class="n">winning_candidate</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">filter_apical_candidates_to_one</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">shaft_candidates_filtered</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                           <span class="n">plot_final_candidate</span><span class="o">=</span><span class="n">plot_winning_candidate</span><span class="p">,</span>
                                            <span class="n">print_df_for_filter_to_one</span><span class="o">=</span><span class="n">print_df_for_filter_to_one</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">winning_candidate</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_candidate = </span><span class="si">{</span><span class="n">winning_candidate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">winning_candidate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#6) If a winner was found --&gt; expand the shaft candidate to connect to soma</span>
            <span class="n">final_shaft_candidate</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">expand_candidate_branches_to_soma</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">candidate</span><span class="o">=</span><span class="n">winning_candidate</span><span class="p">,</span>
                                      <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                      <span class="n">plot_candidate</span><span class="o">=</span><span class="n">plot_winning_candidate_expanded</span><span class="p">,</span>
                                     <span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning candidate expandid = </span><span class="si">{</span><span class="n">final_shaft_candidate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#7) Convert the winning candidate into a limb branch dict</span>
            <span class="n">shaft_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">final_shaft_candidate</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_limb_branch = </span><span class="si">{</span><span class="n">shaft_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># 7b) Adding the shaft labels</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">clear_all_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,[</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">,</span><span class="s2">&quot;apical&quot;</span><span class="p">])</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">shaft_limb_branch</span><span class="p">,</span>
                            <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;apical&quot;</span><span class="p">,</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">])</span>

            <span class="c1">#8) Find the limb branch dict of all the apical</span>
            <span class="n">apical_downstream_limb_branch</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_shaft_direct_downstream</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">plot_limb_branch</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">apical_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_donwstream_branches_from_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                             <span class="n">apical_downstream_limb_branch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apical_limb_branch</span> <span class="o">=</span> <span class="p">{}</span>
        
    <span class="c1"># 7b) Adding the shaft labels</span>
    <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">apical_limb_branch</span><span class="p">,</span>
                    <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;apical&quot;</span><span class="p">])</span>



    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;apical_limb_branch = </span><span class="si">{</span><span class="n">apical_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">label_basal</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding basal labels&quot;</span><span class="p">)</span>
        <span class="n">apu</span><span class="o">.</span><span class="n">basal_classfication</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">label_apical_tuft</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding apical tuft labels&quot;</span><span class="p">)</span>
        <span class="n">apu</span><span class="o">.</span><span class="n">apical_tuft_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                                      <span class="c1">#plot_apical_tuft=True</span>
                                      <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">label_oblique</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding oblique labels&quot;</span><span class="p">)</span>
        <span class="n">apu</span><span class="o">.</span><span class="n">oblique_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                  <span class="c1">#plot_oblique=True</span>
                                  <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_labels</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting compartment classifications&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_compartments</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="p">)</span>
        
    <span class="k">if</span> <span class="p">(</span><span class="n">rotation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">unrotation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1">#print(f&quot;neuron_obj.apical_limb_branch_dict = {neuron_obj.apical_limb_branch_dict}&quot;)</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">unrotation_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        <span class="c1">#print(f&quot;neuron_obj.apical_limb_branch_dict = {neuron_obj.apical_limb_branch_dict}&quot;)</span>
        
    <span class="k">if</span> <span class="n">apply_synapse_compartment_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding the compartment labels to the synapses&quot;</span><span class="p">)</span>
        <span class="n">apu</span><span class="o">.</span><span class="n">set_neuron_synapses_compartment</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">neuron_obj</span><span class="p">,</span><span class="n">apu</span><span class="o">.</span><span class="n">apical_total_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="compartment_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">compartment_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">compartment_labels</span><span class="p">,</span>
                                 <span class="n">not_matching_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">match_type</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">compartment_labels</span><span class="p">,</span>
                                     <span class="n">match_type</span><span class="o">=</span><span class="n">match_type</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="dendrite_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.dendrite_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">dendrite_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">dendrite_labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="axon_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.axon_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;axon&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="apical_total_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_total_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">apical_total_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">apical_total</span><span class="p">)</span></div>

<div class="viewcode-block" id="apical_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">apical_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;apical&quot;</span><span class="p">,</span>
                                     <span class="n">not_matching_labels</span><span class="o">=</span><span class="n">specific_apicals</span><span class="p">)</span></div>

<div class="viewcode-block" id="apical_shaft_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_shaft_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">apical_shaft_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="apical_tuft_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_tuft_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">apical_tuft_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;apical_tuft&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="basal_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.basal_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">basal_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;basal&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="oblique_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.oblique_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">oblique_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;oblique&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="basal_classfication"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.basal_classfication">[docs]</a><span class="k">def</span> <span class="nf">basal_classfication</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">plot_basal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">clear_prior_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To identify and label the basal branches</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dendrite_limb_branch</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span>
    <span class="n">apical_limb_branch_dict</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_total_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">basal_limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_setdiff</span><span class="p">([</span><span class="n">dendrite_limb_branch</span><span class="p">,</span><span class="n">apical_limb_branch_dict</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">add_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">clear_prior_labels</span><span class="p">:</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">clear_all_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,[</span><span class="s2">&quot;basal&quot;</span><span class="p">])</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">basal_limb_branch_dict</span><span class="p">,</span>
                        <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;basal_limb_branch_dict = </span><span class="si">{</span><span class="n">basal_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_basal</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">basal_limb_branch_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">basal_limb_branch_dict</span></div>


<div class="viewcode-block" id="apical_tuft_classification"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_tuft_classification">[docs]</a><span class="k">def</span> <span class="nf">apical_tuft_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">plot_apical_tuft</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">clear_prior_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">add_low_degree_apicals_off_shaft</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#False,</span>
                               <span class="n">low_degree_apicals_min_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0,</span>
                            <span class="n">low_degree_apicals_max_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#40,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;apical_tuft&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To classify the apical tuft branches</span>
<span class="sd">    based on previous apical shaft and apical classification</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the nodes of the apical shaft that have no downstream apical shaft branches</span>
<span class="sd">    (assemble them into a limb branch)</span>
<span class="sd">    2) make all downstream branches of those the apical tuft</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.apical_tuft_classification(neuron_obj,</span>
<span class="sd">                               plot_apical_tuft = True,</span>
<span class="sd">                               add_labels = True,</span>
<span class="sd">                                clear_prior_labels=True,</span>
<span class="sd">                              verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">add_low_degree_apicals_off_shaft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">add_low_degree_apicals_off_shaft</span> <span class="o">=</span> <span class="n">add_low_degree_apicals_off_shaft_tuft_global</span>
    <span class="k">if</span> <span class="n">low_degree_apicals_min_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">low_degree_apicals_min_angle</span> <span class="o">=</span> <span class="n">low_degree_apicals_min_angle_tuft_global</span>
    <span class="k">if</span> <span class="n">low_degree_apicals_max_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">low_degree_apicals_max_angle</span> <span class="o">=</span> <span class="n">low_degree_apicals_max_angle_tuft_global</span>
    
    <span class="n">apical_shaft_ending</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span>
                                  <span class="n">ns</span><span class="o">.</span><span class="n">is_apical_shaft_in_downstream_branches</span><span class="p">,</span>
                                  <span class="p">],</span>
                    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;(is_apical_shaft_in_downstream_branches == False)&quot;</span><span class="p">,</span>
                   <span class="c1">#function_kwargs=dict(matching_labels=[&quot;apical_shaft&quot;]),</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">apical_shaft_limb_branch_dict</span><span class="p">,</span>

                   <span class="p">)</span>
    <span class="n">apical_tuft_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_donwstream_branches_from_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">apical_shaft_ending</span><span class="p">,</span>
                                                <span class="n">include_limb_branch_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">add_low_degree_apicals_off_shaft</span><span class="p">:</span>
        <span class="n">low_degree_apicals_limb_branch</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">oblique_classification</span><span class="p">(</span>
                            <span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">plot_apical_shaft_direct_downstream</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="c1">#arguments for identifying the start of olbiques</span>
                            <span class="n">min_angle</span> <span class="o">=</span> <span class="n">low_degree_apicals_min_angle</span><span class="p">,</span>
                            <span class="n">max_angle</span> <span class="o">=</span> <span class="n">low_degree_apicals_max_angle</span><span class="p">,</span>
                            <span class="n">plot_oblique_start</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">plot_oblique</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

                            <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">clear_prior_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;apical_tuft&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;low_degree_apicals_limb_branch = </span><span class="si">{</span><span class="n">low_degree_apicals_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_low_degree_apicals_off_shaft</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting low_degree_apicals_off_shaft&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">low_degree_apicals_limb_branch</span><span class="p">)</span>
        <span class="n">apical_tuft_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_union</span><span class="p">([</span><span class="n">apical_tuft_limb_branch</span><span class="p">,</span>
                                                        <span class="n">low_degree_apicals_limb_branch</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;apical_tuft_limb_branch = </span><span class="si">{</span><span class="n">apical_tuft_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_apical_tuft</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting apical tuft&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">apical_tuft_limb_branch</span><span class="p">)</span>

    <span class="n">curr_label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">if</span> <span class="n">add_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">clear_prior_labels</span><span class="p">:</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">clear_all_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,[</span><span class="n">curr_label</span><span class="p">])</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">apical_tuft_limb_branch</span><span class="p">,</span>
                        <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">curr_label</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">apical_tuft_limb_branch</span></div>


<div class="viewcode-block" id="oblique_classification"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.oblique_classification">[docs]</a><span class="k">def</span> <span class="nf">oblique_classification</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">plot_apical_shaft_direct_downstream</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1">#arguments for identifying the start of olbiques</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#80,</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#140,</span>
    <span class="n">per_match_ref_vector_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.8,</span>
    <span class="n">dist_match_ref_vector_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#10000,</span>
    <span class="n">plot_oblique_start</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_oblique</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">add_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">clear_prior_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;oblique&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the branches</span>
<span class="sd">    that come of the apical shaft at a certain degree</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the apical_shaft_direct_downstream</span>
<span class="sd">    2) Filter those branches for those with a certain angle</span>
<span class="sd">    3) Find all branches downstream of those with a certain </span>
<span class="sd">    angle as the oblique branches</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">min_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_angle</span> <span class="o">=</span> <span class="n">min_angle_oblique_global</span>
    <span class="k">if</span> <span class="n">max_angle</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="n">max_angle_oblique_global</span>
    <span class="k">if</span> <span class="n">per_match_ref_vector_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">per_match_ref_vector_min</span> <span class="o">=</span> <span class="n">per_match_ref_vector_min_oblique_global</span>
    <span class="k">if</span> <span class="n">dist_match_ref_vector_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dist_match_ref_vector_min</span> <span class="o">=</span> <span class="n">dist_match_ref_vector_min_oblique_global</span>



    <span class="c1">#1) Get the apical_shaft_direct_downstream</span>
    <span class="n">shaft_direct</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_shaft_direct_downstream</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">plot_limb_branch</span><span class="o">=</span><span class="n">plot_apical_shaft_direct_downstream</span><span class="p">)</span>
    <span class="n">shaft_direct_no_tuft</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_setdiff</span><span class="p">([</span><span class="n">shaft_direct</span><span class="p">,</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">apical_tuft_limb_branch_dict</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shaft_direct = </span><span class="si">{</span><span class="n">shaft_direct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#2) Filter those branches for those with a certain angle</span>
    <span class="n">oblique_start_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">skeleton_dist_match_ref_vector</span><span class="p">,</span>
                                  <span class="n">ns</span><span class="o">.</span><span class="n">skeleton_perc_match_ref_vector</span><span class="p">,],</span>
                    <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(skeleton_dist_match_ref_vector &gt; </span><span class="si">{</span><span class="n">dist_match_ref_vector_min</span><span class="si">}</span><span class="s2">) or &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;(skeleton_perc_match_ref_vector &gt; </span><span class="si">{</span><span class="n">per_match_ref_vector_min</span><span class="si">}</span><span class="s2">)&quot;</span>
                          <span class="p">),</span>
                   <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">max_angle</span><span class="o">=</span><span class="n">max_angle</span><span class="p">,</span>
                                       <span class="n">min_angle</span><span class="o">=</span><span class="n">min_angle</span><span class="p">),</span>
                                               <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">shaft_direct_no_tuft</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;oblique_start_limb_branch = </span><span class="si">{</span><span class="n">oblique_start_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_oblique_start</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting oblique start&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">oblique_start_limb_branch</span><span class="p">)</span>

    <span class="c1">#3) Find all branches downstream of those with a certain </span>
    <span class="n">oblique_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_donwstream_branches_from_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                 <span class="n">oblique_start_limb_branch</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;oblique_limb_branch = </span><span class="si">{</span><span class="n">oblique_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_oblique</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting final oblique&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">oblique_limb_branch</span><span class="p">)</span>
    
    <span class="n">curr_label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">if</span> <span class="n">add_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">clear_prior_labels</span><span class="p">:</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">clear_all_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,[</span><span class="n">curr_label</span><span class="p">])</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">oblique_limb_branch</span><span class="p">,</span>
                        <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">curr_label</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">oblique_limb_branch</span></div>

<div class="viewcode-block" id="apical_classification_high_soma_center"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.apical_classification_high_soma_center">[docs]</a><span class="k">def</span> <span class="nf">apical_classification_high_soma_center</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    
    <span class="c1">#determing the possible apical limbs</span>
    <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_angle_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          
    <span class="n">plot_filtered_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">width_min</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>
    <span class="n">distance_from_soma</span> <span class="o">=</span> <span class="mi">80000</span><span class="p">,</span>
    <span class="n">plot_thick_apical_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1">#for filtering the candidate limbs </span>
    <span class="n">min_thick_near_soma_skeletal_length</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>

    <span class="n">plot_final_apical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To identify multiple</span>
<span class="sd">    possible apicals that are at the </span>
<span class="sd">    top of the soma mesh</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) If necessary, filter the limbs</span>
<span class="sd">    2) ON the limbs find the number of fat limbs within certain radius of soma</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.apical_classification_high_soma_center(n_obj_1,</span>
<span class="sd">                                           verbose = True,</span>
<span class="sd">                                          plot_final_apical=True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">soma_angle_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_angle_max</span> <span class="o">=</span> <span class="n">soma_angle_to_apical_global</span>
        
    <span class="k">if</span> <span class="n">width_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_min</span> <span class="o">=</span> <span class="n">width_min_apical_high_soma_global</span>
    <span class="k">if</span> <span class="n">distance_from_soma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">distance_from_soma</span> <span class="o">=</span> <span class="n">distance_from_soma_apical_high_soma_global</span>
    <span class="k">if</span> <span class="n">min_thick_near_soma_skeletal_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_thick_near_soma_skeletal_length</span> <span class="o">=</span> <span class="n">min_thick_near_soma_skeletal_length_apical_high_soma_global</span>
    
    <span class="c1">#1) Filter the limbs that are being considered to have the shaft</span>
    <span class="k">if</span> <span class="n">possible_apical_limbs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">soma_angle_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">filter_limbs_by_soma_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                    <span class="n">soma_angle</span> <span class="o">=</span> <span class="n">soma_angle_max</span><span class="p">,</span>
                                                    <span class="n">angle_less_than</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                   <span class="n">return_int_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Part 0: possible_apical_limbs = </span><span class="si">{</span><span class="n">possible_apical_limbs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_filtered_limbs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting filtered POSSIBLE apical limbs&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_subset_neuron_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">possible_apical_limbs</span><span class="p">)</span>


    <span class="c1"># query for large fat branches near</span>
    <span class="n">thick_apical_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(distance_from_soma &lt; </span><span class="si">{</span><span class="n">distance_from_soma</span><span class="si">}</span><span class="s2">) and &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;(width_new &gt; </span><span class="si">{</span><span class="n">width_min</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">),</span>
                    <span class="n">functions_list</span><span class="o">=</span> <span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">,</span>
                                      <span class="n">ns</span><span class="o">.</span><span class="n">width_new</span><span class="p">],</span>
                   <span class="n">limbs_to_process</span><span class="o">=</span><span class="n">possible_apical_limbs</span><span class="p">,</span>
                   <span class="n">plot_limb_branch_dict</span><span class="o">=</span><span class="n">plot_thick_apical_candidates</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;thick_apical_limb_branch = </span><span class="si">{</span><span class="n">thick_apical_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">final_apical_limbs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">possible_apical_limbs</span><span class="p">:</span>
        <span class="n">limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">thick_apical_limb_branch</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">curr_sk_length</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">sum_feature_over_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">],</span>
                                         <span class="n">thick_apical_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">],</span>
                                         <span class="n">feature_name</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_sk_length</span> <span class="o">&gt;</span> <span class="n">min_thick_near_soma_skeletal_length</span><span class="p">:</span>
                
                <span class="n">final_apical_limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span>

    <span class="n">final_apical_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">final_apical_limbs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_apical_limb_branch = </span><span class="si">{</span><span class="n">final_apical_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_apical</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting final apical from limb angle approach&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">final_apical_limb_branch</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">final_apical_limb_branch</span></div>


<div class="viewcode-block" id="compartment_label_from_branch_obj"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_label_from_branch_obj">[docs]</a><span class="k">def</span> <span class="nf">compartment_label_from_branch_obj</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                      <span class="n">label_order</span> <span class="o">=</span> <span class="n">default_compartment_order</span><span class="p">,</span>
                                      <span class="n">default_label</span> <span class="o">=</span> <span class="n">default_compartment_label</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add compartment</span>
<span class="sd">    labels to all the synapses of a branch</span>
<span class="sd">    based on the branch labels</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Define order of labels to check for</span>
<span class="sd">    For each label</span>
<span class="sd">    1) check to see if label is in the labels</span>
<span class="sd">    of branch</span>
<span class="sd">    2a) if so then add the numbered label to </span>
<span class="sd">    all the synapses in the branch and break</span>
<span class="sd">    2b) if not then continue to the next label</span>

<span class="sd">    Ex: </span>
<span class="sd">    apu.compartment_label_from_branch_obj(branch_obj = neuron_obj[0][0],</span>
<span class="sd">verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">curr_label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">label_order</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="n">curr_label</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">curr_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_label</span> <span class="o">=</span> <span class="n">default_label</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found label = </span><span class="si">{</span><span class="n">curr_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">curr_label</span></div>

<div class="viewcode-block" id="set_neuron_synapses_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.set_neuron_synapses_compartment">[docs]</a><span class="k">def</span> <span class="nf">set_neuron_synapses_compartment</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will set the compartment labels of all synapses</span>
<span class="sd">    based on the compartment label of te branch</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">syu</span><span class="o">.</span><span class="n">set_neuron_synapses_compartment</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="compartment_classification_by_cell_type"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_classification_by_cell_type">[docs]</a><span class="k">def</span> <span class="nf">compartment_classification_by_cell_type</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">cell_type</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">plot_compartments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">apply_synapse_compartment_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will label a neuron by the compartments</span>
<span class="sd">    based on the cell type</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running apical classification because excitatory cell &quot;</span><span class="p">)</span>
        <span class="n">neuron_obj</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">apical_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                 <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                 <span class="n">apply_synapse_compartment_labels</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;inhibitory&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not running any new classification because inhibitory cell&quot;</span><span class="p">)</span>
            
        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">,</span>
                        <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dendrite&quot;</span><span class="p">])</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown cell type = </span><span class="si">{</span><span class="n">cell_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">apply_synapse_compartment_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding the compartment labels to the synapses&quot;</span><span class="p">)</span>
        <span class="n">apu</span><span class="o">.</span><span class="n">set_neuron_synapses_compartment</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_compartments</span><span class="p">:</span> 
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_compartments</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">neuron_obj</span></div>


<div class="viewcode-block" id="compartments_stats"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartments_stats">[docs]</a><span class="k">def</span> <span class="nf">compartments_stats</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">compartment_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute statistics for all the compartments</span>
<span class="sd">    of a neuron_obj</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For each compartment label:</span>
<span class="sd">    1) Get the limb branch dict</span>
<span class="sd">    2) Get the stats over that limb branch</span>
<span class="sd">    3) Add to larger dict with modified names</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.compartment_stats(neuron_obj_proof,</span>
<span class="sd">                     compartment_labels = None,</span>
<span class="sd">                     verbose = True) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">compartment_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  
        <span class="n">compartment_labels</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_labels_for_stats</span><span class="p">()</span>
    
    <span class="n">stats_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartment_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- Working on </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">apu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">_limb_branch_dict&quot;</span><span class="p">)</span>
        <span class="n">comp_limb_branch</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
        <span class="n">local_stats</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">stats_dict_over_limb_branch</span><span class="p">(</span>
            <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">comp_limb_branch</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;local_stats = </span><span class="si">{</span><span class="n">local_stats</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">stats_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">local_stats</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        
    <span class="k">return</span> <span class="n">stats_dict</span></div>

<div class="viewcode-block" id="compartment_feature_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_feature_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">compartment_feature_over_limb_branch_dict</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span><span class="p">,</span>
    <span class="n">feature_for_sum</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To compute a certain feature over ONE compartment</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">compartment_label</span>
    <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">apu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">_limb_branch_dict&quot;</span><span class="p">)</span>
    <span class="n">comp_limb_branch</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">feature_for_sum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">local_val</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">feature_for_sum</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">feature_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">local_val</span> <span class="o">=</span> <span class="n">feature_func</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">comp_limb_branch</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">local_val</span></div>

<div class="viewcode-block" id="compartments_feature_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartments_feature_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">compartments_feature_over_limb_branch_dict</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_for_sum</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute statistics for all the compartments</span>
<span class="sd">    of a neuron_obj</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For each compartment label:</span>
<span class="sd">    1) Get the limb branch dict</span>
<span class="sd">    2) Get the stats over that limb branch</span>
<span class="sd">    3) Add to larger dict with modified names</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.compartment_stats(neuron_obj_proof,</span>
<span class="sd">                     compartment_labels = None,</span>
<span class="sd">                     verbose = True) </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spu</span><span class="o">.</span><span class="n">set_soma_synapses_spine_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">compartment_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  
        <span class="n">compartment_labels</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_labels_for_stats</span><span class="p">()</span>
    
        
    <span class="n">global_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartment_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-- Working on </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
        <span class="n">local_val</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_feature_over_limb_branch_dict</span><span class="p">(</span>
                         <span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">c</span><span class="p">,</span>
                         <span class="n">feature_for_sum</span> <span class="o">=</span> <span class="n">feature_for_sum</span><span class="p">,</span>
                         <span class="n">feature_func</span> <span class="o">=</span> <span class="n">feature_func</span><span class="p">,)</span>
            
        <span class="n">dict_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">feature_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dict_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">feature_name</span><span class="si">}</span><span class="s2">&quot;</span>
            
        <span class="n">global_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dict_name</span><span class="p">:</span><span class="n">local_val</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">global_dict</span></div>

<div class="viewcode-block" id="compartments_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartments_skeleton">[docs]</a><span class="k">def</span> <span class="nf">compartments_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">compartment_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">compartment_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  
        <span class="n">compartment_labels</span> <span class="o">=</span> <span class="n">compartment_labels_for_externals</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">compartments_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">compartment_labels</span> <span class="o">=</span> <span class="n">compartment_labels</span><span class="p">,</span>
                         <span class="n">feature_func</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_limb_branch_dict</span><span class="p">,</span>
                         <span class="n">feature_name</span> <span class="o">=</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="compartment_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_skeleton">[docs]</a><span class="k">def</span> <span class="nf">compartment_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">compartment_label</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_feature_over_limb_branch_dict</span><span class="p">(</span>
                         <span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">compartment_label</span><span class="p">,</span>
                         <span class="n">feature_func</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_limb_branch_dict</span><span class="p">,)</span></div>
    
    

<div class="viewcode-block" id="compartments_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartments_mesh">[docs]</a><span class="k">def</span> <span class="nf">compartments_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">compartment_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">compartment_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  
        <span class="n">compartment_labels</span> <span class="o">=</span> <span class="n">compartment_labels_for_externals</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">compartments_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">compartment_labels</span> <span class="o">=</span> <span class="n">compartment_labels</span><span class="p">,</span>
                         <span class="n">feature_func</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">mesh_over_limb_branch_dict</span><span class="p">,</span>
                         <span class="n">feature_name</span> <span class="o">=</span> <span class="s2">&quot;mesh&quot;</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="compartment_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_mesh">[docs]</a><span class="k">def</span> <span class="nf">compartment_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">compartment_label</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_feature_over_limb_branch_dict</span><span class="p">(</span>
                         <span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">compartment_label</span><span class="p">,</span>
                         <span class="n">feature_func</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">mesh_over_limb_branch_dict</span><span class="p">,)</span></div>


<div class="viewcode-block" id="compartment_features_from_skeleton_and_soma_center"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_features_from_skeleton_and_soma_center">[docs]</a><span class="k">def</span> <span class="nf">compartment_features_from_skeleton_and_soma_center</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                      <span class="n">compartment_label</span><span class="p">,</span>
                                                       <span class="n">features_to_exclude</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span><span class="s2">&quot;n_branches&quot;</span><span class="p">),</span>
                                                       <span class="n">soma_label</span> <span class="o">=</span> <span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                                       <span class="n">soma_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                       <span class="n">name_prefix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                       <span class="n">include_soma_starting_angles</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                       <span class="n">neuron_obj_aligned</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will compute features about a compartment</span>
<span class="sd">    from its skeleton and the skeleton in relation to the soma</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.compartment_features_from_skeleton_and_soma_center(neuron_obj_proof,</span>
<span class="sd">                                                  compartment_label = &quot;oblique&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name_prefix</span> <span class="o">=</span> <span class="n">compartment_label</span>
    <span class="k">if</span> <span class="n">soma_center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">soma_label</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
        
    <span class="k">if</span> <span class="n">neuron_obj_aligned</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="n">neuron_obj_aligned</span><span class="o">.</span><span class="n">skeleton</span>
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">neuron_obj_aligned</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">compartment_skeleton</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">compartment_label</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">features_from_skeleton_and_soma_center</span><span class="p">(</span><span class="n">compartment_skeleton</span><span class="p">,</span>
                                              <span class="n">soma_center</span> <span class="o">=</span> <span class="n">soma_center</span><span class="p">,</span>
                                              <span class="n">name_prefix</span><span class="o">=</span><span class="n">name_prefix</span><span class="p">,</span>
                                              <span class="n">features_to_exclude</span> <span class="o">=</span> <span class="n">features_to_exclude</span><span class="p">,</span>
                                                      <span class="n">skeleton_aligned</span><span class="o">=</span><span class="n">skeleton_aligned</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="print_compartment_features_dict_for_dj_table"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.print_compartment_features_dict_for_dj_table">[docs]</a><span class="k">def</span> <span class="nf">print_compartment_features_dict_for_dj_table</span><span class="p">(</span><span class="n">comp_feature_dict</span><span class="p">):</span>
    <span class="n">int_unsigned_group</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_branches&quot;</span><span class="p">,</span>
                         <span class="s2">&quot;n_short_branches&quot;</span><span class="p">,</span>
                         <span class="s2">&quot;n_long_branches&quot;</span><span class="p">,</span>
                         <span class="s2">&quot;n_medium_branches&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">comp_feature_dict</span><span class="p">:</span>
        <span class="n">int_unsigned_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">int_unsigned_group</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">int_unsigned_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
                
        <span class="k">if</span> <span class="n">int_unsigned_flag</span><span class="p">:</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;int unsigned&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;double&quot;</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=NULL: </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="plot_compartment_mesh_and_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.plot_compartment_mesh_and_skeleton">[docs]</a><span class="k">def</span> <span class="nf">plot_compartment_mesh_and_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">compartment_label</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.plot_compartment_mesh_and_skeleton(neuron_obj_proof,&quot;basal&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">comp_mesh</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">compartment_label</span><span class="p">)</span>
    <span class="n">comp_sk</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">compartment_label</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">comp_mesh</span><span class="p">,</span><span class="n">comp_sk</span><span class="p">,</span>
                         <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No mesh and/or skeleton for this compartment&quot;</span><span class="p">)</span></div>
    

    
<div class="viewcode-block" id="soma_angle_extrema_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.soma_angle_extrema_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">soma_angle_extrema_from_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">extrema_type</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find the max or min</span>
<span class="sd">    soma starting angle for all limbs with that compartment</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">compartment_limb_branch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">apu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compartment_label</span><span class="si">}</span><span class="s2">_limb_branch_dict&quot;</span><span class="p">)</span>
        <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>


    <span class="n">return_value</span> <span class="o">=</span> <span class="n">default_value</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartment_limb_branch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">limb_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_idx</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">compartment_limb_branch</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>

        <span class="n">return_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">extrema_type</span><span class="p">)(</span><span class="n">limb_angles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_angles = </span><span class="si">{</span><span class="n">limb_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extrema_type</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">compartment_label</span><span class="si">}</span><span class="s2"> limb branch&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="soma_angle_min_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.soma_angle_min_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">soma_angle_min_from_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">soma_angle_extrema_from_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span> <span class="o">=</span> <span class="n">compartment_label</span><span class="p">,</span>
    <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="n">compartment_limb_branch</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="n">default_value</span><span class="p">,</span>
    <span class="n">extrema_type</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="soma_angle_max_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.soma_angle_max_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">soma_angle_max_from_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">soma_angle_extrema_from_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span> <span class="o">=</span> <span class="n">compartment_label</span><span class="p">,</span>
    <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="n">compartment_limb_branch</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="n">default_value</span><span class="p">,</span>
    <span class="n">extrema_type</span> <span class="o">=</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="limb_features_from_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.limb_features_from_compartment">[docs]</a><span class="k">def</span> <span class="nf">limb_features_from_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment_label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">compartment_limb_branch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">rotation_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">apply_rotation</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute limb features that depend on alignment of neuron</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Align neuron</span>
<span class="sd">    2) Get the compartment limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apu.limb_features_from_compartment(</span>
<span class="sd">        neuron_obj,</span>
<span class="sd">        compartment_limb_branch=neuron_obj.dendrite_limb_branch_dict,</span>
<span class="sd">        compartment_label=&quot;axon&quot;,</span>
<span class="sd">        apply_rotation=True,</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rotation_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rotation_function</span> <span class="o">=</span> <span class="n">align_neuron_obj</span>
    
    <span class="k">if</span> <span class="n">rotation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">apply_rotation</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">rotation_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">compartment_limb_branch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">apu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compartment_label</span><span class="si">}</span><span class="s2">_limb_branch_dict&quot;</span><span class="p">)</span>
        <span class="n">compartment_limb_branch</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">n_limbs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartment_limb_branch</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="n">soma_angle_max</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">soma_angle_max_from_compartment</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">compartment_limb_branch</span><span class="o">=</span><span class="n">compartment_limb_branch</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="n">soma_angle_min</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">soma_angle_min_from_compartment</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">compartment_limb_branch</span><span class="o">=</span><span class="n">compartment_limb_branch</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_dict</span></div>

<div class="viewcode-block" id="limb_features_from_compartment_over_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.limb_features_from_compartment_over_neuron">[docs]</a><span class="k">def</span> <span class="nf">limb_features_from_compartment_over_neuron</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;basal&quot;</span><span class="p">,</span><span class="s2">&quot;apical_total&quot;</span><span class="p">,</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="s2">&quot;dendrite&quot;</span><span class="p">),</span>
    <span class="n">rotation_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To run limb features for overview compartments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rotation_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rotation_function</span> <span class="o">=</span> <span class="n">align_neuron_obj</span>
    
    <span class="k">if</span> <span class="n">rotation_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">rotation_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    <span class="n">total_limb_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartments</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Working on compartment </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">---&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s2">&quot;apical_total&quot;</span><span class="p">:</span>
            <span class="n">comp_name</span> <span class="o">=</span> <span class="s2">&quot;apical&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comp_name</span> <span class="o">=</span> <span class="n">c</span>
            
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">limb_features_from_compartment</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">compartment_label</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span>
            <span class="n">apply_rotation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Compartment limb stats = </span><span class="si">{</span><span class="n">curr_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">total_limb_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">curr_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
    <span class="k">return</span> <span class="n">total_limb_dict</span></div>


<div class="viewcode-block" id="compartment_from_face_overlap_with_comp_faces_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.compartment_from_face_overlap_with_comp_faces_dict">[docs]</a><span class="k">def</span> <span class="nf">compartment_from_face_overlap_with_comp_faces_dict</span><span class="p">(</span>
    <span class="n">mesh_face_idx</span><span class="p">,</span>
    <span class="n">comp_faces_dict</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to find the compartment of a branch</span>
<span class="sd">    if we know the faces index for a reference mesh</span>
<span class="sd">    and the compartments for a reference mesh</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    Iterate through all compartments in compartment dict</span>
<span class="sd">    1) Find the overlap between faces and compartment </span>
<span class="sd">    2) if the overlap is greater than 0 and </span>
<span class="sd">    greater than current max then set as compartment</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_utils as nru</span>
<span class="sd">    neuron_obj = vdi.neuron_objs_from_cell_type_stage(segment_id)</span>

<span class="sd">    decimated_mesh = vdi.fetch_segment_id_mesh(segment_id)</span>
<span class="sd">    proofread_faces = vdi.fetch_proofread_neuron_faces(segment_id,split_index = split_index)</span>
<span class="sd">    limb_branch_dict = None</span>

<span class="sd">    limb_branch_face_dict = nru.limb_branch_face_idx_dict_from_neuron_obj_overlap_with_face_idx_on_reference_mesh(</span>
<span class="sd">        neuron_obj,</span>
<span class="sd">        faces_idx = proofread_faces,</span>
<span class="sd">        mesh_reference = decimated_mesh,</span>
<span class="sd">        limb_branch_dict = limb_branch_dict,</span>
<span class="sd">        verbose = False</span>
<span class="sd">    )</span>

<span class="sd">    comp_faces_dict = vdi.compartment_faces_dict(segment_id,verbose=False)</span>

<span class="sd">    apu.compartment_from_face_overlap_with_comp_faces_dict(</span>
<span class="sd">        mesh_face_idx = limb_branch_face_dict[&quot;L0&quot;][2],</span>
<span class="sd">        comp_faces_dict = comp_faces_dict,</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_faces</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">curr_comp</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="k">for</span> <span class="n">comp</span><span class="p">,</span><span class="n">comp_faces</span> <span class="ow">in</span> <span class="n">comp_faces_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">comp_faces</span><span class="p">,</span><span class="n">mesh_face_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Changing compartment to </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2"> because </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_face_idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> faces overlap (greater than current max value of </span><span class="si">{</span><span class="n">max_faces</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">curr_comp</span> <span class="o">=</span> <span class="n">comp</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final compartment = </span><span class="si">{</span><span class="n">curr_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">curr_comp</span></div>

<div class="viewcode-block" id="limb_branch_compartment_dict_from_limb_branch_face_and_compartment_faces_dict"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.limb_branch_compartment_dict_from_limb_branch_face_and_compartment_faces_dict">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_compartment_dict_from_limb_branch_face_and_compartment_faces_dict</span><span class="p">(</span>
    <span class="n">limb_branch_face_dict</span><span class="p">,</span>
    <span class="n">compartment_faces_dict</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">limb_branch_compartment_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_info</span> <span class="ow">in</span> <span class="n">limb_branch_face_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; --&gt; limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_compartment_dict</span><span class="p">:</span>
            <span class="n">limb_branch_compartment_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">b_idx</span> <span class="ow">in</span> <span class="n">branch_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; --&gt; branch </span><span class="si">{</span><span class="n">b_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_branch_compartment_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">b_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_from_face_overlap_with_comp_faces_dict</span><span class="p">(</span>
                <span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">limb_branch_face_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">b_idx</span><span class="p">],</span>
                <span class="n">comp_faces_dict</span> <span class="o">=</span> <span class="n">compartment_faces_dict</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_branch_compartment_dict</span></div>

<div class="viewcode-block" id="max_height_for_multi_soma"><a class="viewcode-back" href="../../neurd.html#neurd.apical_utils.max_height_for_multi_soma">[docs]</a><span class="k">def</span> <span class="nf">max_height_for_multi_soma</span><span class="p">():</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">multi_apical_height_global</span></div>
<span class="n">multi_soma_y</span> <span class="o">=</span> <span class="n">max_height_for_multi_soma</span>


<span class="c1"># ------------- parameters for stats ---------------</span>

<span class="n">global_parameters_dict_default_apical</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1">#apical parameters</span>
    <span class="n">soma_angle_to_apical</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
    <span class="n">multi_apical_height</span> <span class="o">=</span> <span class="o">-</span><span class="mi">460_000</span><span class="p">,</span>
    
    <span class="c1"># apical_shaft_like</span>
    <span class="n">max_upward_angle_shaft_like</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">min_upward_length_shaft_like</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
    <span class="n">min_upward_per_match_shaft_like</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="n">min_upward_length_backup_shaft_like</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span> 
    <span class="n">min_upward_per_match_backup_shaft_like</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">width_min_shaft_like</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>
    
    <span class="c1"># apical_filter</span>
    <span class="n">min_skeletal_length_filter_apical</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span><span class="c1">#30000,#50000,</span>
    <span class="n">min_distance_above_soma_filter_apical</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span><span class="c1">#30000,#100000,</span>
    
    <span class="c1">#apical_classification</span>
    <span class="n">candidate_connected_component_radius_apical</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">multi_apical_possible_apical</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="c1">#apical_classification_high_soma_center</span>
    <span class="n">width_min_apical_high_soma</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>
    <span class="n">distance_from_soma_apical_high_soma</span> <span class="o">=</span> <span class="mi">80000</span><span class="p">,</span>
    <span class="n">min_thick_near_soma_skeletal_length_apical_high_soma</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    
    <span class="c1">#filter_apical_candidates_to_one</span>
    <span class="n">non_upward_skeletal_distance_upstream_buffer_filter_apical_one</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span><span class="p">,</span>
    <span class="n">soma_diff_buffer_filter_apical_one</span> <span class="o">=</span> <span class="o">-</span><span class="mi">50000</span><span class="p">,</span>
    <span class="n">downstream_vector_diff_buffer_filter_apical_one</span> <span class="o">=</span> <span class="o">-</span><span class="mi">30000</span><span class="p">,</span>
    <span class="n">default_tie_breaker_filter_apical_one</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
    
    <span class="c1">#apical_tuft_classification</span>
    <span class="n">add_low_degree_apicals_off_shaft_tuft</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">low_degree_apicals_min_angle_tuft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">low_degree_apicals_max_angle_tuft</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    
    
<span class="p">)</span>

<span class="n">global_parameters_dict_default_oblique</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1">#apical_tuft_classification</span>
    <span class="n">min_angle_oblique</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">max_angle_oblique</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>
    <span class="n">per_match_ref_vector_min_oblique</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="n">dist_match_ref_vector_min_oblique</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_default_apical</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_oblique</span><span class="p">,</span>
<span class="p">])</span>


<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">align_neuron_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">unalign_neuron_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span>    

<span class="c1"># ------- microns -----------</span>
<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>


<span class="c1"># --------- h01 -------------</span>
<span class="n">global_parameters_dict_h01_apical</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">multi_apical_possible_apical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
        <span class="n">global_parameters_dict_h01_apical</span>
<span class="p">])</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>
<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">align_neuron_obj</span> <span class="o">=</span> <span class="n">hvu</span><span class="o">.</span><span class="n">data_interface</span><span class="o">.</span><span class="n">align_neuron_obj</span><span class="p">,</span>
    <span class="n">unalign_neuron_obj</span> <span class="o">=</span>  <span class="n">hvu</span><span class="o">.</span><span class="n">data_interface</span><span class="o">.</span><span class="n">unalign_neuron_obj</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># modules_to_set = [apu]</span>
<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>

<span class="c1"># modsetter = modu.ModuleDataTypeSetter(</span>
<span class="c1">#     module = modules_to_set,</span>
<span class="c1">#     algorithms = algorithms</span>
<span class="c1"># )</span>

<span class="c1"># set_global_parameters_and_attributes_by_data_type = modsetter.set_global_parameters_and_attributes_by_data_type</span>
<span class="c1"># output_global_parameters_and_attributes_from_current_data_type = modsetter.output_global_parameters_and_attributes_from_current_data_type</span>

<span class="c1"># set_global_parameters_and_attributes_by_data_type(</span>
<span class="c1">#     data_type=data_type,</span>
<span class="c1">#     algorithms=algorithms</span>
<span class="c1"># )</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mcu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spine_utils</span> <span class="k">as</span> <span class="n">spu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">filtering_utils</span> <span class="k">as</span> <span class="n">flu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">apical_utils</span> <span class="k">as</span> <span class="n">apu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
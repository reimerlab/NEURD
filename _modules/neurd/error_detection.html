<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.error_detection &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.error_detection</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.error_detection</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">data_struct_utils</span> <span class="k">as</span> <span class="n">dsu</span>

<span class="n">double_back_threshold_axon_thick</span> <span class="o">=</span> <span class="mi">120</span>
<span class="n">double_back_threshold_axon_thin</span> <span class="o">=</span> <span class="mi">127</span>

<span class="n">double_back_threshold_axon_thick_inh</span> <span class="o">=</span> <span class="mi">135</span>
<span class="n">double_back_threshold_axon_thin_inh</span> <span class="o">=</span> <span class="mi">140</span>

<span class="c1"># min_upstream_skeletal_distance_global = 500</span>

<span class="c1"># #for the high and low degree matches check that will enforce skipping nodes 7000 nm away from soma</span>
<span class="c1"># min_distance_from_soma_for_proof_global = 10000</span>




<div class="viewcode-block" id="calculate_skip_distance_poly"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.calculate_skip_distance_poly">[docs]</a><span class="k">def</span> <span class="nf">calculate_skip_distance_poly</span><span class="p">(</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">skip_distance_poly_x_global</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">skip_distance_poly_y_global</span>
    
    <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">degree</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="skip_distance_from_branch_width"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.skip_distance_from_branch_width">[docs]</a><span class="k">def</span> <span class="nf">skip_distance_from_branch_width</span><span class="p">(</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">max_skip</span> <span class="o">=</span> <span class="mi">2300</span><span class="p">,</span>
    <span class="n">skip_distance_poly</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the skip distance of of the</span>
<span class="sd">    upstream branch based on the width</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Evaluate the skip distance polynomial</span>
<span class="sd">    at the certain branch width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">skip_distance_poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skip_distance_poly</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">calculate_skip_distance_poly</span><span class="p">()</span>
    <span class="n">skip_value</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">skip_distance_poly</span><span class="p">,</span><span class="n">width</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_skip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">skip_value</span> <span class="o">&gt;</span> <span class="n">max_skip</span><span class="p">:</span>
            <span class="n">skip_value</span> <span class="o">=</span> <span class="n">max_skip</span>
    <span class="k">return</span> <span class="n">skip_value</span></div>
    
<div class="viewcode-block" id="width_jump_edges"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_edges">[docs]</a><span class="k">def</span> <span class="nf">width_jump_edges</span><span class="p">(</span><span class="n">limb</span><span class="p">,</span>
                    <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                     <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">path_to_check</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will only look to see if the width jumps up by a width_jump_threshold threshold ammount</span>
<span class="sd">    and if it does then will save the edges according to that starting soma group</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    ed = reload(ed)</span>
<span class="sd">    ed.width_jump_edges(neuron_obj[5],verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">limb</span><span class="p">)</span>


    <span class="n">width_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">error_edges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
        <span class="n">curr_soma</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">curr_soma_group</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on Soma </span><span class="si">{</span><span class="n">curr_soma</span><span class="si">}</span><span class="s2"> and Soma touching group </span><span class="si">{</span><span class="n">curr_soma_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">curr_soma</span><span class="p">,</span>
                                                 <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">curr_soma_group</span><span class="p">,</span>
                                                 <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">curr_net</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Working on soma group </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">curr_error_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">current_nodes</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">curr_net</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path_to_check</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">current_nodes</span><span class="p">,</span><span class="n">path_to_check</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="c1">#                     if verbose:</span>
<span class="c1">#                         print(f&quot;Skipping edge {current_nodes} because not on path to check: {path_to_check}&quot;)</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Edge: </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                  <span class="n">edge</span><span class="o">=</span><span class="n">current_nodes</span><span class="p">,</span>
                                <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                                <span class="c1">#offset=0,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">downstream_jump</span> <span class="o">=</span> <span class="n">d_width</span><span class="o">-</span><span class="n">up_width</span>

            <span class="k">if</span> <span class="n">downstream_jump</span> <span class="o">&gt;</span> <span class="n">width_jump_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding error edge </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2"> because width jump was </span><span class="si">{</span><span class="n">downstream_jump</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">curr_error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">current_nodes</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">curr_soma</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">error_edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">error_edges</span><span class="p">[</span><span class="n">curr_soma</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">error_edges</span><span class="p">[</span><span class="n">curr_soma</span><span class="p">][</span><span class="n">curr_soma_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_error_edges</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for width = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">width_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">error_edges</span></div>

<div class="viewcode-block" id="path_to_edges"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.path_to_edges">[docs]</a><span class="k">def</span> <span class="nf">path_to_edges</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">skip_nodes</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="n">skip_nodes</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">path</span> <span class="o">!=</span> <span class="n">ni</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="width_jump_edges_path"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_edges_path">[docs]</a><span class="k">def</span> <span class="nf">width_jump_edges_path</span><span class="p">(</span><span class="n">limb</span><span class="p">,</span> <span class="c1">#assuming the concept network is already set</span>
                          <span class="n">path_to_check</span><span class="p">,</span>
                    <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                     <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">return_all_edge_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                          <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                    <span class="n">skip_nodes</span><span class="o">=</span><span class="p">[],</span>
                          
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will only look to see if the width jumps up by a width_jump_threshold threshold ammount</span>
<span class="sd">    </span>
<span class="sd">    **but only along a certain path**</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    curr_limb.set_concept_network_directional(starting_node = 4)</span>
<span class="sd">    err_edges,edges,edges_width_jump = ed.width_jump_edges_path(curr_limb,</span>
<span class="sd">                            path_to_check=np.flip(soma_to_soma_path),</span>
<span class="sd">                                        width_jump_threshold=200  )</span>

<span class="sd">    err_edges,edges,edges_width_jump</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">width_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">curr_net</span> <span class="o">=</span> <span class="n">limb</span><span class="o">.</span><span class="n">concept_network_directional</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">path_to_edges</span><span class="p">(</span><span class="n">path_to_check</span><span class="p">,</span><span class="n">skip_nodes</span><span class="o">=</span><span class="n">skip_nodes</span><span class="p">)</span>
    <span class="n">edges_width_jump</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">error_edges</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="k">for</span> <span class="n">current_nodes</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        
        <span class="n">skip_nodes_present</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">skip_nodes</span><span class="p">,</span><span class="n">current_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skip_nodes_present</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt;Skipping Edge </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2"> because had at least on skip node: </span><span class="si">{</span><span class="n">skip_nodes_present</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">limb</span><span class="p">,</span>
                              <span class="n">edge</span><span class="o">=</span><span class="n">current_nodes</span><span class="p">,</span>
                            <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                            <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">downstream_jump</span> <span class="o">=</span> <span class="n">d_width</span><span class="o">-</span><span class="n">up_width</span>
        <span class="n">edges_width_jump</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downstream_jump</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Edge: </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2">: jump = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">downstream_jump</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">downstream_jump</span> <span class="o">&gt;=</span> <span class="n">width_jump_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding error edge </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2"> because width jump was </span><span class="si">{</span><span class="n">downstream_jump</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">current_nodes</span><span class="p">))</span>

    
    <span class="n">edges_width_jump</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges_width_jump</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for width = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">width_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_all_edge_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error_edges</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">edges_width_jump</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error_edges</span></div>



<div class="viewcode-block" id="double_back_edges"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_edges">[docs]</a><span class="k">def</span> <span class="nf">double_back_edges</span><span class="p">(</span>
    <span class="n">limb</span><span class="p">,</span>
    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">130</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">path_to_check</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all of the edges where the skeleton doubles back on itself</span>

<span class="sd">    Application: For error detection</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">limb</span><span class="p">)</span>


    <span class="n">width_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">error_edges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
        <span class="n">curr_soma</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">curr_soma_group</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on Soma </span><span class="si">{</span><span class="n">curr_soma</span><span class="si">}</span><span class="s2"> and Soma touching group </span><span class="si">{</span><span class="n">curr_soma_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
            
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">curr_soma</span><span class="p">,</span>
                                                 <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">curr_soma_group</span><span class="p">,</span>
                                                 <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">curr_net</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Working on soma group </span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">curr_error_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">current_nodes</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">curr_net</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Edge: </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path_to_check</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">current_nodes</span><span class="p">,</span><span class="n">path_to_check</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="c1">#                     if verbose:</span>
<span class="c1">#                         print(f&quot;Skipping edge {current_nodes} because not on path to check: {path_to_check}&quot;)</span>
                    <span class="k">continue</span>

            <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                  <span class="n">edge</span><span class="o">=</span><span class="n">current_nodes</span><span class="p">,</span>
                                  <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            1) Flip the upstream skeleton (the downstream one should be in right direction)</span>
<span class="sd">            2) Get the endpoints from first and last of skeleton coordinates for both to find the vectors</span>
<span class="sd">            3) Find the angle between them</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">up_sk_flipped</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">up_sk</span><span class="p">)</span>

            <span class="n">up_vec</span> <span class="o">=</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">d_vec</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            
            
            <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">up_vec</span><span class="p">,</span><span class="n">d_vec</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">curr_angle</span> <span class="o">&gt;</span> <span class="n">double_back_threshold</span><span class="p">:</span>
                <span class="n">curr_error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">current_nodes</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">curr_soma</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">error_edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">error_edges</span><span class="p">[</span><span class="n">curr_soma</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">error_edges</span><span class="p">[</span><span class="n">curr_soma</span><span class="p">][</span><span class="n">curr_soma_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_error_edges</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for width = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">width_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">error_edges</span></div>



<div class="viewcode-block" id="double_back_edges_path"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_edges_path">[docs]</a><span class="k">def</span> <span class="nf">double_back_edges_path</span><span class="p">(</span>
    <span class="n">limb</span><span class="p">,</span>
    <span class="n">path_to_check</span><span class="p">,</span>
    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">130</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">return_all_edge_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">skip_nodes</span><span class="o">=</span><span class="p">[]):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all of the edges where the skeleton doubles back on itself</span>
<span class="sd">    **but only along a certain path**</span>

<span class="sd">    Application: For error detection</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    curr_limb.set_concept_network_directional(starting_node = 2)</span>
<span class="sd">    err_edges,edges,edges_width_jump = ed.double_back_edges_path(curr_limb,</span>
<span class="sd">                            path_to_check=soma_to_soma_path )</span>

<span class="sd">    err_edges,edges,edges_width_jump</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">limb</span>


    <span class="n">width_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">curr_net</span> <span class="o">=</span> <span class="n">limb</span><span class="o">.</span><span class="n">concept_network_directional</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">path_to_edges</span><span class="p">(</span><span class="n">path_to_check</span><span class="p">,</span><span class="n">skip_nodes</span><span class="o">=</span><span class="n">skip_nodes</span><span class="p">)</span>
    <span class="n">edges_doubling_back</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">error_edges</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="k">for</span> <span class="n">current_nodes</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>

        <span class="n">skip_nodes_present</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">skip_nodes</span><span class="p">,</span><span class="n">current_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skip_nodes_present</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt;Skipping Edge </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2"> because had at least on skip node: </span><span class="si">{</span><span class="n">skip_nodes_present</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                              <span class="n">edge</span><span class="o">=</span><span class="n">current_nodes</span><span class="p">,</span>
                              <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        1) Flip the upstream skeleton (the downstream one should be in right direction)</span>
<span class="sd">        2) Get the endpoints from first and last of skeleton coordinates for both to find the vectors</span>
<span class="sd">        3) Find the angle between them</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">up_sk_flipped</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">up_sk</span><span class="p">)</span>

        <span class="n">up_vec</span> <span class="o">=</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">d_vec</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">up_vec</span><span class="p">,</span><span class="n">d_vec</span><span class="p">)</span>
        <span class="n">edges_doubling_back</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Edge: </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2">: curr_angle = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
        
        
        <span class="k">if</span> <span class="n">curr_angle</span> <span class="o">&gt;</span> <span class="n">double_back_threshold</span><span class="p">:</span>
            <span class="n">error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">current_nodes</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for doubling_back = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">width_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_all_edge_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error_edges</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">edges_doubling_back</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error_edges</span></div>


<span class="c1"># ----------- 1/31: This will only compare doubling back and width transitions for big nodes</span>
<div class="viewcode-block" id="width_jump_double_back_edges_path"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_double_back_edges_path">[docs]</a><span class="k">def</span> <span class="nf">width_jump_double_back_edges_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span> <span class="c1">#assuming the concept network is already set</span>
    <span class="n">path</span><span class="p">,</span>
    <span class="n">starting_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
    <span class="n">width_name_backup</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>

    <span class="n">skeletal_length_to_skip</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>

    <span class="c1"># parameters for the boundary transition</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="c1">#have to make the offset larger because the spines are cancelled out 2000 from the endpoints</span>


    <span class="c1">#the thresholds for determining if there are errors</span>
    <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">width_jump_axon_like_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
    <span class="n">running_width_jump_method</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    
                                      
                                      
    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
    <span class="n">double_back_axon_like_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="n">perform_double_back_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">perform_width_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">perform_axon_width_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">skip_double_back_errors_for_axon</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>


    <span class="n">allow_axon_double_back_angle_with_top</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">allow_axon_double_back_angle_with_top_width_min</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
                                      
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_all_edge_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">axon_comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To get the double back and width jumps along a path of a limb</span>
<span class="sd">    (but only for those branches that are deemed significant by a long enough skeletal length)</span>

<span class="sd">    -- have options to set for both width and doubling back</span>
<span class="sd">    -- option to set that will skip the doubling back if axon (or axon-like) or not</span>
<span class="sd">    -- have option for axon width jump (so if want different than dendritic)</span>

<span class="sd">    Pseducodde: </span>
<span class="sd">    1) Get the order of coordinates on te path</span>
<span class="sd">    2) Calculate the skeletal lengths of branches </span>
<span class="sd">    3) Determine the branches that are too small skeletal wise (deemed insignificant) and remove from path</span>

<span class="sd">    -- IF THERE IS AT LEAST 2 BRANCHES LEFT TO TEST --</span>

<span class="sd">    4) Revise the ordered coordinates by deleted the indexes that are too small</span>
<span class="sd">    5) Compute the enw edges to test</span>
<span class="sd">    6) Get the pairs of endpoints for each edge</span>

<span class="sd">    7) Iterate through all of the edges to test</span>
<span class="sd">        - find if any of the branches are labeled as axon or axon-like</span>
<span class="sd">        a. get the skeleton and width boundary</span>
<span class="sd">        b. Get the width jump (and record)</span>
<span class="sd">        c. Get the skeleton angle (and record)</span>
<span class="sd">        d. Depending on the conditions set add the start node and then next node </span>
<span class="sd">           in the original path to the error edges if violates one of the rules</span>

<span class="sd">    8) Return the error edges and all of the skeleton angle, width jump data for the path analyzed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;running_width_jump_method=</span><span class="si">{</span><span class="n">running_width_jump_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_threshold=</span><span class="si">{</span><span class="n">double_back_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_axon_like_threshold=</span><span class="si">{</span><span class="n">double_back_axon_like_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skip_double_back_errors_for_axon =  </span><span class="si">{</span><span class="n">skip_double_back_errors_for_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">endpoints_verbose</span> <span class="o">=</span> <span class="kc">False</span>
    

    <span class="c1">#------------------------------------------------</span>
    <span class="n">path</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">width_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#0) Figure out the starting coordinate if not specified</span>
    <span class="k">if</span> <span class="n">starting_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_coordinate</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_coordinate</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;starting_coordinate was None and there was not just one unique coordinate &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; between 1st and 2nd node on path: </span><span class="si">{</span><span class="n">unique_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">unique_coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">endpoints_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found starting coordinate = </span><span class="si">{</span><span class="n">starting_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#1) Get the order of coordinates on the path</span>
    <span class="n">ordered_coordinates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">ordered_endpoints_on_branch_path</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">,</span>
                <span class="n">starting_endpoint_coordinate</span> <span class="o">=</span> <span class="n">starting_coordinate</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">endpoints_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ordered_coordinates = </span><span class="se">\n</span><span class="si">{</span><span class="n">ordered_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#2) Calculate the skeletal lengths of branches </span>
    <span class="n">branches_sk_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>

    <span class="c1">#3) Determine the branches that are too small skeletal wise (deemed insignificant) and remove from path</span>
    <span class="n">branch_idx_for_revised_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">branches_sk_len</span><span class="o">&gt;</span><span class="n">skeletal_length_to_skip</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">branch_idx_removed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">branches_sk_len</span><span class="o">&lt;=</span><span class="n">skeletal_length_to_skip</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_idx_for_revised_path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_all_edge_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],[],[],[],[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="n">revised_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">branch_idx_for_revised_path</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches_removed = </span><span class="si">{</span><span class="n">path</span><span class="p">[</span><span class="n">branch_idx_removed</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> --&gt; revised path: </span><span class="si">{</span><span class="n">revised_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#4) Revise the ordered coordinates by deleted the indexes that are too small</span>
    <span class="n">revised_ordered_coordinates</span> <span class="o">=</span> <span class="n">ordered_coordinates</span><span class="p">[</span><span class="n">branch_idx_for_revised_path</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">endpoints_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;revised_ordered_coordinates = </span><span class="se">\n</span><span class="si">{</span><span class="n">revised_ordered_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#5) Compute the enw edges to test</span>
    <span class="n">revised_edges</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">path_to_edges</span><span class="p">(</span><span class="n">revised_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">endpoints_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;revised_edges= </span><span class="si">{</span><span class="n">revised_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#6) Get the pairs of endpoints for each edge</span>
    <span class="n">common_endpoints_revised</span> <span class="o">=</span> <span class="n">revised_ordered_coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">endpoints_verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;common_endpoints_revised = </span><span class="se">\n</span><span class="si">{</span><span class="n">common_endpoints_revised</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    7) Iterate through all of the edges to test</span>
<span class="sd">        - find if any of the branches are labeled as axon or axon-like</span>
<span class="sd">        a. get the skeleton and width boundary</span>
<span class="sd">        b. Get the width jump (and record)</span>
<span class="sd">        c. Get the skeleton angle (and record)</span>
<span class="sd">        d. Depending on the conditions set add the start node and then next node </span>
<span class="sd">           in the original path to the error edges if violates one of the rules</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edges_doubling_back</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges_width_jump</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">error_edges_doubling_back</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">error_edges_width_jump</span><span class="o">=</span> <span class="p">[]</span>

    <span class="n">width_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">current_nodes</span><span class="p">,</span><span class="n">nodes_common_endpoints</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">revised_edges</span><span class="p">,</span><span class="n">common_endpoints_revised</span><span class="p">):</span>

        <span class="c1">#- find if any of the branches are labeled as axon or axon-like</span>
        <span class="n">curr_labels</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">current_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">labels</span> <span class="o">+</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">current_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">labels</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_labels = </span><span class="si">{</span><span class="n">curr_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">curr_labels</span><span class="p">:</span>
            <span class="n">axon_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axon_flag</span> <span class="o">=</span> <span class="kc">False</span>


        <span class="k">if</span> <span class="s2">&quot;axon-like&quot;</span> <span class="ow">in</span> <span class="n">curr_labels</span><span class="p">:</span>
            <span class="n">axon_like_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axon_like_flag</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on edge: </span><span class="si">{</span><span class="n">current_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">axon_flag</span> <span class="ow">and</span> <span class="n">axon_comparison_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_comparison_distance</span> <span class="o">=</span> <span class="n">axon_comparison_distance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span>
            
        

        <span class="c1">#a. get the skeleton and width boundary</span>
        <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                              <span class="n">edge</span><span class="o">=</span><span class="n">current_nodes</span><span class="p">,</span>
                            <span class="n">upstream_common_endpoint</span><span class="o">=</span><span class="n">nodes_common_endpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">downstream_common_endpoint</span><span class="o">=</span><span class="n">nodes_common_endpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">error_on_no_network_connection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">comparison_distance</span><span class="o">=</span><span class="n">current_comparison_distance</span><span class="p">,</span>
                            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                            <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">up_width</span> <span class="o">&lt;</span> <span class="n">width_min</span><span class="p">:</span>
            <span class="n">width_min</span> <span class="o">=</span> <span class="n">up_width</span>
            
        <span class="c1">#b. Get the width jump (and record)</span>
        
        
        <span class="k">if</span> <span class="n">running_width_jump_method</span><span class="p">:</span>
            
            <span class="n">downstream_jump</span> <span class="o">=</span> <span class="n">d_width</span><span class="o">-</span><span class="n">width_min</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">downstream_jump</span> <span class="o">=</span> <span class="n">d_width</span><span class="o">-</span><span class="n">up_width</span>
        
        <span class="n">edges_width_jump</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downstream_jump</span><span class="p">)</span>

        <span class="c1">#c. Get the skeleton angle (and record)</span>
        <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">parent_child_skeletal_angle</span><span class="p">(</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span><span class="p">)</span>
        <span class="n">edges_doubling_back</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_jump = </span><span class="si">{</span><span class="n">downstream_jump</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_angle = </span><span class="si">{</span><span class="n">curr_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#d. Depending on the conditions set add the start node and then next node </span>
        <span class="c1">#in the original path to the error edges if violates one of the rules</span>

        <span class="c1"># -- 4/23 Revisions ---------</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        What we want is to error out the edge that doubled back and the preceeding one</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#         upstream_node = current_nodes[0]</span>
<span class="c1">#         downstream_node_for_error = path[np.where(path == upstream_node)[0] + 1][0]</span>

        <span class="n">downstream_node_for_error</span> <span class="o">=</span> <span class="n">current_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="n">downstream_node_for_error</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">edge_to_error</span> <span class="o">=</span> <span class="p">[</span><span class="n">upstream_node</span><span class="p">,</span><span class="n">downstream_node_for_error</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;POTENTIALLY edge_to_error = </span><span class="si">{</span><span class="n">edge_to_error</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



<span class="w">        </span><span class="sd">&#39;&#39;&#39; OLD WAY WITHOUT IMPROVED DOUBLE BACK LOGIC</span>
<span class="sd">        if perform_double_back_errors:</span>
<span class="sd">            if curr_angle &gt; double_back_threshold:</span>
<span class="sd">                if skip_double_back_errors_for_axon and not axon_flag:</span>
<span class="sd">                    if verbose:</span>
<span class="sd">                        print(&quot;Appending edge to double back errors&quot;)</span>
<span class="sd">                    error_edges_doubling_back.append(edge_to_error)</span>
<span class="sd">                else:</span>
<span class="sd">                    if verbose:</span>
<span class="sd">                        print(&quot;Skipping the double back check because axon_flag was set (OTHERWISE WOULD)&quot;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">perform_double_back_errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axon_flag</span> <span class="ow">and</span> <span class="n">skip_double_back_errors_for_axon</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the double back check because axon_flag was set (OTHERWISE WOULD)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">axon_flag</span> <span class="ow">and</span> <span class="n">double_back_axon_like_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">curr_double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_axon_like_threshold</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold</span>

                <span class="k">if</span> <span class="n">curr_angle</span> <span class="o">&gt;</span> <span class="n">curr_double_back_threshold</span><span class="p">:</span>
                    <span class="n">append_flag</span> <span class="o">=</span> <span class="kc">True</span>
                    
                    <span class="c1"># ---- 4/23 Addition --------#</span>
                    <span class="c1">#will allow for axon to double back if it is pointing back to top</span>
                    <span class="k">if</span> <span class="n">allow_axon_double_back_angle_with_top</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">allow_axon_double_back_angle_with_top_width_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">allow_axon_double_back_angle_with_top_width_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">d_vec_child</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">angle_with_top</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">angle_from_top</span><span class="p">(</span><span class="n">d_vec_child</span><span class="p">)</span>
                        <span class="n">upstream_node_width</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">])</span>
                        <span class="c1">#print(f&quot;upstream_node_width = {upstream_node_width}, allow_axon_double_back_angle_with_top_width_min = {allow_axon_double_back_angle_with_top_width_min}&quot;)</span>
                        <span class="c1">#print(f&quot;angle_with_top = {angle_with_top} (threshold = {allow_axon_double_back_angle_with_top})&quot;)</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">angle_with_top</span> <span class="o">&lt;</span> <span class="n">allow_axon_double_back_angle_with_top</span> <span class="p">)</span> <span class="ow">and</span> 
                           <span class="p">(</span><span class="n">upstream_node_width</span> <span class="o">&gt;</span> <span class="n">allow_axon_double_back_angle_with_top_width_min</span><span class="p">)):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the double back even though double back threshold violated because &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;the angle with the top is </span><span class="si">{</span><span class="n">angle_with_top</span><span class="si">}</span><span class="s2"> which is less than set threshold </span><span class="si">{</span><span class="n">allow_axon_double_back_angle_with_top</span><span class="si">}</span><span class="s2"> &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">and upstream_node_width (</span><span class="si">{</span><span class="n">upstream_node_width</span><span class="si">}</span><span class="s2">) is greater than threshold </span><span class="si">{</span><span class="n">allow_axon_double_back_angle_with_top_width_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">append_flag</span> <span class="o">=</span> <span class="kc">False</span>
                            
                    <span class="k">if</span> <span class="n">append_flag</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Appending edge to double back errors with threshold: </span><span class="si">{</span><span class="n">curr_double_back_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">error_edges_doubling_back</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_to_error</span><span class="p">)</span>
<span class="c1">#                         from python_tools import system_utils as su</span>
<span class="c1">#                         su.compressed_pickle(up_sk,&quot;up_sk&quot;)</span>
<span class="c1">#                         su.compressed_pickle(d_sk,&quot;d_sk&quot;)</span>
<span class="c1">#                         raise Exception(&quot;&quot;)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping the double back becuase </span><span class="si">{</span><span class="n">curr_angle</span><span class="si">}</span><span class="s2"> angle not larger than threshold </span><span class="si">{</span><span class="n">curr_double_back_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        

        <span class="k">if</span> <span class="n">perform_width_errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axon_like_flag</span> <span class="ow">or</span> <span class="n">axon_flag</span><span class="p">:</span>
                <span class="n">curr_wdith_threshold</span> <span class="o">=</span> <span class="n">width_jump_axon_like_threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_wdith_threshold</span> <span class="o">=</span> <span class="n">width_jump_threshold</span>
                
            <span class="n">add_width_errors_flag</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="k">if</span> <span class="n">axon_flag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">perform_axon_width_errors</span><span class="p">:</span>
                <span class="n">add_width_errors_flag</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">downstream_jump</span> <span class="o">&gt;</span> <span class="n">curr_wdith_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">add_width_errors_flag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Appending edge to width errors&quot;</span><span class="p">)</span>
                    <span class="n">error_edges_width_jump</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_to_error</span><span class="p">)</span>
                

    <span class="n">all_error_edges</span> <span class="o">=</span> <span class="n">error_edges_doubling_back</span> <span class="o">+</span> <span class="n">error_edges_width_jump</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_error_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">all_error_edges</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">unique_rows</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_error_edges</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>




    <span class="k">if</span> <span class="n">return_all_edge_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_error_edges</span><span class="p">,</span><span class="n">error_edges_doubling_back</span><span class="p">,</span><span class="n">error_edges_width_jump</span><span class="p">,</span><span class="n">edges_doubling_back</span><span class="p">,</span><span class="n">edges_width_jump</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_error_edges</span></div>


<span class="c1"># ----------------------------------------------------- #</span>
        
        
    
<div class="viewcode-block" id="resolving_crossovers"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.resolving_crossovers">[docs]</a><span class="k">def</span> <span class="nf">resolving_crossovers</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                        <span class="n">coordinate</span><span class="p">,</span>
                        <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
                         <span class="c1">#match_threshold = 60,</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">return_new_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">return_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">plot_intermediates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                         
                         <span class="n">apply_width_filter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">best_match_width_diff_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">best_match_width_diff_max_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">best_match_width_diff_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         
                         <span class="n">best_singular_match</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">lowest_angle_sum_for_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">return_existing_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         
                         
                         
                         <span class="n">edges_to_avoid</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         
                         <span class="n">no_non_cut_disconnected_comps</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#should be true</span>
                         <span class="n">branches_to_disconnect</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#will distinguish branches that need cutting from those that dont</span>
                         
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the connectivity that should be at the location</span>
<span class="sd">    of a crossover (the cuts that should be made and the new connectivity)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all the branches that correspond to the coordinate</span>
<span class="sd">    2) For each branch</span>
<span class="sd">    - get the boundary cosine angle between the other branches</span>
<span class="sd">    - if within a threshold then add edge</span>
<span class="sd">    3) Ge the subgraph of all these branches:</span>
<span class="sd">    - find what edges you have to cut</span>
<span class="sd">    4) Return the cuts/subgraph</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    resolving_crossovers(limb_obj = copy.deepcopy(curr_limb),</span>
<span class="sd">                     coordinate = high_degree_coordinates[0],</span>
<span class="sd">                    match_threshold = 40,</span>
<span class="sd">                    verbose = False,</span>
<span class="sd">                     return_new_edges = True,</span>
<span class="sd">                    return_subgraph=True,</span>
<span class="sd">                    plot_intermediates=False)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">apply_width_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">apply_width_filter</span> <span class="o">=</span> <span class="n">apply_width_filter_global</span>
        
    <span class="k">if</span> <span class="n">best_match_width_diff_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">best_match_width_diff_max</span> <span class="o">=</span> <span class="n">best_match_width_diff_max_global</span>
        
    <span class="k">if</span> <span class="n">best_match_width_diff_max_perc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">best_match_width_diff_max_perc</span> <span class="o">=</span> <span class="n">best_match_width_diff_max_perc_global</span>
        
    <span class="k">if</span> <span class="n">best_match_width_diff_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">best_match_width_diff_min</span> <span class="o">=</span> <span class="n">best_match_width_diff_min_global</span>
        
    <span class="k">if</span> <span class="n">no_non_cut_disconnected_comps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">no_non_cut_disconnected_comps</span> <span class="o">=</span> <span class="n">no_non_cut_disconnected_comps_global</span>
    
    <span class="k">if</span> <span class="n">best_singular_match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">best_singular_match</span> <span class="o">=</span> <span class="n">best_singular_match_global</span>
        
    <span class="k">if</span> <span class="n">lowest_angle_sum_for_pairs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lowest_angle_sum_for_pairs</span> <span class="o">=</span> <span class="n">lowest_angle_sum_for_pairs_global</span>
        
        
    
<span class="c1">#     print(f&quot;comparison_distance = {comparison_distance}&quot;)</span>
<span class="c1">#     print(f&quot;offset= {offset}&quot;)</span>
    
    
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">debug_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">apply_width_filter</span> <span class="o">=</span> <span class="n">apply_width_filter</span><span class="p">,</span>
        <span class="n">best_match_width_diff_max</span> <span class="o">=</span> <span class="n">best_match_width_diff_max</span><span class="p">,</span>
        <span class="n">best_match_width_diff_max_perc</span> <span class="o">=</span> <span class="n">best_match_width_diff_max_perc</span><span class="p">,</span>
        <span class="n">best_match_width_diff_min</span> <span class="o">=</span> <span class="n">best_match_width_diff_min</span><span class="p">,</span>
        <span class="n">best_singular_match</span><span class="o">=</span><span class="n">best_singular_match</span><span class="p">,</span>
        <span class="n">lowest_angle_sum_for_pairs</span><span class="o">=</span><span class="n">lowest_angle_sum_for_pairs</span><span class="p">,)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inisde resolving_crossovers: debug_dict=/n</span><span class="si">{</span><span class="n">debug_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    
    <span class="c1">#1) Get all the branches that correspond to the coordinate</span>
    <span class="n">sk_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">br</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">]</span>

    <span class="n">coordinate_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">sk_branches</span><span class="p">,</span><span class="n">coordinate</span><span class="p">))</span>
    <span class="n">curr_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">]</span>

    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate = </span><span class="si">{</span><span class="n">coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate_branches = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">,</span><span class="n">curr_colors</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    
    <span class="k">if</span> <span class="n">plot_intermediates</span><span class="p">:</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">)</span>
    
    
    <span class="c1"># 2) For each branch</span>
    <span class="c1"># - get the boundary cosine angle between the other branches</span>
    <span class="c1"># - if within a threshold then add edge</span>

    <span class="n">match_branches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">match_branches_angle</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">all_aligned_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_avoid= </span><span class="si">{</span><span class="n">edges_to_avoid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">br1_idx</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">br2_idx</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">br1_idx</span><span class="o">&gt;=</span><span class="n">br2_idx</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">edges_to_avoid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">intersect2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edges_to_avoid</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">]))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping edge: </span><span class="si">{</span><span class="p">[</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> because in edges_to_avoid &quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                
                
            <span class="n">edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">]</span>
            <span class="n">edge_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk_branches</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">]</span>
            <span class="n">aligned_sk_parts</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">offset_skeletons_aligned_at_shared_endpoint</span><span class="p">(</span><span class="n">edge_skeletons</span><span class="p">,</span>
                                                                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                                             <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                                             <span class="n">common_endpoint</span><span class="o">=</span><span class="n">coordinate</span><span class="p">)</span>
            

            <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">parent_child_skeletal_angle</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Angle between </span><span class="si">{</span><span class="n">br1_idx</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">br2_idx</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">curr_angle</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

            <span class="c1"># - if within a threshold then add edge</span>
            <span class="k">if</span> <span class="n">curr_angle</span> <span class="o">&lt;=</span> <span class="n">match_threshold</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                ----- 7/15: Will now eliminate all edges where the width jump is too large ----</span>
<span class="sd">        </span>
<span class="sd">                best_match_width_diff_max = 75,</span>
<span class="sd">                best_match_width_diff_max_perc = 0.60,</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">add_edge_flag</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">apply_width_filter</span><span class="p">:</span>
                    
                    <span class="n">width_diff</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_diff_basic</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">)</span>
                    <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_diff_percentage_basic</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_diff = </span><span class="si">{</span><span class="n">width_diff</span><span class="si">}</span><span class="s2">, width_diff_perc = </span><span class="si">{</span><span class="n">width_diff_perc</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="p">(((</span><span class="n">width_diff</span> <span class="o">&gt;</span> <span class="n">best_match_width_diff_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">width_diff_perc</span> <span class="o">&gt;</span> <span class="n">best_match_width_diff_max_perc</span><span class="p">))</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">width_diff_perc</span> <span class="o">&gt;</span> <span class="n">best_match_width_diff_min</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding edge </span><span class="si">{</span><span class="p">[</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> because width_diff= </span><span class="si">{</span><span class="n">width_diff</span><span class="si">}</span><span class="s2">, width_diff_perc= = </span><span class="si">{</span><span class="n">width_diff_perc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">add_edge_flag</span> <span class="o">=</span> <span class="kc">False</span>
                
                <span class="k">if</span> <span class="n">add_edge_flag</span><span class="p">:</span>
                    <span class="n">match_branches</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">])</span>
                    <span class="n">match_branches_angle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">plot_intermediates</span><span class="p">:</span>
                <span class="c1">#saving off the aligned skeletons to visualize later</span>
                <span class="n">all_aligned_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">all_aligned_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Matches = </span><span class="si">{</span><span class="n">match_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    
    
        
    <span class="c1"># -------- 12 / 31 : Will attempt to only keep the best singular match between nodes ------- #</span>
    
    <span class="k">if</span> <span class="n">lowest_angle_sum_for_pairs</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Psuedocode: (if matched_branches is not empty)</span>
<span class="sd">        1) Turn the matched branhes and the match_branches_angle</span>
<span class="sd">        into a weighted graph</span>
<span class="sd">        2) Get the lowest weight graph and output the edges</span>
<span class="sd">        3) Turn to lists and reassign as the matched branches</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(f&quot;Using lowest_angle_sum_for_pairs optimization&quot;)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; JUST COMPILED PROCESS INTO FUNCTION</span>
<span class="sd">            curr_branches_G = xu.edges_and_weights_to_graph(match_branches,</span>
<span class="sd">                                                            match_branches_angle)</span>
<span class="sd">            match_branches,match_branches_angle = xu.degree_1_max_edge_min_max_weight_graph(</span>
<span class="sd">                G = curr_branches_G,</span>
<span class="sd">                verbose = False,</span>
<span class="sd">                plot_winning_graph = False,</span>
<span class="sd">                return_edge_info=True)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span>  <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">lowest_weighted_sum_singular_matches</span><span class="p">(</span>
                                                            <span class="n">match_branches</span><span class="p">,</span>
                                                            <span class="n">match_branches_angle</span><span class="p">)</span>
            
            <span class="n">match_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">match_branches</span><span class="p">)</span>
            <span class="n">match_branches_angle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">match_branches_angle</span><span class="p">)</span>
        
        
    <span class="k">elif</span> <span class="n">best_singular_match</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        0) Create an alredy_matched list</span>
<span class="sd">        1) Get the sorting indexes by match angle</span>
<span class="sd">        2) Iterate through match angle indexes in order:</span>
<span class="sd">        a. if both nodes in edge have not been matched </span>
<span class="sd">            - add edge to final list</span>
<span class="sd">            - add edge nodes to already_matched list</span>
<span class="sd">        b. else:</span>
<span class="sd">            - skip edge</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">already_matched</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">matched_branches_revised</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">smallest_to_largest_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">match_branches_angle</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e_i</span> <span class="ow">in</span> <span class="n">smallest_to_largest_angles</span><span class="p">:</span>
            <span class="n">curr_edge</span> <span class="o">=</span> <span class="n">match_branches</span><span class="p">[</span><span class="n">e_i</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">already_matched</span><span class="p">,</span><span class="n">curr_edge</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">matched_branches_revised</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_edge</span><span class="p">)</span>
                <span class="n">already_matched</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_edge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matched_branches_revised = </span><span class="si">{</span><span class="n">matched_branches_revised</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">match_branches</span> <span class="o">=</span> <span class="n">matched_branches_revised</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not using any edge optimized pairing&quot;</span><span class="p">)</span>
        
    
    
    <span class="k">if</span> <span class="n">plot_intermediates</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Aligned Skeleton Parts&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="n">all_aligned_skeletons</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_intermediates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_match</span> <span class="ow">in</span> <span class="n">match_branches</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_match</span><span class="p">],</span>
                 <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                 <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_match</span><span class="p">],</span>
                 <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">)</span>
            
    
    <span class="c1"># find what cuts and connections need to make</span>
    <span class="n">limb_subgraph</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original graph&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">limb_subgraph</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_branches = </span><span class="si">{</span><span class="n">match_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Older way of doing that just accounted for edges in current graph</span>
<span class="sd">    sorted_edges = np.sort(limb_subgraph.edges(),axis=1)</span>
<span class="sd">    if len(match_branches)&gt;0:</span>
<span class="sd">        </span>
<span class="sd">        sorted_confirmed_edges = np.sort(match_branches,axis=1)</span>


<span class="sd">        edges_to_delete = []</span>

<span class="sd">        for ed in sorted_edges:</span>
<span class="sd">            if not return_existing_edges:</span>
<span class="sd">                if len(nu.matching_rows_old(sorted_confirmed_edges,ed))==0:</span>
<span class="sd">                    edges_to_delete.append(ed)</span>
<span class="sd">            else:</span>
<span class="sd">                edges_to_delete.append(ed)</span>

<span class="sd">        edges_to_create = []</span>

<span class="sd">        for ed in sorted_confirmed_edges:</span>
<span class="sd">            if not return_existing_edges:</span>
<span class="sd">                if len(nu.matching_rows_old(sorted_edges,ed))==0:</span>
<span class="sd">                    edges_to_create.append(ed)</span>
<span class="sd">            else:</span>
<span class="sd">                edges_to_create.append(ed)</span>
<span class="sd">    else:</span>
<span class="sd">        edges_to_delete = sorted_edges</span>
<span class="sd">        edges_to_create = []</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1/10/22: </span>
<span class="sd">    Purpose: Don&#39;t want edges that are not </span>
<span class="sd">    the ones subject to cutting to be disconnected even if not find pairing</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the current edges to create</span>
<span class="sd">    2) Build a graph from those matched edges and nodes considering</span>
<span class="sd">    3) For each node not in nodes to cut:</span>
<span class="sd">       a) If not</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">no_non_cut_disconnected_comps</span><span class="p">:</span>
        
        
        
        <span class="k">if</span> <span class="n">branches_to_disconnect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;no_non_cut_disconnected_comps but branches_to_disconnect is None in resolving_crossovers&quot;</span><span class="p">)</span>
            
        <span class="n">branches_to_disconnect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">,</span><span class="n">branches_to_disconnect</span><span class="p">)</span>
        
        <span class="n">all_start_nodes</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_starting_nodes</span>
        <span class="n">branches_to_avoid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_start_nodes</span><span class="p">,</span><span class="n">branches_to_disconnect</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches_to_avoid= </span><span class="si">{</span><span class="n">branches_to_avoid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">match_branches</span><span class="p">)</span>
        
        <span class="n">new_neighbors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">,</span>
                              <span class="n">branches_to_disconnect</span><span class="p">,</span>
                              <span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches_to_avoid</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">curr_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors_simple</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">curr_neighbors</span>
                              <span class="p">,</span><span class="n">branches_to_disconnect</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">: No Pair so adding back old edge&quot;</span><span class="p">)</span>
                <span class="n">old_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors_simple</span><span class="p">(</span><span class="n">limb_subgraph</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">: Old neighbors = </span><span class="si">{</span><span class="n">old_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">new_neighbors</span><span class="o">+=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="n">b</span><span class="p">,</span><span class="n">o</span><span class="p">]))</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">old_neighbors</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">branches_to_avoid</span><span class="p">]</span>
           
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>     
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_neighbors = </span><span class="si">{</span><span class="n">new_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">match_branches</span> <span class="o">+=</span> <span class="n">new_neighbors</span>
        
        
    <span class="c1"># ----------- 1/8/21 New iteration that just says what edges should be there and what shouldn&#39;t</span>
    <span class="n">edges_to_create</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">match_branches</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">possible_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">,</span> <span class="mi">2</span><span class="p">))),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">possible_edges</span><span class="p">,</span><span class="n">match_branches</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    
    
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_delete (resolve crossover) = </span><span class="si">{</span><span class="n">edges_to_delete</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_create (resolve crossover) = </span><span class="si">{</span><span class="n">edges_to_create</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">edges_to_delete</span><span class="p">]</span> 
    <span class="k">if</span> <span class="n">return_new_edges</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_subgraph</span><span class="p">:</span>
        <span class="c1">#actually creating the new sugraph</span>
        <span class="n">graph_copy</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
        <span class="n">graph_copy</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">)</span>
        <span class="n">graph_copy</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_components in adjusted graph = </span><span class="si">{</span><span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">graph_copy</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph_copy</span><span class="p">)</span>
        
        
    <span class="k">return</span> <span class="n">return_value</span></div>





<span class="c1"># ------------ part that will error all floating axon pieces ----------- #</span>


<div class="viewcode-block" id="error_branches_by_axons"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.error_branches_by_axons">[docs]</a><span class="k">def</span> <span class="nf">error_branches_by_axons</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">visualize_errors_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">min_skeletal_path_threshold</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span>
                                <span class="n">sub_skeleton_length</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span>
                                <span class="n">ais_angle_threshold</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
                                <span class="n">non_ais_angle_threshold</span> <span class="o">=</span> <span class="mi">65</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_limbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_axon_non_axon_faces</span><span class="p">:</span>
            <span class="n">axon_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
            <span class="n">non_axon_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">axon_faces</span><span class="p">,</span><span class="n">non_axon_faces</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    
    <span class="n">axon_seg_dict</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_like_segments</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">include_ais</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">filter_away_end_false_positives</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">visualize_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="p">)</span>

    <span class="c1"># Step 2: Get the branches that should not be considered for axons</span>


    <span class="n">to_keep_limb_names</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">filter_limbs_below_soma_percentile</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">axons_to_consider</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">axon_seg_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">to_keep_limb_names</span><span class="p">])</span>
    <span class="n">axons_to_not_keep</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">axon_seg_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_keep_limb_names</span><span class="p">])</span>
    

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axons not keeping because of soma: </span><span class="si">{</span><span class="n">axons_to_not_keep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Step 3: Erroring out the axons based on projections</span>

    <span class="n">valid_axon_branches_by_limb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">not_valid_axon_branches_by_limb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


    
    <span class="n">axon_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">curr_limb_name</span><span class="p">,</span><span class="n">curr_axon_nodes</span> <span class="ow">in</span> <span class="n">axons_to_consider</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----- Working on </span><span class="si">{</span><span class="n">curr_limb_name</span><span class="si">}</span><span class="s2"> ------&quot;</span><span class="p">)</span>
        <span class="c1"># curr_limb_name = &quot;L0&quot;</span>
        <span class="c1"># curr_axon_nodes = axons_to_consider[curr_limb_name]</span>
        <span class="n">curr_limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">curr_limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>


        <span class="c1">#1) Get the nodes that are axons</span>


        <span class="c1">#2) Group into connected components</span>
        <span class="n">curr_limb_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="n">axon_subgraph</span> <span class="o">=</span> <span class="n">curr_limb_network</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">curr_axon_nodes</span><span class="p">)</span>
        <span class="n">axon_connected_components</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">axon_subgraph</span><span class="p">))</span>

        <span class="n">valid_axon_branches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#3) Iterate through the connected components</span>
        <span class="k">for</span> <span class="n">ax_idx</span><span class="p">,</span><span class="n">ax_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axon_connected_components</span><span class="p">):</span>
            <span class="n">valid_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Axon Group </span><span class="si">{</span><span class="n">ax_idx</span><span class="si">}</span><span class="s2"> of size </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ax_group</span><span class="p">)</span><span class="si">}</span><span class="s2">--&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">soma_idx</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">():</span>
                <span class="n">all_start_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_starting_attr_by_limb_and_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="s2">&quot;starting_node&quot;</span><span class="p">)</span>
                <span class="n">all_start_coord</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_starting_attr_by_limb_and_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">start_node</span><span class="p">,</span><span class="n">start_coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_start_node</span><span class="p">,</span><span class="n">all_start_coord</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Working on soma </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">, starting_node </span><span class="si">{</span><span class="n">start_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1">#find the shortest path between the axon group and the starting node</span>
                    <span class="n">current_shortest_path</span><span class="p">,</span><span class="n">st_node</span><span class="p">,</span><span class="n">end_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">curr_limb_network</span><span class="p">,[</span><span class="n">start_node</span><span class="p">],</span><span class="nb">list</span><span class="p">(</span><span class="n">ax_group</span><span class="p">))</span>
                    

                    <span class="c1">#get the skeleton of the path</span>
                    <span class="n">path_skeletons</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">current_shortest_path</span><span class="p">])</span>

                    <span class="c1">#order the skeleton by a certain coordinate</span>
                    <span class="n">ordered_path_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">path_skeletons</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">start_coord</span><span class="p">)</span>

                    <span class="c1">#check and see if skeletal distance is lower than distance check and if it is then use a different angle check</span>
                    <span class="k">if</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">ordered_path_skeleton</span><span class="p">)</span><span class="o">&lt;</span> <span class="n">min_skeletal_path_threshold</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using AIS angle threshold </span><span class="si">{</span><span class="n">ais_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">curr_angle_threshold</span> <span class="o">=</span> <span class="n">ais_angle_threshold</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not using AIS angle threshold&quot;</span><span class="p">)</span>
                        <span class="n">curr_angle_threshold</span> <span class="o">=</span> <span class="n">non_ais_angle_threshold</span>


                    <span class="c1">#get the first skeletal distance of threshold</span>
                    <span class="n">keep_skeleton_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">ordered_path_skeleton</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">sub_skeleton_length</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                    
                    <span class="n">restricted_skeleton</span> <span class="o">=</span> <span class="n">ordered_path_skeleton</span><span class="p">[</span><span class="n">keep_skeleton_indices</span><span class="p">]</span>
                    <span class="n">restricted_skeleton_endpoints_sk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                    <span class="n">restricted_skeleton_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">restricted_skeleton</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">restricted_skeleton_vector</span> <span class="o">=</span> <span class="n">restricted_skeleton_vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">restricted_skeleton_vector</span><span class="p">)</span>

                    <span class="c1">#angle between going down and skeleton vector</span>
                    <span class="n">sk_angle</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">axon_vector</span><span class="p">,</span><span class="n">restricted_skeleton_vector</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_angle= </span><span class="si">{</span><span class="n">sk_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">sk_angle</span> <span class="o">&gt;</span> <span class="n">curr_angle_threshold</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*****Path to axon group not valid******&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="k">pass</span>
                            <span class="c1">#print(&quot;Path to axon group valid so adding them as valid axon segments&quot;)</span>
                        <span class="n">valid_axon_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ax_group</span><span class="p">))</span>
                        <span class="n">valid_flag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

    <span class="c1">#                 if curr_limb_name == &quot;L1&quot;:</span>
    <span class="c1">#                     raise Exception()</span>

                <span class="k">if</span> <span class="n">valid_flag</span><span class="p">:</span>
                    <span class="k">break</span>


        
            

        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_axon_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">valid_axon_branches_by_limb</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">valid_axon_branches</span><span class="p">)</span>
            <span class="n">not_valid_axon_branches_by_limb</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_axon_nodes</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">valid_axon_branches</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_axon_branches_by_limb</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">not_valid_axon_branches_by_limb</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_axon_nodes</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">For limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2"> the valid axon branches are </span><span class="si">{</span><span class="n">valid_axon_branches_by_limb</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following are not valid: </span><span class="si">{</span><span class="n">not_valid_axon_branches_by_limb</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Step 4: Compiling all the errored faces</span>


    <span class="n">final_error_axons</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">axons_to_not_keep</span><span class="p">)</span>
    <span class="n">final_error_axons</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">not_valid_axon_branches_by_limb</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_error_axons = </span><span class="si">{</span><span class="n">final_error_axons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">visualize_errors_at_end</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                              <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">final_error_axons</span><span class="p">,</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                             <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">final_error_axons</span></div>


<div class="viewcode-block" id="error_faces_by_axons"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.error_faces_by_axons">[docs]</a><span class="k">def</span> <span class="nf">error_faces_by_axons</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">error_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">visualize_errors_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">min_skeletal_path_threshold</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span>
                                <span class="n">sub_skeleton_length</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span>
                                <span class="n">ais_angle_threshold</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
                                <span class="n">non_ais_angle_threshold</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
                         <span class="n">return_axon_non_axon_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the faces that are errors after computing </span>
<span class="sd">    the branches that are errors</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">error_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">final_error_axons</span> <span class="o">=</span> <span class="n">error_branches_by_axons</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                    <span class="n">visualize_errors_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">min_skeletal_path_threshold</span> <span class="o">=</span> <span class="n">min_skeletal_path_threshold</span><span class="p">,</span>
                                <span class="n">sub_skeleton_length</span> <span class="o">=</span> <span class="n">sub_skeleton_length</span><span class="p">,</span>
                                <span class="n">ais_angle_threshold</span> <span class="o">=</span> <span class="n">ais_angle_threshold</span><span class="p">,</span>
                                <span class="n">non_ais_angle_threshold</span> <span class="o">=</span> <span class="n">non_ais_angle_threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_error_axons</span> <span class="o">=</span> <span class="n">error_branches</span>
        
    
    <span class="c1"># Step 5: Getting all of the errored faces</span>
    <span class="n">error_faces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_limb_name</span><span class="p">,</span><span class="n">error_branch_idx</span> <span class="ow">in</span> <span class="n">final_error_axons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span>
        <span class="n">curr_error_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                            <span class="p">[</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">error_branch_idx</span><span class="p">],</span>
                                       <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


        <span class="c1">#curr_error_faces = np.concatenate([new_limb_mesh_face_idx[curr_limb[k].mesh_face_idx] for k in error_branch_idx])</span>
        <span class="n">error_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_error_faces</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_faces_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">error_faces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">error_faces_concat</span> <span class="o">=</span> <span class="n">error_faces</span>
        
    <span class="n">error_faces_concat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error_faces_concat</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> -------- Total number of error faces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">error_faces_concat</span><span class="p">)</span><span class="si">}</span><span class="s2"> --------------&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">visualize_errors_at_end</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">error_faces_concat</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">return_axon_non_axon_faces</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the axon and non-axonal faces&quot;</span><span class="p">)</span>
        <span class="n">axon_faces</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_dict_to_faces</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">valid_axon_branches_by_limb</span><span class="p">)</span>
        <span class="n">non_axon_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">axon_faces</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_faces_concat</span><span class="p">,</span><span class="n">axon_faces</span><span class="p">,</span><span class="n">non_axon_faces</span>
        
    <span class="k">return</span> <span class="n">error_faces_concat</span></div>

<span class="sd">&#39;&#39;&#39; Old Way that did not have the function split up</span>
<span class="sd">def error_faces_by_axons(neuron_obj,verbose=False,visualize_errors_at_end=False,</span>
<span class="sd">                        min_skeletal_path_threshold = 15000,</span>
<span class="sd">                                sub_skeleton_length = 20000,</span>
<span class="sd">                                ais_angle_threshold = 110,</span>
<span class="sd">                                non_ais_angle_threshold = 50,</span>
<span class="sd">                         return_axon_non_axon_faces=False):</span>
<span class="sd">    </span>
<span class="sd">    if neuron_obj.n_limbs == 0:</span>
<span class="sd">        if return_axon_non_axon_faces:</span>
<span class="sd">            axon_faces = np.array([])</span>
<span class="sd">            non_axon_faces = np.arange(len(neuron_obj.mesh.faces))</span>
<span class="sd">            return np.array([]),axon_faces,non_axon_faces</span>
<span class="sd">        return np.array([])</span>
<span class="sd">    </span>
<span class="sd">    axon_seg_dict = au.axon_like_segments(neuron_obj,include_ais=False,</span>
<span class="sd">                                          filter_away_end_false_positives=True,</span>
<span class="sd">                                          visualize_at_end=False,</span>
<span class="sd">                                         )</span>

<span class="sd">    # Step 2: Get the branches that should not be considered for axons</span>


<span class="sd">    to_keep_limb_names = nru.filter_limbs_below_soma_percentile(neuron_obj,verbose=False)</span>

<span class="sd">    axons_to_consider = dict([(k,v) for k,v in axon_seg_dict.items() if k in to_keep_limb_names])</span>
<span class="sd">    axons_to_not_keep = dict([(k,v) for k,v in axon_seg_dict.items() if k not in to_keep_limb_names])</span>
<span class="sd">    </span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Axons not keeping because of soma: {axons_to_not_keep}&quot;)</span>

<span class="sd">    # Step 3: Erroring out the axons based on projections</span>

<span class="sd">    valid_axon_branches_by_limb = dict()</span>
<span class="sd">    not_valid_axon_branches_by_limb = dict()</span>


<span class="sd">    </span>
<span class="sd">    axon_vector = np.array([0,1,0])</span>

<span class="sd">    for curr_limb_name,curr_axon_nodes in axons_to_consider.items():</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;\n----- Working on {curr_limb_name} ------&quot;)</span>
<span class="sd">        # curr_limb_name = &quot;L0&quot;</span>
<span class="sd">        # curr_axon_nodes = axons_to_consider[curr_limb_name]</span>
<span class="sd">        curr_limb_idx = int(curr_limb_name[1:])</span>
<span class="sd">        curr_limb = neuron_obj[curr_limb_idx]</span>


<span class="sd">        #1) Get the nodes that are axons</span>


<span class="sd">        #2) Group into connected components</span>
<span class="sd">        curr_limb_network = nx.from_edgelist(curr_limb.concept_network.edges())</span>
<span class="sd">        axon_subgraph = curr_limb_network.subgraph(curr_axon_nodes)</span>
<span class="sd">        axon_connected_components = list(nx.connected_components(axon_subgraph))</span>

<span class="sd">        valid_axon_branches = []</span>

<span class="sd">        #3) Iterate through the connected components</span>
<span class="sd">        for ax_idx,ax_group in enumerate(axon_connected_components):</span>
<span class="sd">            valid_flag = False</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;-- Axon Group {ax_idx} of size {len(ax_group)}--&quot;)</span>
<span class="sd">            for soma_idx in curr_limb.touching_somas():</span>
<span class="sd">                all_start_node = nru.all_starting_attr_by_limb_and_soma(curr_limb,soma_idx,&quot;starting_node&quot;)</span>
<span class="sd">                all_start_coord = nru.all_starting_attr_by_limb_and_soma(curr_limb,soma_idx,&quot;starting_coordinate&quot;)</span>
<span class="sd">                for start_node,start_coord in zip(all_start_node,all_start_coord):</span>
<span class="sd">                    if verbose:</span>
<span class="sd">                        print(f&quot;   Working on soma {soma_idx}, starting_node {start_node}&quot;)</span>

<span class="sd">                    #find the shortest path between the axon group and the starting node</span>
<span class="sd">                    current_shortest_path,st_node,end_node = xu.shortest_path_between_two_sets_of_nodes(curr_limb_network,[start_node],list(ax_group))</span>
<span class="sd">                    </span>

<span class="sd">                    #get the skeleton of the path</span>
<span class="sd">                    path_skeletons = sk.stack_skeletons([curr_limb[k].skeleton for k in current_shortest_path])</span>

<span class="sd">                    #order the skeleton by a certain coordinate</span>
<span class="sd">                    ordered_path_skeleton = sk.order_skeleton(path_skeletons,start_endpoint_coordinate=start_coord)</span>

<span class="sd">                    #check and see if skeletal distance is lower than distance check and if it is then use a different angle check</span>
<span class="sd">                    if sk.calculate_skeleton_distance(ordered_path_skeleton)&lt; min_skeletal_path_threshold:</span>
<span class="sd">                        if verbose:</span>
<span class="sd">                            print(f&quot;Using AIS angle threshold {ais_angle_threshold}&quot;)</span>
<span class="sd">                        curr_angle_threshold = ais_angle_threshold</span>
<span class="sd">                    else:</span>
<span class="sd">                        if verbose:</span>
<span class="sd">                            print(&quot;Not using AIS angle threshold&quot;)</span>
<span class="sd">                        curr_angle_threshold = non_ais_angle_threshold</span>


<span class="sd">                    #get the first skeletal distance of threshold</span>
<span class="sd">                    keep_skeleton_indices = np.where(sk.calculate_skeleton_segment_distances(ordered_path_skeleton)&lt;=sub_skeleton_length)[0]</span>

<span class="sd">                    </span>
<span class="sd">                    restricted_skeleton = ordered_path_skeleton[keep_skeleton_indices]</span>
<span class="sd">                    restricted_skeleton_endpoints_sk = np.array([restricted_skeleton[0][0],restricted_skeleton[-1][-1]]).reshape(-1,2,3)</span>
<span class="sd">                    restricted_skeleton_vector = np.array(restricted_skeleton[-1][-1]-restricted_skeleton[0][0])</span>
<span class="sd">                    restricted_skeleton_vector = restricted_skeleton_vector/np.linalg.norm(restricted_skeleton_vector)</span>

<span class="sd">                    #angle between going down and skeleton vector</span>
<span class="sd">                    sk_angle = nu.angle_between_vectors(axon_vector,restricted_skeleton_vector)</span>
<span class="sd">                    if verbose:</span>
<span class="sd">                        print(f&quot;sk_angle= {sk_angle}&quot;)</span>

<span class="sd">                    if sk_angle &gt; curr_angle_threshold:</span>
<span class="sd">                        if verbose:</span>
<span class="sd">                            print(&quot;*****Path to axon group not valid******&quot;)</span>
<span class="sd">                    else:</span>
<span class="sd">                        if verbose:</span>
<span class="sd">                            pass</span>
<span class="sd">                            #print(&quot;Path to axon group valid so adding them as valid axon segments&quot;)</span>
<span class="sd">                        valid_axon_branches.append(list(ax_group))</span>
<span class="sd">                        valid_flag = True</span>
<span class="sd">                        break</span>

<span class="sd">    #                 if curr_limb_name == &quot;L1&quot;:</span>
<span class="sd">    #                     raise Exception()</span>

<span class="sd">                if valid_flag:</span>
<span class="sd">                    break</span>


<span class="sd">        </span>
<span class="sd">            </span>

<span class="sd">        </span>
<span class="sd">        if len(valid_axon_branches) &gt; 0:</span>
<span class="sd">            valid_axon_branches_by_limb[curr_limb_name] = np.concatenate(valid_axon_branches)</span>
<span class="sd">            not_valid_axon_branches_by_limb[curr_limb_name] = list(np.setdiff1d(curr_axon_nodes,np.concatenate(valid_axon_branches)))</span>
<span class="sd">        else:</span>
<span class="sd">            valid_axon_branches_by_limb[curr_limb_name] = []</span>
<span class="sd">            not_valid_axon_branches_by_limb[curr_limb_name] = list(curr_axon_nodes)</span>
<span class="sd">        </span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;\n\nFor limb {curr_limb_idx} the valid axon branches are {valid_axon_branches_by_limb[curr_limb_name] }&quot;)</span>
<span class="sd">            print(f&quot;The following are not valid: {not_valid_axon_branches_by_limb[curr_limb_name]}&quot;)</span>

<span class="sd">    # Step 4: Compiling all the errored faces</span>


<span class="sd">    final_error_axons = copy.copy(axons_to_not_keep)</span>
<span class="sd">    final_error_axons.update(not_valid_axon_branches_by_limb)</span>
<span class="sd">    </span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;final_error_axons = {final_error_axons}&quot;)</span>


<span class="sd">    # Step 5: Getting all of the errored faces</span>

<span class="sd">    error_faces = []</span>
<span class="sd">    for curr_limb_name,error_branch_idx in final_error_axons.items():</span>
<span class="sd">        curr_limb = neuron_obj[curr_limb_name]</span>
<span class="sd">        curr_error_faces = tu.original_mesh_faces_map(neuron_obj.mesh,</span>
<span class="sd">                                                            [curr_limb[k].mesh for k in error_branch_idx],</span>
<span class="sd">                                       matching=True,</span>
<span class="sd">                                       print_flag=False)</span>


<span class="sd">        #curr_error_faces = np.concatenate([new_limb_mesh_face_idx[curr_limb[k].mesh_face_idx] for k in error_branch_idx])</span>
<span class="sd">        error_faces.append(curr_error_faces)</span>

<span class="sd">    if len(error_faces) &gt; 0:</span>
<span class="sd">        error_faces_concat = np.concatenate(error_faces)</span>
<span class="sd">    else:</span>
<span class="sd">        error_faces_concat = error_faces</span>
<span class="sd">        </span>
<span class="sd">    error_faces_concat = np.array(error_faces_concat).astype(&quot;int&quot;)</span>
<span class="sd">        </span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;\n\n -------- Total number of error faces = {len(error_faces_concat)} --------------&quot;)</span>

<span class="sd">    if visualize_errors_at_end:</span>
<span class="sd">        nviz.plot_objects(main_mesh = neuron_obj.mesh,</span>
<span class="sd">            meshes=[neuron_obj.mesh.submesh([error_faces_concat],append=True)],</span>
<span class="sd">                         meshes_colors=[&quot;red&quot;])</span>
<span class="sd">        </span>
<span class="sd">    if return_axon_non_axon_faces:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(&quot;Computing the axon and non-axonal faces&quot;)</span>
<span class="sd">        axon_faces = nru.limb_branch_dict_to_faces(neuron_obj,valid_axon_branches_by_limb)</span>
<span class="sd">        non_axon_faces = np.delete(np.arange(len(neuron_obj.mesh.faces)),axon_faces)</span>
<span class="sd">        return error_faces_concat,axon_faces,non_axon_faces</span>
<span class="sd">        </span>
<span class="sd">    return error_faces_concat</span>

<span class="sd">&#39;&#39;&#39;</span>




    
<span class="c1"># ---- 4/22 v4 Error Detection Rules ----------</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def axon_fork_divergence_errors_limb_branch_dict(neuron_obj,</span>
<span class="sd">                                           divergence_threshold_mean = 160,</span>
<span class="sd">                                            upstream_width_threshold = 80,</span>
<span class="sd">                                           verbose = False,</span>
<span class="sd">                                                ):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will create a limb branch dict of all the skinny forking errors</span>
<span class="sd">    on an axon</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the axon limb of the neuron (if none then return emptty dictionary)</span>
<span class="sd">    2) Restrict the neuron to only axon pieces, with a width below certain threshold and having one sibling</span>
<span class="sd">    3) Run the fork divergence function </span>
<span class="sd">    4) Return the limb branch dict highlight the errors where occured</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    if neuron_obj.axon_limb_name is None:</span>
<span class="sd">        return {}</span>
<span class="sd">    </span>
<span class="sd">    axon_brancehs = ns.query_neuron_by_labels(neuron_obj,</span>
<span class="sd">                                         matching_labels = [&quot;axon&quot;])</span>

<span class="sd">    two_downstream_thick_axon_limb_branch = ns.query_neuron(neuron_obj,</span>
<span class="sd">                   functions_list = [&quot;n_siblings&quot;,&quot;axon_width&quot;],</span>
<span class="sd">                   query = f&quot;(n_siblings == 1) and (axon_width)&lt;{downstream_width_threshold}&quot;,</span>
<span class="sd">                   return_dataframe=False,</span>
<span class="sd">                    limb_branch_dict_restriction=axon_brancehs,</span>
<span class="sd">                   limbs_to_process=[neuron_obj.axon_limb_name])</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;two_downstream_thick_axon_limb_branch = {two_downstream_thick_axon_limb_branch}&quot;)</span>

<span class="sd">    fork_div_limb_branch = ns.query_neuron(neuron_obj,</span>
<span class="sd">               functions_list = [&quot;fork_divergence&quot;],</span>
<span class="sd">               query = f&quot;fork_divergence &lt; {divergence_threshold_mean}&quot;,</span>
<span class="sd">               return_dataframe=False,</span>
<span class="sd">                limb_branch_dict_restriction=two_downstream_thick_axon_limb_branch,</span>
<span class="sd">               limbs_to_process=[neuron_obj.axon_limb_name])</span>
<span class="sd">    </span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;With divergence_threshold_mean = {divergence_threshold_mean}\nfork_div_limb_branch = {fork_div_limb_branch}&quot;)</span>

<span class="sd">    return fork_div_limb_branch</span>

<span class="sd">&#39;&#39;&#39;</span>
<div class="viewcode-block" id="attempt_width_matching_for_fork_divergence"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.attempt_width_matching_for_fork_divergence">[docs]</a><span class="k">def</span> <span class="nf">attempt_width_matching_for_fork_divergence</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                              <span class="n">fork_div_limb_branch</span><span class="p">,</span>
                                              <span class="n">width_match_threshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                                              <span class="n">width_match_buffer</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To see if there is a possible winner in the forking</span>
<span class="sd">    based on width matching, and if there is then </span>
<span class="sd">    remove it from the error branches</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Divide the branches into sibling groups</span>
<span class="sd">    2) For each sibling group:</span>

<span class="sd">    a. Get the upstream node and its width</span>
<span class="sd">    b. Get the widths of all of the sibling nodes </span>
<span class="sd">    c. subtract the upstream nodes with from them and take the absolute value</span>
<span class="sd">    d. get the minimum differences and check 2 things:</span>
<span class="sd">        i) less than width_match_threshold</span>
<span class="sd">        2) less than maximum difference by width_match_buffer</span>

<span class="sd">    e1. If yes --&gt; then only add the argmax to the error branches</span>
<span class="sd">    e2. If no --&gt; then add both to the error branches</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Divide the branches into sibling groups</span>
    <span class="n">fork_div_limb_branch_rev</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">fork_div_limb_branch</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">fork_div_limb_branch_rev</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#1) Divide the branches into sibling groups</span>
        <span class="n">sib_groups</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">group_nodes_into_siblings</span><span class="p">(</span><span class="n">G</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">branch_list</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> sib_groups= </span><span class="si">{</span><span class="n">sib_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sib_groups</span><span class="p">:</span>
            <span class="c1">#a. Get the upstream node and its width</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not processing </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> because there was not 2 nodes in pair&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
                
            <span class="n">up_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">up_node_width</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">up_node</span><span class="p">])</span>

            <span class="n">d_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span>
            <span class="n">width_differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d_widths</span> <span class="o">-</span> <span class="n">up_node_width</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For sibling group </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">: upstream node = </span><span class="si">{</span><span class="n">up_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">F</span><span class="s2">&quot;Widths are </span><span class="si">{</span><span class="n">d_widths</span><span class="si">}</span><span class="s2">, upstream_width = </span><span class="si">{</span><span class="n">up_node_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_differences= </span><span class="si">{</span><span class="n">width_differences</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            d. get the minimum differences and check 2 things:</span>
<span class="sd">            i) less than width_match_threshold</span>
<span class="sd">            2) less than maximum difference by width_match_buffer</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">winning_idx</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">width_differences</span><span class="p">)</span>
            <span class="n">max_idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">min_idx</span>

            <span class="k">if</span> <span class="p">((</span><span class="n">width_differences</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>  <span class="o">&lt;</span> <span class="n">width_match_threshold</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">width_differences</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">width_match_buffer</span> <span class="o">&lt;</span> <span class="n">width_differences</span><span class="p">[</span><span class="n">max_idx</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With min_idx= </span><span class="si">{</span><span class="n">min_idx</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">s</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span><span class="si">}</span><span class="s2"> was a matching node to the upstream node&quot;</span><span class="p">)</span>
                <span class="n">winning_idx</span> <span class="o">=</span> <span class="n">min_idx</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            e1. If yes --&gt; then only add the argmax to the error branches</span>
<span class="sd">            e2. If no --&gt; then add both to the error branches</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">winning_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fork_div_limb_branch_rev</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fork_div_limb_branch_rev</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">max_idx</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">fork_div_limb_branch_rev</span></div>


<div class="viewcode-block" id="axon_fork_divergence_errors_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.axon_fork_divergence_errors_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">axon_fork_divergence_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">divergence_threshold_mean</span> <span class="o">=</span> <span class="mi">160</span><span class="p">,</span>
                                            <span class="n">width_threshold</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
                                            <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span>
                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">plot_two_downstream_thick_axon_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">plot_fork_div_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            
                                            <span class="c1">#arguments for attempting a matching of the one of the 2 parts of fork</span>
                                            <span class="n">attempt_width_matching</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="n">width_match_threshold</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                                            <span class="n">width_match_buffer</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                                                 
                                                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will create a limb branch dict of all the skinny forking errors</span>
<span class="sd">    on an axon</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the axon limb of the neuron (if none then return emptty dictionary)</span>
<span class="sd">    2) Restrict the neuron to only axon pieces, with a width below certain threshold and having one sibling</span>
<span class="sd">    3) Run the fork divergence function </span>
<span class="sd">    4) Return the limb branch dict highlight the errors where occured</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="n">axon_brancehs</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>

    <span class="n">two_downstream_thick_axon_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_siblings&quot;</span><span class="p">,</span><span class="s2">&quot;axon_width&quot;</span><span class="p">,</span><span class="s2">&quot;upstream_axon_width&quot;</span><span class="p">],</span>
                   <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(n_siblings == 1) and (axon_width&lt;</span><span class="si">{</span><span class="n">width_threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; and (upstream_axon_width &lt; </span><span class="si">{</span><span class="n">upstream_width_max</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                   <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">axon_brancehs</span><span class="p">,</span>
                   <span class="n">limbs_to_process</span><span class="o">=</span><span class="p">[</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_name</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;two_downstream_thick_axon_limb_branch = </span><span class="si">{</span><span class="n">two_downstream_thick_axon_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_two_downstream_thick_axon_limb_branch</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">two_downstream_thick_axon_limb_branch</span><span class="p">)</span>

    <span class="n">fork_div_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
               <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fork_divergence&quot;</span><span class="p">],</span>
               <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;fork_divergence &lt; </span><span class="si">{</span><span class="n">divergence_threshold_mean</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
               <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">two_downstream_thick_axon_limb_branch</span><span class="p">,</span>
               <span class="n">limbs_to_process</span><span class="o">=</span><span class="p">[</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_name</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With divergence_threshold_mean = </span><span class="si">{</span><span class="n">divergence_threshold_mean</span><span class="si">}</span><span class="se">\n</span><span class="s2">fork_div_limb_branch = </span><span class="si">{</span><span class="n">fork_div_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">attempt_width_matching</span><span class="p">:</span>
        <span class="n">fork_div_limb_branch</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">attempt_width_matching_for_fork_divergence</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                              <span class="n">fork_div_limb_branch</span><span class="p">,</span>
                                              <span class="n">width_match_threshold</span> <span class="o">=</span> <span class="n">width_match_threshold</span><span class="p">,</span>
                                              <span class="n">width_match_buffer</span> <span class="o">=</span> <span class="n">width_match_buffer</span><span class="p">,</span>
                                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_fork_div_limb_branch</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">fork_div_limb_branch</span><span class="p">)</span>
    
    <span class="n">final_limb_branch</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">fork_div_limb_branch</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">final_limb_branch</span></div>



<div class="viewcode-block" id="webbing_t_errors_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.webbing_t_errors_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">webbing_t_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">axon_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="c1">#child_width_maximum = 75,</span>
                                <span class="n">child_width_maximum</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                <span class="n">plot_two_downstream_thin_axon_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">plot_wide_angled_children</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">error_if_web_is_none</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

                                <span class="c1">#arguments for the web thresholding</span>
                                <span class="n">web_size_threshold</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
                                <span class="n">web_size_type</span><span class="o">=</span><span class="s2">&quot;ray_trace_median&quot;</span><span class="p">,</span>
                                <span class="n">web_above_threshold</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

                                <span class="n">plot_web_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">child_skeletal_threshold</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                     <span class="n">ignore_if_child_mesh_not_touching</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Return all of the branches that are errors based on the </span>
<span class="sd">    rule that when the axon is small and forms a wide angle t then </span>
<span class="sd">    there should be a characteristic webbing that is wide enough </span>
<span class="sd">    (if not then it is probably just a merge error)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all of the candidate branches in the axon</span>
<span class="sd">    2) Find all those that have a webbing t error</span>
<span class="sd">    3) find all of the downstream nodes of that nodes </span>
<span class="sd">    and add them to a limb branch dict that gets returned</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">wide_angled_children</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">wide_angle_t_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">axon_only</span> <span class="o">=</span> <span class="n">axon_only</span><span class="p">,</span>
                                                <span class="n">child_width_maximum</span> <span class="o">=</span> <span class="n">child_width_maximum</span><span class="p">,</span>
                                                <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="n">parent_width_maximum</span><span class="p">,</span>
                                                <span class="n">plot_two_downstream_thin_axon_limb_branch</span> <span class="o">=</span> <span class="n">plot_two_downstream_thin_axon_limb_branch</span><span class="p">,</span>
                                                <span class="n">plot_wide_angled_children</span> <span class="o">=</span> <span class="n">plot_wide_angled_children</span><span class="p">,</span>
                                                <span class="n">child_skeletal_threshold</span> <span class="o">=</span> <span class="n">child_skeletal_threshold</span><span class="p">,</span>
                                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ignore_if_child_mesh_not_touching</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;wide_angled_children before ignoring non touhing meshes = </span><span class="si">{</span><span class="n">wide_angled_children</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">wide_angled_children</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;downstream_nodes_mesh_connected&quot;</span><span class="p">],</span>
                <span class="n">query</span><span class="o">=</span><span class="s2">&quot;downstream_nodes_mesh_connected == True&quot;</span><span class="p">,</span>
               <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">wide_angled_children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;wide_angled_children AFTER ignoring non touhing meshes = </span><span class="si">{</span><span class="n">wide_angled_children</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">invalid_branches_from_webbing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l_name</span><span class="p">,</span><span class="n">error_web_branches</span> <span class="ow">in</span> <span class="n">wide_angled_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span>
        <span class="n">local_errors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">error_web_branches</span><span class="p">:</span>
            <span class="n">curr_web</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">.</span><span class="n">web</span>

            <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">error_if_web_is_none</span> <span class="ow">and</span> <span class="n">curr_web</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">curr_web</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">au</span><span class="o">.</span><span class="n">valid_web_for_t</span><span class="p">(</span><span class="n">curr_web</span><span class="p">,</span>
                                   <span class="n">size_threshold</span> <span class="o">=</span> <span class="n">web_size_threshold</span><span class="p">,</span>
                                   <span class="n">size_type</span> <span class="o">=</span> <span class="n">web_size_type</span><span class="p">,</span>
                                   <span class="n">above_threshold</span> <span class="o">=</span> <span class="n">web_above_threshold</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">):</span>
                <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">add_downstream_nodes</span><span class="p">:</span>
                <span class="n">down_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">down_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From limb </span><span class="si">{</span><span class="n">l_name</span><span class="si">}</span><span class="s2">, branch </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">, Adding the downstream nodes </span><span class="si">{</span><span class="n">down_nodes</span><span class="si">}</span><span class="s2">  &quot;</span><span class="p">)</span>
                    <span class="n">local_errors</span> <span class="o">+=</span> <span class="n">down_nodes</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_errors</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">invalid_branches_from_webbing</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_errors</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final web t error limb branch dict = </span><span class="si">{</span><span class="n">invalid_branches_from_webbing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_web_errors</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">invalid_branches_from_webbing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">invalid_branches_from_webbing</span></div>

<div class="viewcode-block" id="webbing_t_errors_limb_branch_dict_old"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.webbing_t_errors_limb_branch_dict_old">[docs]</a><span class="k">def</span> <span class="nf">webbing_t_errors_limb_branch_dict_old</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">axon_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="c1">#child_width_maximum = 75,</span>
                                <span class="n">child_width_maximum</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                <span class="n">plot_two_downstream_thin_axon_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">plot_wide_angled_children</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">error_if_web_is_none</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

                                <span class="c1">#arguments for the web thresholding</span>
                                <span class="n">web_size_threshold</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
                                <span class="n">web_size_type</span><span class="o">=</span><span class="s2">&quot;ray_trace_median&quot;</span><span class="p">,</span>
                                <span class="n">web_above_threshold</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

                                <span class="n">plot_web_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">child_skeletal_threshold</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                     <span class="n">ignore_if_child_mesh_not_touching</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Return all of the branches that are errors based on the </span>
<span class="sd">    rule that when the axon is small and forms a wide angle t then </span>
<span class="sd">    there should be a characteristic webbing that is wide enough </span>
<span class="sd">    (if not then it is probably just a merge error)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all of the candidate branches in the axon</span>
<span class="sd">    2) Find all those that have a webbing t error</span>
<span class="sd">    3) find all of the downstream nodes of that nodes </span>
<span class="sd">    and add them to a limb branch dict that gets returned</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">wide_angled_children</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">wide_angle_t_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">axon_only</span> <span class="o">=</span> <span class="n">axon_only</span><span class="p">,</span>
                                                <span class="n">child_width_maximum</span> <span class="o">=</span> <span class="n">child_width_maximum</span><span class="p">,</span>
                                                <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="n">parent_width_maximum</span><span class="p">,</span>
                                                <span class="n">plot_two_downstream_thin_axon_limb_branch</span> <span class="o">=</span> <span class="n">plot_two_downstream_thin_axon_limb_branch</span><span class="p">,</span>
                                                <span class="n">plot_wide_angled_children</span> <span class="o">=</span> <span class="n">plot_wide_angled_children</span><span class="p">,</span>
                                                <span class="n">child_skeletal_threshold</span> <span class="o">=</span> <span class="n">child_skeletal_threshold</span><span class="p">,</span>
                                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>


    <span class="n">invalid_branches_from_webbing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">upstream_nodes_for_error</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l_name</span><span class="p">,</span><span class="n">error_web_branches</span> <span class="ow">in</span> <span class="n">wide_angled_children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span>
        <span class="n">local_upstream</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">error_web_branches</span><span class="p">:</span>
            <span class="n">curr_web</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">w</span><span class="p">]</span><span class="o">.</span><span class="n">web</span>

            <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">error_if_web_is_none</span> <span class="ow">and</span> <span class="n">curr_web</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">curr_web</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">au</span><span class="o">.</span><span class="n">valid_web_for_t</span><span class="p">(</span><span class="n">curr_web</span><span class="p">,</span>
                                   <span class="n">size_threshold</span> <span class="o">=</span> <span class="n">web_size_threshold</span><span class="p">,</span>
                                   <span class="n">size_type</span> <span class="o">=</span> <span class="n">web_size_type</span><span class="p">,</span>
                                   <span class="n">above_threshold</span> <span class="o">=</span> <span class="n">web_above_threshold</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">):</span>
                <span class="n">add_downstream_nodes</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">add_downstream_nodes</span><span class="p">:</span>
                <span class="n">local_upstream</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_upstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">upstream_nodes_for_error</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_upstream</span>
    
    <span class="k">if</span> <span class="n">ignore_if_child_mesh_not_touching</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;local_upstream before ignoring non touhing meshes = </span><span class="si">{</span><span class="n">local_upstream</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">upstream_nodes_for_error</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;downstream_nodes_mesh_connected&quot;</span><span class="p">],</span>
                <span class="n">query</span><span class="o">=</span><span class="s2">&quot;downstream_nodes_mesh_connected == True&quot;</span><span class="p">,</span>
               <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">upstream_nodes_for_error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;local_upstream AFTER ignoring non touhing meshes = </span><span class="si">{</span><span class="n">local_upstream</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
    <span class="k">for</span> <span class="n">l_name</span><span class="p">,</span><span class="n">error_web_branches</span> <span class="ow">in</span> <span class="n">upstream_nodes_for_error</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">local_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">error_web_branches</span><span class="p">:</span>
            <span class="n">down_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">w</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">down_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From limb </span><span class="si">{</span><span class="n">l_name</span><span class="si">}</span><span class="s2">, branch </span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">, Adding the downstream nodes </span><span class="si">{</span><span class="n">down_nodes</span><span class="si">}</span><span class="s2">  &quot;</span><span class="p">)</span>
                <span class="n">local_errors</span> <span class="o">+=</span> <span class="n">down_nodes</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_errors</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">invalid_branches_from_webbing</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_errors</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final web t error limb branch dict = </span><span class="si">{</span><span class="n">invalid_branches_from_webbing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_web_errors</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">invalid_branches_from_webbing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">invalid_branches_from_webbing</span></div>

    
<span class="c1"># -------- New Rule 4: High Degree Branching ----------#</span>
    
<div class="viewcode-block" id="matched_branches_by_angle"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.matched_branches_by_angle">[docs]</a><span class="k">def</span> <span class="nf">matched_branches_by_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                              <span class="n">branches</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">shared_skeleton_endpoints_for_connected_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                    <span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                    <span class="n">check_concept_network_connectivity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">matched_branches_by_angle_at_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="o">=</span><span class="n">coordinate</span><span class="p">,</span>
    <span class="n">coordinate_branches</span> <span class="o">=</span> <span class="n">branches</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="matched_branches_by_angle_at_coordinate"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.matched_branches_by_angle_at_coordinate">[docs]</a><span class="k">def</span> <span class="nf">matched_branches_by_angle_at_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">coordinate_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_intermediates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_intermediates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_match_intermediates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">less_than_threshold</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Given a list of branch indexes on a limb that all touch, find:</span>
<span class="sd">    a) the skeleton angle between them all</span>
<span class="sd">    b) apply a threshold on the angle between to only keep those below/above</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import error_detection as ed</span>
<span class="sd">    ed.matched_branches_by_angle_at_coordinate(limb_obj,</span>
<span class="sd">                                            coordinate,</span>
<span class="sd">                                            offset=1500,</span>
<span class="sd">                                            comparison_distance = 1000,</span>
<span class="sd">                                            match_threshold = 40,</span>
<span class="sd">                                            verbose = True,</span>
<span class="sd">                                            plot_intermediates = False,</span>
<span class="sd">                                            plot_match_intermediates = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">coordinate_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coordinate_branches</span><span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">coordinate</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">curr_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate_branches = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">,</span><span class="n">curr_colors</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_intermediates</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">)</span>

    <span class="n">match_branches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">match_branches_angle</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">all_aligned_skeletons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">br1_idx</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">br2_idx</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">br1_idx</span><span class="o">&gt;=</span><span class="n">br2_idx</span><span class="p">:</span>
                <span class="k">continue</span>


            <span class="n">edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">]</span>
            <span class="n">edge_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">]</span>
            <span class="n">aligned_sk_parts</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">offset_skeletons_aligned_at_shared_endpoint</span><span class="p">(</span><span class="n">edge_skeletons</span><span class="p">,</span>
                                                                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                                             <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                                             <span class="n">common_endpoint</span><span class="o">=</span><span class="n">coordinate</span><span class="p">)</span>


            <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">parent_child_skeletal_angle</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Angle between </span><span class="si">{</span><span class="n">br1_idx</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">br2_idx</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">curr_angle</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

            <span class="c1"># - if within a threshold then add edge</span>
            <span class="k">if</span> <span class="n">less_than_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">curr_angle</span> <span class="o">&lt;=</span> <span class="n">match_threshold</span><span class="p">:</span>
                    <span class="n">match_branches</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">])</span>
                    <span class="n">match_branches_angle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">curr_angle</span> <span class="o">&gt;=</span> <span class="n">match_threshold</span><span class="p">:</span>
                    <span class="n">match_branches</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">br1_idx</span><span class="p">,</span><span class="n">br2_idx</span><span class="p">])</span>
                    <span class="n">match_branches_angle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_intermediates</span><span class="p">:</span>
                <span class="c1">#saving off the aligned skeletons to visualize later</span>
                <span class="n">all_aligned_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">all_aligned_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Matches = </span><span class="si">{</span><span class="n">match_branches</span><span class="si">}</span><span class="s2">, Final Matches Angle = </span><span class="si">{</span><span class="n">match_branches_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">plot_match_intermediates</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Aligned Skeleton Parts&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="n">all_aligned_skeletons</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_match_intermediates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_match</span> <span class="ow">in</span> <span class="n">match_branches</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_match</span><span class="p">],</span>
                 <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                 <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_match</span><span class="p">],</span>
                 <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">return_intermediates</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span><span class="p">,</span><span class="n">all_aligned_skeletons</span><span class="p">,</span><span class="n">curr_colors</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">match_branches</span><span class="p">,</span><span class="n">match_branches_angle</span></div>
<span class="w">    </span>
<span class="w">    </span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def high_degree_upstream_match_old(</span>
<span class="sd">    limb_obj,</span>
<span class="sd">    coordinate = None,</span>
<span class="sd">    upstream_branch = None,</span>
<span class="sd">    downstream_branches = None,</span>

<span class="sd">    #arguments for the angle checking</span>
<span class="sd">    offset=1500,</span>
<span class="sd">    comparison_distance = 2000,</span>
<span class="sd">    worst_case_match_threshold = 65,</span>
<span class="sd">    plot_intermediates = False,</span>
<span class="sd">    plot_match_intermediates = False,</span>

<span class="sd">    #args for width matching</span>
<span class="sd">    width_diff_max = 75,#np.inf,100,</span>
<span class="sd">    width_diff_perc = 60,</span>

<span class="sd">    #args for definite pairs</span>
<span class="sd">    match_threshold = 45,</span>
<span class="sd">    angle_buffer = 15,</span>
<span class="sd">    </span>
<span class="sd">    max_degree_to_resolve = 6,</span>
<span class="sd">    max_degree_to_resolve_wide = 8,</span>
<span class="sd">    max_degree_to_resolve_width_threshold = 200,</span>
<span class="sd">    </span>
<span class="sd">    axon_dependent = True,</span>
<span class="sd">    </span>
<span class="sd">    width_max = 170,</span>

<span class="sd">    #args for picking the final winner</span>
<span class="sd">    match_method = &quot;best_match&quot;, #other option is &quot;best_match&quot;</span>
<span class="sd">    </span>
<span class="sd">    remove_short_thick_endnodes = True,</span>
<span class="sd">    short_thick_endnodes_to_remove = None,</span>
<span class="sd">    min_degree_to_resolve = 4,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    </span>
<span class="sd">    kiss_check = True,</span>
<span class="sd">    kiss_check_bbox_longest_side_threshold = 450,</span>
<span class="sd">    </span>
<span class="sd">    ):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To figure out which downstream</span>
<span class="sd">    node is the most likely continuation of the </span>
<span class="sd">    upstream node</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Determine branches touching coordinate and which node is the upstream node and which are downstream</span>
<span class="sd">    1) Compute the skeletal angles between all branches</span>
<span class="sd">    2) Create a skeletal graph where make the edges between</span>
<span class="sd">    all nodes that meet the worst case scenario</span>
<span class="sd">    3) Compute the width difference between all branches connected by an edge</span>
<span class="sd">    Remove all the edges that violate the width difference threshold</span>
<span class="sd">    4) Create definite pairs by looking for edges that meet:</span>
<span class="sd">    - match threshold</span>
<span class="sd">    - have buffer better than other edges</span>
<span class="sd">    ** for those edges, eliminate all edges on those</span>
<span class="sd">    2 nodes except that edge</span>

<span class="sd">    5) If the upstream node has at least one valid </span>
<span class="sd">    match then eliminate others above the match threshold</span>

<span class="sd">    6) Get a subgraph that includes the upstream node:</span>
<span class="sd">    if there are other nodes in the group use on of the following to determine winner</span>
<span class="sd">        a) best match</span>
<span class="sd">        b) least sum angle</span>

<span class="sd">    7) Return the winning edge, and optionally all of the other</span>
<span class="sd">    downstream nodes that are errored out</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>

<span class="sd">    #0) Determine which node is the upstream node and which are downstream</span>
<span class="sd">    if upstream_branch is None or downstream_branches is None:</span>
<span class="sd">        branches_at_coord = nru.find_branch_with_specific_coordinate(limb_obj,coordinate)</span>

<span class="sd">        upstream_branch, downstream_branches = nru.classify_upstream_downsream(limb_obj,</span>
<span class="sd">                                   branch_list = branches_at_coord,</span>
<span class="sd">                                    verbose = verbose)</span>
<span class="sd">    else:</span>
<span class="sd">        branches_at_coord = np.hstack([downstream_branches,[upstream_branch]])</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;branches_at_coord = {branches_at_coord}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    4/24 Addition: Will remove the short thick axon endnodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if remove_short_thick_endnodes:</span>
<span class="sd">        if short_thick_endnodes_to_remove is None:</span>
<span class="sd">            short_thick_endnodes_to_remove = au.short_thick_branches_from_limb(limb_obj,</span>
<span class="sd">                                 verbose = False)</span>
<span class="sd">        branches_at_coord = np.setdiff1d(branches_at_coord,short_thick_endnodes_to_remove)</span>
<span class="sd">            </span>
<span class="sd">    if len(branches_at_coord) &lt; min_degree_to_resolve:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Number of branches ({len(branches_at_coord)}, aka branches_at_coord = {branches_at_coord}) was less than min_degree_to_resolve ({min_degree_to_resolve}) so returning no error branches&quot;)</span>
<span class="sd">        return None,np.array([])</span>
<span class="sd">        </span>
<span class="sd">    # -- end of short thick addition --------</span>
<span class="sd">    </span>

<span class="sd">    if max_degree_to_resolve_wide is not None:</span>
<span class="sd">        up_width = au.axon_width(limb_obj[upstream_branch])</span>
<span class="sd">        if up_width &gt; max_degree_to_resolve_width_threshold:</span>
<span class="sd">            max_degree_to_resolve = max_degree_to_resolve_wide</span>
<span class="sd">            print(f&quot;Changing max_degree_to_resolve = {max_degree_to_resolve_wide} because upstream width was {up_width} &quot;)</span>
<span class="sd">    </span>
<span class="sd">    if len(branches_at_coord) &gt; max_degree_to_resolve:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Number of branches ({len(branches_at_coord)}) was more than max_degree_to_resolve ({max_degree_to_resolve}) so returning all downstream as error branches&quot;)</span>
<span class="sd">        return None,branches_at_coord</span>
<span class="sd">    </span>
<span class="sd">    widths_in_branches = np.array([au.axon_width(limb_obj[b]) for b in branches_at_coord])</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;widths_in_branches = {widths_in_branches}&quot;)</span>
<span class="sd">        </span>
<span class="sd">    widths_in_branches = widths_in_branches[widths_in_branches != 0]</span>
<span class="sd">    </span>
<span class="sd">    if width_max is not None:</span>
<span class="sd">        if len(widths_in_branches[widths_in_branches&gt;width_max]) == len(widths_in_branches):</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Returning No errors because widths are too thick for skeletons to be trusted&quot;)</span>
<span class="sd">            return None,[]</span>
<span class="sd">    </span>
<span class="sd">    if axon_dependent:</span>
<span class="sd">        for b in branches_at_coord:</span>
<span class="sd">            if &quot;axon&quot; not in limb_obj[b].labels:</span>
<span class="sd">                if verbose:</span>
<span class="sd">                    print(f&quot;Returning No errors because not all branches were axons&quot;)</span>
<span class="sd">                return None,[]</span>

<span class="sd">    #1) Compute the skeletal angles between all branches</span>
<span class="sd">    matched_edges, matched_edges_angles = ed.matched_branches_by_angle_at_coordinate(limb_obj,</span>
<span class="sd">                                            coordinate,</span>
<span class="sd">                                               coordinate_branches = branches_at_coord,</span>
<span class="sd">                                            offset=offset,</span>
<span class="sd">                                            comparison_distance = comparison_distance,</span>
<span class="sd">                                            match_threshold = worst_case_match_threshold,</span>
<span class="sd">                                            verbose = verbose,</span>
<span class="sd">                                            plot_intermediates = plot_intermediates,</span>
<span class="sd">                                            plot_match_intermediates = plot_match_intermediates,</span>
<span class="sd">                                            )</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;matched_edges = {matched_edges}&quot;</span>
<span class="sd">              f&quot;matched_edges_angles = {matched_edges_angles}&quot;)</span>



<span class="sd">    # 2) Create a skeletal graph where make the edges between</span>
<span class="sd">    # all nodes that meet the worst case scenario</span>

<span class="sd">    G = nx.Graph()</span>
<span class="sd">    G.add_nodes_from(branches_at_coord)</span>
<span class="sd">    G.add_weighted_edges_from([k+[v] for k,v in zip(matched_edges,matched_edges_angles)])</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Step 2: Edges with worst case scenario matching = {worst_case_match_threshold}&quot;)</span>
<span class="sd">        print(f&quot;Remaining Edges = {G.edges()}, Remaining Nodes = {G.nodes()}&quot;)</span>
<span class="sd">    #     nx.draw(G,with_labels=True)</span>
<span class="sd">    #     plt.show()</span>


<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    3) Compute the width difference between all branches connected by an edge</span>
<span class="sd">    Remove all the edges that violate the width difference threshold</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    edges_to_remove_by_width = []</span>
<span class="sd">    for e in G.edges():</span>
<span class="sd">        b1,b2 = e</span>
<span class="sd">        b1_width = au.axon_width(limb_obj[b1])</span>
<span class="sd">        b2_width = au.axon_width(limb_obj[b2])    </span>
<span class="sd">        width_difference = np.abs(b1_width-b2_width)</span>
<span class="sd">        </span>
<span class="sd">        if width_diff_perc is not None:</span>
<span class="sd">            width_diff_max_perc = width_diff_perc*np.max([b1_width,b2_width])/100</span>
<span class="sd">            #print(f&quot;Computed width_diff_max as {width_diff_max_perc} using width_diff_perc = {width_diff_perc} and width_diff_max = {width_diff_max}&quot;)</span>
<span class="sd">            if width_diff_max is not None:</span>
<span class="sd">                width_diff_max = np.max([width_diff_max_perc,width_diff_max])</span>
<span class="sd">                </span>
<span class="sd">                #print(f&quot;The maximum width chosen was {width_diff_max}&quot;)</span>
<span class="sd">            else:</span>
<span class="sd">                width_diff_max = width_diff_max_perc</span>
<span class="sd">                </span>
<span class="sd">        if width_difference &gt; width_diff_max:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Removing edges {e} because width difference {width_difference}&quot;)</span>
<span class="sd">            edges_to_remove_by_width.append(e)</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;edges_to_remove_by_width = {edges_to_remove_by_width}&quot;)</span>

<span class="sd">    G.remove_edges_from(edges_to_remove_by_width)</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Step 2: Edges after widht mismatch&quot;)</span>
<span class="sd">        print(f&quot;Remaining Edges = {G.edges()}, Remaining Nodes = {G.nodes()}&quot;)</span>
<span class="sd">    #     nx.draw(G,with_labels=True)</span>
<span class="sd">    #     plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    4) Create definite pairs by looking for edges that meet:</span>
<span class="sd">    - match threshold</span>
<span class="sd">    - have buffer better than other edges</span>
<span class="sd">    ** for those edges, eliminate all edges on those</span>
<span class="sd">    2 nodes except that edge</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through each edge:</span>
<span class="sd">    a) get the current weight of this edge</span>
<span class="sd">    b) get all the other edges that are touching the two nodes and their weights</span>
<span class="sd">    c) Run the following test on the edge:</span>
<span class="sd">       i) Is it in the match limit</span>
<span class="sd">       ii) is it less than other edge weightbs by the buffer size</span>
<span class="sd">    d) If pass the tests then delete all of the other edges from the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    other_edges_to_remove = []</span>
<span class="sd">    for e in G.edges():</span>
<span class="sd">        e = np.sort(e)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;--Working on edge {e}--&quot;)</span>
<span class="sd">        e_weight = xu.get_edge_weight(G,e)</span>
<span class="sd">        all_edges = np.unique(</span>
<span class="sd">                    np.sort(</span>
<span class="sd">                    np.array(xu.node_to_edges(G,e[0]) + xu.node_to_edges(G,e[1])),axis=1)</span>
<span class="sd">                    ,axis=0)</span>


<span class="sd">        #b) get all the other edges that are touching the two nodes and their weights</span>
<span class="sd">        other_edges = nu.setdiff2d(all_edges,e.reshape(-1,2))</span>

<span class="sd">        if len(other_edges) == 0:</span>
<span class="sd">            other_edge_min = np.inf</span>
<span class="sd">        else:</span>
<span class="sd">            other_edge_weights = [xu.get_edge_weight(G,edg) for edg in other_edges]</span>
<span class="sd">            #print(f&quot;other_edge_weights = {other_edge_weights}&quot;)</span>
<span class="sd">            other_edge_min = np.min(other_edge_weights)</span>
<span class="sd">            #print(f&quot;other_edge_min = {other_edge_min}&quot;)</span>

<span class="sd">        edge_buffer = other_edge_min - e_weight</span>
<span class="sd">        if e_weight &lt;= match_threshold and edge_buffer &gt; angle_buffer:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Edge {e} is matches definite match threshold with: &quot;</span>
<span class="sd">                     f&quot;\nEdge Buffer of {edge_buffer} (angle_buffer = {angle_buffer})&quot;</span>
<span class="sd">                     f&quot;\nEdge Angle of {e_weight} (match_threshold = {match_threshold})&quot;)</span>
<span class="sd">            other_edges_to_remove += list(other_edges)</span>
<span class="sd">    G.remove_edges_from(other_edges_to_remove)</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Step 4: Definite Edges&quot;)</span>
<span class="sd">        print(f&quot;Remaining Edges = {G.edges()}, Remaining Nodes = {G.nodes()}&quot;)</span>
<span class="sd">    #     nx.draw(G,with_labels=True)</span>
<span class="sd">    #     plt.show()</span>


<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    5) If the upstream node has at least one valid </span>
<span class="sd">    match then eliminate others above the match threshold</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    upstream_subgraph = np.array([list(k) for k in nx.connected_components(G) </span>
<span class="sd">                                  if upstream_branch in k][0])</span>
<span class="sd">    upstream_G = G.subgraph(upstream_subgraph)</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;upstream_subgraph = {upstream_subgraph}&quot;)</span>

<span class="sd">    poss_connections = np.array(xu.get_neighbors(upstream_G,upstream_branch))</span>
<span class="sd">    poss_connections_weights = np.array([xu.get_edge_weight(G,(upstream_branch,k)) for k in poss_connections])</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Possible Connections = {poss_connections}, angles = {poss_connections_weights}&quot;)</span>

<span class="sd">    n_below_match = len(np.where(poss_connections_weights&lt;=match_threshold)[0])</span>
<span class="sd">    if n_below_match &gt; 0:</span>
<span class="sd">        e_to_delete = [(upstream_branch,k) for k in </span>
<span class="sd">                       poss_connections[poss_connections_weights&gt;match_threshold]]</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Deleting the following nodes because above match threshold while {n_below_match} are: {e_to_delete}&quot;)</span>
<span class="sd">        G.remove_edges_from(e_to_delete)</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;Step 5: Removing worst case edges&quot;)</span>
<span class="sd">        print(f&quot;Remaining Edges = {G.edges()}&quot;)</span>

<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    ---------- 4/29 Addition: Kiss Filter -----------</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    0) Get the offset skeleton coordinates for all nodes in graph</span>
<span class="sd">    1) find all the possible partitions of the remaining nodes</span>

<span class="sd">    &quot;&quot;&quot; </span>
<span class="sd">    if kiss_check:</span>
<span class="sd">        upstream_matches = xu.get_neighbors(G,upstream_branch)</span>
<span class="sd">        if len(upstream_matches)&gt;1:</span>
<span class="sd">            print(f&quot;Working on Kissing check because possible upstream matches greater than 1: {upstream_matches}&quot;)</span>

<span class="sd">            G = ed.cut_kissing_graph_edges(G,limb_obj,</span>
<span class="sd">                kiss_check_bbox_longest_side_threshold = kiss_check_bbox_longest_side_threshold,</span>
<span class="sd">                coordinate = coordinate,</span>
<span class="sd">                offset=offset,</span>
<span class="sd">                comparison_distance = comparison_distance,</span>
<span class="sd">                plot_offset_skeletons = False,</span>
<span class="sd">                plot_source_sink_vertices = False,</span>
<span class="sd">                plot_cut_vertices = False,</span>
<span class="sd">                plot_cut_bbox = False,</span>
<span class="sd">                verbose = False</span>
<span class="sd">                            )</span>

<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Step 5b: Removing kissing edges&quot;)</span>
<span class="sd">                print(f&quot;Remaining Edges = {G.edges()}&quot;)</span>
<span class="sd">        else:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Not doing kiss check because upstream_matches = {upstream_matches}&quot;)</span>


<span class="sd">    </span>


<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Part 6:</span>
<span class="sd">    if there are other nodes in the group use on of the following to determine winner</span>
<span class="sd">        a) best match</span>
<span class="sd">        b) least sum angle</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    upstream_subgraph = np.array([list(k) for k in nx.connected_components(G) </span>
<span class="sd">                                  if upstream_branch in k][0])</span>
<span class="sd">    if len(upstream_subgraph) == 1:</span>
<span class="sd">        winning_node = None</span>
<span class="sd">        error_branches = downstream_branches</span>
<span class="sd">    else:</span>
<span class="sd">        if match_method == &quot;best_match&quot;:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Using best match method&quot;)</span>
<span class="sd">            winning_node = xu.get_neighbor_min_weighted_edge(G,upstream_branch)</span>
<span class="sd">        elif match_method == &quot;lowest_angle_sum&quot;:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Using lowest_angle_sum method&quot;)</span>
<span class="sd">            raise Exception(&quot;hasn&#39;t been fixed to make sure the upstream node is guaranteed to be in the output graph&quot;)</span>
<span class="sd">            G_final = xu.graph_to_lowest_weighted_sum_singular_matches(G,</span>
<span class="sd">            verbose = verbose,</span>
<span class="sd">            return_graph = True)</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            winning_node = xu.get_neighbors(G_final,upstream_branch)</span>
<span class="sd">            if len(winning_node) != 1:</span>
<span class="sd">                raise Exception(f&quot;Not just one winning node: {winning_node}&quot;)</span>
<span class="sd">            else:</span>
<span class="sd">                winning_node = winning_node[0]</span>
<span class="sd">        else:</span>
<span class="sd">            raise Exception(f&quot;Unimplemented match_method : {match_method} &quot;)</span>


<span class="sd">        error_branches = downstream_branches[downstream_branches!= winning_node]</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;for upstream node {upstream_branch}, winning_node = {winning_node}, error_branches = {error_branches}&quot;)</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    --- 5/12: Not having the short thick end nodes in the errors to remove</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if remove_short_thick_endnodes:    </span>
<span class="sd">        #print(f&quot;short_thick_endnodes_to_remove = {short_thick_endnodes_to_remove}&quot;)</span>
<span class="sd">        error_branches = np.setdiff1d(error_branches,short_thick_endnodes_to_remove)</span>
<span class="sd">    </span>
<span class="sd">    return winning_node,error_branches</span>

<span class="sd">&#39;&#39;&#39;</span>



<span class="w">    </span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def high_degree_branch_errors_limb_branch_dict_old(neuron_obj,</span>
<span class="sd">                                              **kwargs):</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To resolve high degree nodes for the axon branches</span>
<span class="sd">    and to return a limb branch dict of all of the errors</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the axon limb</span>
<span class="sd">    2) Find all of the high degree coordinates on the axon limb</span>

<span class="sd">    For each high degree coordinate</span>
<span class="sd">    a. Send the coordinate to the high_degree_upstream_match</span>
<span class="sd">    b. Get the error limbs back and if non empty then add to the limb branch dict</span>

<span class="sd">    return the limb branch dict</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    axon_name = neuron_obj.axon_limb_name</span>
<span class="sd">    if axon_name is None:</span>
<span class="sd">        return dict()</span>
<span class="sd">    limb_obj = neuron_obj[axon_name]</span>

<span class="sd">    short_thick_endnodes_to_remove = au.short_thick_branches_from_limb(limb_obj,</span>
<span class="sd">                                 verbose = False)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    exactly_equal = False</span>
<span class="sd">    crossover_coordinates = nru.high_degree_branching_coordinates_on_limb(limb_obj,min_degree_to_find=4,</span>
<span class="sd">                                                                             exactly_equal=exactly_equal,</span>
<span class="sd">                                                                             )</span>
<span class="sd">    limb_branch_dict = dict()</span>
<span class="sd">    error_branches = []</span>
<span class="sd">    for j,c in enumerate(crossover_coordinates):</span>
<span class="sd">        #if verbose:</span>
<span class="sd">        print(f&quot;\n\n ----- Working on coordinate {j}: {c}--------&quot;)</span>
<span class="sd">        winning_downstream,error_downstream = ed.high_degree_upstream_match(limb_obj,</span>
<span class="sd">                              coordinate = c,</span>
<span class="sd">                            plot_intermediates = False,</span>
<span class="sd">                            plot_match_intermediates = False,</span>
<span class="sd">                            short_thick_endnodes_to_remove = short_thick_endnodes_to_remove,</span>
<span class="sd">                                                                           **kwargs)</span>
<span class="sd">        print(f&quot;winning_downstream = {winning_downstream},error_downstream = {error_downstream} &quot;)</span>
<span class="sd">        #if verbose:</span>
<span class="sd">        print(f&quot;coordinate {c} had error branches {error_downstream}--------&quot;)</span>
<span class="sd">        if len(error_downstream) &gt; 0:</span>
<span class="sd">            error_branches += list(error_downstream)</span>

<span class="sd">    if len(error_branches) &gt; 0:</span>
<span class="sd">        limb_branch_dict[axon_name] = np.array(error_branches)</span>

<span class="sd">    return limb_branch_dict</span>
<span class="sd">    </span>
<span class="sd">&#39;&#39;&#39;</span>




<div class="viewcode-block" id="thick_t_errors_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.thick_t_errors_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">thick_t_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">axon_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span>
        <span class="n">min_child_width_max</span> <span class="o">=</span> <span class="mi">78</span><span class="p">,</span><span class="c1">#85,</span>
        <span class="n">child_skeletal_threshold</span> <span class="o">=</span> <span class="mi">7000</span><span class="p">,</span>
        <span class="n">plot_two_downstream_thin_axon_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_wide_angled_children</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_thick_t_crossing_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">plot_t_error_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate a limb branch dict of the for branches</span>
<span class="sd">    where probably a thick axon has crossed a smaller axon</span>

<span class="sd">    Application: Will then be used to filter away in proofreading</span>


<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all of the thin axon branches with 2 downstream nodes</span>
<span class="sd">    2) Filter list down to those with </span>
<span class="sd">    a) a high enough sibling angles</span>
<span class="sd">    b) high min child skeletal length</span>
<span class="sd">    c) min max child width</span>

<span class="sd">    ** those branches that pass that filter are where error occurs</span>

<span class="sd">    For all error branches</span>
<span class="sd">    i) find the downstream nodes</span>
<span class="sd">    ii) add the downstream nodes to the error branch list</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    ed.thick_t_errors_limb_branch_dict(filt_neuron,</span>
<span class="sd">                               plot_two_downstream_thin_axon_limb_branch = False,</span>
<span class="sd">                            plot_wide_angled_children = False,</span>
<span class="sd">                            plot_thick_t_crossing_limb_branch = False,</span>
<span class="sd">                            plot_t_error_limb_branch = True,</span>
<span class="sd">                            verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wide_angle_T_thin_parent</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">wide_angle_t_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">axon_only</span> <span class="o">=</span> <span class="n">axon_only</span><span class="p">,</span>
                                <span class="n">child_width_maximum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="n">parent_width_maximum</span><span class="p">,</span>
                                <span class="n">plot_two_downstream_thin_axon_limb_branch</span> <span class="o">=</span> <span class="n">plot_two_downstream_thin_axon_limb_branch</span><span class="p">,</span>
                                <span class="n">plot_wide_angled_children</span> <span class="o">=</span> <span class="n">plot_wide_angled_children</span><span class="p">,</span>
                                <span class="n">child_skeletal_threshold</span> <span class="o">=</span> <span class="n">child_skeletal_threshold</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="n">thick_t_crossing_limb_branch</span><span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;children_axon_width_max&quot;</span><span class="p">],</span>
                   <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;children_axon_width_max &gt; </span><span class="si">{</span><span class="n">min_child_width_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                   <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">wide_angle_T_thin_parent</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;thick_t_crossing_limb_branch= </span><span class="si">{</span><span class="n">thick_t_crossing_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_thick_t_crossing_limb_branch</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plotting plot_thick_t_crossing_limb_branch = </span><span class="si">{</span><span class="n">thick_t_crossing_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">thick_t_crossing_limb_branch</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For all error branches</span>
<span class="sd">    i) find the downstream nodes</span>
<span class="sd">    ii) add the downstream nodes to the error branch list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">t_error_limb_branch</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">thick_t_crossing_limb_branch</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">t_error_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
            <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="n">t_error_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span>
        <span class="n">t_error_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t_error_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t_error_limb_branch= </span><span class="si">{</span><span class="n">t_error_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_t_error_limb_branch</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plotting plot_t_error_limb_branch&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">t_error_limb_branch</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t_error_limb_branch</span></div>


<div class="viewcode-block" id="cut_kissing_graph_edges"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.cut_kissing_graph_edges">[docs]</a><span class="k">def</span> <span class="nf">cut_kissing_graph_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                            <span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">coordinate</span><span class="p">,</span>
    <span class="n">kiss_check_bbox_longest_side_threshold</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">only_process_partitions_with_valid_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_offset_skeletons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_source_sink_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_cut_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_cut_bbox</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            
                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove edges</span>
<span class="sd">    in a connectivity graph that </span>
<span class="sd">    are between nodes that come from</span>
<span class="sd">    low mesh bridging (usually due to merge errors)</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the mesh intersection</span>
<span class="sd">    2) Get the offset skeletons and the endpoints</span>
<span class="sd">    3) Find all possible partions of the branch </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># ---- 4/30 Change: Want all meshes at that coordinate so doesn&#39;t disconnect the mesh --- #</span>
<span class="c1">#     mesh_inter = nru.branches_combined_mesh(limb_obj,branches,</span>
<span class="c1">#                               plot_mesh=False)</span>
    <span class="n">branches_at_coord</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="n">mesh_inter</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_combined_mesh</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branches_at_coord</span><span class="p">,</span>
                              <span class="n">plot_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    

    <span class="n">offset_skeletons</span><span class="p">,</span><span class="n">skeleton_offset_points</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">coordinate_to_offset_skeletons</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                      <span class="n">coordinate</span><span class="o">=</span><span class="n">coordinate</span><span class="p">,</span>
                                       <span class="n">branches</span><span class="o">=</span> <span class="n">branches</span><span class="p">,</span>
                                       <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                       <span class="n">plot_offset_skeletons</span><span class="o">=</span><span class="n">plot_offset_skeletons</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                       <span class="n">return_skeleton_endpoints</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="p">)</span>

    <span class="n">skeleton_offset_points_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">:</span><span class="n">sk_o</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">sk_o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="n">skeleton_offset_points</span><span class="p">)}</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_offset_points_dict = </span><span class="si">{</span><span class="n">skeleton_offset_points_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_partitions&quot;</span><span class="p">)</span>    
    <span class="n">node_partitions</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">all_partitions</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">partition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_partitions</span><span class="p">):</span>
        <span class="n">part1</span><span class="p">,</span><span class="n">part2</span> <span class="o">=</span> <span class="n">partition</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on partition </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">part1</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">part2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">only_process_partitions_with_valid_edges</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: check that there is at least one valid edge</span>
<span class="sd">            in each of the partitions, or else continue</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">skip_partition</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
                <span class="n">part_G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">part_G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping Partition </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">partition</span><span class="si">}</span><span class="s2"> because there was not a valid edge in </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">skip_partition</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="k">if</span> <span class="n">skip_partition</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Continuing with Partition because valid edge&quot;</span><span class="p">)</span>
        
        <span class="n">source_coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton_offset_points_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">part1</span><span class="p">]</span>
        <span class="n">sink_coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeleton_offset_points_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">part2</span><span class="p">]</span>

        <span class="n">cut_coordinates</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">min_cut_to_partition_mesh_vertices</span><span class="p">(</span><span class="n">mesh_inter</span><span class="p">,</span>
                                              <span class="n">source_coordinates</span><span class="p">,</span>
                                              <span class="n">sink_coordinates</span><span class="p">,</span>
                                               <span class="n">plot_source_sink_vertices</span><span class="o">=</span> <span class="n">plot_source_sink_vertices</span><span class="p">,</span>
                                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                              <span class="n">return_edge_midpoint</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">plot_cut_vertices</span> <span class="o">=</span> <span class="n">plot_cut_vertices</span><span class="p">)</span>

    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(f&quot;cut_coordinates = {cut_coordinates}&quot;)</span>


        <span class="k">if</span> <span class="n">cut_coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output was None so continuing&quot;</span><span class="p">)</span>
            <span class="k">continue</span>


        <span class="n">cut_bbox</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">coordinates_to_bounding_box</span><span class="p">(</span><span class="n">cut_coordinates</span><span class="p">)</span>
        <span class="n">cut_bbox_volume</span> <span class="o">=</span> <span class="n">cut_bbox</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">cut_bbox_longest_side</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bounding_box_longest_side</span><span class="p">(</span><span class="n">cut_bbox</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cut_bbox_volume = </span><span class="si">{</span><span class="n">cut_bbox_volume</span><span class="si">}</span><span class="s2">, cut_bbox_longest_side = </span><span class="si">{</span><span class="n">cut_bbox_longest_side</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_cut_bbox</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">mesh_inter</span><span class="p">,</span>
                              <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">cut_bbox</span><span class="p">],</span>
                              <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">],</span>
                              <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span>
                <span class="p">)</span>

        <span class="c1"># apply the kiss threshold o see if edges should be cut</span>
        <span class="k">if</span> <span class="n">cut_bbox_longest_side</span> <span class="o">&lt;</span> <span class="n">kiss_check_bbox_longest_side_threshold</span><span class="p">:</span>
            <span class="c1">#if verbose:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;** triggered kiss check cut becuase cut_bbox_longest_side = </span><span class="si">{</span><span class="n">cut_bbox_longest_side</span><span class="si">}</span><span class="s2">***&quot;</span><span class="p">)</span>
            <span class="c1">#then delete the edges that are not contained within the partitions</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">remove_inter_partition_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                                <span class="n">partition</span><span class="p">,</span>
                                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edges after removing partition = </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_edges_with_weights</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">----Final Edges After Kissing Processing = </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_edges_with_weights</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>

<span class="c1"># ------ Rule 7: Width Jump and Double Back Revision ----------- #</span>
<div class="viewcode-block" id="width_jump_from_upstream_min"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_from_upstream_min">[docs]</a><span class="k">def</span> <span class="nf">width_jump_from_upstream_min</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">branch_idx</span><span class="p">,</span>
                      <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Find the width jump up</span>
<span class="sd">    of a current branch from those </span>
<span class="sd">    proceeding it</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the minimum proceeding width</span>
<span class="sd">    2) Find the current width</span>
<span class="sd">    3) Subtract and Return</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import error_detection as ed</span>
<span class="sd">    ed.width_jump_from_upstream_min(limb_obj=neuron_obj[0],</span>
<span class="sd">    branch_idx=318,</span>
<span class="sd">    skeletal_length_min = 2000,</span>
<span class="sd">    verbose = False)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">min_upstream_width</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">min_width_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                          <span class="n">branch_idx</span><span class="p">,</span>
                          <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="n">skeletal_length_min</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="n">current_width</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">])</span>
    <span class="n">width_jump</span> <span class="o">=</span> <span class="n">current_width</span> <span class="o">-</span> <span class="n">min_upstream_width</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_upstream_width = </span><span class="si">{</span><span class="n">min_upstream_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_width = </span><span class="si">{</span><span class="n">current_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_jump = </span><span class="si">{</span><span class="n">width_jump</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">width_jump</span></div>


<div class="viewcode-block" id="width_jump_up_error_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_up_error_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">width_jump_up_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                         <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min_for_min</span><span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
                                        <span class="n">width_jump_max</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                        <span class="n">plot_final_width_jump</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all branches</span>
<span class="sd">    that hae a jump up of width </span>
<span class="sd">    from the minimum of the upsream widths </span>
<span class="sd">    (that are indicative of an error)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Given a starting limb branch dict</span>
<span class="sd">    1) Query the neuron for those branhes</span>
<span class="sd">    that have a certain upstream width and have</span>
<span class="sd">    a certain skeletal width</span>
<span class="sd">    2) Query the neuron for those</span>
<span class="sd">    with a width jump above a certain amount</span>
<span class="sd">    3) Graph the query </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before any restrictions in width jump, limb_branch_dict_restriction = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">restrict_by_branch_and_upstream_skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span> 
                                                <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                                                <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min</span><span class="p">,</span>
                                                      <span class="n">branch_skeletal_length_min</span><span class="o">=</span><span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After skeletal restrictions, limb_branch_dict_restriction = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict_restriction</span>

    
    
    <span class="n">width_jump_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;width_jump_from_upstream_min&quot;</span><span class="p">],</span>
                    <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;width_jump_from_upstream_min&gt;</span><span class="si">{</span><span class="n">width_jump_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">skeletal_length_min</span><span class="o">=</span><span class="n">upstream_skeletal_length_min_for_min</span><span class="p">),</span>
                    <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_width_jump</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_jump_limb_branch (WITH threshold </span><span class="si">{</span><span class="n">width_jump_from_upstream_min</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">width_jump_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">width_jump_limb_branch</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">width_jump_limb_branch</span></div>


<div class="viewcode-block" id="width_jump_up_axon"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_up_axon">[docs]</a><span class="k">def</span> <span class="nf">width_jump_up_axon</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#5000,</span>
    <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#8000,</span>
    <span class="n">upstream_skeletal_length_min_for_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#4000,</span>
    <span class="n">width_jump_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#55,</span>
    <span class="n">axon_width_threshold_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#au.axon_thick_threshold,</span>
    <span class="n">plot_width_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To apply the width </span>
<span class="sd">    jump up check on the axon segments of neuron</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Set the width parameters corectly for axon</span>
<span class="sd">    1) Find all of the axon branches</span>
<span class="sd">    2) Run the width jump check</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">limb_utils</span> <span class="k">as</span> <span class="n">lu</span>
    <span class="k">if</span> <span class="n">upstream_skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min_width_j_axon_global</span>
    <span class="k">if</span> <span class="n">branch_skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="n">branch_skeletal_length_min_width_j_axon_global</span>
    <span class="k">if</span> <span class="n">upstream_skeletal_length_min_for_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_skeletal_length_min_for_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min_for_min_width_j_axon_global</span>
    <span class="k">if</span> <span class="n">width_jump_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_jump_max</span> <span class="o">=</span> <span class="n">width_jump_max_width_j_axon_global</span>
    <span class="k">if</span> <span class="n">axon_width_threshold_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_threshold_max</span> <span class="o">=</span> <span class="n">axon_width_threshold_max_width_j_axon_global</span>
    


    <span class="n">axon_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                            <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
    
    <span class="n">axon_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span>
                       <span class="c1">#&quot;axon_width&quot;,</span>
                       <span class="n">lu</span><span class="o">.</span><span class="n">width_upstream_limb_ns</span><span class="p">,</span>
                   <span class="p">],</span>
                   <span class="n">query</span><span class="o">=</span><span class="p">(</span>
                       <span class="c1">#f&quot;axon_width &lt;= {axon_width_threshold_max}&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;width_upstream &lt;= </span><span class="si">{</span><span class="n">axon_width_threshold_max</span><span class="si">}</span><span class="s2">&quot;</span>
                   <span class="p">),</span>
                   <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">axon_limb_branch</span><span class="p">)</span>
    

    <span class="n">width_errors</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">width_jump_up_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">axon_limb_branch</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min</span><span class="p">,</span>
                                         <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min_for_min</span><span class="o">=</span> <span class="n">upstream_skeletal_length_min_for_min</span><span class="p">,</span>
                                        <span class="n">width_jump_max</span> <span class="o">=</span> <span class="n">width_jump_max</span><span class="p">,</span>
                                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_width_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">width_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Width Errors To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_errors = </span><span class="si">{</span><span class="n">width_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">width_errors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">width_errors</span></div>


<span class="c1">#dendrite_trunk_width = 500</span>

<div class="viewcode-block" id="dendrite_branch_restriction"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.dendrite_branch_restriction">[docs]</a><span class="k">def</span> <span class="nf">dendrite_branch_restriction</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#dendrite_trunk_width,</span>
                                <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#5000,</span>
                                <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span>
                               <span class="p">):</span>
    <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">limb_utils</span> <span class="k">as</span> <span class="n">lu</span>
    
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_dendr_restr_global</span>
    <span class="k">if</span> <span class="n">upstream_skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min_dendr_restr_global</span>
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">not_matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before any querying started: </span><span class="si">{</span><span class="n">current_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="n">query</span><span class="o">=</span><span class="p">(</span>
                       <span class="c1">#f&quot;(width_neuron &lt;= {width_max}) &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;(width_upstream &lt;= </span><span class="si">{</span><span class="n">width_max</span><span class="si">}</span><span class="s2">)&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;and (total_upstream_skeletal_length&gt;</span><span class="si">{</span><span class="n">upstream_skeletal_length_min</span><span class="si">}</span><span class="s2">)&quot;</span>
                       <span class="p">)</span>
    
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span>
                       <span class="c1">#&quot;width_neuron&quot;,</span>
                       <span class="n">lu</span><span class="o">.</span><span class="n">width_upstream_limb_ns</span><span class="p">,</span>
                       <span class="s2">&quot;total_upstream_skeletal_length&quot;</span><span class="p">],</span>
                   <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
                   <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">current_limb_branch_dict</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;query = </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_limb_branch_dict = </span><span class="si">{</span><span class="n">current_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="c1">#print(f&quot;current_limb_branch_dict = {current_limb_branch_dict}&quot;)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_limb_branch_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">current_limb_branch_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">current_limb_branch_dict</span></div>



<div class="viewcode-block" id="width_jump_up_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.width_jump_up_dendrite">[docs]</a><span class="k">def</span> <span class="nf">width_jump_up_dendrite</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#5000,</span>
    <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#7000,</span>
    <span class="n">upstream_skeletal_length_min_for_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#4000,</span>
    <span class="n">width_jump_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#200,</span>
    <span class="n">plot_width_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To apply the width </span>
<span class="sd">    jump up check on the axon segments of neuron</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Set the width parameters corectly for axon</span>
<span class="sd">    1) Find all of the axon branches</span>
<span class="sd">    2) Run the width jump check</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">upstream_skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min_width_j_dendr_global</span>
    <span class="k">if</span> <span class="n">branch_skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="n">branch_skeletal_length_min_width_j_dendr_global</span>
    <span class="k">if</span> <span class="n">upstream_skeletal_length_min_for_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_skeletal_length_min_for_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min_for_min_width_j_dendr_global</span>
    <span class="k">if</span> <span class="n">width_jump_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_jump_max</span> <span class="o">=</span> <span class="n">width_jump_max_width_j_dendr_global</span>



    <span class="n">dendrite_limb_branch</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">dendrite_branch_restriction</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="c1">#print(f&quot;dendrite_limb_branch = {dendrite_limb_branch}&quot;)</span>
    
    <span class="n">width_errors</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">width_jump_up_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">dendrite_limb_branch</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min</span><span class="p">,</span>
                                         <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min_for_min</span><span class="o">=</span> <span class="n">upstream_skeletal_length_min_for_min</span><span class="p">,</span>
                                        <span class="n">width_jump_max</span> <span class="o">=</span> <span class="n">width_jump_max</span><span class="p">,</span>
                                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_width_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">width_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Width Errors To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_errors = </span><span class="si">{</span><span class="n">width_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">width_errors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">width_errors</span></div>


<span class="c1"># -------------- Doubling Back Errors ---------------------- #</span>


<div class="viewcode-block" id="double_back_error_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_error_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">double_back_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">double_back_threshold</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
                                       <span class="n">branch_skeletal_length_min</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
                                       
                                         <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                                       
                                       <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
                                       <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">plot_final_double_back</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all branches that have a skeleton that</span>
<span class="sd">    doubles back by a certain degree</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">restrict_by_branch_and_upstream_skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span> 
                                                <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                                                <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="n">upstream_skeletal_length_min</span><span class="p">,</span>
                                                      <span class="n">branch_skeletal_length_min</span><span class="o">=</span><span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After skeletal restrictions, limb_branch_dict_restriction = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict_restriction</span>

    <span class="n">double_back_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;parent_angle&quot;</span><span class="p">],</span>
                    <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;parent_angle&gt;</span><span class="si">{</span><span class="n">double_back_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                        <span class="n">check_upstream_network_connectivity</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_double_back</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_limb_branch_dict (WITH threshold </span><span class="si">{</span><span class="n">double_back_threshold</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">double_back_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">double_back_limb_branch_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">double_back_limb_branch_dict</span></div>


<div class="viewcode-block" id="double_back_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_dendrite">[docs]</a><span class="k">def</span> <span class="nf">double_back_dendrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">double_back_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#120,</span>
                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3000,</span>
                         <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0,</span>
                         <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#7000, #deciding which branches will be skipped because of length</span>
                         <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">plot_starting_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">plot_double_back_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all skeletal double </span>
<span class="sd">    back errors on dendrite port</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">double_back_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold_double_b_dendrite_global</span>
    <span class="k">if</span> <span class="n">comparison_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_double_b_dendrite_global</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_double_b_dendrite_global</span>
    <span class="k">if</span> <span class="n">branch_skeletal_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="n">branch_skeletal_length_min_double_b_dendrite_global</span>
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_dendr_double_back_restr_global</span>
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">dendrite_branch_restriction</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">width_max</span><span class="o">=</span><span class="n">width_max</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_starting_limb_branch</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No limb_branch_dict To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_limb_branch_dict = </span><span class="si">{</span><span class="n">current_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">current_limb_branch_dict</span><span class="p">)</span>
                         
    <span class="n">double_back_errors</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">double_back_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">double_back_threshold</span><span class="o">=</span><span class="n">double_back_threshold</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">current_limb_branch_dict</span><span class="p">,</span>
                                      <span class="n">plot_final_double_back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                           <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                        <span class="n">branch_skeletal_length_min</span><span class="o">=</span><span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_double_back_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">double_back_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Double Back Errors To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_errors = </span><span class="si">{</span><span class="n">double_back_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">double_back_errors</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">double_back_errors</span></div>


<div class="viewcode-block" id="double_back_axon_thin"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_axon_thin">[docs]</a><span class="k">def</span> <span class="nf">double_back_axon_thin</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">axon_width_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">double_back_threshold</span><span class="o">=</span><span class="mi">135</span><span class="p">,</span>
                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                         <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span> <span class="c1">#deciding which branches will be skipped because of length</span>
                         <span class="n">plot_starting_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">plot_double_back_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all skeletal double </span>
<span class="sd">    back errors on dendrite port</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axon_width_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_threshold</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_thick_threshold</span>
        
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon_width&quot;</span><span class="p">],</span>
                   <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;axon_width &lt;= </span><span class="si">{</span><span class="n">axon_width_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                   <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">current_limb_branch_dict</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_starting_limb_branch</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No limb_branch_dict To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_limb_branch_dict = </span><span class="si">{</span><span class="n">current_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">current_limb_branch_dict</span><span class="p">)</span>
                         
    <span class="n">double_back_errors</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">double_back_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">double_back_threshold</span><span class="o">=</span><span class="n">double_back_threshold</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">current_limb_branch_dict</span><span class="p">,</span>
                                      <span class="n">plot_final_double_back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                           <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                        <span class="n">branch_skeletal_length_min</span><span class="o">=</span><span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_double_back_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">double_back_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Double Back Errors To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_errors = </span><span class="si">{</span><span class="n">double_back_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">double_back_errors</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">double_back_errors</span></div>


<div class="viewcode-block" id="double_back_axon_thick"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_axon_thick">[docs]</a><span class="k">def</span> <span class="nf">double_back_axon_thick</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">axon_width_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">axon_width_threshold_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">double_back_threshold</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                         <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span> <span class="c1">#deciding which branches will be skipped because of length</span>
                         <span class="n">plot_starting_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">plot_double_back_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all skeletal double </span>
<span class="sd">    back errors on dendrite port</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axon_width_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_threshold</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_thick_threshold</span>
        
    <span class="k">if</span> <span class="n">axon_width_threshold_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_threshold_max</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_ais_threshold</span>
        
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
    
    <span class="n">current_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon_width&quot;</span><span class="p">],</span>
                   <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;(axon_width &gt; </span><span class="si">{</span><span class="n">axon_width_threshold</span><span class="si">}</span><span class="s2">) and (axon_width &lt; </span><span class="si">{</span><span class="n">axon_width_threshold_max</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                   <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">current_limb_branch_dict</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_starting_limb_branch</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No limb_branch_dict To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_limb_branch_dict = </span><span class="si">{</span><span class="n">current_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">current_limb_branch_dict</span><span class="p">)</span>
                         
    <span class="n">double_back_errors</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">double_back_error_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">double_back_threshold</span><span class="o">=</span><span class="n">double_back_threshold</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">current_limb_branch_dict</span><span class="p">,</span>
                                      <span class="n">plot_final_double_back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                           <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                        <span class="n">branch_skeletal_length_min</span><span class="o">=</span><span class="n">branch_skeletal_length_min</span><span class="p">,</span>
                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_double_back_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">double_back_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No Double Back Errors To Plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_errors = </span><span class="si">{</span><span class="n">double_back_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">double_back_errors</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">double_back_errors</span></div>

<span class="c1"># -------------- 6/21: Version 6 Erro Detection Rules --------- #</span>


<span class="c1"># --------- High degree branching -------------- #</span>



<div class="viewcode-block" id="calculate_skip_distance"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.calculate_skip_distance">[docs]</a><span class="k">def</span> <span class="nf">calculate_skip_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">calculate_skip_distance_including_downstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">calculate_skip_distance_including_downstream</span><span class="p">:</span>
        <span class="c1">#1) Get all downstream branhes (with an optional skip distance)</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        <span class="n">all_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
<span class="c1">#             print(f&quot;all_nodes = {all_nodes}&quot;)</span>
        <span class="n">curr_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">]</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="p">[</span><span class="n">ed</span><span class="o">.</span><span class="n">skip_distance_from_branch_width</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_width</span><span class="p">]</span>
<span class="c1">#             print(f&quot;curr_width = {curr_width}&quot;)</span>
<span class="c1">#             print(f&quot;skip_distance = {skip_distance}&quot;)</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">skip_distance</span><span class="p">)</span>
        <span class="c1">#if verbose:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current node skip distance was </span><span class="si">{</span><span class="n">ed</span><span class="o">.</span><span class="n">skip_distance_from_branch_width</span><span class="p">(</span><span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]))</span><span class="si">}</span><span class="s2"> but max skip distance was </span><span class="si">{</span><span class="n">skip_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_width</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">])</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">skip_distance_from_branch_width</span><span class="p">(</span><span class="n">curr_width</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> the skip distance was </span><span class="si">{</span><span class="n">skip_distance</span><span class="si">}</span><span class="s2"> (for width </span><span class="si">{</span><span class="n">curr_width</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">skip_distance</span></div>


<div class="viewcode-block" id="high_low_degree_upstream_match_preprocessing"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.high_low_degree_upstream_match_preprocessing">[docs]</a><span class="k">def</span> <span class="nf">high_low_degree_upstream_match_preprocessing</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    
    <span class="c1">#arguments for determining downstream nodes</span>
    <span class="n">skip_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_distance_from_soma_for_proof</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axon_spines</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1"># 3,</span>
    
    <span class="c1"># helps determine the max degrees to resolve</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve_width_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#200,</span>
    
    
    <span class="c1"># parameter checking to see if high degree resolve can be used</span>
    <span class="n">width_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#35,</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#170,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True, </span>

    <span class="c1">#arguments for what to return</span>
    <span class="n">return_skip_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    To take a node on a limb and determine</span>
<span class="sd">    a) if the node should even be processed (and if it shouldn&#39;t what is the return value)</span>
<span class="sd">    b) What the downstream nodes to be processed should be</span>
<span class="sd">    c) What the skip distance and skip nodes are</span>
<span class="sd">    </span>
<span class="sd">    What want to return: </span>
<span class="sd">    - return value</span>
<span class="sd">    - skip distance</span>
<span class="sd">    - skipped_nodes</span>
<span class="sd">    - downstream_branches</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Calulate the skip distance</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#verbose = True</span>
    <span class="c1"># ----- setting the parameters --------</span>
    <span class="k">if</span> <span class="n">min_distance_from_soma_for_proof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_distance_from_soma_for_proof</span> <span class="o">=</span> <span class="n">min_distance_from_soma_for_proof_global</span>
        
    <span class="k">if</span> <span class="n">min_degree_to_resolve</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="n">min_degree_to_resolve_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve_absolute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_absolute_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve_wide</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_wide_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve_width_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve_width_threshold</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_width_threshold_global</span>
    <span class="k">if</span> <span class="n">width_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_min</span> <span class="o">=</span> <span class="n">width_min_global</span>
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_global</span>
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max_global</span>
    <span class="k">if</span> <span class="n">axon_dependent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_dependent</span> <span class="o">=</span> <span class="n">axon_dependent_global</span>
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    
    
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">skipped_nodes</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">short_thick_endnodes_to_remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">short_thick_endnodes_to_remove</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">short_thick_endnodes_to_remove</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because in short_thick_endnodes_to_remove&quot;</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>

    <span class="k">if</span> <span class="n">axon_spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axon_spines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">axon_spines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because in axon_spines&quot;</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>
            
    
    
    <span class="k">if</span> <span class="n">min_upstream_skeletal_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#curr_sk_len = limb_obj[branch_idx].skeletal_length</span>
        <span class="n">curr_sk_len</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeletal_length_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="k">if</span>  <span class="n">curr_sk_len</span> <span class="o">&lt;</span> <span class="n">min_upstream_skeletal_distance</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because skeletal length (</span><span class="si">{</span><span class="n">curr_sk_len</span><span class="si">}</span><span class="s2">) was less than min_upstream_skeletal_distance = </span><span class="si">{</span><span class="n">min_upstream_skeletal_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>
            
    <span class="k">if</span> <span class="n">min_distance_from_soma_for_proof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">min_distance_from_soma_for_proof</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because distance away from soma (</span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s2">) was less than min_distance_from_soma_for_proof = </span><span class="si">{</span><span class="n">min_distance_from_soma_for_proof</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>
                
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_skip_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">skip_distance</span><span class="p">,</span><span class="n">skipped_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span>
                            
                            
    
    <span class="k">if</span> <span class="n">skip_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#print(f&#39;Calculating skip distance&#39;)</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">calculate_skip_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                  <span class="n">branch_idx</span><span class="p">)</span>
    <span class="c1"># ----- Phase A: Preprocessing before matching -----------</span>
    
    
    <span class="c1">#1) Get all downstream branhes (with an optional skip distance)</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">endnode_branches_of_branches_within_distance_downtream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                              <span class="n">branch_idx</span><span class="p">,</span>
                                                              <span class="n">skip_distance</span><span class="o">=</span><span class="n">skip_distance</span><span class="p">)</span>
    
    <span class="n">all_downstream_branches</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">branches_within_distance_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                     <span class="n">branch_idx</span><span class="p">,</span>
                                                                     <span class="n">distance_threshold</span><span class="o">=</span><span class="n">skip_distance</span><span class="p">)</span>
    <span class="n">skipped_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_downstream_branches</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skipped_nodes = </span><span class="si">{</span><span class="n">skipped_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="c1">#2) Remove short thick endnodes from possible branches in the high degree point</span>
    <span class="k">if</span> <span class="n">short_thick_endnodes_to_remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">short_thick_endnodes_to_remove</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of short_thick_endnodes_to_remove = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">short_thick_endnodes_to_remove</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_branches after remove_short_thick_endnodes = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">axon_spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">axon_spines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of axon_spines = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">axon_spines</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_branches after remove_short_thick_endnodes = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) Return if not enough branches at the intersection</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_degree_to_resolve</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">), aka downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2">) was less than min_degree_to_resolve (</span><span class="si">{</span><span class="n">min_degree_to_resolve</span><span class="si">}</span><span class="s2">) so returning no error branches&quot;</span><span class="p">)</span>
        <span class="n">return_value</span> <span class="o">=</span>  <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>
        
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_skip_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">skip_distance</span><span class="p">,</span><span class="n">skipped_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span>
    
    <span class="c1"># -------- 8/1: Sets a limit on the maximum branch degree to be resolved ---------</span>
    <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">branch_idx</span>
    

    <span class="k">if</span> <span class="n">max_degree_to_resolve_absolute</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_degree_to_resolve_absolute</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">) was more than max_degree_to_resolve (</span><span class="si">{</span><span class="n">max_degree_to_resolve_absolute</span><span class="si">}</span><span class="s2">) so returning all downstream as error branches&quot;</span><span class="p">)</span>
        <span class="n">return_value</span><span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_skip_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">skip_distance</span><span class="p">,</span><span class="n">skipped_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span> 
       
    <span class="c1"># 4) If the branch being considered is thick enough then increase the max degree to resolve</span>
    
    
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_w</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">width_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">upstream_branch</span><span class="p">,</span>
                                                        <span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">,</span>
                                                        <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upstream_w</span> <span class="o">&gt;</span> <span class="n">upstream_width_max</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning No errors because upstream width (</span><span class="si">{</span><span class="n">upstream_w</span><span class="si">}</span><span class="s2">) is greaeter than the upstream_width_max </span><span class="si">{</span><span class="n">upstream_width_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span>  <span class="p">[</span><span class="kc">None</span><span class="p">,[]]</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_skip_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">skip_distance</span><span class="p">,</span><span class="n">skipped_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span> 
        
    <span class="c1"># ----------- Returning if the upstream widht is too great ------------- #</span>
    
    <span class="k">if</span> <span class="n">max_degree_to_resolve_wide</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">up_width</span> <span class="o">=</span> <span class="n">width_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_branch</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">up_width</span> <span class="o">&gt;</span> <span class="n">max_degree_to_resolve_width_threshold</span><span class="p">:</span>
            <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_wide</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Changing max_degree_to_resolve = </span><span class="si">{</span><span class="n">max_degree_to_resolve_wide</span><span class="si">}</span><span class="s2"> because upstream width was </span><span class="si">{</span><span class="n">up_width</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="c1">#5) Return all downstream branches as errors if number of branches at intersection is too large</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_degree_to_resolve</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">) was more than max_degree_to_resolve (</span><span class="si">{</span><span class="n">max_degree_to_resolve</span><span class="si">}</span><span class="s2">) so returning all downstream as error branches&quot;</span><span class="p">)</span>
        <span class="n">return_value</span><span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">]</span>

        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_skip_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">skip_distance</span><span class="p">,</span><span class="n">skipped_nodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span>    
    

    <span class="n">all_branch_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">downstream_branches</span><span class="p">,[</span><span class="n">upstream_branch</span><span class="p">]])</span>

    
    <span class="c1">#widths_in_branches = np.array([width_func(limb_obj[b]) for b in all_branch_idx])</span>
    <span class="n">widths_in_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cnu</span><span class="o">.</span><span class="n">width_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">b</span><span class="p">,</span>
                                                        <span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">,</span>
                                                        <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">all_branch_idx</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;widths_in_branches = </span><span class="si">{</span><span class="n">widths_in_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">widths_in_branches</span> <span class="o">=</span> <span class="n">widths_in_branches</span><span class="p">[</span><span class="n">widths_in_branches</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># 6) Do not process the intersection if all the branches are thick or not all are axons (return no errors)</span>
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths_in_branches</span><span class="p">[</span><span class="n">widths_in_branches</span><span class="o">&gt;</span><span class="n">width_max</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths_in_branches</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning No errors because widths are too thick for skeletons to be trusted&quot;</span><span class="p">)</span>
            <span class="n">return_value</span> <span class="o">=</span>  <span class="p">[</span><span class="kc">None</span><span class="p">,[]]</span>

    <span class="k">if</span> <span class="n">axon_dependent</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">downstream_branches</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Returning No errors because not all branches were axons&quot;</span><span class="p">)</span>
                <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,[]]</span>
                
    
    <span class="n">upstream_width</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">upstream_width</span> <span class="o">&lt;</span> <span class="n">width_min</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upstream width is too small (under </span><span class="si">{</span><span class="n">width_min</span><span class="si">}</span><span class="s2">) so not processing&quot;</span><span class="p">)</span>
        <span class="n">return_value</span> <span class="o">=</span>  <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])]</span>
    
    
    <span class="k">if</span> <span class="n">return_skip_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">skip_distance</span><span class="p">,</span><span class="n">skipped_nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span><span class="p">,</span><span class="n">downstream_branches</span></div>
    


<span class="c1"># def high_degree_upstream_match_old_2(</span>
<span class="c1">#     limb_obj,</span>
<span class="c1">#     branch_idx,</span>
    
<span class="c1">#     #--- Phase A: arguments for determining downstream nodes ------</span>
<span class="c1">#     skip_distance = None,#3000,</span>
<span class="c1">#     min_upstream_skeletal_distance = None,</span>
<span class="c1">#     remove_short_thick_endnodes = True,</span>
<span class="c1">#     axon_spines = None,</span>
    
<span class="c1">#     short_thick_endnodes_to_remove = None,</span>
<span class="c1">#     min_degree_to_resolve = 3,</span>
    
<span class="c1">#     # helps determine the max degrees to resolve</span>
<span class="c1">#     width_func = au.axon_width,</span>
<span class="c1">#     max_degree_to_resolve_absolute = 1000,</span>
<span class="c1">#     max_degree_to_resolve = 1000,</span>
<span class="c1">#     max_degree_to_resolve_wide = 1000,</span>
<span class="c1">#     max_degree_to_resolve_width_threshold = 200,</span>
    
<span class="c1">#     # parameter checking to see if high degree resolve can be used</span>
<span class="c1">#     width_max = 170,</span>
<span class="c1">#     axon_dependent = True,</span>
    
<span class="c1">#     plot_starting_branches = False,</span>

<span class="c1">#     # --- Phase B.1: parameters for local edge attributes ------</span>
<span class="c1">#     offset=1500,</span>
<span class="c1">#     comparison_distance = 2000,</span>
<span class="c1">#     plot_extracted_skeletons = False,</span>
    
    
<span class="c1">#     # --- Phase B.2: parameters for local edge query ------</span>
    
<span class="c1">#     worst_case_sk_angle_match_threshold = 65,</span>
    
<span class="c1">#     width_diff_max = 75,#np.inf,100,</span>
<span class="c1">#     width_diff_perc = 0.60,</span>
    
<span class="c1">#     perform_synapse_filter = True,</span>
<span class="c1">#     synapse_density_diff_threshold = 0.00015, #was 0.00021</span>
<span class="c1">#     n_synapses_diff_threshold = 6,</span>
    
<span class="c1">#     plot_G_local_edge = False,</span>
    
<span class="c1">#     # ----- Phase B.3: parameters for global attributes ---</span>
<span class="c1">#     #args for definite pairs</span>
<span class="c1">#     sk_angle_match_threshold = 45,</span>
<span class="c1">#     sk_angle_buffer = 15,</span>
    
<span class="c1">#     width_diff_perc_threshold = 0.15,</span>
<span class="c1">#     width_diff_perc_buffer = 0.30,</span>

<span class="c1">#     # ----- Phase B.4 paraeters for global query ---</span>
<span class="c1">#     plot_G_global_edge = False,</span>
    
<span class="c1">#     # ----- Phase B.6 paraeters for ndoe query ---</span>
<span class="c1">#     plot_G_node_edge = False,</span>
    
<span class="c1">#     # ---- Phase C: Optional Kiss filter ----</span>
<span class="c1">#     kiss_check = False,</span>
<span class="c1">#     kiss_check_bbox_longest_side_threshold = 450,</span>

<span class="c1">#     # ---- Phase D: Picking the final winner -----</span>
<span class="c1">#     plot_final_branch_matches = False,</span>
<span class="c1">#     match_method = &quot;all_error_if_not_one_match&quot;,# &quot;best_match&quot;, #other option is &quot;best_match&quot;</span>
<span class="c1">#     use_exclusive_partner = True,</span>
<span class="c1">#     plot_G_exclusive_partner_edge = False,</span>
    
<span class="c1">#     verbose = False,</span>
<span class="c1">#     ):</span>
<span class="c1">#     #print(f&quot;perform_synapse_filter = {perform_synapse_filter}&quot;)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Purpose: To Determine if branches downstream from a certain</span>
<span class="c1">#     branch should be errored out based on crossovers and </span>
<span class="c1">#     high degree branching downstream</span>
    
<span class="c1">#     Pseudocode: </span>
<span class="c1">#     Phase A:</span>
<span class="c1">#     #1) Get all downstream branhes (with an optional skip distance)</span>
<span class="c1">#     #2) Remove short thick endnodes from possible branches in the high degree point</span>
<span class="c1">#     #3) Return if not enough branches at the intersection</span>
<span class="c1">#     #4) If the branch being considered is thick enough then increase the max degree to resolve</span>
<span class="c1">#     #5) Return all downstream branches as errors if number of branches at intersection is too large</span>
<span class="c1">#     #6) Do not process the intersection if all the branches are thick or not all are axons (return no errors)</span>
    
<span class="c1">#     Phase B: </span>
<span class="c1">#     #1) Compute features of a complete graph that connets all upsream and downsream edges</span>
<span class="c1">#     #(slightly different computation for upstream than downstream edges)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1"># #     if branch_idx == 13:</span>
<span class="c1"># #         verbose = True</span>
<span class="c1">#     plot_G_local_edge = True</span>
<span class="c1">#     plot_G_global_edge = True</span>
<span class="c1">#     plot_G_node_edge= True</span>

<span class="c1">#     if remove_short_thick_endnodes:</span>
<span class="c1">#         if short_thick_endnodes_to_remove is None:</span>
<span class="c1">#             short_thick_endnodes_to_remove = au.short_thick_branches_from_limb(limb_obj,</span>
<span class="c1">#                                  verbose = False)</span>
            
<span class="c1">#         limb_obj.short_thick_endnodes = short_thick_endnodes_to_remove</span>
    
<span class="c1">#     if axon_spines is not None:</span>
<span class="c1">#         limb_obj.axon_spines = axon_spines</span>
            
<span class="c1">#     # ---------- Phase A: Figure out if branch needs to be processed at all (and if so compute the downstream branches ---</span>
<span class="c1">#     (return_value,</span>
<span class="c1">#     downstream_branches,</span>
<span class="c1">#     skip_distance,</span>
<span class="c1">#     skipped_nodes) = high_low_degree_upstream_match_preprocessing(</span>
<span class="c1">#                         limb_obj,</span>
<span class="c1">#                         branch_idx,</span>

<span class="c1">#                         #arguments for determining downstream nodes</span>
<span class="c1">#                         skip_distance = skip_distance,</span>
<span class="c1">#                         min_upstream_skeletal_distance = min_upstream_skeletal_distance,</span>
<span class="c1">#                         short_thick_endnodes_to_remove = limb_obj.short_thick_endnodes,</span>
<span class="c1">#                         axon_spines = limb_obj.axon_spines,</span>
<span class="c1">#                         min_degree_to_resolve = min_degree_to_resolve,</span>

<span class="c1">#                         # helps determine the max degrees to resolve</span>
<span class="c1">#                         width_func = width_func,</span>
<span class="c1">#                         max_degree_to_resolve_absolute = max_degree_to_resolve_absolute,</span>
<span class="c1">#                         max_degree_to_resolve = max_degree_to_resolve,</span>
<span class="c1">#                         max_degree_to_resolve_wide = max_degree_to_resolve_wide,</span>
<span class="c1">#                         max_degree_to_resolve_width_threshold = max_degree_to_resolve_width_threshold,</span>

<span class="c1">#                         # parameter checking to see if high degree resolve can be used</span>
<span class="c1">#                         width_max = width_max,</span>
<span class="c1">#                         axon_dependent = axon_dependent, </span>

<span class="c1">#                         #arguments for what to return</span>
<span class="c1">#                         return_skip_info=True,</span>
        
<span class="c1">#                         verbose=verbose,</span>
<span class="c1">#                         )</span>
    
<span class="c1">#     if len(return_value) &gt; 0:</span>
<span class="c1">#         return return_value</span>
    
<span class="c1">#     # ---------- Phase B: Start the filtering of downstream branches for the match ----</span>
    
<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;***Branch being considered after filters = {branch_idx}***&quot;)</span>
    
<span class="c1">#     #1) Compute features of a complete graph that connets all upsream and downsream edges</span>
<span class="c1">#     #(slightly different computation for upstream than downstream edges)</span>
    
<span class="c1">#     upstream_branch = branch_idx</span>
<span class="c1">#     all_branch_idx = np.hstack([downstream_branches,[upstream_branch]])</span>
    
<span class="c1">#     G = xu.complete_graph_from_node_ids(all_branch_idx)</span>
    
    
<span class="c1">#     if plot_starting_branches:</span>
<span class="c1">#         nviz.plot_branch_groupings(limb_obj = limb_obj,</span>
<span class="c1">#         groupings = [[k] for k in G.nodes],</span>
<span class="c1">#         verbose = False,</span>
<span class="c1">#         plot_meshes = True,</span>
<span class="c1">#         plot_skeletons = True,</span>
<span class="c1">#         extra_group = skipped_nodes)</span>
        
        
<span class="c1">#     G_e_2=nst.compute_edge_attributes_locally_upstream_downstream(</span>
<span class="c1">#             limb_obj,</span>
<span class="c1">#             upstream_branch,</span>
<span class="c1">#             downstream_branches,</span>
<span class="c1">#             offset=offset,</span>
<span class="c1">#             comparison_distance = comparison_distance,</span>
<span class="c1">#             plot_extracted_skeletons = plot_extracted_skeletons,</span>
    
<span class="c1">#     )</span>
        
<span class="c1">#     &#39;&#39;&#39;=</span>
<span class="c1">#     arguments_for_all_edge_functions = dict(</span>
<span class="c1">#                                         #nodes_to_exclude=nodes_to_exclude,</span>
<span class="c1">#                                            branch_1_direction=&quot;upstream&quot;,</span>
<span class="c1">#                                             branch_2_direction=&quot;downstream&quot;,</span>
<span class="c1">#                                            comparison_distance = 10000)</span>
    
<span class="c1">#     nodes_to_compute = [upstream_branch]</span>
<span class="c1">#     edge_functions = dict(sk_angle=dict(function=nst.parent_child_sk_angle,</span>
<span class="c1">#                                         arguments=dict(offset=offset,</span>
<span class="c1">#                                                       comparison_distance=comparison_distance,</span>
<span class="c1">#                                                       plot_extracted_skeletons=plot_extracted_skeletons)),</span>
<span class="c1">#                          width_diff = nst.width_diff,</span>
<span class="c1">#                           width_diff_percentage = nst.width_diff_percentage,</span>
<span class="c1">#                          synapse_density_diff=nst.synapse_density_diff,</span>
<span class="c1">#                           n_synapses_diff = nst.n_synapses_diff,</span>
<span class="c1">#                           none_to_some_synapses = nst.none_to_some_synapses</span>
<span class="c1">#                          )</span>

<span class="c1">#     G_e_1 = nst.compute_edge_attributes_locally(G,</span>
<span class="c1">#                                               limb_obj,</span>
<span class="c1">#                                              nodes_to_compute,</span>
<span class="c1">#                                              edge_functions,</span>
<span class="c1">#                                              verbose=False,</span>
<span class="c1">#                                                 arguments_for_all_edge_functions=arguments_for_all_edge_functions,</span>
<span class="c1">#                                              directional = False)</span>
    
<span class="c1">#     nodes_to_compute = downstream_branches</span>
    
<span class="c1">#     arguments_for_all_edge_functions = dict(</span>
<span class="c1">#                                         #nodes_to_exclude=nodes_to_exclude,</span>
<span class="c1">#                                            branch_1_direction=&quot;downstream&quot;,</span>
<span class="c1">#                                             branch_2_direction=&quot;downstream&quot;,</span>
<span class="c1">#                                            comparison_distance = 10000)</span>
    
<span class="c1">#     edge_functions = dict(</span>
<span class="c1">#                           sk_angle=dict(function=nst.sibling_sk_angle,</span>
<span class="c1">#                                         arguments=dict(offset=offset,</span>
<span class="c1">#                                                       comparison_distance=comparison_distance,</span>
<span class="c1">#                                                 plot_extracted_skeletons=plot_extracted_skeletons)),</span>
<span class="c1">#                          width_diff = nst.width_diff,</span>
<span class="c1">#                           width_diff_percentage = nst.width_diff_percentage,</span>
<span class="c1">#                          synapse_density_diff=nst.synapse_density_diff,</span>
<span class="c1">#                           n_synapses_diff = nst.n_synapses_diff,</span>
<span class="c1">#                          none_to_some_synapses = nst.none_to_some_synapses)</span>

<span class="c1">#     G_e_2 = nst.compute_edge_attributes_locally(G_e_1,</span>
<span class="c1">#                                               limb_obj,</span>
<span class="c1">#                                              nodes_to_compute,</span>
<span class="c1">#                                              edge_functions,</span>
<span class="c1">#                                              verbose=False,</span>
<span class="c1">#                                                 arguments_for_all_edge_functions=arguments_for_all_edge_functions,</span>
<span class="c1">#                                              directional = False)</span>
        
<span class="c1">#     &#39;&#39;&#39;</span>
        
<span class="c1">#     #2) Filter the edges by local properties</span>
<span class="c1">#     synapse_query = (f&quot;((synapse_density_diff&lt;{synapse_density_diff_threshold}) or&quot; </span>
<span class="c1">#                         f&quot; (n_synapses_diff &lt; {n_synapses_diff_threshold}))&quot;)</span>

<span class="c1">#     branch_match_query = (f&quot;(((width_diff &lt; {width_diff_max}) or (width_diff_percentage &lt; {width_diff_perc}))&quot;</span>
<span class="c1">#                           f&quot; and (sk_angle &lt; {worst_case_sk_angle_match_threshold}))&quot;)</span>

<span class="c1">#     if perform_synapse_filter:</span>
<span class="c1">#         branch_match_query += f&quot;and {synapse_query}&quot;</span>

<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;branch_match_query = :\n{branch_match_query}&quot;)</span>

<span class="c1">#     G_edge_filt = xu.d(G_e_2,</span>
<span class="c1">#                                       edge_query=branch_match_query,</span>
<span class="c1">#                                       verbose=verbose)</span>
<span class="c1">#     if plot_G_local_edge:</span>
<span class="c1">#         print(f&quot;\n--- Before Local Query ---&quot;)</span>
<span class="c1">#         print(xu.edge_df(G_e_2))</span>
<span class="c1">#         print(&quot;Afer Local query: &quot;)</span>
<span class="c1">#         print(xu.edge_df(G_edge_filt))</span>
<span class="c1">#         nx.draw(G_edge_filt,with_labels=True) </span>
<span class="c1">#         plt.show()</span>
    
    
<span class="c1">#     G = G_edge_filt</span>
<span class="c1">#     if len(G_edge_filt.edges()) &gt; 0:</span>
<span class="c1">#         # ------------- Phase B.2: Looking at global features for query ------- #</span>
<span class="c1">#         print(f&quot;plot_G_global_edge = {plot_G_global_edge}&quot;)</span>
<span class="c1">#         if verbose:</span>
<span class="c1">#             print(f&quot;Performing global features query&quot;)</span>

<span class="c1">#         # 3) computes the global fetures</span>
<span class="c1">#         edge_functions_global = dict(definite_partner_sk_delete=dict(function=nst.edges_to_delete_from_threshold_and_buffer,</span>
<span class="c1">#                                                               arguments=dict(threshold=sk_angle_match_threshold,</span>
<span class="c1">#                                                                                   buffer= sk_angle_buffer,</span>
<span class="c1">#                                                                            verbose = False,</span>
<span class="c1">#                                                                             edge_attribute = &quot;sk_angle&quot;)),</span>
<span class="c1">#                                 definite_partner_width_delete=dict(function=nst.edges_to_delete_from_threshold_and_buffer,</span>
<span class="c1">#                                                               arguments=dict(threshold=width_diff_perc_threshold,</span>
<span class="c1">#                                                                                   buffer= width_diff_perc_buffer,</span>
<span class="c1">#                                                                            verbose = False,</span>
<span class="c1">#                                                                             edge_attribute = &quot;width_diff_percentage&quot;))</span>

<span class="c1">#                          )</span>

<span class="c1">#         # 4) Filtering Graph by global properties (applying the definite filter pair)</span>
<span class="c1">#         G_edge_filt_with_att = nst.compute_edge_attributes_globally(G_edge_filt,</span>
<span class="c1">#                                              edge_functions_global)</span>
<span class="c1">#         G_global_1 = xu.query_to_subgraph(G_edge_filt_with_att,</span>
<span class="c1">#                                           edge_query=&quot;(definite_partner_sk_delete == False) or ((definite_partner_sk_delete != True) and (definite_partner_width_delete != True))&quot;,</span>
<span class="c1">#                                           verbose=verbose)</span>

<span class="c1">#         if plot_G_global_edge:</span>
<span class="c1">#             print(f&quot;\n--- Before Global Query ---&quot;)</span>
<span class="c1">#             print(xu.edge_df(G_edge_filt_with_att))</span>
<span class="c1">#             print(&quot;Afer Global query: &quot;)</span>
<span class="c1">#             print(xu.edge_df(G_global_1))</span>
<span class="c1">#             nx.draw(G_global_1,with_labels=True) </span>
<span class="c1">#             plt.show()</span>
            
<span class="c1">#         G = G_global_1</span>
<span class="c1">#         if len(G_global_1.edges())&gt;0:</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;Performing node features query&quot;)</span>
    
<span class="c1">#             # 5) Computing NOde features (for sfiltering on the upstream node edges)</span>
<span class="c1">#             edge_functions_node_global = dict(above_threshold_delete=dict(</span>
<span class="c1">#                                         function=nst.edges_to_delete_on_node_above_threshold_if_one_below,</span>
<span class="c1">#                                         arguments=dict(threshold=sk_angle_match_threshold,</span>
<span class="c1">#                                            verbose = False)</span>
<span class="c1">#                                         )</span>
<span class="c1">#                              )</span>

<span class="c1">#             if use_exclusive_partner:</span>
<span class="c1">#                 nodes_to_compute = list(G_global_1.nodes())</span>
<span class="c1">#             else:</span>
<span class="c1">#                 nodes_to_compute = branch_idx</span>
                
<span class="c1">#             G_edge_filt_with_node_att = nst.compute_edge_attributes_around_node(G_global_1,</span>
<span class="c1">#                                              edge_functions_node_global,</span>
<span class="c1">#                                                 nodes_to_compute=nodes_to_compute,</span>
<span class="c1">#                                              )</span>

<span class="c1">#             # 6) Filtering graph based on node features</span>
<span class="c1">#             G_global_2 = xu.query_to_subgraph(G_edge_filt_with_node_att,</span>
<span class="c1">#                                           edge_query=&quot;above_threshold_delete != True&quot;,</span>
<span class="c1">#                                           verbose=verbose)</span>

<span class="c1">#             if plot_G_node_edge:</span>
<span class="c1">#                 print(f&quot;\n--- Before Node Query ---&quot;)</span>
<span class="c1">#                 print(xu.edge_df(G_edge_filt_with_node_att))</span>
<span class="c1">#                 print(&quot;Afer Node query: &quot;)</span>
<span class="c1">#                 print(xu.edge_df(G_global_2))</span>
<span class="c1">#                 nx.draw(G_global_2,with_labels=True) </span>
<span class="c1">#                 plt.show()</span>
                
<span class="c1">#             G = G_global_2</span>
        
        
<span class="c1">#     upstream_branch = branch_idx</span>
    
    
<span class="c1">#     # ------- Phase C: Optional Kiss Filter ------</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     ---------- 4/29 Addition: Kiss Filter -----------</span>

<span class="c1">#     Pseudocode:</span>
<span class="c1">#     0) Get the offset skeleton coordinates for all nodes in graph</span>
<span class="c1">#     1) find all the possible partitions of the remaining nodes</span>

<span class="c1">#     &quot;&quot;&quot; </span>
<span class="c1">#     if kiss_check:</span>
<span class="c1">#         if verbose:</span>
<span class="c1">#             print(f&quot;Attempting to perform Kiss check&quot;)</span>
<span class="c1">#         coordinate = nru.downstream_endpoint(limb_obj,upstream_branch)</span>
<span class="c1">#         upstream_matches = xu.get_neighbors(G,upstream_branch)</span>
<span class="c1">#         if len(upstream_matches)&gt;1:</span>
<span class="c1">#             print(f&quot;Working on Kissing check because possible upstream matches greater than 1: {upstream_matches}&quot;)</span>

<span class="c1">#             G = ed.cut_kissing_graph_edges(G,limb_obj,</span>
<span class="c1">#                 kiss_check_bbox_longest_side_threshold = kiss_check_bbox_longest_side_threshold,</span>
<span class="c1">#                 coordinate = coordinate,</span>
<span class="c1">#                 offset=offset,</span>
<span class="c1">#                 comparison_distance = comparison_distance,</span>
<span class="c1">#                 plot_offset_skeletons = False,</span>
<span class="c1">#                 plot_source_sink_vertices = False,</span>
<span class="c1">#                 plot_cut_vertices = False,</span>
<span class="c1">#                 plot_cut_bbox = False,</span>
<span class="c1">#                 verbose = False</span>
<span class="c1">#                             )</span>

<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;Step 5b: Removing kissing edges&quot;)</span>
<span class="c1">#                 print(f&quot;Remaining Edges = {G.edges()}&quot;)</span>
<span class="c1">#         else:</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;Not doing kiss check because upstream_matches = {upstream_matches}&quot;)</span>


    
<span class="c1">#     # ------- Phase D: Picking the Winner of the upstream branch and error branches ------</span>
    
    
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Part 6:</span>
<span class="c1">#     if there are other nodes in the group use on of the following to determine winner</span>
<span class="c1">#         a) best match</span>
<span class="c1">#         b) least sum angle</span>
<span class="c1">#     &quot;&quot;&quot;</span>
    
    
<span class="c1">#     upstream_subgraph = np.array([list(k) for k in nx.connected_components(G) </span>
<span class="c1">#                                   if upstream_branch in k][0])</span>
<span class="c1">#     if len(upstream_subgraph) == 1:</span>
<span class="c1">#         winning_node = None</span>
<span class="c1">#         error_branches = downstream_branches</span>
<span class="c1">#     else:</span>
<span class="c1">#         if match_method == &quot;best_match&quot;:</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;Using best match method&quot;)</span>
<span class="c1">#             winning_node = xu.get_neighbor_min_weighted_edge(G,upstream_branch)</span>
<span class="c1">#         elif match_method == &quot;lowest_angle_sum&quot;:</span>
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;Using lowest_angle_sum method&quot;)</span>
<span class="c1">#             raise Exception(&quot;hasn&#39;t been fixed to make sure the upstream node is guaranteed to be in the output graph&quot;)</span>
<span class="c1">#             G_final = xu.graph_to_lowest_weighted_sum_singular_matches(G,</span>
<span class="c1">#             verbose = verbose,</span>
<span class="c1">#             return_graph = True)</span>
            
            
<span class="c1">#             winning_node = xu.get_neighbors(G_final,upstream_branch)</span>
<span class="c1">#             if len(winning_node) != 1:</span>
<span class="c1">#                 raise Exception(f&quot;Not just one winning node: {winning_node}&quot;)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 winning_node = winning_node[0]</span>
<span class="c1">#         elif match_method == &quot;all_error_if_not_one_match&quot;:</span>
<span class="c1">#             error_branches = downstream_branches</span>
<span class="c1">#             if len(upstream_subgraph) == 2:</span>
<span class="c1">#                 winning_node = upstream_subgraph[upstream_subgraph!=upstream_branch][0]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 winning_node = None</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise Exception(f&quot;Unimplemented match_method : {match_method} &quot;)</span>


<span class="c1">#         error_branches = downstream_branches[downstream_branches!= winning_node]</span>

<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;for upstream node {upstream_branch}, winning_node = {winning_node}, error_branches = {error_branches}&quot;)</span>

<span class="c1">#     if plot_final_branch_matches:</span>
<span class="c1">#         nviz.plot_branch_groupings(limb_obj = limb_obj,</span>
<span class="c1">#         groupings = G,</span>
<span class="c1">#         verbose = False,</span>
<span class="c1">#         plot_meshes = True,</span>
<span class="c1">#         plot_skeletons = True,</span>
<span class="c1">#             extra_group = skipped_nodes,)</span>
    
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     --- 5/12: Not having the short thick end nodes in the errors to remove</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     if remove_short_thick_endnodes:    </span>
<span class="c1">#         #print(f&quot;short_thick_endnodes_to_remove = {short_thick_endnodes_to_remove}&quot;)</span>
<span class="c1">#         error_branches = np.setdiff1d(error_branches,short_thick_endnodes_to_remove)</span>
        
<span class="c1">#     if axon_spines is not None:</span>
<span class="c1">#         error_branches = np.setdiff1d(error_branches,axon_spines)</span>
    
<span class="c1">#     return winning_node,error_branches</span>

<div class="viewcode-block" id="high_degree_false_positive_low_sibling_filter"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.high_degree_false_positive_low_sibling_filter">[docs]</a><span class="k">def</span> <span class="nf">high_degree_false_positive_low_sibling_filter</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">downstream_idx</span><span class="p">,</span>
    <span class="n">width_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#320,</span>
    <span class="n">sibling_skeletal_angle_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#90,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to not error out high degree branches</span>
<span class="sd">    that have a degree of 4 and the error branches</span>
<span class="sd">    have a very low sibling angle</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) If have 2 error branches</span>
<span class="sd">    2) If the width is above a threshold</span>
<span class="sd">    3) Find the skeletal angle between the two components</span>
<span class="sd">    4) Return no errors if less than certain skeletal length</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    high_degree_false_positive_low_sibling_filter(</span>
<span class="sd">        neuron_obj[2],</span>
<span class="sd">        3,</span>
<span class="sd">        [1,2],</span>
<span class="sd">        verbose = True,</span>
<span class="sd">        width_min = 400,</span>
<span class="sd">        #sibling_skeletal_angle_max=80</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">)</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inside high_degree_false_positive_low_sibling_filter ****&quot;</span><span class="p">)</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">width_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_min</span> <span class="o">=</span> <span class="n">width_min_high_degree_false_positive_global</span>
    <span class="k">if</span> <span class="n">sibling_skeletal_angle_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sibling_skeletal_angle_max</span> <span class="o">=</span><span class="n">sibling_skeletal_angle_max_high_degree_false_positive_global</span>
    
    <span class="n">error_downstream</span> <span class="o">=</span> <span class="n">downstream_idx</span>
    <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No winning branch so returning&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_downstream</span>
    
    <span class="k">if</span> <span class="n">error_downstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;None error_downstream so returning&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_downstream</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_downstream</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not exactly 2 downstream errors so returning&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_downstream</span>
    
    <span class="n">upstream_b</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
    <span class="n">upstream_b_width</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_new</span><span class="p">(</span><span class="n">upstream_b</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">upstream_b_width</span> <span class="o">&lt;</span> <span class="n">width_min</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upstream width (</span><span class="si">{</span><span class="n">upstream_b_width</span><span class="si">}</span><span class="s2">) less than width_min(</span><span class="si">{</span><span class="n">width_min</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_downstream</span>
    
    <span class="c1">#3) Find the skeletal angle between the two components</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">error_downstream</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">error_downstream</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">skel_angle</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span>
            <span class="n">b1</span><span class="o">.</span><span class="n">skeleton_vector_upstream</span><span class="p">,</span>
            <span class="n">b2</span><span class="o">.</span><span class="n">skeleton_vector_upstream</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">)</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">error_downstream</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">error_downstream</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">skel_angle</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span>
            <span class="n">b1</span><span class="o">.</span><span class="n">skeleton_vector_upstream</span><span class="p">,</span>
            <span class="n">b2</span><span class="o">.</span><span class="n">skeleton_vector_upstream</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skel_angle between downstream branches = </span><span class="si">{</span><span class="n">skel_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#4) Return no errors if less than certain skeletal length</span>
    <span class="k">if</span> <span class="n">skel_angle</span> <span class="o">&lt;</span> <span class="n">sibling_skeletal_angle_max</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sibling angle less than max so returning no branches&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sibling angle greater than max so returning original errors&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">error_downstream</span></div>
    
<div class="viewcode-block" id="high_degree_upstream_match"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.high_degree_upstream_match">[docs]</a><span class="k">def</span> <span class="nf">high_degree_upstream_match</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    
    <span class="c1">#--- Phase A: arguments for determining downstream nodes ------</span>
    <span class="n">skip_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3000,</span>
    <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_short_thick_endnodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">axon_spines</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    
    <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1"># ----------- default parameters for these set in the preprocessing function</span>
    <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3,</span>
    
    <span class="c1"># helps determine the max degrees to resolve</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve_width_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#200,</span>
    
    <span class="c1"># parameter checking to see if high degree resolve can be used</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#170,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">plot_starting_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># --- Phase B.1: parameters for local edge attributes ------</span>
    <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#1000,#1500,</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2000,</span>
    <span class="n">plot_extracted_skeletons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="c1"># --- Phase B.2: parameters for local edge query ------</span>
    
    <span class="n">worst_case_sk_angle_match_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#65,</span>
    
    <span class="n">width_diff_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#75,#np.inf,100,</span>
    <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.60,</span>
    
    <span class="n">perform_synapse_filter</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1"># True,</span>
    <span class="n">synapse_density_diff_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.00015, #was 0.00021</span>
    <span class="n">n_synapses_diff_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#6,</span>
    
    <span class="n">plot_G_local_edge</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># ----- Phase B.3: parameters for global attributes ---</span>
    <span class="c1">#args for definite pairs</span>
    <span class="n">sk_angle_match_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#45,</span>
    <span class="n">sk_angle_buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#25,</span>
    
    <span class="n">width_diff_perc_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.15,</span>
    <span class="n">width_diff_perc_buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.30,</span>

    <span class="c1"># ----- Phase B.4 paraeters for global query ---</span>
    <span class="n">plot_G_global_edge</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># ----- Phase B.6 paraeters for ndoe query ---</span>
    <span class="n">plot_G_node_edge</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># ---- Phase C: Optional Kiss filter ----</span>
    <span class="n">kiss_check</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">kiss_check_bbox_longest_side_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#450,</span>

    <span class="c1"># ---- Phase D: Picking the final winner -----</span>
    <span class="n">plot_final_branch_matches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">match_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#&quot;all_error_if_not_one_match&quot;,# &quot;best_match&quot;, #other option is &quot;best_match&quot;</span>
    <span class="n">use_exclusive_partner</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True,</span>
    
    <span class="c1">#false positive low sibling filter</span>
    <span class="n">use_high_degree_false_positive_filter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="c1">#print(f&quot;perform_synapse_filter = {perform_synapse_filter}&quot;)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Determine if branches downstream from a certain</span>
<span class="sd">    branch should be errored out based on crossovers and </span>
<span class="sd">    high degree branching downstream</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    Phase A:</span>
<span class="sd">    #1) Get all downstream branhes (with an optional skip distance)</span>
<span class="sd">    #2) Remove short thick endnodes from possible branches in the high degree point</span>
<span class="sd">    #3) Return if not enough branches at the intersection</span>
<span class="sd">    #4) If the branch being considered is thick enough then increase the max degree to resolve</span>
<span class="sd">    #5) Return all downstream branches as errors if number of branches at intersection is too large</span>
<span class="sd">    #6) Do not process the intersection if all the branches are thick or not all are axons (return no errors)</span>
<span class="sd">    </span>
<span class="sd">    Phase B: </span>
<span class="sd">    #1) Compute features of a complete graph that connets all upsream and downsream edges</span>
<span class="sd">    #(slightly different computation for upstream than downstream edges)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#     if branch_idx == 3:</span>
<span class="c1">#         verbose = True</span>

    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>

    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_high_d_match_global</span>
    <span class="k">if</span> <span class="n">comparison_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_high_d_match_global</span>
    <span class="k">if</span> <span class="n">worst_case_sk_angle_match_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">worst_case_sk_angle_match_threshold</span> <span class="o">=</span> <span class="n">worst_case_sk_angle_match_threshold_high_d_match_global</span>
    <span class="k">if</span> <span class="n">width_diff_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_max</span> <span class="o">=</span> <span class="n">width_diff_max_high_d_match_global</span>
    <span class="k">if</span> <span class="n">width_diff_perc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="n">width_diff_perc_high_d_match_global</span>
    <span class="k">if</span> <span class="n">perform_synapse_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">perform_synapse_filter</span> <span class="o">=</span> <span class="n">perform_synapse_filter_high_d_match_global</span>
    <span class="k">if</span> <span class="n">synapse_density_diff_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">synapse_density_diff_threshold</span> <span class="o">=</span> <span class="n">synapse_density_diff_threshold_high_d_match_global</span>
    <span class="k">if</span> <span class="n">n_synapses_diff_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_synapses_diff_threshold</span> <span class="o">=</span> <span class="n">n_synapses_diff_threshold_high_d_match_global</span>
    <span class="k">if</span> <span class="n">sk_angle_match_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sk_angle_match_threshold</span> <span class="o">=</span> <span class="n">sk_angle_match_threshold_high_d_match_global</span>
    <span class="k">if</span> <span class="n">sk_angle_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sk_angle_buffer</span> <span class="o">=</span> <span class="n">sk_angle_buffer_high_d_match_global</span>
    <span class="k">if</span> <span class="n">width_diff_perc_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_perc_threshold</span> <span class="o">=</span> <span class="n">width_diff_perc_threshold_high_d_match_global</span>
    <span class="k">if</span> <span class="n">width_diff_perc_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_perc_buffer</span> <span class="o">=</span> <span class="n">width_diff_perc_buffer_high_d_match_global</span>
    <span class="k">if</span> <span class="n">kiss_check</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kiss_check</span> <span class="o">=</span> <span class="n">kiss_check_high_d_match_global</span>
    <span class="k">if</span> <span class="n">kiss_check_bbox_longest_side_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kiss_check_bbox_longest_side_threshold</span> <span class="o">=</span> <span class="n">kiss_check_bbox_longest_side_threshold_high_d_match_global</span>
    <span class="k">if</span> <span class="n">match_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">match_method</span> <span class="o">=</span> <span class="n">match_method_high_d_match_global</span>
    <span class="k">if</span> <span class="n">use_exclusive_partner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_exclusive_partner</span> <span class="o">=</span> <span class="n">use_exclusive_partner_high_d_match_global</span>
        
    <span class="k">if</span> <span class="n">use_high_degree_false_positive_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_high_degree_false_positive_filter</span> <span class="o">=</span> <span class="n">use_high_degree_false_positive_filter_global</span>

    <span class="k">if</span> <span class="n">remove_short_thick_endnodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">short_thick_endnodes_to_remove</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">short_thick_branches_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="n">short_thick_endnodes_to_remove</span>
    
    <span class="k">if</span> <span class="n">axon_spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="n">axon_spines</span>
        
    <span class="c1">#print(f&quot;width_diff_perc_threshold = {width_diff_perc_threshold}&quot;)</span>
    <span class="c1">#print(f&quot;width_diff_perc_buffer = {width_diff_perc_buffer}&quot;)</span>
    
            
    <span class="c1"># ---------- Phase A: Figure out if branch needs to be processed at all (and if so compute the downstream branches ---</span>
    <span class="p">(</span><span class="n">return_value</span><span class="p">,</span>
    <span class="n">downstream_branches</span><span class="p">,</span>
    <span class="n">skip_distance</span><span class="p">,</span>
    <span class="n">skipped_nodes</span><span class="p">)</span> <span class="o">=</span> <span class="n">high_low_degree_upstream_match_preprocessing</span><span class="p">(</span>
                        <span class="n">limb_obj</span><span class="p">,</span>
                        <span class="n">branch_idx</span><span class="p">,</span>

                        <span class="c1">#arguments for determining downstream nodes</span>
                        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">skip_distance</span><span class="p">,</span>
                        <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="n">min_upstream_skeletal_distance</span><span class="p">,</span>
                        <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span><span class="p">,</span>
                        <span class="n">axon_spines</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span><span class="p">,</span>
                        <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="n">min_degree_to_resolve</span><span class="p">,</span>

                        <span class="c1"># helps determine the max degrees to resolve</span>
                        <span class="n">width_func</span> <span class="o">=</span> <span class="n">width_func</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_absolute</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="n">max_degree_to_resolve</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_wide</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve_width_threshold</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_width_threshold</span><span class="p">,</span>

                        <span class="c1"># parameter checking to see if high degree resolve can be used</span>
                        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">,</span>
                        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max</span><span class="p">,</span>
                        <span class="n">axon_dependent</span> <span class="o">=</span> <span class="n">axon_dependent</span><span class="p">,</span> 

                        <span class="c1">#arguments for what to return</span>
                        <span class="n">return_skip_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        
                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                        <span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span>
    
    <span class="c1"># ---------- Phase B: Start the filtering of downstream branches for the match ----</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;***Branch being considered after filters = </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">***&quot;</span><span class="p">)</span>
    
<span class="c1">#     if branch_idx == 78:</span>
<span class="c1">#         verbose = True</span>
<span class="c1">#         plot_G_local_edge = True</span>
<span class="c1">#         plot_G_global_edge = True</span>
<span class="c1">#         plot_final_branch_matches = True</span>
    
    <span class="n">winning_node</span><span class="p">,</span><span class="n">error_branches</span><span class="o">=</span><span class="n">gf</span><span class="o">.</span><span class="n">upstream_pair_singular</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                          <span class="n">upstream_branch</span><span class="o">=</span><span class="n">branch_idx</span><span class="p">,</span>
                          <span class="n">downstream_branches</span><span class="o">=</span><span class="n">downstream_branches</span><span class="p">,</span>
                           <span class="n">plot_starting_branches</span> <span class="o">=</span> <span class="n">plot_starting_branches</span><span class="p">,</span>
                        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                        <span class="n">plot_extracted_skeletons</span> <span class="o">=</span> <span class="n">plot_extracted_skeletons</span><span class="p">,</span>


                        <span class="n">worst_case_sk_angle_match_threshold</span> <span class="o">=</span> <span class="n">worst_case_sk_angle_match_threshold</span><span class="p">,</span>

                        <span class="n">width_diff_max</span> <span class="o">=</span> <span class="n">width_diff_max</span><span class="p">,</span><span class="c1">#np.inf,100,</span>
                        <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="n">width_diff_perc</span><span class="p">,</span>

                        <span class="n">perform_synapse_filter</span> <span class="o">=</span> <span class="n">perform_synapse_filter</span><span class="p">,</span>
                        <span class="n">synapse_density_diff_threshold</span> <span class="o">=</span> <span class="n">synapse_density_diff_threshold</span><span class="p">,</span> <span class="c1">#was 0.00021</span>
                        <span class="n">n_synapses_diff_threshold</span> <span class="o">=</span> <span class="n">n_synapses_diff_threshold</span><span class="p">,</span>

                        <span class="n">plot_G_local_edge</span> <span class="o">=</span> <span class="n">plot_G_local_edge</span><span class="p">,</span>

                        <span class="c1"># ----- Phase B.3: parameters for global attributes ---</span>
                        <span class="c1">#args for definite pairs</span>
                        <span class="n">perform_global_edge_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">sk_angle_match_threshold</span> <span class="o">=</span> <span class="n">sk_angle_match_threshold</span><span class="p">,</span>
                        <span class="n">sk_angle_buffer</span> <span class="o">=</span> <span class="n">sk_angle_buffer</span><span class="p">,</span>

                        <span class="n">width_diff_perc_threshold</span> <span class="o">=</span> <span class="n">width_diff_perc_threshold</span><span class="p">,</span>
                        <span class="n">width_diff_perc_buffer</span> <span class="o">=</span> <span class="n">width_diff_perc_buffer</span><span class="p">,</span>

                        <span class="c1"># ----- Phase B.4 paraeters for global query ---</span>
                        <span class="n">plot_G_global_edge</span> <span class="o">=</span> <span class="n">plot_G_global_edge</span><span class="p">,</span>


                        <span class="c1"># ------- For Node Query ----#</span>
                        <span class="n">perform_node_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">use_exclusive_partner</span> <span class="o">=</span> <span class="n">use_exclusive_partner</span><span class="p">,</span>
                        <span class="n">plot_G_node_edge</span> <span class="o">=</span> <span class="n">plot_G_node_edge</span><span class="p">,</span>
                           
                        <span class="n">kiss_check</span> <span class="o">=</span> <span class="n">kiss_check</span><span class="p">,</span>
                        <span class="n">kiss_check_bbox_longest_side_threshold</span> <span class="o">=</span> <span class="n">kiss_check_bbox_longest_side_threshold</span><span class="p">,</span>

                        <span class="c1"># ---- Phase D: Picking the final winner -----</span>
                        <span class="n">plot_final_branch_matches</span> <span class="o">=</span> <span class="n">plot_final_branch_matches</span><span class="p">,</span>
                        <span class="n">match_method</span> <span class="o">=</span> <span class="n">match_method</span><span class="p">,</span><span class="c1"># &quot;best_match&quot;, #other option is &quot;best_match&quot;</span>

                        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                          <span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    --- 5/12: Not having the short thick end nodes in the errors to remove</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">remove_short_thick_endnodes</span><span class="p">:</span>    
        <span class="c1">#print(f&quot;short_thick_endnodes_to_remove = {short_thick_endnodes_to_remove}&quot;)</span>
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">error_branches</span><span class="p">,</span><span class="n">short_thick_endnodes_to_remove</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">axon_spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">error_branches</span><span class="p">,</span><span class="n">axon_spines</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">use_high_degree_false_positive_filter</span><span class="p">:</span>
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">high_degree_false_positive_low_sibling_filter</span><span class="p">(</span>
            <span class="n">limb_obj</span><span class="p">,</span>
            <span class="n">winning_node</span><span class="p">,</span>
            <span class="n">error_branches</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using use_high_degree_false_positive_filter and after error_branches = </span><span class="si">{</span><span class="n">error_branches</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">winning_node</span><span class="p">,</span><span class="n">error_branches</span></div>



    

<div class="viewcode-block" id="high_degree_branch_errors_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.high_degree_branch_errors_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">high_degree_branch_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                               <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="s2">&quot;axon&quot;</span><span class="p">,</span>
                                               <span class="c1"># parameters to add as more filters for the branches to check</span>
                                               <span class="n">skip_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                               <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                               <span class="n">plot_limb_branch_pre_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">plot_limb_branch_post_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">plot_limb_branch_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">high_degree_order_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">filter_axon_spines</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                               <span class="n">axon_spines_limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                               <span class="n">filter_short_thick_endnodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                               <span class="n">debug_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To resolve high degree nodes for a neuron </span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) get the limb branch dict to start over</span>
<span class="sd">    2) Find all of the high degree coordinates on the axon limb</span>

<span class="sd">    For each high degree coordinate</span>
<span class="sd">    a. Send the coordinate to the high_degree_upstream_match</span>
<span class="sd">    b. Get the error limbs back and if non empty then add to the limb branch dict</span>

<span class="sd">    return the limb branch dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#debug_branches = [4]</span>
    
    <span class="k">if</span> <span class="n">min_upstream_skeletal_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="n">min_upstream_skeletal_distance_global</span>
    
    
<span class="c1">#     high_degree_order_verbose = True</span>
<span class="c1">#     verbose = True</span>
    
    
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>
    <span class="k">elif</span> <span class="n">limb_branch_dict</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="s2">&quot;dendrite&quot;</span><span class="p">]:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_branch_dict</span><span class="si">}</span><span class="s2">_limb_branch_dict&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="k">if</span> <span class="n">plot_limb_branch_pre_filter</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The initial limb branch dict before the skip distance and skeletal length &quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict</span><span class="p">)</span>
    
<span class="c1"># ------ Moved this filter into the preprocessing stage of high_lower_degree branching preprocessing ----</span>
    
<span class="c1">#     high_degree_limb_branch = ns.query_neuron(neuron_obj,</span>
<span class="c1">#                     functions_list=[&quot;skeletal_length&quot;],</span>
<span class="c1">#                     query = f&quot;(skeletal_length&gt;{min_skeletal_distance})&quot;,</span>
<span class="c1">#                     function_kwargs=dict(skip_distance=skip_distance),</span>
<span class="c1">#                    limb_branch_dict_restriction=limb_branch_dict)</span>

<span class="c1">#     if plot_limb_branch_post_filter:</span>
<span class="c1">#         print(f&quot;The initial limb branch dict after min_skeletal_distance = {min_skeletal_distance} &quot;)</span>
<span class="c1">#         nviz.plot_limb_branch_dict(neuron_obj,</span>
<span class="c1">#                                    high_degree_limb_branch)</span>
    
    <span class="k">if</span> <span class="n">filter_axon_spines</span> <span class="ow">and</span> <span class="n">axon_spines_limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_spines_limb_branch_dict</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_spines_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">axon_spines_limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_spines_limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="k">if</span> <span class="n">filter_short_thick_endnodes</span><span class="p">:</span>
        <span class="n">short_thick_endnodes_to_remove_limb_branch</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">short_thick_branches_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">short_thick_endnodes_to_remove_limb_branch</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">limb_branch_dict_errors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ----- Working on limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">-------&quot;</span><span class="p">)</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
<span class="c1">#         short_thick_endnodes_to_remove = au.short_thick_branches_from_limb(limb_obj,</span>
<span class="c1">#                                      verbose = False)</span>

        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">short_thick_endnodes_to_remove_limb_branch</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1">#short_thick_endnodes_to_remove = short_thick_endnodes_to_remove_limb_branch[limb_name]</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="n">short_thick_endnodes_to_remove_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="p">[]</span>

        
        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">axon_spines_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="n">axon_spines_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">error_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug_branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">debug_branches</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_starting_branches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_G_local_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_G_global_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_G_node_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_final_branch_matches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">high_degree_order_verbose</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
            
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ----- Working on branch </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">--------&quot;</span><span class="p">)</span>
            <span class="n">winning_downstream</span><span class="p">,</span><span class="n">error_downstream</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">high_degree_upstream_match</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                                <span class="n">branch_idx</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
                                                                                <span class="n">skip_distance</span><span class="o">=</span><span class="n">skip_distance</span><span class="p">,</span>
                                <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span><span class="p">,</span>
                                                                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">high_degree_order_verbose</span><span class="p">,</span>
                                                                                <span class="n">axon_spines</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span><span class="p">,</span>
                                                                                <span class="n">min_upstream_skeletal_distance</span><span class="o">=</span><span class="n">min_upstream_skeletal_distance</span><span class="p">,</span>
                                                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
            <span class="c1">#winning_downstream,error_downstream = [],[]</span>
        
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_downstream = </span><span class="si">{</span><span class="n">winning_downstream</span><span class="si">}</span><span class="s2">,error_downstream = </span><span class="si">{</span><span class="n">error_downstream</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_downstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">error_branches</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">error_downstream</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_errors</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error_branches</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">plot_limb_branch_errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After high degree branch filter errors: limb_branch_dict_errors = </span><span class="si">{</span><span class="n">limb_branch_dict_errors</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict_errors</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_branch_dict_errors</span></div>





<div class="viewcode-block" id="high_degree_branch_errors_dendrite_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.high_degree_branch_errors_dendrite_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">high_degree_branch_errors_dendrite_limb_branch_dict</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>

    <span class="c1"># parameters for high_degree_branch_errors_limb_branch_dict</span>
    <span class="n">skip_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1_500,</span>
    <span class="c1">#min_upstream_skeletal_distance = None,#10_000,</span>
    <span class="n">plot_limb_branch_pre_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_post_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">high_degree_order_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">filter_axon_spines</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_short_thick_endnodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">debug_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    
    <span class="c1">#--------high degree upstream match parameters-----</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#800,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000000,</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1_500,</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3_000,</span>
    <span class="n">width_diff_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#150,</span>
    <span class="n">perform_synapse_filter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">width_diff_perc_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">width_diff_perc_buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1">#---- parameters for limb branch restriction -------</span>
    <span class="n">min_skeletal_length_endpoints</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#4_000,</span>
    <span class="n">plot_endpoints_filtered</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">min_distance_from_soma_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#7_000,</span>
    <span class="n">plot_soma_restr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">use_high_degree_false_positive_filter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_diff_perc_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_perc_threshold</span> <span class="o">=</span> <span class="n">width_diff_perc_threshold_high_d_match_dendr_global</span>
    <span class="k">if</span> <span class="n">width_diff_perc_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_perc_buffer</span> <span class="o">=</span> <span class="n">width_diff_perc_buffer_high_d_match_dendr_global</span>
    
    <span class="k">if</span> <span class="n">skip_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">skip_distance_high_degree_dendr_global</span>
<span class="c1">#     if min_upstream_skeletal_distance is None:</span>
<span class="c1">#         min_upstream_skeletal_distance = min_upstream_skeletal_distance_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">comparison_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">width_diff_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_max</span> <span class="o">=</span> <span class="n">width_diff_max_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">perform_synapse_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">perform_synapse_filter</span> <span class="o">=</span> <span class="n">perform_synapse_filter_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">min_skeletal_length_endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_skeletal_length_endpoints</span> <span class="o">=</span> <span class="n">min_skeletal_length_endpoints_high_degree_dendr_global</span>
    <span class="k">if</span> <span class="n">min_distance_from_soma_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_distance_from_soma_mesh</span> <span class="o">=</span> <span class="n">min_distance_from_soma_mesh_high_degree_dendr_global</span>
        
    <span class="k">if</span> <span class="n">use_high_degree_false_positive_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_high_degree_false_positive_filter</span> <span class="o">=</span> <span class="n">use_high_degree_false_positive_filter_dendr_global</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_max = </span><span class="si">{</span><span class="n">width_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_width_max = </span><span class="si">{</span><span class="n">upstream_width_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># purpose: To find the small end nodes</span>
    
    <span class="n">limb_branch_too_close</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">euclidean_distance_close_to_soma_limb_branch</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">distance_threshold</span><span class="o">=</span><span class="n">min_distance_from_soma_mesh</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot_soma_restr</span>
    <span class="p">)</span>    
    
    <span class="n">axon_spines_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(skeletal_length &lt; </span><span class="si">{</span><span class="n">min_skeletal_length_endpoints</span><span class="si">}</span><span class="s2">) and (n_downstream_nodes == 0)&quot;</span><span class="p">,</span>
        <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">,</span>
        <span class="n">plot_limb_branch_dict</span><span class="o">=</span><span class="n">plot_endpoints_filtered</span>
    <span class="p">)</span>
    
    <span class="n">limb_b_restr</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_setdiff</span><span class="p">([</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">,</span><span class="n">limb_branch_too_close</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_too_close = </span><span class="si">{</span><span class="n">limb_branch_too_close</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_spines_limb_branch = </span><span class="si">{</span><span class="n">axon_spines_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">ed</span><span class="o">.</span><span class="n">high_degree_branch_errors_limb_branch_dict</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_b_restr</span><span class="p">,</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">skip_distance</span><span class="p">,</span>
        <span class="c1">#min_upstream_skeletal_distance = min_upstream_skeletal_distance,</span>
        <span class="n">plot_limb_branch_pre_filter</span> <span class="o">=</span> <span class="n">plot_limb_branch_pre_filter</span><span class="p">,</span>
        <span class="n">plot_limb_branch_post_filter</span> <span class="o">=</span> <span class="n">plot_limb_branch_post_filter</span><span class="p">,</span>
        <span class="n">plot_limb_branch_errors</span> <span class="o">=</span> <span class="n">plot_limb_branch_errors</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">high_degree_order_verbose</span> <span class="o">=</span> <span class="n">high_degree_order_verbose</span><span class="p">,</span>
        <span class="n">filter_axon_spines</span> <span class="o">=</span> <span class="n">filter_axon_spines</span><span class="p">,</span>
        <span class="n">axon_spines_limb_branch_dict</span><span class="o">=</span><span class="n">axon_spines_limb_branch</span><span class="p">,</span>
        <span class="n">filter_short_thick_endnodes</span> <span class="o">=</span> <span class="n">filter_short_thick_endnodes</span><span class="p">,</span>
        <span class="n">debug_branches</span> <span class="o">=</span> <span class="n">debug_branches</span><span class="p">,</span>

        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">,</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max</span><span class="p">,</span>
        <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
        <span class="n">width_diff_max</span> <span class="o">=</span> <span class="n">width_diff_max</span><span class="p">,</span>
        <span class="n">perform_synapse_filter</span> <span class="o">=</span> <span class="n">perform_synapse_filter</span><span class="p">,</span>
        
        <span class="n">width_diff_perc_threshold</span> <span class="o">=</span> <span class="n">width_diff_perc_threshold</span><span class="p">,</span>
        <span class="n">width_diff_perc_buffer</span> <span class="o">=</span> <span class="n">width_diff_perc_buffer</span><span class="p">,</span>
        
        <span class="n">use_high_degree_false_positive_filter</span><span class="o">=</span><span class="n">use_high_degree_false_positive_filter</span><span class="p">,</span>

        <span class="o">**</span><span class="n">kwargs</span>

    <span class="p">)</span></div>





<span class="c1"># ---------- The low degree error detection ----------- #</span>
<span class="n">low_degree_filters_default</span> <span class="o">=</span> <span class="p">[]</span>
<div class="viewcode-block" id="low_degree_upstream_match"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.low_degree_upstream_match">[docs]</a><span class="k">def</span> <span class="nf">low_degree_upstream_match</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>

    <span class="c1">#--- Phase A: arguments for determining downstream nodes ------</span>
    <span class="n">skip_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0,#3000,</span>
    <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2000,</span>
    <span class="n">remove_short_thick_endnodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axon_spines</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    
    <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2,</span>
    <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2,</span>
    
    <span class="c1"># helps determine the max degrees to resolve</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2,</span>
    <span class="c1">#max_width_to_resolve = None,</span>
    
    <span class="c1"># parameter checking to see if high degree resolve can be used</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#170,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">plot_starting_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># --- Phase B.1: parameters for local edge attributes ------</span>
    <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#1000,#1500,</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2000,</span>
    <span class="n">plot_extracted_skeletons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="c1"># --- Phase B.2: parameters for local edge query ------</span>
    
    <span class="n">worst_case_sk_angle_match_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#65,</span>
    
    <span class="n">width_diff_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#75,#np.inf,100,</span>
    <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.60,</span>
    
    <span class="n">perform_synapse_filter</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1"># True,</span>
    <span class="n">synapse_density_diff_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.00015, #was 0.00021</span>
    <span class="n">n_synapses_diff_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#6,</span>
    
    <span class="n">plot_G_local_edge</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">filters_to_run</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Determine if branches downstream from a certain</span>
<span class="sd">    branch should be errored out based on forking rules</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    1) Determine if branch should even be processed</span>
<span class="sd">    if should be processed</span>
<span class="sd">    2) Calculate the edge attributes for this local graph</span>
<span class="sd">    3) Iterate through all of the filters filters_to_run</span>
<span class="sd">        a. Send the limb, graph to the filter to run</span>
<span class="sd">        b. </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#     if branch_idx == 13:</span>
<span class="c1">#         verbose = True</span>

    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    <span class="k">if</span> <span class="n">skip_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">skip_distance_low_d_match_global</span>
    <span class="k">if</span> <span class="n">min_upstream_skeletal_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="n">min_upstream_skeletal_distance_low_d_match_global</span>
    <span class="k">if</span> <span class="n">min_degree_to_resolve</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="n">min_degree_to_resolve_low_d_match_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve_wide</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_wide_low_d_match_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve_absolute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_absolute_low_d_match_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_low_d_match_global</span>
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_low_d_match_global</span>
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max_low_d_match_global</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_low_d_match_global</span>
    <span class="k">if</span> <span class="n">comparison_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_low_d_match_global</span>
    <span class="k">if</span> <span class="n">worst_case_sk_angle_match_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">worst_case_sk_angle_match_threshold</span> <span class="o">=</span> <span class="n">worst_case_sk_angle_match_threshold_low_d_match_global</span>
    <span class="k">if</span> <span class="n">width_diff_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_max</span> <span class="o">=</span> <span class="n">width_diff_max_low_d_match_global</span>
    <span class="k">if</span> <span class="n">width_diff_perc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="n">width_diff_perc_low_d_match_global</span>
    <span class="k">if</span> <span class="n">perform_synapse_filter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">perform_synapse_filter</span> <span class="o">=</span> <span class="n">perform_synapse_filter_low_d_match_global</span>
    <span class="k">if</span> <span class="n">synapse_density_diff_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">synapse_density_diff_threshold</span> <span class="o">=</span> <span class="n">synapse_density_diff_threshold_low_d_match_global</span>
    <span class="k">if</span> <span class="n">n_synapses_diff_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_synapses_diff_threshold</span> <span class="o">=</span> <span class="n">n_synapses_diff_threshold_low_d_match_global</span>

    <span class="k">if</span> <span class="n">remove_short_thick_endnodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">short_thick_endnodes_to_remove</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">short_thick_branches_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            
    
    <span class="k">if</span> <span class="n">short_thick_endnodes_to_remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="n">short_thick_endnodes_to_remove</span>
    <span class="k">if</span> <span class="n">axon_spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="n">axon_spines</span>
        
    <span class="c1"># ---------- Phase A: Figure out if branch needs to be processed at all (and if so compute the downstream branches ---</span>
    <span class="p">(</span><span class="n">return_value</span><span class="p">,</span>
    <span class="n">downstream_branches</span><span class="p">,</span>
    <span class="n">skip_distance</span><span class="p">,</span>
    <span class="n">skipped_nodes</span><span class="p">)</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">high_low_degree_upstream_match_preprocessing</span><span class="p">(</span>
                        <span class="n">limb_obj</span><span class="p">,</span>
                        <span class="n">branch_idx</span><span class="p">,</span>

                        <span class="c1">#arguments for determining downstream nodes</span>
                        <span class="n">skip_distance</span> <span class="o">=</span> <span class="n">skip_distance</span><span class="p">,</span>
                        <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="n">min_upstream_skeletal_distance</span><span class="p">,</span>
                        <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span><span class="p">,</span>
                        <span class="n">axon_spines</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="p">,</span>
                        <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="n">min_degree_to_resolve</span><span class="p">,</span>

                        <span class="c1"># helps determine the max degrees to resolve</span>
                        <span class="n">width_func</span> <span class="o">=</span> <span class="n">width_func</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_absolute</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="n">max_degree_to_resolve</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">max_degree_to_resolve_width_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

                        <span class="c1"># parameter checking to see if high degree resolve can be used</span>
                        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">,</span>
                        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max</span><span class="p">,</span>
                        <span class="n">axon_dependent</span> <span class="o">=</span> <span class="n">axon_dependent</span><span class="p">,</span> 

                        <span class="c1">#arguments for what to return</span>
                        <span class="n">return_skip_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        
                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                        <span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">return_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running local filtering for branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">branch_idx</span>
    <span class="n">G_e_2</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">compute_edge_attributes_locally_upstream_downstream</span><span class="p">(</span>
                <span class="n">limb_obj</span><span class="p">,</span>
                <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="p">,</span>
                <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                <span class="n">plot_extracted_skeletons</span><span class="o">=</span><span class="n">plot_extracted_skeletons</span><span class="p">,</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_G_local_edge</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- After Edge Attributes ---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">edge_df</span><span class="p">(</span><span class="n">G_e_2</span><span class="p">,</span><span class="n">with_node_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        
    <span class="n">G</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">compute_node_attributes_upstream_downstream</span><span class="p">(</span>
                            <span class="n">G</span><span class="o">=</span><span class="n">G_e_2</span><span class="p">,</span>
                            <span class="n">limb_obj</span><span class="o">=</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">upstream_branch</span><span class="o">=</span><span class="n">upstream_branch</span><span class="p">,</span>
                            <span class="n">downstream_branches</span><span class="o">=</span><span class="n">downstream_branches</span><span class="p">,</span>
                           <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_G_local_edge</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- After node attributes ---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    
    
    <span class="c1">#return G</span>
    
    <span class="k">if</span> <span class="n">filters_to_run</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filters_to_run</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">default_low_degree_graph_filters</span>
        
    <span class="c1"># ------- Part that will now run the filters -------#</span>
    <span class="n">error_branches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#verbose = True</span>
    <span class="n">filter_triggered</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">filt_func</span> <span class="ow">in</span> <span class="n">filters_to_run</span><span class="p">:</span>
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">filt_func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                  <span class="n">limb_obj</span><span class="p">,</span>
                                  <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span>
                                  <span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">filter_triggered</span> <span class="o">=</span> <span class="n">filt_func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_triggered = </span><span class="si">{</span><span class="n">filter_triggered</span><span class="si">}</span><span class="s2">, error_branches = </span><span class="si">{</span><span class="n">error_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">break</span>
    
<span class="c1">#     if branch_idx = 30:</span>
<span class="c1">#         raise Exception(&quot;&quot;)</span>
    <span class="k">if</span> <span class="n">short_thick_endnodes_to_remove</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>    
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">error_branches</span><span class="p">,</span><span class="n">short_thick_endnodes_to_remove</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">axon_spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">error_branches</span><span class="p">,</span><span class="n">axon_spines</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">error_branches</span><span class="p">,</span><span class="n">filter_triggered</span></div>
    
    
    

<div class="viewcode-block" id="low_degree_branch_errors_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.low_degree_branch_errors_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">low_degree_branch_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                               <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="s2">&quot;axon&quot;</span><span class="p">,</span>
                                               <span class="c1"># parameters to add as more filters for the branches to check</span>
                                               <span class="n">skip_distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                               <span class="n">plot_limb_branch_pre_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">plot_limb_branch_post_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">plot_limb_branch_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">low_degree_order_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                               <span class="n">filter_axon_spines</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                              <span class="n">filters_to_run</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                               <span class="n">debug_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To resolve low degree nodes for a neuron </span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) get the limb branch dict to start over</span>
<span class="sd">    2) Find all of the high degree coordinates on the axon limb</span>

<span class="sd">    For each high degree coordinate</span>
<span class="sd">    a. Send the coordinate to the high_degree_upstream_match</span>
<span class="sd">    b. Get the error limbs back and if non empty then add to the limb branch dict</span>

<span class="sd">    return the limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import error_detection as ed</span>
<span class="sd">    ed.low_degree_branch_errors_limb_branch_dict(filt_neuron,</span>
<span class="sd">                                                 verbose = True,</span>
<span class="sd">                                                low_degree_order_verbose=True,</span>
<span class="sd">                                                filters_to_run = [gf.axon_double_back_filter],</span>
<span class="sd">                                                plot_G_local_edge = True)</span>
<span class="sd">                                                </span>
<span class="sd">    Ex on how to debug a certain filter on a certain branch:</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#     high_degree_order_verbose = True</span>
    <span class="k">if</span> <span class="n">min_upstream_skeletal_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="n">min_upstream_skeletal_distance_global</span>
    
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>
    <span class="k">elif</span> <span class="n">limb_branch_dict</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
    
    <span class="k">if</span> <span class="n">plot_limb_branch_pre_filter</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The initial limb branch dict before the skip distance and skeletal length &quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">filter_axon_spines</span><span class="p">:</span>
        <span class="n">axon_spines_limb_branch_dict</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_spines_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axon_spines_limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">short_thick_endnodes_to_remove_limb_branch</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">short_thick_branches_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="n">limb_branch_dict_errors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ----- Working on limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">-------&quot;</span><span class="p">)</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
<span class="c1">#         short_thick_endnodes_to_remove = au.short_thick_branches_from_limb(limb_obj,</span>
<span class="c1">#                                      verbose = False)</span>

        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">short_thick_endnodes_to_remove_limb_branch</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1">#short_thick_endnodes_to_remove = short_thick_endnodes_to_remove_limb_branch[limb_name]</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="n">short_thick_endnodes_to_remove_limb_branch</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span> <span class="o">=</span> <span class="p">[]</span>

        
        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">axon_spines_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="n">axon_spines_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">error_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug_branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">debug_branches</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_starting_branches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_G_local_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_G_global_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_G_node_edge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_final_branch_matches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                
                <span class="n">low_degree_order_verbose</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ----- Working on branch </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">--------&quot;</span><span class="p">)</span>
            <span class="n">error_downstream</span><span class="p">,</span><span class="n">triggered_filter</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">low_degree_upstream_match</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                                <span class="n">branch_idx</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
                                                                                <span class="n">skip_distance</span><span class="o">=</span><span class="n">skip_distance</span><span class="p">,</span>
                                <span class="n">short_thick_endnodes_to_remove</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">short_thick_endnodes</span><span class="p">,</span>
                                                                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">low_degree_order_verbose</span><span class="p">,</span>
                                                                                <span class="n">axon_spines</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">axon_spines</span><span class="p">,</span>
                                                                                <span class="n">min_upstream_skeletal_distance</span><span class="o">=</span><span class="n">min_upstream_skeletal_distance</span><span class="p">,</span>
                                                                              <span class="n">filters_to_run</span><span class="o">=</span><span class="n">filters_to_run</span><span class="p">,</span>
                                                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1">#if verbose:</span>
            <span class="k">if</span> <span class="n">triggered_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2"> triggered </span><span class="si">{</span><span class="n">triggered_filter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#winning_downstream,error_downstream = [],[]</span>
        
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_downstream = </span><span class="si">{</span><span class="n">error_downstream</span><span class="si">}</span><span class="s2">,triggered_filter = </span><span class="si">{</span><span class="n">triggered_filter</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_downstream</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">error_branches</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">error_downstream</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_errors</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error_branches</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">plot_limb_branch_errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After low degree branch filter errors: limb_branch_dict_errors = </span><span class="si">{</span><span class="n">limb_branch_dict_errors</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict_errors</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_branch_dict_errors</span></div>
    

<div class="viewcode-block" id="double_back_threshold_axon_by_width"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.double_back_threshold_axon_by_width">[docs]</a><span class="k">def</span> <span class="nf">double_back_threshold_axon_by_width</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">branch_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">axon_thin_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">double_back_threshold_thin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">double_back_threshold_thick</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will compute the dobule back threshold to use </span>
<span class="sd">    based on the upstream width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">double_back_threshold_thick</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">double_back_threshold_thick</span> <span class="o">=</span> <span class="n">double_back_threshold_axon_thick</span>
    <span class="k">if</span> <span class="n">double_back_threshold_thin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">double_back_threshold_thin</span> <span class="o">=</span> <span class="n">double_back_threshold_axon_thin</span>
    <span class="k">if</span> <span class="n">axon_thin_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_thin_width_max</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_thick_threshold</span>
    
    <span class="k">if</span> <span class="n">limb_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">branch_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;</span> <span class="n">axon_thin_width_max</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">double_back_threshold_axon_thin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">double_back_threshold_axon_thick</span>
    <span class="k">return</span> <span class="n">thresh</span></div>


<div class="viewcode-block" id="upstream_node_from_G"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.upstream_node_from_G">[docs]</a><span class="k">def</span> <span class="nf">upstream_node_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">upstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                  <span class="nb">dict</span><span class="p">(</span><span class="n">node_type</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upstream_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not 1 upstream node: </span><span class="si">{</span><span class="n">upstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">upstream_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="downstream_nodes_from_G"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.downstream_nodes_from_G">[docs]</a><span class="k">def</span> <span class="nf">downstream_nodes_from_G</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                  <span class="nb">dict</span><span class="p">(</span><span class="n">node_type</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">downstream_nodes</span></div>


<div class="viewcode-block" id="debug_branches_low_degree"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.debug_branches_low_degree">[docs]</a><span class="k">def</span> <span class="nf">debug_branches_low_degree</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">debug_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">filters_to_run</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ed.debug_branches_low_degree(neuron_obj,debug_branches=[68])</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ed</span><span class="o">.</span><span class="n">low_degree_branch_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">filters_to_run</span> <span class="o">=</span> <span class="n">filters_to_run</span><span class="p">,</span>
                                         <span class="n">debug_branches</span><span class="o">=</span><span class="n">debug_branches</span>
                                            <span class="p">)</span></div>

<div class="viewcode-block" id="debug_branches_high_degree"><a class="viewcode-back" href="../../neurd.html#neurd.error_detection.debug_branches_high_degree">[docs]</a><span class="k">def</span> <span class="nf">debug_branches_high_degree</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">debug_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ed</span><span class="o">.</span><span class="n">high_degree_branch_errors_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">debug_branches</span><span class="o">=</span><span class="n">debug_branches</span>
                                            <span class="p">)</span></div>



<span class="c1"># ------------- parameters for stats ---------------</span>

<span class="n">global_parameters_dict_default_auto_proof</span> <span class="o">=</span> <span class="n">dsu</span><span class="o">.</span><span class="n">DictType</span><span class="p">(</span>

    <span class="n">double_back_threshold_axon_thick_inh</span> <span class="o">=</span> <span class="mi">135</span><span class="p">,</span>
    <span class="n">double_back_threshold_axon_thin_inh</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>
    
    <span class="n">min_upstream_skeletal_distance</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="n">min_distance_from_soma_for_proof</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    
    <span class="c1"># ---- high_low_degree_upstream_match_preprocessing ----</span>
    <span class="n">min_degree_to_resolve</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    
    <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_width_threshold</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    
    <span class="n">width_min</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="mi">170</span><span class="p">,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;int unsigned&quot;</span><span class="p">),</span>
    <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
    
    <span class="c1"># **** filter 2 *****</span>
    <span class="c1"># -----high_degree_upstream_match ----</span>
    <span class="n">skip_distance_poly_x</span> <span class="o">=</span> <span class="p">((</span><span class="mi">80</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span><span class="s2">&quot;blob&quot;</span><span class="p">),</span>
    <span class="n">skip_distance_poly_y</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1500</span><span class="p">,</span><span class="mi">2000</span><span class="p">),</span><span class="s2">&quot;blob&quot;</span><span class="p">),</span>
    
    <span class="c1"># --- Phase B.1: parameters for local edge attributes ------</span>
    <span class="n">offset_high_d_match</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="c1">#1500,</span>
    <span class="n">comparison_distance_high_d_match</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    
    
    <span class="c1"># --- Phase B.2: parameters for local edge query ------</span>
    <span class="n">worst_case_sk_angle_match_threshold_high_d_match</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
    
    <span class="n">width_diff_max_high_d_match</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span><span class="c1">#np.inf,100,</span>
    <span class="n">width_diff_perc_high_d_match</span> <span class="o">=</span> <span class="mf">0.60</span><span class="p">,</span>
    
    <span class="n">perform_synapse_filter_high_d_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">synapse_density_diff_threshold_high_d_match</span> <span class="o">=</span> <span class="mf">0.00015</span><span class="p">,</span> <span class="c1">#was 0.00021</span>
    <span class="n">n_synapses_diff_threshold_high_d_match</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    
    <span class="c1"># ----- Phase B.3: parameters for global attributes ---</span>
    <span class="c1">#args for definite pairs</span>
    <span class="n">sk_angle_match_threshold_high_d_match</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
    <span class="n">sk_angle_buffer_high_d_match</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
    
    <span class="n">width_diff_perc_threshold_high_d_match</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span>
    <span class="n">width_diff_perc_buffer_high_d_match</span> <span class="o">=</span> <span class="mf">0.30</span><span class="p">,</span>
    
    <span class="c1"># ---- Phase C: Optional Kiss filter ----</span>
    <span class="n">kiss_check_high_d_match</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">kiss_check_bbox_longest_side_threshold_high_d_match</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>

    <span class="c1"># ---- Phase D: Picking the final winner -----</span>
    <span class="n">match_method_high_d_match</span> <span class="o">=</span> <span class="s2">&quot;all_error_if_not_one_match&quot;</span><span class="p">,</span><span class="c1"># &quot;best_match&quot;, #other option is &quot;best_match&quot;</span>
    <span class="n">use_exclusive_partner_high_d_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="c1"># -- filtering out false positives --</span>
    <span class="n">use_high_degree_false_positive_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">width_min_high_degree_false_positive</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
    <span class="n">sibling_skeletal_angle_max_high_degree_false_positive</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
    
    
    
    <span class="c1"># **** filter 3 *****</span>
    <span class="c1"># -----low_degree_upstream_match ----\</span>
    <span class="n">skip_distance_low_d_match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="c1">#3000,</span>
    <span class="n">min_upstream_skeletal_distance_low_d_match</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    
    <span class="n">min_degree_to_resolve_low_d_match</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_wide_low_d_match</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    
    <span class="c1"># helps determine the max degrees to resolve</span>
    <span class="n">max_degree_to_resolve_absolute_low_d_match</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_low_d_match</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    
    <span class="n">width_max_low_d_match</span> <span class="o">=</span> <span class="mi">170</span><span class="p">,</span>
    <span class="n">upstream_width_max_low_d_match</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;int unsigned&quot;</span><span class="p">),</span>
    
    <span class="n">offset_low_d_match</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span><span class="c1">#1500,</span>
    <span class="n">comparison_distance_low_d_match</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    
    <span class="c1"># --- Phase B.2: parameters for local edge query ------</span>
    
    <span class="n">worst_case_sk_angle_match_threshold_low_d_match</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
    
    <span class="n">width_diff_max_low_d_match</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span><span class="c1">#np.inf,100,</span>
    <span class="n">width_diff_perc_low_d_match</span> <span class="o">=</span> <span class="mf">0.60</span><span class="p">,</span>
    
    <span class="n">perform_synapse_filter_low_d_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">synapse_density_diff_threshold_low_d_match</span> <span class="o">=</span> <span class="mf">0.00015</span><span class="p">,</span> <span class="c1">#was 0.00021</span>
    <span class="n">n_synapses_diff_threshold_low_d_match</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    
    
    <span class="c1">#---*** width restriction --**    </span>
    <span class="n">width_max_dendr_restr</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="n">width_max_dendr_double_back_restr</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length_min_dendr_restr</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    
    <span class="c1"># **** filter 4 ***** #</span>
    <span class="c1">#--- width_jump_dendrite ---</span>
    <span class="n">upstream_skeletal_length_min_width_j_dendr</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">branch_skeletal_length_min_width_j_dendr</span> <span class="o">=</span> <span class="mi">7000</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length_min_for_min_width_j_dendr</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
    <span class="n">width_jump_max_width_j_dendr</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    
    <span class="c1"># **** filter 5 ***** #</span>
    <span class="c1">#--- width_jump_axon ---</span>
    <span class="n">upstream_skeletal_length_min_width_j_axon</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">branch_skeletal_length_min_width_j_axon</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length_min_for_min_width_j_axon</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
    <span class="n">width_jump_max_width_j_axon</span> <span class="o">=</span> <span class="mi">55</span><span class="p">,</span>
    <span class="n">axon_width_threshold_max_width_j_axon</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    
    <span class="c1"># **** filter 6 ***** #</span>
    <span class="c1"># ---- dendrite double back -----</span>
    <span class="n">double_back_threshold_double_b_dendrite</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
    <span class="n">comparison_distance_double_b_dendrite</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
    <span class="n">offset_double_b_dendrite</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">branch_skeletal_length_min_double_b_dendrite</span> <span class="o">=</span> <span class="mi">7000</span><span class="p">,</span> <span class="c1">#deciding which branches will be skipped because of length</span>
    
    
    
    
<span class="p">)</span>

<span class="n">global_parameters_dict_default_high_degree_dendr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">skip_distance_high_degree_dendr</span> <span class="o">=</span> <span class="mi">1_200</span><span class="p">,</span>
    <span class="c1">#min_upstream_skeletal_distance_high_degree_dendr = 10_000,</span>
    <span class="n">width_max_high_degree_dendr</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span><span class="c1">#550,</span>
    <span class="n">upstream_width_max_high_degree_dendr</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span><span class="c1">#550,</span>
    <span class="n">offset_high_degree_dendr</span> <span class="o">=</span> <span class="mi">1_500</span><span class="p">,</span>
    <span class="n">comparison_distance_high_degree_dendr</span> <span class="o">=</span> <span class="mi">3_000</span><span class="p">,</span>
    <span class="n">width_diff_max_high_degree_dendr</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
    <span class="n">perform_synapse_filter_high_degree_dendr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">width_diff_perc_threshold_high_d_match_dendr</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span>
    <span class="n">width_diff_perc_buffer_high_d_match_dendr</span> <span class="o">=</span> <span class="mf">0.20</span><span class="p">,</span>
    
    <span class="n">use_high_degree_false_positive_filter_dendr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1">#---- parameters for limb branch restriction -------</span>
    <span class="n">min_skeletal_length_endpoints_high_degree_dendr</span> <span class="o">=</span> <span class="mi">8_000</span><span class="p">,</span><span class="c1">#4_000,</span>
    <span class="n">min_distance_from_soma_mesh_high_degree_dendr</span> <span class="o">=</span> <span class="mi">7_000</span><span class="p">,</span>
    
    
 <span class="p">)</span>


<span class="n">global_parameters_dict_default_crossover</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># ---- resolve crossover parameters ----</span>
    <span class="n">apply_width_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">best_match_width_diff_max</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
    <span class="n">best_match_width_diff_max_perc</span> <span class="o">=</span> <span class="mf">0.60</span><span class="p">,</span>
    <span class="n">best_match_width_diff_min</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
    <span class="n">no_non_cut_disconnected_comps</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">best_singular_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">lowest_angle_sum_for_pairs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_default_auto_proof</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_crossover</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_high_degree_dendr</span><span class="p">,</span>
    
<span class="p">])</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">double_back_threshold_axon_thick</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
    <span class="n">double_back_threshold_axon_thin</span> <span class="o">=</span> <span class="mi">127</span><span class="p">,</span>
<span class="p">)</span>    

<span class="c1"># ------- microns -----------</span>
<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># ====== h01 -----------</span>
<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="n">global_parameters_dict_h01_auto_proof</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">skip_distance_poly_x</span> <span class="o">=</span> <span class="p">((</span><span class="mi">80</span><span class="p">,</span><span class="mi">400</span><span class="p">),</span><span class="s2">&quot;blob&quot;</span><span class="p">),</span>
    <span class="n">skip_distance_poly_y</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1500</span><span class="p">,</span><span class="mi">1700</span><span class="p">),</span><span class="s2">&quot;blob&quot;</span><span class="p">),</span>
    
    <span class="c1">#high degree match </span>
    <span class="n">use_high_degree_false_positive_filter</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">width_min_high_degree_false_positive</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
    <span class="n">sibling_skeletal_angle_max_high_degree_false_positive</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
    
    
    
    <span class="c1">#low degree match</span>
    <span class="n">width_max_low_d_match</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
    
    
    <span class="n">width_jump_axon</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    
    <span class="c1">#doubling back angle</span>
    <span class="n">double_back_threshold_double_b_dendrite</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    
    <span class="c1">#---*** width restriction --**    </span>
    <span class="n">width_max_dendr_restr</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span>
    <span class="n">width_max_dendr_double_back_restr</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">upstream_skeletal_length_min_dendr_restr</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01_high_degree_dendr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">skip_distance_high_degree_dendr</span> <span class="o">=</span> <span class="mi">3_000</span><span class="p">,</span><span class="c1">#1_500,</span>
    <span class="n">width_max_high_degree_dendr</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span><span class="c1">#550,</span>
    <span class="n">upstream_width_max_high_degree_dendr</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span><span class="c1">#550,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_h01_auto_proof</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_high_degree_dendr</span>
    
<span class="p">])</span>



<span class="n">global_parameters_dict_h01_split</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>
<span class="c1"># modules_to_set = [ed,(au,&quot;auto_proof&quot;),gf]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="c1"># if skip_distance_poly is None:</span>
<span class="c1">#     skip_distance_poly = calculate_skip_distance_poly()</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">branch_utils</span> <span class="k">as</span> <span class="n">bu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">graph_filters</span> <span class="k">as</span> <span class="n">gf</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">data_struct_utils</span> <span class="k">as</span> <span class="n">dsu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">error_detection</span> <span class="k">as</span> <span class="n">ed</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
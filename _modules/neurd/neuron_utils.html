<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.neuron_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.neuron_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.neuron_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>



<span class="sd">Purpose of this file: To help the development of the neuron object</span>
<span class="sd">1) Concept graph methods</span>
<span class="sd">2) Preprocessing pipeline for creating the neuron object from a meshs</span>




<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">reload</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span> 
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">trimesh.ray</span> <span class="kn">import</span> <span class="n">ray_pyembree</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>

<span class="n">soma_face_offset</span> <span class="o">=</span> <span class="mi">2</span>


<span class="c1">#importing at the bottom so don&#39;t get any conflicts</span>

<span class="c1">#for meshparty preprocessing</span>

<span class="c1"># tools for restricting </span>

<span class="c1"># -------------- 7/22 Help Filter Bad Branches ------------------ #</span>
<div class="viewcode-block" id="classify_error_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.classify_error_branch">[docs]</a><span class="k">def</span> <span class="nf">classify_error_branch</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">width_to_face_ratio</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">curr_width</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">width</span>
    <span class="n">curr_face_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">curr_width</span><span class="o">/</span><span class="n">curr_face_count</span> <span class="o">&gt;</span> <span class="n">width_to_face_ratio</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="classify_endpoint_error_branches_from_limb_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.classify_endpoint_error_branches_from_limb_concept_network">[docs]</a><span class="k">def</span> <span class="nf">classify_endpoint_error_branches_from_limb_concept_network</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To identify all endpoints of concept graph where the branch meshes/skeleton</span>
<span class="sd">    are likely a result of bad skeletonization or meshing:</span>
<span class="sd">    </span>
<span class="sd">    Applications: Can get rid of these branches later</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the endpoints of the concept network</span>
<span class="sd">    2) Get all of the branch objects for the endpoints</span>
<span class="sd">    3) Return the idx&#39;s of the branch objects that test positive for being an error branch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#1) Get all of the endpoints of the concept network</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1">#2) Get all of the branch objects for the endpoints</span>
    <span class="n">end_node_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">]</span>
    
    <span class="c1">#3) Return the idx&#39;s of the branch objects that test positive for being an error branch</span>
    <span class="n">total_error_end_node_branches</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">en_idx</span><span class="p">,</span><span class="n">e_branch</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">,</span><span class="n">end_node_branches</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">classify_error_branch</span><span class="p">(</span><span class="n">e_branch</span><span class="p">):</span>
            <span class="n">total_error_end_node_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">en_idx</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">total_error_end_node_branches</span></div>
    

<span class="c1"># -------------- tools for the concept networks ------------------ #</span>


<div class="viewcode-block" id="whole_neuron_branch_concept_network_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.whole_neuron_branch_concept_network_old">[docs]</a><span class="k">def</span> <span class="nf">whole_neuron_branch_concept_network_old</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">,</span>
                                  <span class="n">directional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">limb_soma_touch_dictionary</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the entire concept network with all of the limbs and </span>
<span class="sd">    somas connected of an entire neuron</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">    input_neuron: neuron object</span>
<span class="sd">    directional: If want a directional or undirectional concept_network returned</span>
<span class="sd">    limb_soma_touch_dictionary: a dictionary mapping the limb to the starting soma</span>
<span class="sd">    you want it to start if directional option is set</span>
<span class="sd">    Ex:  {&quot;L1&quot;:[0,1]})</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:  </span>
<span class="sd">    1) Get the soma subnetwork from the concept network of the neuron</span>
<span class="sd">    2) For each limb network:</span>
<span class="sd">    - if directional: </span>
<span class="sd">    a) if no specific starting soma picked --&gt; use the soma with the smallest index as starting one</span>
<span class="sd">    - if undirectional</span>
<span class="sd">    a2) if undirectional then just choose the concept network</span>
<span class="sd">    b) Rename all of the nodes to L#_#</span>
<span class="sd">    c) Add the network to the soma/total network and add an edge from the soma to the starting node</span>
<span class="sd">    (do so for all)</span>

<span class="sd">    3) Then take a subgraph of the concept network based on the nodes you want</span>
<span class="sd">    4) Send the subgraph to a function that graphs the networkx graph</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    

    <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">limb_soma_touch_dictionary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_soma_touch_dictionary</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_soma_touch_dictionary</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">limb_soma_touch_dictionary</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">limb_soma_touch_dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">int_label</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span> <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved invalid input for  limb_soma_touch_dictionary: </span><span class="si">{</span><span class="n">limb_soma_touch_dictionary</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">total_network</span><span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()))</span>

    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on Limb: </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_soma_touch_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">touching_soma</span> <span class="o">=</span> <span class="n">limb_soma_touch_dictionary</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">touching_soma</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        <span class="n">curr_network</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directional</span><span class="p">:</span>
            <span class="n">curr_network</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_soma</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                For all somas specified: get the network</span>
<span class="sd">                1) if this is first one then just copy the network</span>
<span class="sd">                2) if not then get the edges and add to existing network</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">starting_soma</span> <span class="ow">in</span> <span class="n">touching_soma</span><span class="p">:</span>
                    <span class="c1"># now need to iterate through all touching groups</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---Working on soma: </span><span class="si">{</span><span class="n">starting_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="p">,</span><span class="n">soma_group_idx</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">soma_specific_network</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>
                    
                    <span class="c1">#Just making sure that curr_network already exists to add things to</span>
                    <span class="k">if</span> <span class="n">curr_network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">soma_specific_network</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># ---------- Will go through and set the edges and the network data ---------- #</span>
                        
                        <span class="c1">#get the edges</span>
                        <span class="n">curr_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">soma_specific_network</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

                        <span class="c1">#get the specific starting node for that network and add it to the current one</span>
                        <span class="c1">#print(f&quot;For limb_idx {limb_idx}, curr_limb_obj.all_concept_network_data = {curr_limb_obj.all_concept_network_data}&quot;)</span>
                        <span class="n">matching_concept_network_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="k">if</span> 
                                                         <span class="p">((</span><span class="n">soma_label</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">starting_soma</span><span class="p">)</span> <span class="ow">or</span> <span class="p">([</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">starting_soma</span><span class="p">))]</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_concept_network_data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The concept_network data for the starting soma (</span><span class="si">{</span><span class="n">starting_soma</span><span class="si">}</span><span class="s2">) did not have exactly one match: </span><span class="si">{</span><span class="n">matching_concept_network_data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="n">matching_concept_network_dict</span> <span class="o">=</span> <span class="n">matching_concept_network_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">curr_starting_node</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
                        <span class="n">curr_starting_coordinate</span><span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>

                        <span class="c1">#set the starting coordinate in the concept network</span>
                        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_starting_node</span><span class="p">:{</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">:</span><span class="n">curr_starting_coordinate</span><span class="p">}}</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;attrs = </span><span class="si">{</span><span class="n">attrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="n">attrs</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_network</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>

        <span class="c1">#At this point should have the desired concept network</span>

        <span class="c1">#print(curr_network.nodes())</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span>
        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="n">mapping</span><span class="p">)</span>
        <span class="c1">#print(curr_network.nodes())</span>
<span class="c1">#         if print_flag:</span>
<span class="c1">#             print(f&#39;current network edges = {curr_network[&quot;L0_17&quot;],curr_network[&quot;L0_20&quot;]}&#39;)</span>


        <span class="c1">#need to get all connections from soma to limb:</span>
        <span class="n">soma_to_limb_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">soma_connecting_dict</span> <span class="ow">in</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">soma_to_limb_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">soma_label</span><span class="p">(</span><span class="n">soma_connecting_dict</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]),</span>
                                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">soma_connecting_dict</span><span class="p">[</span><span class="s1">&#39;starting_node&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="n">total_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">total_network</span><span class="p">,</span><span class="n">curr_network</span><span class="p">)</span>
        <span class="n">total_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">soma_to_limb_edges</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;current network edges = </span><span class="si">{</span><span class="n">total_network</span><span class="p">[</span><span class="s2">&quot;L0_17&quot;</span><span class="p">],</span><span class="n">total_network</span><span class="p">[</span><span class="s2">&quot;L0_20&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">directional</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">total_network</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">total_network</span></div>


<div class="viewcode-block" id="whole_neuron_branch_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.whole_neuron_branch_concept_network">[docs]</a><span class="k">def</span> <span class="nf">whole_neuron_branch_concept_network</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">,</span>
                                    <span class="n">directional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">limb_soma_touch_dictionary</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
                                <span class="n">with_data_in_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the entire concept network with all of the limbs and </span>
<span class="sd">    somas connected of an entire neuron</span>

<span class="sd">    Arguments:</span>
<span class="sd">    input_neuron: neuron object</span>
<span class="sd">    directional: If want a directional or undirectional concept_network returned</span>
<span class="sd">    limb_soma_touch_dictionary: a dictionary mapping the limb to the starting soma and soma_idx</span>
<span class="sd">    you want visualize if directional is chosen</span>

<span class="sd">    This will visualize multiple somas and multiple soma touching groups</span>
<span class="sd">    Ex:  {1:[{0:[0,1],1:[0]}]})</span>


<span class="sd">    Pseudocode:  </span>
<span class="sd">    1) Get the soma subnetwork from the concept network of the neuron</span>
<span class="sd">    2) For each limb network:</span>
<span class="sd">    - if directional: </span>
<span class="sd">    a) if no specific starting soma picked --&gt; use the soma with the smallest index as starting one</span>
<span class="sd">    - if undirectional</span>
<span class="sd">    a2) if undirectional then just choose the concept network</span>
<span class="sd">    b) Rename all of the nodes to L#_#</span>
<span class="sd">    c) Add the network to the soma/total network and add an edge from the soma to the starting node</span>
<span class="sd">    (do so for all)</span>

<span class="sd">    3) Then take a subgraph of the concept network based on the nodes you want</span>
<span class="sd">    4) Send the subgraph to a function that graphs the networkx graph</span>


<span class="sd">        &quot;&quot;&quot;</span>



    <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">limb_soma_touch_dictionary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_soma_touch_dictionary</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_soma_touch_dictionary</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1">#make sure that the limb labels are numbers</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">limb_soma_touch_dictionary</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        Iterate through all of the limbs</span>
<span class="sd">            Iterate through all of the soma starting info</span>
<span class="sd">                Build the dictionary for all possible touches</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limb_soma_touch_dictionary</span> <span class="o">=</span> <span class="n">limb_to_soma_mapping</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved invalid input for  limb_soma_touch_dictionary: </span><span class="si">{</span><span class="n">limb_soma_touch_dictionary</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">total_network</span><span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()))</span>

    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">soma_info_dict</span> <span class="ow">in</span> <span class="n">limb_soma_touch_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>

        <span class="n">curr_network</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directional</span><span class="p">:</span>
            <span class="n">curr_network</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">starting_soma</span><span class="p">,</span><span class="n">soma_group_info</span> <span class="ow">in</span> <span class="n">soma_info_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                For all somas specified: get the network</span>
<span class="sd">                1) if this is first one then just copy the network</span>
<span class="sd">                2) if not then get the edges and add to existing network</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">soma_group_idx</span> <span class="ow">in</span> <span class="n">soma_group_info</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---Working on soma: </span><span class="si">{</span><span class="n">starting_soma</span><span class="si">}</span><span class="s2">, group = </span><span class="si">{</span><span class="n">soma_group_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="p">,</span><span class="n">soma_group_idx</span><span class="o">=</span><span class="n">soma_group_idx</span><span class="p">)</span>
                    <span class="n">soma_specific_network</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span>

                    <span class="c1">#Just making sure that curr_network already exists to add things to</span>
                    <span class="k">if</span> <span class="n">curr_network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">soma_specific_network</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># ---------- Will go through and set the edges and the network data ---------- #</span>

                        <span class="c1">#get the edges</span>
                        <span class="n">curr_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">soma_specific_network</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

                        <span class="n">matching_concept_network_dict</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_concept_network_data_by_soma_and_idx</span><span class="p">(</span><span class="n">starting_soma</span><span class="p">,</span>
                                                                                                           <span class="n">soma_group_idx</span><span class="p">)</span>


                        <span class="n">curr_starting_node</span> <span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
                        <span class="n">curr_starting_coordinate</span><span class="o">=</span> <span class="n">matching_concept_network_dict</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>

                        <span class="c1">#set the starting coordinate in the concept network</span>
                        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_starting_node</span><span class="p">:{</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">:</span><span class="n">curr_starting_coordinate</span><span class="p">}}</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;attrs = </span><span class="si">{</span><span class="n">attrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="n">attrs</span><span class="p">)</span>
                        
                        


        <span class="c1">#At this point should have the desired concept network</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span>
        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="n">mapping</span><span class="p">)</span>

        <span class="c1">#need to get all connections from soma to limb:</span>
        <span class="n">soma_to_limb_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">soma_connecting_dict</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">soma_to_limb_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">soma_label</span><span class="p">(</span><span class="n">soma_connecting_dict</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]),</span>
                                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">soma_connecting_dict</span><span class="p">[</span><span class="s1">&#39;starting_node&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="n">total_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">total_network</span><span class="p">,</span><span class="n">curr_network</span><span class="p">)</span>
        <span class="n">total_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">soma_to_limb_edges</span><span class="p">)</span>

<span class="c1">#         if print_flag:</span>
<span class="c1">#             print(f&#39;current network edges = {total_network[&quot;L0_17&quot;],total_network[&quot;L0_20&quot;]}&#39;)</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">with_data_in_nodes</span><span class="p">:</span>
        <span class="n">total_network</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">copy_G_without_data</span><span class="p">(</span><span class="n">total_network</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">directional</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">total_network</span><span class="p">)</span>
    

        
    <span class="k">return</span> <span class="n">total_network</span></div>



<div class="viewcode-block" id="get_limb_names_from_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_limb_names_from_concept_network">[docs]</a><span class="k">def</span> <span class="nf">get_limb_names_from_concept_network</span><span class="p">(</span><span class="n">concept_network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Function that takes in either a neuron object</span>
<span class="sd">    or the concept network and returns just the concept network</span>
<span class="sd">    depending on the input</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_soma_names_from_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_soma_names_from_concept_network">[docs]</a><span class="k">def</span> <span class="nf">get_soma_names_from_concept_network</span><span class="p">(</span><span class="n">concept_network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Function that takes in either a neuron object</span>
<span class="sd">    or the concept network and returns just the concept network</span>
<span class="sd">    depending on the input</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="return_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.return_concept_network">[docs]</a><span class="k">def</span> <span class="nf">return_concept_network</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Function that takes in either a neuron object</span>
<span class="sd">    or the concept network and returns just the concept network</span>
<span class="sd">    depending on the input</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">current_neuron</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Neuron&quot;</span><span class="p">:</span>
        <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span>
    <span class="c1">#elif type(current_neuron) == type(xu.GraphOrderedEdges()):</span>
    <span class="k">elif</span> <span class="n">current_neuron</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;GraphOrderedEdges&quot;</span><span class="p">:</span>
        <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">current_neuron</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exception_string</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_neuron not a Neuron object or Graph Ordered Edges instance: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">current_neuron</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">current_neuron</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">exception_string</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">curr_concept_network</span></div>
    

<div class="viewcode-block" id="convert_limb_concept_network_to_neuron_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.convert_limb_concept_network_to_neuron_skeleton">[docs]</a><span class="k">def</span> <span class="nf">convert_limb_concept_network_to_neuron_skeleton</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">check_connected_component</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a concept network that has the branch </span>
<span class="sd">    data within it to the skeleton for that limb</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the nodes names of the branches </span>
<span class="sd">    2) Order the node names</span>
<span class="sd">    3) For each node get the skeletons into an array</span>
<span class="sd">    4) Stack the array</span>
<span class="sd">    5) Want to check that skeleton is connected component</span>
<span class="sd">    </span>
<span class="sd">    Example of how to run: </span>
<span class="sd">    full_skeleton = convert_limb_concept_network_to_neuron_skeleton(recovered_neuron.concept_network.nodes[&quot;L1&quot;][&quot;data&quot;].concept_network)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="c1">#print(f&quot;sorted_nodes = {sorted_nodes}&quot;)</span>
    <span class="n">full_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_nodes</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">check_connected_component</span><span class="p">:</span>
        <span class="n">sk</span><span class="o">.</span><span class="n">check_skeleton_one_component</span><span class="p">(</span><span class="n">full_skeleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">full_skeleton</span></div>
    
<div class="viewcode-block" id="get_starting_info_from_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_starting_info_from_concept_network">[docs]</a><span class="k">def</span> <span class="nf">get_starting_info_from_concept_network</span><span class="p">(</span><span class="n">concept_networks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To turn a dictionary that maps the soma indexes to a concept map</span>
<span class="sd">    into just a list of dictionaries with all the staring information</span>
<span class="sd">    </span>
<span class="sd">    Ex input:</span>
<span class="sd">    concept_networks = {0:concept_network, 1:concept_network,}</span>
<span class="sd">    </span>
<span class="sd">    Ex output:</span>
<span class="sd">    [dict(starting_soma=..,starting_node=..</span>
<span class="sd">            starting_endpoints=...,starting_coordinate=...,touching_soma_vertices=...)]</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get the soma it&#39;s connect to</span>
<span class="sd">    2) get the node that has the starting coordinate </span>
<span class="sd">    3) get the endpoints and starting coordinate for that nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">output_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">current_soma</span><span class="p">,</span><span class="n">curr_concept_network_list</span> <span class="ow">in</span> <span class="n">concept_networks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">curr_concept_network</span> <span class="ow">in</span> <span class="n">curr_concept_network_list</span><span class="p">:</span>
            <span class="n">curr_output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="c1"># 1) get the soma it&#39;s connect to</span>
            <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_soma</span>

            <span class="c1"># 2) get the node that has the starting coordinate </span>
            <span class="n">starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span>
            <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starting_node</span>

            <span class="n">endpoints_dict</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;endpoints&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">starting_node</span><span class="p">],</span>
                           <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;starting_endpoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpoints_dict</span><span class="p">[</span><span class="n">starting_node</span><span class="p">]</span>

            <span class="n">starting_node_dict</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">starting_node</span><span class="p">],</span>
                           <span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#get the starting coordinate of the starting dict</span>
            <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">starting_node_dict</span><span class="p">[</span><span class="n">starting_node</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;touching_soma_vertices&quot;</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                
            <span class="c1">#soma starting group</span>
            <span class="k">if</span> <span class="s2">&quot;soma_group_idx&quot;</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                
            

            <span class="n">curr_output_dict</span><span class="p">[</span><span class="s2">&quot;concept_network&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_concept_network</span>
            <span class="n">output_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_output_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">output_dicts</span></div>


<div class="viewcode-block" id="convert_concept_network_to_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.convert_concept_network_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">convert_concept_network_to_skeleton</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">):</span>
    <span class="c1">#get the midpoints</span>
    <span class="n">node_locations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span>
    <span class="n">curr_edges</span> <span class="o">=</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    <span class="n">graph_nodes_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span><span class="n">node_locations</span><span class="p">[</span><span class="n">n2</span><span class="p">])</span> <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">curr_edges</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph_nodes_skeleton</span></div>


<div class="viewcode-block" id="convert_concept_network_to_undirectional"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.convert_concept_network_to_undirectional">[docs]</a><span class="k">def</span> <span class="nf">convert_concept_network_to_undirectional</span><span class="p">(</span><span class="n">concept_network</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">concept_network</span><span class="p">)</span></div>

<div class="viewcode-block" id="convert_concept_network_to_directional"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.convert_concept_network_to_directional">[docs]</a><span class="k">def</span> <span class="nf">convert_concept_network_to_directional</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span>
                                        <span class="n">node_widths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">no_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Create a dictionary with the keys as all the nodes and empty list as values</span>
<span class="sd">    1) Get the starting node</span>
<span class="sd">    2) Find all neighbors of starting node</span>
<span class="sd">    2b) Add the starting node to the list of all the nodes it is neighbors to</span>
<span class="sd">    3) Add starter node to the &quot;procesed_nodes&quot; so it is not processed again</span>
<span class="sd">    4) Add each neighboring node to the &quot;to_be_processed&quot; list</span>

<span class="sd">    5) Start loop that will continue until &quot;to_be_processed&quot; is done</span>
<span class="sd">    a. Get the next node to be processed</span>
<span class="sd">    b. Get all neighbors</span>
<span class="sd">    c. For all nodes who are not currently in the curr_nodes&#39;s list from the lookup dictionary</span>
<span class="sd">    --&gt; add the curr_node to those neighbor nodes lists</span>
<span class="sd">    d. For all nodes not already in the to_be_processed or procesed_nodes, add them to the to_be_processed list</span>
<span class="sd">    ...</span>
<span class="sd">    z. when no more nodes in to_be_processed list then reak</span>

<span class="sd">    6) if the no_cycles option is selected:</span>
<span class="sd">    - for every neruong with multiple neurons in list, choose the one that has the branch width that closest matches</span>

<span class="sd">    7) convert the incoming edges dictionary to edge for a directional graph</span>
<span class="sd">    </span>
<span class="sd">    Example of how to use: </span>
<span class="sd">    </span>
<span class="sd">    example_concept_network = nx.from_edgelist([[1,2],[2,3],[3,4],[4,5],[2,5],[2,6]])</span>
<span class="sd">    nx.draw(example_concept_network,with_labels=True)</span>
<span class="sd">    plt.show()</span>
<span class="sd">    xu.set_node_attributes_dict(example_concept_network,{1:dict(starting_coordinate=np.array([1,2,3]))})</span>

<span class="sd">    directional_ex_concept_network = nru.convert_concept_network_to_directional(example_concept_network,no_cycles=True)</span>
<span class="sd">    nx.draw(directional_ex_concept_network,with_labels=True)</span>
<span class="sd">    plt.show()</span>

<span class="sd">    node_widths = {1:0.5,2:0.61,3:0.73,4:0.88,5:.9,6:0.4}</span>
<span class="sd">    directional_ex_concept_network = nru.convert_concept_network_to_directional(example_concept_network,no_cycles=True,node_widths=node_widths)</span>
<span class="sd">    nx.draw(directional_ex_concept_network,with_labels=True)</span>
<span class="sd">    plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">concept_network</span>
    <span class="n">mesh_widths</span> <span class="o">=</span> <span class="n">node_widths</span>

    <span class="c1">#if only one node in concept_network then return</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Concept graph size was 1 or less so returning original&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span>

    <span class="c1">#0) Create a dictionary with the keys as all the nodes and empty list as values</span>
    <span class="n">incoming_edges_to_node</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span>
    <span class="n">to_be_processed_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">processed_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">+</span> <span class="mi">100</span>

    <span class="c1">#1) Get the starting node </span>
    <span class="n">starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span>

    <span class="c1">#2) Find all neighbors of starting node</span>
    <span class="n">curr_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">starting_node</span><span class="p">)</span>

    <span class="c1">#2b) Add the starting node to the list of all the nodes it is neighbors to</span>
    <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">curr_neighbors</span><span class="p">:</span>
        <span class="n">incoming_edges_to_node</span><span class="p">[</span><span class="n">cn</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_node</span><span class="p">)</span>

    <span class="c1">#3) Add starter node to the &quot;procesed_nodes&quot; so it is not processed again</span>
    <span class="n">processed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_node</span><span class="p">)</span>

    <span class="c1">#4) Add each neighboring node to the &quot;to_be_processed&quot; list</span>
    <span class="n">to_be_processed_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_neighbors</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span> <span class="p">])</span>
    <span class="c1"># print(f&quot;incoming_edges_to_node AT START= {incoming_edges_to_node}&quot;)</span>
    <span class="c1"># print(f&quot;processed_nodes_AT_START = {processed_nodes}&quot;)</span>
    <span class="c1"># print(f&quot;to_be_processed_nodes_AT_START = {to_be_processed_nodes}&quot;)</span>

    <span class="c1">#5) Start loop that will continue until &quot;to_be_processed&quot; is done</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
    <span class="c1">#     print(&quot;\n&quot;)</span>
    <span class="c1">#     print(f&quot;processed_nodes = {processed_nodes}&quot;)</span>
    <span class="c1">#     print(f&quot;to_be_processed_nodes = {to_be_processed_nodes}&quot;)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_processed_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1">#a. Get the next node to be processed</span>
        
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">to_be_processed_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#print(f&quot;curr_node = {curr_node}&quot;)</span>
        <span class="c1">#b. Get all neighbors</span>
        <span class="n">curr_node_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="c1">#print(f&quot;curr_node_neighbors = {curr_node_neighbors}&quot;)</span>
        <span class="c1">#c. For all nodes who are not currently in the curr_nodes&#39;s list from the lookup dictionary</span>
        <span class="c1">#--&gt; add the curr_node to those neighbor nodes lists</span>
        <span class="k">for</span> <span class="n">cn</span> <span class="ow">in</span> <span class="n">curr_node_neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cn</span> <span class="o">==</span> <span class="n">curr_node</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;found a self connection in network graph&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">incoming_edges_to_node</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]:</span>
                <span class="n">incoming_edges_to_node</span><span class="p">[</span><span class="n">cn</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>

            <span class="c1">#d. For all nodes not already in the to_be_processed or procesed_nodes, add them to the to_be_processed list</span>
            <span class="k">if</span> <span class="n">cn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_be_processed_nodes</span> <span class="ow">and</span> <span class="n">cn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
                <span class="n">to_be_processed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span>


        <span class="c1"># add the nodes to those been processed</span>
        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>


        <span class="c1">#z. when no more nodes in to_be_processed list then reak</span>
        

    <span class="c1">#print(f&quot;incoming_edges_to_node = {incoming_edges_to_node}&quot;)</span>
    <span class="c1">#6) if the no_cycles option is selected:</span>
    <span class="c1">#- for every neruong with multiple neurons in list, choose the one that has the branch width that closest matches</span>

    <span class="n">incoming_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">incoming_edges_to_node</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_disconnected_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">incoming_lengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;after loop in directed concept graph, not all nodes have incoming edges (except starter node)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">no_cycles</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;checking and resolving cycles&quot;</span><span class="p">)</span>
        <span class="c1">#get the nodes with multiple incoming edges</span>
        <span class="n">multi_incoming</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">incoming_edges_to_node</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">])</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_incoming</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are loops to resolve and &#39;no_cycles&#39; parameters set requires us to fix eliminate them&quot;</span><span class="p">)</span>
            <span class="c1">#find the mesh widths of all the incoming edges and the current edge</span>

            <span class="c1">#if mesh widths are available then go that route</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh_widths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using mesh_widths for resolving loops&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">curr_node</span><span class="p">,</span><span class="n">incoming_nodes</span> <span class="ow">in</span> <span class="n">multi_incoming</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">curr_node_width</span> <span class="o">=</span> <span class="n">mesh_widths</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
                    <span class="n">incoming_nodes_width_difference</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mesh_widths</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span> <span class="n">curr_node_width</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">incoming_nodes</span><span class="p">]</span>
                    <span class="n">winning_incoming_node</span> <span class="o">=</span> <span class="n">incoming_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">incoming_nodes_width_difference</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)]</span>
                    <span class="n">incoming_edges_to_node</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_incoming_node</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#if not mesh widths available then just pick the longest edge</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Get the coordinates of all of the nodes</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">node_coordinates_dict</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span><span class="n">return_array</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_coordinates_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">incoming_edges_to_node</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The keys of the concept graph with &#39;coordinates&#39; do not match the keys of the edge dictionary&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Just going to use the first incoming edge by default&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">curr_node</span><span class="p">,</span><span class="n">incoming_nodes</span> <span class="ow">in</span> <span class="n">multi_incoming</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">winning_incoming_node</span> <span class="o">=</span> <span class="n">incoming_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">incoming_edges_to_node</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_incoming_node</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#then have coordinate information</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using coordinate distance to pick the winning node&quot;</span><span class="p">)</span>
                    <span class="n">curr_node_coordinate</span> <span class="o">=</span> <span class="n">node_coordinates_dict</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
                    <span class="n">incoming_nodes_distance</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_coordinates_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span> <span class="n">curr_node_coordinate</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">incoming_nodes</span><span class="p">]</span>
                    <span class="n">winning_incoming_node</span> <span class="o">=</span> <span class="n">incoming_nodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">incoming_nodes_distance</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)]</span>
                    <span class="n">incoming_edges_to_node</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_incoming_node</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No cycles to fix&quot;</span><span class="p">)</span>


        <span class="c1">#check that all have length of 1</span>
        <span class="n">multi_incoming</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">incoming_edges_to_node</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">suppress_disconnected_errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_incoming</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inside the no_cycles but at the end all of the nodes only don&#39;t have one incoming cycle&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;multi_incoming = </span><span class="si">{</span><span class="n">multi_incoming</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#7) convert the incoming edges dictionary to edge for a directional graph</span>
    <span class="n">total_edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">no_cycles</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_node</span><span class="p">,</span><span class="n">incoming_nodes</span> <span class="ow">in</span> <span class="n">multi_incoming</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">curr_incoming_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">curr_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">incoming_nodes</span><span class="p">]</span>
            <span class="n">total_edges</span> <span class="o">+=</span> <span class="n">curr_incoming_edges</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_node</span><span class="p">,</span><span class="n">incoming_nodes</span> <span class="ow">in</span> <span class="n">incoming_edges_to_node</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">curr_incoming_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">j</span><span class="p">,</span><span class="n">curr_node</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">incoming_nodes</span><span class="p">]</span>
            <span class="n">total_edges</span> <span class="o">+=</span> <span class="n">curr_incoming_edges</span>


    <span class="c1">#creating the directional network</span>
    <span class="n">curr_limb_concept_network_directional</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">create_empty_copy</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">with_data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">curr_limb_concept_network_directional</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">total_edges</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">curr_limb_concept_network_directional</span></div>


<div class="viewcode-block" id="branches_to_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branches_to_concept_network">[docs]</a><span class="k">def</span> <span class="nf">branches_to_concept_network</span><span class="p">(</span><span class="n">curr_branch_skeletons</span><span class="p">,</span>
                             <span class="n">starting_coordinate</span><span class="p">,</span>
                              <span class="n">starting_edge</span><span class="p">,</span>
                                <span class="n">touching_soma_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">soma_group_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">starting_soma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">max_iterations</span><span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will change a list of branches into </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting_edge inside branches_to_conept = </span><span class="si">{</span><span class="n">starting_edge</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">processed_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edge_endpoints_to_process</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">concept_network_edges</span> <span class="o">=</span> <span class="p">[]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If there is only one branch then just pass back a one-node graph </span>
<span class="sd">    with no edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_skeletons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Passed no branches to be turned into concept network&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_skeletons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">concept_network</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span>
        <span class="n">concept_network</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">starting_node</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1">#print(&quot;setting touching_soma_vertices 1&quot;)</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">starting_node</span><span class="p">:{</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">:</span><span class="n">starting_coordinate</span><span class="p">,</span>
                                <span class="s2">&quot;endpoints&quot;</span><span class="p">:</span><span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">starting_edge</span><span class="p">)</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span>
                               <span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">:</span><span class="n">touching_soma_vertices</span><span class="p">,</span>
                                <span class="s2">&quot;soma_group_idx&quot;</span><span class="p">:</span><span class="n">soma_group_idx</span><span class="p">,</span>
                               <span class="s2">&quot;starting_soma&quot;</span><span class="p">:</span><span class="n">starting_soma</span><span class="p">}</span>
                                <span class="p">}</span>
        
        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">attrs</span><span class="p">)</span>
        <span class="c1">#print(f&quot;Recovered touching vertices after 1 = {xu.get_all_nodes_with_certain_attribute_key(concept_network,&#39;touching_soma_vertices&#39;)}&quot;)</span>
        
        <span class="c1">#add the endpoints </span>
        <span class="k">return</span> <span class="n">concept_network</span>

    <span class="c1"># 0) convert each branch to one segment and build a graph from it</span>
    
    
    <span class="c1"># 8-29 debug</span>
    <span class="c1">#curr_branch_meshes_downsampled = [sk.resize_skeleton_branch(b,n_segments=1) for b in curr_branch_skeletons]</span>
    <span class="n">curr_branch_meshes_downsampled</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_branch_skeletons</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_branch_meshes_downsampled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">n_segments</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following branch </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> could not be downsampled: </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;not downsampled branch&quot;</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    In order to solve the problem that once resized there could be repeat edges</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) predict the branches that are repeats and then create a map </span>
<span class="sd">    of the non-dom (to be replaced) and dominant (the ones to replace)</span>
<span class="sd">    2) Get an arange list of the branch idxs and then delete the non-dominant ones</span>
<span class="sd">    3) Run the whole concept map process</span>
<span class="sd">    4) At the end for each non-dominant one, at it in (with it&#39;s idx) and copy</span>
<span class="sd">    the edges of the dominant one that it was mapped to</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">downsampled_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">)</span>
    <span class="c1"># curr_sk_graph_debug = sk.convert_skeleton_to_graph_old(downsampled_skeleton)</span>
    <span class="c1"># nx.draw(curr_sk_graph_debug,with_labels = True)</span>

    <span class="c1">#See if touching row matches the original: </span>
    

    <span class="n">all_skeleton_vertices</span> <span class="o">=</span> <span class="n">downsampled_skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">unique_rows</span><span class="p">,</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_skeleton_vertices</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">reshaped_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">unique_edges</span><span class="p">,</span><span class="n">unique_edges_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">reshaped_indices</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
    <span class="n">multiplicity_edge_counter</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">unique_edges_indices</span><span class="p">))</span>
    <span class="c1">#this will give the unique edge that appears multiple times</span>
    <span class="n">duplicate_edge_identifiers</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">multiplicity_edge_counter</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> 
    
    <span class="c1">#for keeping track of original indexes</span>
    <span class="n">original_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">))</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This will delete any branches that have the same two common endpoints</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate_edge_identifiers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">duplicate_edge_identifiers</span><span class="p">)</span><span class="si">}</span><span class="s2"> duplication nodes found&quot;</span><span class="p">)</span>
        <span class="n">all_conn_comp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">duplicate_edge_identifiers</span><span class="p">:</span>
            <span class="n">all_conn_comp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">unique_edges_indices</span> <span class="o">==</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">domination_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">curr_comp</span> <span class="ow">in</span> <span class="n">all_conn_comp</span><span class="p">:</span>
            <span class="n">dom_node</span> <span class="o">=</span> <span class="n">curr_comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">non_dom_nodes</span> <span class="o">=</span> <span class="n">curr_comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">n_dom</span> <span class="ow">in</span> <span class="n">non_dom_nodes</span><span class="p">:</span>
                <span class="n">domination_map</span><span class="p">[</span><span class="n">n_dom</span><span class="p">]</span> <span class="o">=</span> <span class="n">dom_node</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;domination_map = </span><span class="si">{</span><span class="n">domination_map</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

        <span class="n">to_delete_rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">domination_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1">#delete all of the non dominant rows from the indexes and the skeletons</span>
        <span class="n">original_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">original_idxs</span><span class="p">,</span><span class="n">to_delete_rows</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">curr_branch_meshes_downsampled</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_delete_rows</span><span class="p">]</span>
    
    <span class="c1">#print(f&quot;curr_branch_meshes_downsampled[24] = {curr_branch_meshes_downsampled[24]}&quot;)</span>
    <span class="n">curr_stacked_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">)</span>
    <span class="c1">#print(f&quot;curr_stacked_skeleton[24] = {curr_stacked_skeleton[24]}&quot;)</span>

    <span class="n">branches_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_stacked_skeleton</span><span class="p">)</span> <span class="c1">#can recover the original skeleton</span>
<span class="c1">#     print(f&quot;len(curr_stacked_skeleton) = {len(curr_stacked_skeleton)}&quot;)</span>
<span class="c1">#     print(f&quot;len(branches_graph.edges_ordered()) = {len(branches_graph.edges_ordered())}&quot;)</span>
<span class="c1">#     print(f&quot;(branches_graph.edges_ordered())[24] = {(branches_graph.edges_ordered())[24]}&quot;)</span>
<span class="c1">#     print(f&quot;coordinates = (branches_graph.edges_ordered())[24] = {xu.get_node_attributes(branches_graph,node_list=(branches_graph.edges_ordered())[24])}&quot;)</span>


    <span class="c1">#************************ need to just make an edges lookup dictionary*********#</span>


    <span class="c1">#1) Identify the starting node on the starting branch</span>
    <span class="n">starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">starting_coordinate</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;At the start, starting_node (in terms of the skeleton, that shouldn&#39;t match the starting edge) = </span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">starting_node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The number of starting nodes found was not exactly one: </span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#1b) Add all edges incident and their other node label to a list to check (add the first node to processed nodes list)</span>
    <span class="n">incident_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_to_edges</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="n">starting_node</span><span class="p">)</span>
    <span class="c1">#print(f&quot;incident_edges = {incident_edges}&quot;)</span>
    <span class="c1"># #incident_edges_idx = edge_to_index(incident_edges)</span>

    <span class="c1"># #adding them to the list to be processed (gets the edge and the downstream edge)</span>
    <span class="n">edge_endpoints_to_process</span> <span class="o">=</span> <span class="p">[(</span><span class="n">edges</span><span class="p">,</span><span class="n">edges</span><span class="p">[</span><span class="n">edges</span> <span class="o">!=</span> <span class="n">starting_node</span> <span class="p">])</span> <span class="k">for</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">incident_edges</span><span class="p">]</span>
    <span class="n">processed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_node</span><span class="p">)</span>

    <span class="c1">#need to add all of the newly to look edges and the current edge to the concept_network_edges</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) convert starting edge to the node identifiers</span>
<span class="sd">    2) iterate through all the edges to process and add the combos where the edge does not match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge_coeff</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_edge</span><span class="p">:</span>
        <span class="n">edge_coeff</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">k</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
    
    
    <span class="k">for</span> <span class="n">curr_edge</span><span class="p">,</span><span class="n">edge_enpt</span> <span class="ow">in</span> <span class="n">edge_endpoints_to_process</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">curr_edge</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge_coeff</span><span class="p">)):</span>
            <span class="c1">#add to the concept graph</span>
            <span class="n">concept_network_edges</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_edge</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_coeff</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starting_node_edge</span> <span class="o">=</span> <span class="n">curr_edge</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;printing out current edge:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">starting_node_edge</span><span class="p">))</span>
        
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
        <span class="c1">#print(f&quot;==\n\n On iteration {i}==&quot;)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_endpoints_to_process</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge_endpoints_to_process was empty so exiting loop after </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> iterations&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="c1">#2) Pop the edge edge number,endpoint of the stack</span>
        <span class="n">edge</span><span class="p">,</span><span class="n">endpt</span> <span class="o">=</span> <span class="n">edge_endpoints_to_process</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#print(f&quot;edge,endpt = {(edge,endpt)}&quot;)</span>
        <span class="c1">#- if edge already been processed then continue</span>
        <span class="k">if</span> <span class="n">endpt</span> <span class="ow">in</span> <span class="n">processed_nodes</span><span class="p">:</span>
            <span class="c1">#print(f&quot;Already processed endpt = {endpt} so skipping&quot;)</span>
            <span class="k">continue</span>
        <span class="c1">#a. Find all edges incident on this node</span>
        <span class="n">incident_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_to_edges</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="n">endpt</span><span class="p">)</span>
        <span class="c1">#print(f&quot;incident_edges = {incident_edges}&quot;)</span>

        <span class="n">considering_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">incident_edges</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">edge</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">edge</span><span class="p">))]</span>
        <span class="c1">#print(f&quot;considering_edges = {considering_edges}&quot;)</span>
        <span class="c1">#b. Create edges from curent edge to those edges incident with it</span>
        <span class="n">concept_network_edges</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">edge</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">considering_edges</span><span class="p">]</span>

        <span class="c1">#c. Add the current node as processed</span>
        <span class="n">processed_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endpt</span><span class="p">)</span>

        <span class="c1">#d. For each edge incident add the edge and the other connecting node to the list</span>
        <span class="n">new_edge_processing</span> <span class="o">=</span> <span class="p">[(</span><span class="n">e</span><span class="p">,</span><span class="n">e</span><span class="p">[</span><span class="n">e</span> <span class="o">!=</span> <span class="n">endpt</span> <span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">considering_edges</span><span class="p">]</span>
        <span class="n">edge_endpoints_to_process</span> <span class="o">=</span> <span class="n">edge_endpoints_to_process</span> <span class="o">+</span> <span class="n">new_edge_processing</span>
        <span class="c1">#print(f&quot;edge_endpoints_to_process = {edge_endpoints_to_process}&quot;)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_endpoints_to_process</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reached max_interations of </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2"> and the edge_endpoints_to_process not empty&quot;</span><span class="p">)</span>

    <span class="c1">#flattening the connections so we can get the indexes of these edges</span>
    <span class="n">flattened_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">concept_network_edges</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="n">orders</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="n">edge_list</span><span class="o">=</span><span class="n">flattened_connections</span><span class="p">)</span>
    <span class="c1">#******</span>
    
    <span class="n">fixed_idx_orders</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">orders</span><span class="p">]</span>
    <span class="n">concept_network_edges_fixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fixed_idx_orders</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    
    <span class="c1"># # edge_endpoints_to_process</span>
    <span class="c1">#print(f&quot;concept_network_edges_fixed = {concept_network_edges_fixed}&quot;)</span>
    <span class="n">concept_network</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">GraphOrderedEdges</span><span class="p">()</span>
    <span class="c1">#print(&quot;type(concept_network) = {type(concept_network)}&quot;)</span>
    <span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">concept_network_edges_fixed</span><span class="p">])</span>
    
    <span class="c1">#add the endpoints as attributes to each of the nodes</span>
    <span class="n">node_endpoints_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">old_ordered_edges</span> <span class="o">=</span> <span class="n">branches_graph</span><span class="o">.</span><span class="n">edges_ordered</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge_idx</span><span class="p">,</span><span class="n">curr_branch_graph_edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old_ordered_edges</span><span class="p">):</span>
        <span class="n">new_edge_idx</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">edge_idx</span><span class="p">]</span>
        <span class="n">curr_enpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="n">curr_branch_graph_edge</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">node_endpoints_dict</span><span class="p">[</span><span class="n">new_edge_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">endpoints</span><span class="o">=</span><span class="n">curr_enpoints</span><span class="p">)</span>
        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">node_endpoints_dict</span><span class="p">)</span>
    
    
    
    
    <span class="c1">#add the starting coordinate to the corresponding node</span>
    <span class="c1">#print(f&quot;starting_node_edge right before = {starting_node_edge}&quot;)</span>
    <span class="n">starting_order</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">branches_graph</span><span class="p">,</span><span class="n">edge_list</span><span class="o">=</span><span class="p">[</span><span class="n">starting_node_edge</span><span class="p">])</span> 
    <span class="c1">#print(f&quot;starting_order right before = {starting_order}&quot;)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">starting_order</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only one starting edge index was not found,starting_order=</span><span class="si">{</span><span class="n">starting_order</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
    
    <span class="n">starting_edge_index</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">starting_order</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_node in concept map (that should match the starting edge) = </span><span class="si">{</span><span class="n">starting_edge_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#attrs = {starting_node[0]:{&quot;starting_coordinate&quot;:starting_coordinate}} #old way that think uses the wrong starting_node</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">starting_edge_index</span><span class="p">:{</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">:</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">:</span><span class="n">touching_soma_vertices</span><span class="p">,</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">:</span><span class="n">soma_group_idx</span><span class="p">,</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">:</span><span class="n">starting_soma</span><span class="p">}}</span> 
    <span class="c1">#print(&quot;setting touching_soma_vertices 2&quot;)</span>
    <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">attrs</span><span class="p">)</span>
    <span class="c1">#print(f&quot;Recovered touching vertices after 2 = {xu.get_all_nodes_with_certain_attribute_key(concept_network,&#39;touching_soma_vertices&#39;)}&quot;)</span>
    
    <span class="c1">#want to set all of the edge endpoints on the nodes as well just for a check</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for branches to concept conversion = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="c1"># Add back the nodes that were deleted</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate_edge_identifiers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Working on adding back the edges that were duplicates&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">non_dom</span><span class="p">,</span><span class="n">dom</span> <span class="ow">in</span> <span class="n">domination_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1">#print(f&quot;Re-adding: {non_dom}&quot;)</span>
            <span class="c1">#get the endpoints attribute</span>
            <span class="c1"># local_node_endpoints_dict</span>
            
            <span class="n">curr_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">dom</span><span class="p">)</span>  
            <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_neighbors</span><span class="p">))</span><span class="o">*</span><span class="n">non_dom</span><span class="p">,</span><span class="n">curr_neighbors</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
            
            <span class="n">curr_endpoint</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;endpoints&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">dom</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#print(f&quot;curr_endpoint in add back = {curr_endpoint}&quot;)</span>
            <span class="n">add_back_attribute_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">non_dom</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="n">endpoints</span><span class="o">=</span><span class="n">curr_endpoint</span><span class="p">)}</span>
            <span class="c1">#print(f&quot;To add dict = {add_back_attribute_dict}&quot;)</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">add_back_attribute_dict</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">concept_network</span></div>



<span class="sd">&quot;&quot;&quot; Older function definition</span>
<span class="sd">def generate_limb_concept_networks_from_global_connectivity(</span>
<span class="sd">    limb_idx_to_branch_meshes_dict,</span>
<span class="sd">    limb_idx_to_branch_skeletons_dict,</span>
<span class="sd">    soma_idx_to_mesh_dict,</span>
<span class="sd">    soma_idx_connectivity,</span>
<span class="sd">    current_neuron,</span>
<span class="sd">    return_limb_labels=True</span>
<span class="sd">    ): </span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="check_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.check_concept_network">[docs]</a><span class="k">def</span> <span class="nf">check_concept_network</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">closest_endpoint</span><span class="p">,</span>
                          <span class="n">curr_limb_divided_skeletons</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">return_touching_piece</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="n">recovered_touching_piece</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">starting_coordinate</span><span class="o">=</span><span class="n">closest_endpoint</span><span class="p">))</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;recovered_touching_piece = </span><span class="si">{</span><span class="n">recovered_touching_piece</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After concept mapping size = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of nodes in the concept graph and number of branches passed to it did not match</span><span class="se">\n</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;len(curr_limb_concept_network.nodes())=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">, len(curr_limb_divided_skeletons)= </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was more than 1 connected components in the concept network&quot;</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">un_resized_b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        1) get the endpoints of the current branch</span>
<span class="sd">        2) get the endpoints in the concept map</span>
<span class="sd">        3) compare</span>
<span class="sd">        - if not equalt then break</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#1) get the endpoints of the current branch</span>
        <span class="n">b_endpoints</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">un_resized_b</span><span class="p">)</span><span class="o">.</span><span class="n">endpoints</span>
        <span class="c1">#2) get the endpoints in the concept map</span>
        <span class="n">graph_endpoints</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;endpoints&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#print(f&quot;original_branch_endpoints = {b_endpoints}, concept graph node endpoints = {graph_endpoints}&quot;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="n">b_endpoints</span><span class="p">,</span><span class="n">graph_endpoints</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> in concept graph endpoints do not match the endpoints of the original branch</span><span class="se">\n</span><span class="s2">&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;original_branch_endpoints = </span><span class="si">{</span><span class="n">b_endpoints</span><span class="si">}</span><span class="s2">, concept graph node endpoints = </span><span class="si">{</span><span class="n">graph_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_touching_piece</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recovered_touching_piece</span></div>
            
<span class="c1">#for finding the closest endpoint</span>
<div class="viewcode-block" id="generate_limb_concept_networks_from_global_connectivity"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.generate_limb_concept_networks_from_global_connectivity">[docs]</a><span class="k">def</span> <span class="nf">generate_limb_concept_networks_from_global_connectivity</span><span class="p">(</span>
        <span class="n">limb_correspondence</span><span class="p">,</span>
        <span class="n">soma_meshes</span><span class="p">,</span>
        <span class="n">soma_idx_connectivity</span><span class="p">,</span>
        <span class="n">current_neuron</span><span class="p">,</span>
        <span class="n">limb_to_soma_starting_endpoints</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_limb_labels</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ****** Could significantly speed this up if better picked the </span>
<span class="sd">    periphery meshes (which now are sending all curr_limb_divided_meshes)</span>
<span class="sd">    sent to </span>
<span class="sd">    </span>
<span class="sd">    tu.mesh_pieces_connectivity(main_mesh=current_neuron,</span>
<span class="sd">                                        central_piece = curr_soma_mesh,</span>
<span class="sd">                                    periphery_pieces=curr_limb_divided_meshes)</span>
<span class="sd">    *********</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Purpose: To create concept networks for all of the skeletons</span>
<span class="sd">             based on our knowledge of the mesh</span>

<span class="sd">        Things it needs: </span>
<span class="sd">        - branch_mehses</span>
<span class="sd">        - branch skeletons</span>
<span class="sd">        - soma meshes</span>
<span class="sd">        - whole neuron</span>
<span class="sd">        - soma_to_piece_connectivity</span>

<span class="sd">        What it returns:</span>
<span class="sd">        - concept networks</span>
<span class="sd">        - branch labels</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the meshes for that limb (that were decomposed)</span>
<span class="sd">    2) Use the entire neuron, the soma meshes and the list of meshes and find out shich one is touching the soma</span>
<span class="sd">    3) With the one that is touching the soma, find the enpoints of the skeleton</span>
<span class="sd">    4) Find the closest matching endpoint</span>
<span class="sd">    5) Send the deocmposed skeleton branches to the branches_to_concept_network function</span>
<span class="sd">    6) Graph the concept graph using the mesh centers</span>

<span class="sd">    Example of Use: </span>
<span class="sd">    </span>
<span class="sd">    from neurd import neuron</span>
<span class="sd">    neuron = reload(neuron)</span>

<span class="sd">    #getting mesh and skeleton dictionaries</span>
<span class="sd">    limb_idx_to_branch_meshes_dict = dict()</span>
<span class="sd">    limb_idx_to_branch_skeletons_dict = dict()</span>
<span class="sd">    for k in limb_correspondence.keys():</span>
<span class="sd">        limb_idx_to_branch_meshes_dict[k] = [limb_correspondence[k][j][&quot;branch_mesh&quot;] for j in limb_correspondence[k].keys()]</span>
<span class="sd">        limb_idx_to_branch_skeletons_dict[k] = [limb_correspondence[k][j][&quot;branch_skeleton&quot;] for j in limb_correspondence[k].keys()]      </span>

<span class="sd">    #getting the soma dictionaries</span>
<span class="sd">    soma_idx_to_mesh_dict = dict()</span>
<span class="sd">    for k,v in enumerate(current_mesh_data[0][&quot;soma_meshes&quot;]):</span>
<span class="sd">        soma_idx_to_mesh_dict[k] = v</span>

<span class="sd">    soma_idx_connectivity = current_mesh_data[0][&quot;soma_to_piece_connectivity&quot;]</span>


<span class="sd">    limb_concept_networkx,limb_labels = neuron.generate_limb_concept_networks_from_global_connectivity(</span>
<span class="sd">        limb_idx_to_branch_meshes_dict = limb_idx_to_branch_meshes_dict,</span>
<span class="sd">        limb_idx_to_branch_skeletons_dict = limb_idx_to_branch_skeletons_dict,</span>
<span class="sd">        soma_idx_to_mesh_dict = soma_idx_to_mesh_dict,</span>
<span class="sd">        soma_idx_connectivity = soma_idx_connectivity,</span>
<span class="sd">        current_neuron=current_neuron,</span>
<span class="sd">        return_limb_labels=True</span>
<span class="sd">        )</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;********************************** generate_limb_concept_networks_from_global_connectivity****************************&quot;</span><span class="p">)</span>
    <span class="c1"># ------------ 7/17 Added preprocessing Step so can give the function more generic arguments ---------------- #</span>
    <span class="c1">#getting mesh and skeleton dictionaries</span>
    <span class="n">limb_idx_to_branch_meshes_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_idx_to_branch_skeletons_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">limb_idx_to_branch_meshes_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">limb_idx_to_branch_skeletons_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>      

    <span class="c1">#getting the soma dictionaries</span>
    <span class="n">soma_idx_to_mesh_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">):</span>
        <span class="n">soma_idx_to_mesh_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>




    
    
    
    

    
    
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_idx_to_branch_meshes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_idx_to_branch_skeletons_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was a difference in the keys for the limb_idx_to_branch_meshes_dict and limb_idx_to_branch_skeletons_dict&quot;</span><span class="p">)</span>
        
    <span class="n">global_concept_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">total_limb_concept_networks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">total_limb_labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">soma_mesh_faces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limb_idx_to_branch_meshes_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">local_concept_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">------Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> -------&quot;</span><span class="p">)</span>
        <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">curr_limb_divided_meshes</span> <span class="o">=</span> <span class="n">limb_idx_to_branch_meshes_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="c1">#curr_limb_divided_meshes_idx = [v[&quot;branch_face_idx&quot;] for v in limb_correspondence[limb_idx].values()]</span>
        <span class="n">curr_limb_divided_skeletons</span> <span class="o">=</span> <span class="n">limb_idx_to_branch_skeletons_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside loop len(curr_limb_divided_meshes) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
             <span class="sa">f</span><span class="s2">&quot; len(curr_limb_divided_skeletons) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1">#find what mesh piece was touching</span>
        <span class="n">touching_soma_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">soma_idx_connectivity</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">touching_soma_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_soma_indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Did not find touching soma index&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_soma_indexes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merge limb detected&quot;</span><span class="p">)</span>
            
        
        <span class="k">for</span> <span class="n">soma_idx</span> <span class="ow">in</span> <span class="n">touching_soma_indexes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on soma_idx: </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>
            <span class="n">curr_soma_mesh</span> <span class="o">=</span> <span class="n">soma_idx_to_mesh_dict</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span>
            
            
            
            <span class="k">if</span> <span class="n">soma_idx</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">soma_mesh_faces</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">soma_info</span> <span class="o">=</span> <span class="n">soma_mesh_faces</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">soma_info</span> <span class="o">=</span> <span class="n">curr_soma_mesh</span>
                
            <span class="c1">#filter the periphery pieces</span>
            <span class="n">original_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_meshes</span><span class="p">))</span>
            
            <span class="n">periph_filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">distances_periphery_to_soma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">closest_distance_between_meshes</span><span class="p">(</span><span class="n">curr_soma_mesh</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_divided_meshes</span><span class="p">])</span>
            <span class="n">periphery_distance_threshold</span> <span class="o">=</span> <span class="mi">2000</span>
            
            <span class="n">original_idxs</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">distances_periphery_to_soma</span><span class="o">&lt;</span><span class="n">periphery_distance_threshold</span><span class="p">]</span>
            <span class="n">filtered_periphery_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_limb_divided_meshes</span><span class="p">)[</span><span class="n">distances_periphery_to_soma</span><span class="o">&lt;</span><span class="n">periphery_distance_threshold</span><span class="p">]</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for filtering periphery meshes = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">periph_filter_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">periph_filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_periphery_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There were no periphery meshes within a threshold distance of the mesh&quot;</span><span class="p">)</span>
            

            <span class="n">touching_pieces</span><span class="p">,</span><span class="n">touching_vertices</span><span class="p">,</span><span class="n">central_piece_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">current_neuron</span><span class="p">,</span>
                                        <span class="n">central_piece</span> <span class="o">=</span> <span class="n">soma_info</span><span class="p">,</span>
                                        <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">filtered_periphery_meshes</span><span class="p">,</span>
                                                         <span class="n">return_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">return_central_faces</span><span class="o">=</span><span class="kc">True</span>
                                                                                 <span class="p">)</span>
            <span class="n">soma_mesh_faces</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">central_piece_faces</span>
            
            <span class="c1">#fixing the indexes so come out the same</span>
            <span class="n">touching_pieces</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">touching_pieces</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;touching_pieces = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh connectivity = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">periph_filter_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**More than one touching point to soma, touching_pieces = </span><span class="si">{touching_pieces}</span><span class="s2">**&quot;</span><span class="p">)</span>
<span class="w">                </span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot; 9/17: Want to pick the one with the starting endpoint if exists</span>
<span class="sd">                Pseudocode: </span>
<span class="sd">                1) Get the starting endpoint if exists</span>
<span class="sd">                2) Get the endpoints of all the touching branches</span>
<span class="sd">                3) Get the index (if any ) of the branch that has this endpoint in skeleton</span>
<span class="sd">                4) Make that the winning index</span>
<span class="sd">                </span>
<span class="sd">                </span>
<span class="sd">                </span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">limb_to_soma_starting_endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using new winning piece based on starting coordinate&quot;</span><span class="p">)</span>
                    <span class="n">ideal_starting_coordinate</span> <span class="o">=</span> <span class="n">limb_to_soma_starting_endpoints</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">soma_idx</span><span class="p">]</span>
                    <span class="n">touching_pieces_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">endpoints</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">touching_pieces</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;trying to use new find_branch_skeleton_with_specific_coordinate&quot;</span><span class="p">)</span>
                    <span class="n">winning_piece_idx</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">touching_pieces_branches</span><span class="p">,</span>
                                                                  <span class="n">current_coordinate</span><span class="o">=</span><span class="n">ideal_starting_coordinate</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># picking the piece with the most shared vertices</span>
                    <span class="n">len_touch_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">touching_vertices</span><span class="p">]</span>
                    <span class="n">winning_piece_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">len_touch_vertices</span><span class="p">)</span>
                    
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_piece_idx = </span><span class="si">{</span><span class="n">winning_piece_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">touching_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">touching_pieces</span><span class="p">[</span><span class="n">winning_piece_idx</span><span class="p">]]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning touching piece = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">touching_pieces_soma_vertices</span> <span class="o">=</span> <span class="n">touching_vertices</span><span class="p">[</span><span class="n">winning_piece_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">touching_pieces_soma_vertices</span> <span class="o">=</span> <span class="n">touching_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No touching pieces&quot;</span><span class="p">)</span>
            
            <span class="c1">#print out the endpoints of the winning touching piece</span>
            
                
            <span class="c1">#3) With the one that is touching the soma, find the enpoints of the skeleton</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using touching_pieces[0] = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">touching_branch</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">[</span><span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">touching_branch</span><span class="o">.</span><span class="n">endpoints</span>
<span class="w">            </span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;  OLDER WAY OF FINDING STARTING ENDPOINT WHERE JUST COMPARES TO SOMA CENTER</span>
<span class="sd">            print(f&quot;Touching piece endpoints = {endpoints}&quot;)</span>
<span class="sd">            soma_midpoint = np.mean(curr_soma_mesh.vertices,axis=0)</span>

<span class="sd">            #4) Find the closest matching endpoint</span>
<span class="sd">            closest_idx = np.argmin([np.linalg.norm(soma_midpoint-k) for k in endpoints])</span>
<span class="sd">            closest_endpoint = endpoints[closest_idx]</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            

            <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">limb_to_soma_starting_endpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;  # -----------  9/16 -------------- #</span>
<span class="sd">                Will pick the starting coordinate that was given if it was on the winning piece</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">ideal_starting_coordinate</span> <span class="o">=</span> <span class="n">limb_to_soma_starting_endpoints</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">soma_idx</span><span class="p">]</span>
                <span class="n">endpoints_list</span> <span class="o">=</span> <span class="n">endpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">match_result</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">endpoints_list</span><span class="p">,</span><span class="n">ideal_starting_coordinate</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_result</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="n">endpoints_list</span><span class="p">[</span><span class="n">match_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">closest_endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;  # -----------  9/1 -------------- #</span>
<span class="sd">                New method for finding </span>
<span class="sd">                1) Build a KDTree of the winning touching piece soma boundary vertices</span>
<span class="sd">                2) query the endpoints against the vertices</span>
<span class="sd">                3) pick the endpoint that has the closest match</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">ex_branch_KDTree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">touching_pieces_soma_vertices</span><span class="p">)</span>
                <span class="n">distances</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">ex_branch_KDTree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
                <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)]</span>
            
            

            
            
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside inner loop &quot;</span>
             <span class="sa">f</span><span class="s2">&quot;len(curr_limb_divided_skeletons) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_endpoint WITH NEW KDTREE METHOD= </span><span class="si">{</span><span class="n">closest_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;About to send touching_soma_vertices = </span><span class="si">{</span><span class="n">touching_pieces_soma_vertices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">branches_to_concept_network</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">,</span><span class="n">closest_endpoint</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                                                                   <span class="n">touching_soma_vertices</span><span class="o">=</span><span class="n">touching_pieces_soma_vertices</span><span class="p">)</span>
            
            <span class="c1">#print(f&quot;Recovered touching vertices = {xu.get_all_nodes_with_certain_attribute_key(curr_limb_concept_network,&#39;touching_soma_vertices&#39;)}&quot;)</span>
            <span class="n">curr_concept_network</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb_concept_network</span>
            
            
            <span class="c1"># ----- Some checks that make sure concept mapping went well ------ #</span>
            <span class="c1">#get the node that has the starting coordinate:</span>
            <span class="n">recovered_touching_piece</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">starting_coordinate</span><span class="o">=</span><span class="n">closest_endpoint</span><span class="p">))</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;recovered_touching_piece = </span><span class="si">{</span><span class="n">recovered_touching_piece</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">recovered_touching_piece</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> and soma </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2"> the recovered_touching and original touching do not match</span><span class="se">\n</span><span class="s2">&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;recovered_touching_piece = </span><span class="si">{</span><span class="n">recovered_touching_piece</span><span class="si">}</span><span class="s2">, original_touching_pieces = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                                                         

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After concept mapping size = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">):</span>
                   <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of nodes in the concept graph and number of branches passed to it did not match</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;len(curr_limb_concept_network.nodes())=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">, len(curr_limb_divided_skeletons)= </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was more than 1 connected components in the concept network&quot;</span><span class="p">)</span>
            
<span class="c1">#             #for debugging: </span>
<span class="c1">#             endpoints_dict = xu.get_node_attributes(curr_limb_concept_network,attribute_name=&quot;endpoints&quot;,return_array=False)</span>
<span class="c1">#             print(f&quot;endpoints_dict = {endpoints_dict}&quot;)</span>
<span class="c1">#             print(f&quot;{curr_limb_concept_network.nodes()}&quot;)</span>
            
            
            <span class="c1">#make sure that the original divided_skeletons endpoints match the concept map endpoints</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">un_resized_b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Pseudocode: </span>
<span class="sd">                1) get the endpoints of the current branch</span>
<span class="sd">                2) get the endpoints in the concept map</span>
<span class="sd">                3) compare</span>
<span class="sd">                - if not equalt then break</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1">#1) get the endpoints of the current branch</span>
                <span class="n">b_endpoints</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">un_resized_b</span><span class="p">)</span><span class="o">.</span><span class="n">endpoints</span>
                <span class="c1">#2) get the endpoints in the concept map</span>
                <span class="n">graph_endpoints</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;endpoints&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#print(f&quot;original_branch_endpoints = {b_endpoints}, concept graph node endpoints = {graph_endpoints}&quot;)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="n">b_endpoints</span><span class="p">,</span><span class="n">graph_endpoints</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> in concept graph endpoints do not match the endpoints of the original branch</span><span class="se">\n</span><span class="s2">&quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;original_branch_endpoints = </span><span class="si">{</span><span class="n">b_endpoints</span><span class="si">}</span><span class="s2">, concept graph node endpoints = </span><span class="si">{</span><span class="n">graph_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
        <span class="n">total_limb_concept_networks</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_concept_network</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">total_limb_labels</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;MergeError&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_limb_labels</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Normal&quot;</span>
            
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Local time for concept mapping = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_concept_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ----- Total time for concept mapping = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_concept_time</span><span class="si">}</span><span class="s2"> ----&quot;</span><span class="p">)</span>
        
        
    <span class="c1">#returning from the function    </span>
        
    <span class="k">if</span> <span class="n">return_limb_labels</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_limb_concept_networks</span><span class="p">,</span><span class="n">total_limb_labels</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_limb_concept_networks</span></div>

<span class="c1"># ----------------------- End of Concept Networks ------------------------------------- #</span>
    
    

<span class="c1"># -----------------------  For the compression of a neuron object ---------------------- #</span>
<div class="viewcode-block" id="find_face_idx_and_check_recovery"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.find_face_idx_and_check_recovery">[docs]</a><span class="k">def</span> <span class="nf">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span><span class="n">submesh_list</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">check_recovery</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">submesh_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nothing in submesh_list sent to find_face_idx_and_check_recovery so just returning empty list&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
    <span class="n">submesh_list_face_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">sm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">submesh_list</span><span class="p">):</span>
        
        <span class="n">sm_faces_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">original_mesh</span><span class="p">,</span> 
                                   <span class="n">submesh</span><span class="o">=</span><span class="n">sm</span><span class="p">,</span>
                               <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">submesh_list_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sm_faces_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For submesh </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: sm.faces.shape = </span><span class="si">{</span><span class="n">sm</span><span class="o">.</span><span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, sm_faces_idx.shape = </span><span class="si">{</span><span class="n">sm_faces_idx</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">check_recovery</span><span class="p">:</span>
        <span class="n">recovered_submesh_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">sm_f</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">sm_f</span> <span class="ow">in</span> <span class="n">submesh_list_face_idx</span><span class="p">]</span>
        <span class="c1">#return recovered_submesh_meshes</span>

    
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">orig_sm</span><span class="p">,</span><span class="n">rec_sm</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">submesh_list</span><span class="p">,</span><span class="n">recovered_submesh_meshes</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="n">orig_sm</span><span class="p">,</span><span class="n">rec_sm</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">tu</span><span class="o">.</span><span class="n">compare_meshes_by_face_midpoints</span><span class="p">(</span><span class="n">orig_sm</span><span class="p">,</span><span class="n">rec_sm</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Submesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> was not able to be accurately recovered&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">submesh_list_face_idx</span></div>
    




<div class="viewcode-block" id="smaller_preprocessed_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.smaller_preprocessed_data">[docs]</a><span class="k">def</span> <span class="nf">smaller_preprocessed_data</span><span class="p">(</span><span class="n">neuron_object</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">double_soma_obj</span> <span class="o">=</span> <span class="n">neuron_object</span>
    
    <span class="n">total_compression_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    
    
    
    
    <span class="c1"># doing the soma recovery more streamlined</span>
    <span class="n">compression_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">soma_meshes_face_idx</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for soma meshes compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">compression_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">compression_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#insignificant, non_soma touching and inside pieces just mesh pieces ()</span>
    <span class="n">insignificant_limbs_face_idx</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;insignificant_limbs&quot;</span><span class="p">])</span>
    <span class="n">not_processed_soma_containing_meshes_face_idx</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;not_processed_soma_containing_meshes&quot;</span><span class="p">])</span>

    <span class="n">inside_pieces_face_idx</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;inside_pieces&quot;</span><span class="p">])</span>

    <span class="n">non_soma_touching_meshes_face_idx</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for insignificant_limbs,inside_pieces,non_soma_touching_meshes,not_processed_soma_containing_meshes compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">compression_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">compression_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1"># recover the limb meshes from the original</span>
    <span class="c1">#------------------------------- THERE IS SOME DISCONNECTED IN THE MESH THAT IS IN PREPROCESSED DATA AND THE ACTUAL LIMB MESH ------------------ #</span>
    <span class="c1">#------------------------------- MAKES SENSE BECAUSE DOING MESH CORRESPONDENCE AFTERWARDS THAT ALTERS THE MESH BRANCHES A BIT, SO JUST PULL FROM THE MESH_FACES_IDX ------------------ #</span>

    <span class="n">limb_meshes_face_idx</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for limb_meshes compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">compression_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">compression_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>    
    
    <span class="c1"># limb_correspondence can get rid of branch mesh and just recover from branch_face_idx</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Want to keep skeleton and width</span>
<span class="sd">    2) Generate new branch_face_idx based on the original mesh</span>
<span class="sd">    --&gt; later can recover the branch_mesh from the whole neuron mesh and the new branch_face_idx</span>
<span class="sd">    --&gt; regenerate the and branch_face_idx from the recovered limb mesh and he recovered mesh</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Starting Limb Correspondence Compression&quot;</span><span class="p">)</span>
    <span class="n">new_limb_correspondence</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">])</span>
    

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_limb_correspondence</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
            <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx_whole_neuron&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_face_idx_and_check_recovery</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                           <span class="n">submesh_list</span><span class="o">=</span><span class="p">[</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;branch_face_idx&quot;</span> <span class="ow">in</span> <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;branch_mesh&quot;</span> <span class="ow">in</span> <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">del</span> <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span>
                
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for new_limb_correspondence compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">compression_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">compression_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
    
    
    <span class="c1"># all of the data will be </span>
    <span class="n">soma_meshes_face_idx</span>

    <span class="c1"># soma_to_piece_connectivity is already small dictionary</span>
    <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span>
    <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">]</span>
    

    <span class="n">insignificant_limbs_face_idx</span>
    <span class="n">inside_pieces_face_idx</span>
    <span class="n">non_soma_touching_meshes_face_idx</span>

    <span class="n">limb_meshes_face_idx</span>

    <span class="n">new_limb_correspondence</span>

    <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s1">&#39;limb_labels&#39;</span><span class="p">]</span>
    <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s1">&#39;limb_concept_networks&#39;</span><span class="p">]</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Algorithm for how to save off the following: </span>
<span class="sd">    1) width_new (the dictionary where keyword maps to scalar) #save as dict of dict</span>
<span class="sd">    2) width_array (the dictionary where keyword maps to array)# </span>
<span class="sd">    3) spines(list or none): </span>
<span class="sd">    4) branch_labels (list): dict of dict</span>
<span class="sd">    </span>
<span class="sd">    How to store the width_new (just a dictionary for all of the widths)</span>
<span class="sd">    width_new_key = just anraveled</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    <span class="n">computed_attribute_dict</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">get_computed_attribute_data</span><span class="p">()</span>
    
    <span class="c1">#geting the labels data</span>
    <span class="n">labels_lookup</span> <span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">get_attribute_dict</span><span class="p">(</span><span class="s2">&quot;labels&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;soma_volume_ratios&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">double_soma_obj</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span><span class="o">.</span><span class="n">volume_ratio</span> <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()]</span>
        
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="p">,</span><span class="s2">&quot;original_mesh_idx&quot;</span><span class="p">):</span>
        <span class="n">original_mesh_idx</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">original_mesh_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">soma_names</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
    
    
    <span class="n">pipeline_products</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="p">,</span><span class="s2">&quot;pipeline_products&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pipeline_products</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pipeline_products</span> <span class="o">=</span> <span class="n">pipeline_products</span><span class="o">.</span><span class="n">export</span><span class="p">()</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">meshu</span><span class="o">.</span><span class="n">clear_all_mesh_cache_in_nested_data_struct</span><span class="p">(</span><span class="n">pipeline_products</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    
    <span class="n">compressed_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                          <span class="c1">#saving the original number of faces and vertices to make sure reconstruciton doesn&#39;t happen with wrong mesh</span>
                          <span class="n">original_mesh_n_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">),</span>
                          <span class="n">original_mesh_n_vertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span> 
        
                          <span class="n">soma_meshes_face_idx</span><span class="o">=</span><span class="n">soma_meshes_face_idx</span><span class="p">,</span>

                          <span class="n">soma_to_piece_connectivity</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">],</span>
                          <span class="n">soma_volumes</span><span class="o">=</span><span class="p">[</span><span class="n">double_soma_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">_volume</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_names</span><span class="p">],</span>
                          
                          <span class="c1"># --- 6/9 Addition: Synapses stored off</span>
                        
                          <span class="n">soma_synapses</span> <span class="o">=</span> <span class="p">[</span><span class="n">syu</span><span class="o">.</span><span class="n">synapses_to_exports</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="s2">&quot;synapses&quot;</span><span class="p">,[]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_names</span><span class="p">],</span>
                          <span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_to_exports</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="p">,</span><span class="s2">&quot;distance_errored_synapses&quot;</span><span class="p">,[])),</span>
                          <span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_to_exports</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">double_soma_obj</span><span class="p">,</span><span class="s2">&quot;mesh_errored_synapses&quot;</span><span class="p">,[])),</span>
        
                          
                          <span class="n">soma_sdfs</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">],</span>
                          <span class="n">soma_volume_ratios</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">],</span>

                          <span class="n">insignificant_limbs_face_idx</span><span class="o">=</span><span class="n">insignificant_limbs_face_idx</span><span class="p">,</span>
                          <span class="n">not_processed_soma_containing_meshes_face_idx</span> <span class="o">=</span> <span class="n">not_processed_soma_containing_meshes_face_idx</span><span class="p">,</span>
                          <span class="n">glia_faces</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;glia_faces&quot;</span><span class="p">],</span>
                          <span class="n">labels</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
                          <span class="n">inside_pieces_face_idx</span><span class="o">=</span><span class="n">inside_pieces_face_idx</span><span class="p">,</span>
                          <span class="n">non_soma_touching_meshes_face_idx</span><span class="o">=</span><span class="n">non_soma_touching_meshes_face_idx</span><span class="p">,</span>

                          <span class="n">limb_meshes_face_idx</span><span class="o">=</span><span class="n">limb_meshes_face_idx</span><span class="p">,</span>

                          <span class="n">new_limb_correspondence</span><span class="o">=</span><span class="n">new_limb_correspondence</span><span class="p">,</span>
                            
                          <span class="n">segment_id</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="p">,</span>
                          <span class="n">description</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">description</span><span class="p">,</span>
                          <span class="n">decomposition_type</span><span class="o">=</span><span class="n">double_soma_obj</span><span class="o">.</span><span class="n">decomposition_type</span><span class="p">,</span>
            
                          <span class="c1"># don&#39;t need these any more because will recompute them when decompressing</span>
                          <span class="c1">#limb_labels= double_soma_obj.preprocessed_data[&#39;limb_labels&#39;],</span>
                          <span class="c1">#limb_concept_networks=double_soma_obj.preprocessed_data[&#39;limb_concept_networks&#39;]</span>
        
                          <span class="c1">#new spine/width/labels compression</span>
                          <span class="n">computed_attribute_dict</span> <span class="o">=</span> <span class="n">computed_attribute_dict</span><span class="p">,</span>
                          
                          <span class="c1">#For concept network creation</span>
                          <span class="n">limb_network_stating_info</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">],</span>
        
                          <span class="c1">#for storing the faces indexed into the original mesh</span>
                          <span class="n">original_mesh_idx</span><span class="o">=</span><span class="n">original_mesh_idx</span><span class="p">,</span>
        
                          <span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">nucleus_id</span><span class="p">,</span>
                          <span class="n">split_index</span> <span class="o">=</span> <span class="n">double_soma_obj</span><span class="o">.</span><span class="n">split_index</span><span class="p">,</span>
                          
                          <span class="n">pipeline_products</span> <span class="o">=</span> <span class="n">pipeline_products</span><span class="p">,</span>
                                           
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for compression = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">total_compression_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">compressed_dict</span></div>


<div class="viewcode-block" id="save_compressed_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.save_compressed_neuron">[docs]</a><span class="k">def</span> <span class="nf">save_compressed_neuron</span><span class="p">(</span>
    <span class="n">neuron_object</span><span class="p">,</span>
    <span class="n">output_folder</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span>
    <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">file_name_append</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_file_path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">export_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">output_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_folder</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">file_name</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neuron_object</span><span class="o">.</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">neuron_object</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span>
        
    <span class="k">if</span> <span class="n">file_name_append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">file_name_append</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">output_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
    <span class="n">output_path</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    
    <span class="n">inhib_object_compressed_preprocessed_data</span> <span class="o">=</span> <span class="n">smaller_preprocessed_data</span><span class="p">(</span><span class="n">neuron_object</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">compressed_size</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">inhib_object_compressed_preprocessed_data</span><span class="p">,</span><span class="n">output_path</span><span class="p">,</span><span class="n">return_size</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---Finished outputing neuron at location: </span><span class="si">{</span><span class="n">output_path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="si">}</span><span class="s2">---&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">export_mesh</span><span class="p">:</span>
        <span class="n">neuron_object</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_path</span><span class="o">.</span><span class="n">absolute</span><span class="p">())</span> <span class="o">+</span><span class="s2">&quot;.off&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_file_path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output_path</span></div>
    
    

<span class="c1">#For decompressing the neuron</span>
<div class="viewcode-block" id="decompress_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.decompress_neuron">[docs]</a><span class="k">def</span> <span class="nf">decompress_neuron</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span><span class="n">original_mesh</span><span class="p">,</span>
                     <span class="n">suppress_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">using_original_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="c1">#error_on_original_mesh_faces_vertices_mismatch=False</span>
                     <span class="p">):</span>
    <span class="k">if</span> <span class="n">suppress_output</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Decompressing Neuron in minimal output mode...please wait&quot;</span><span class="p">)</span>
    
    <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="n">suppress_output</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
        
        <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">loaded_compression</span> <span class="o">=</span> <span class="n">su</span><span class="o">.</span><span class="n">decompress_pickle</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inside decompress neuron and decomposition_type = </span><span class="si">{</span><span class="n">loaded_compression</span><span class="p">[</span><span class="s1">&#39;decomposition_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decompress pickle time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="c1">#creating dictionary that will be used to construct the new neuron object</span>
        <span class="n">recovered_preprocessed_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a) soma_meshes: use the </span>
<span class="sd">        Data: soma_meshes_face_idx </span>
<span class="sd">        Process: use submesh on the neuron mesh for each</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">Path</span><span class="p">())</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">())[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;.h5&#39;</span><span class="p">:</span>
                <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing_h5</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recieved trimesh as orignal mesh&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got an unknown type as the original mesh: </span><span class="si">{</span><span class="n">original_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting mesh time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            

        <span class="c1"># ------- 1/23 Addition: where using a saved mesh face idx to index into an original mesh ------#</span>
        <span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;original_mesh_idx&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> 
        
        <span class="k">if</span> <span class="n">using_original_mesh</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">original_mesh_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The flag for using original mesh was set but no original_mesh_faces_idx stored in compressed data&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original mesh BEFORE using original_mesh_idx = </span><span class="si">{</span><span class="n">original_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">original_mesh_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original mesh AFTER using original_mesh_idx = </span><span class="si">{</span><span class="n">original_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
        <span class="n">error_on_original_mesh_faces_vertices_mismatch</span><span class="o">=</span><span class="kc">False</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">!=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;original_mesh_n_faces&quot;</span><span class="p">]:</span>
            <span class="n">warning_string</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of faces in mesh used for compression (</span><span class="si">{</span><span class="n">loaded_compression</span><span class="p">[</span><span class="s1">&#39;original_mesh_n_faces&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; does not match the number of faces in mesh passed to decompress_neuron function &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">error_on_original_mesh_faces_vertices_mismatch</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Passed faces original mesh check&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">!=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;original_mesh_n_vertices&quot;</span><span class="p">]:</span>
            <span class="n">warning_string</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of vertices in mesh used for compression (</span><span class="si">{</span><span class="n">loaded_compression</span><span class="p">[</span><span class="s1">&#39;original_mesh_n_vertices&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; does not match the number of vertices in mesh passed to decompress_neuron function &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">error_on_original_mesh_faces_vertices_mismatch</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Passed vertices original mesh check&quot;</span><span class="p">)</span>
            
            
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Face and Vertices check time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;soma_meshes_face_idx&quot;</span><span class="p">]]</span>
<span class="w">        </span>
<span class="w">        </span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        b) soma_to_piece_connectivity</span>
<span class="sd">        Data: soma_to_piece_connectivity</span>
<span class="sd">        Process: None</span>

<span class="sd">        c) soma_sdfs</span>
<span class="sd">        Data: soma_sdfs</span>
<span class="sd">        Process: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">]</span>
        
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volumes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;soma_volumes&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_synapses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;soma_synapses&quot;</span><span class="p">,</span>
                                                                    <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">]))</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;mesh_errored_synapses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mesh_errored_synapses&quot;</span><span class="p">,[])</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;distance_errored_synapses&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;distance_errored_synapses&quot;</span><span class="p">,[])</span>
        
                                                
        
        <span class="k">if</span> <span class="s2">&quot;soma_volume_ratios&quot;</span> <span class="ow">in</span>  <span class="n">loaded_compression</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;using precomputed soma_volume_ratios&quot;</span><span class="p">)</span>
            <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_volume_ratios&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original Soma mesh time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        d) insignificant_limbs</span>
<span class="sd">        Data: insignificant_limbs_face_idx</span>
<span class="sd">        Process: use submesh on the neuron mesh for each</span>

<span class="sd">        d) non_soma_touching_meshes</span>
<span class="sd">        Data: non_soma_touching_meshes_face_idx</span>
<span class="sd">        Process: use submesh on the neuron mesh for each</span>

<span class="sd">        d) inside_pieces</span>
<span class="sd">        Data: inside_pieces_face_idx</span>
<span class="sd">        Process: use submesh on the neuron mesh for each</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;insignificant_limbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;insignificant_limbs_face_idx&quot;</span><span class="p">]]</span>
        
        
        
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;not_processed_soma_containing_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;not_processed_soma_containing_meshes_face_idx&quot;</span><span class="p">]]</span>
        
        
        
        
        <span class="k">if</span> <span class="s2">&quot;glia_faces&quot;</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">curr_glia</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;glia_faces&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_glia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;glia_faces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_glia</span>
        
        
        <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">curr_labels</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_labels</span>
        
        
        

        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;non_soma_touching_meshes_face_idx&quot;</span><span class="p">]]</span>

        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;inside_pieces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;inside_pieces_face_idx&quot;</span><span class="p">]]</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Insignificant and Not-processed and glia time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        e) limb_meshes</span>
<span class="sd">        Data: limb_meshes_face_idx</span>
<span class="sd">        Process: use submesh on the neuron mesh for each</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;limb_meshes_face_idx&quot;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb meshes time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        f) limb_correspondence</span>
<span class="sd">        Data: new_limb_correspondence</span>
<span class="sd">        Process: </span>
<span class="sd">        -- get branch mesh for each item</span>
<span class="sd">        --&gt; later can recover the branch_mesh from the whole neuron mesh and the new branch_face_idx</span>
<span class="sd">        -- get branch_face_idx for each itme</span>
<span class="sd">        --&gt; regenerate the and branch_face_idx from the recovered limb mesh and he recovered mesh</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_limb_correspondence</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;new_limb_correspondence&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_limb_correspondence</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">comb_meshes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Working on branch </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx_whole_neuron&quot;</span><span class="p">]],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                
                <span class="k">try</span><span class="p">:</span>
                    
                    <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> 
                                               <span class="n">submesh</span><span class="o">=</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="p">,</span>
                                           <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="c1">#Then try using the stitched meshes</span>
                    <span class="c1">#possible_non_touching_meshes = [c for c in recovered_preprocessed_data[&quot;non_soma_touching_meshes&quot;] if len(c.faces) == len(new_limb_correspondence[k][j][&quot;branch_mesh&quot;].faces)]</span>
                    <span class="n">possible_non_touching_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)]</span>
                    <span class="n">found_match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">t_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possible_non_touching_meshes</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">t_mesh</span><span class="p">,</span> 
                                                   <span class="n">submesh</span><span class="o">=</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="p">,</span>
                                               <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">found_match</span><span class="o">=</span><span class="kc">True</span>
                            <span class="k">break</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Viable Non soma touching mesh(</span><span class="si">{</span><span class="n">zz</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">t_mesh</span><span class="si">}</span><span class="s2"> was not a match&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_match</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">comb_meshes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">comb_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">])</span>
                            <span class="n">comb_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">comb_meshes</span><span class="p">)</span>
                        <span class="c1">#print(f&quot;comb_meshes = {comb_meshes}&quot;)</span>
                        <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span>
                                <span class="n">original_mesh</span><span class="o">=</span><span class="n">comb_meshes</span><span class="p">,</span> 
                                                   <span class="n">submesh</span><span class="o">=</span><span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">],</span>
                                               <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1">#                         except:</span>
<span class="c1">#                             raise Exception(f&#39;Could Not find matching faces on decompression of mesh {new_limb_correspondence[k][j][&quot;branch_mesh&quot;]}&#39;)</span>
                    


                <span class="k">if</span> <span class="s2">&quot;branch_face_idx_whole_neuron&quot;</span> <span class="ow">in</span> <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">del</span> <span class="n">new_limb_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_face_idx_whole_neuron&quot;</span><span class="p">]</span>

        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_limb_correspondence</span>

        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb Correspondence = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># ------------------ This is old way of restoring the limb concept networks but won&#39;t work now ------------- #</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        g) limb_concept_networks, limb_labels:</span>
<span class="sd">        Data: All previous data</span>
<span class="sd">        Process: Call the funciton that creates the concept_networks using all the data above</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="sd">        limb_concept_networks,limb_labels = generate_limb_concept_networks_from_global_connectivity(</span>
<span class="sd">                limb_correspondence = recovered_preprocessed_data[&quot;limb_correspondence&quot;],</span>
<span class="sd">                #limb_idx_to_branch_meshes_dict = limb_idx_to_branch_meshes_dict,</span>
<span class="sd">                #limb_idx_to_branch_skeletons_dict = limb_idx_to_branch_skeletons_dict,</span>

<span class="sd">                soma_meshes=recovered_preprocessed_data[&quot;soma_meshes&quot;],</span>
<span class="sd">                soma_idx_connectivity=recovered_preprocessed_data[&quot;soma_to_piece_connectivity&quot;] ,</span>
<span class="sd">                #soma_idx_to_mesh_dict = soma_idx_to_mesh_dict,</span>
<span class="sd">                #soma_idx_connectivity = soma_idx_connectivity,</span>

<span class="sd">                current_neuron=original_mesh,</span>
<span class="sd">                return_limb_labels=True</span>
<span class="sd">                )</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># ----------------- ------------- #</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode for limb concept networks</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">limb_network_stating_info</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span>
        
        <span class="n">limb_concept_networks</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">limb_labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">new_limb_correspondence_indiv</span> <span class="ow">in</span> <span class="n">new_limb_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">new_limb_correspondence_indiv</span><span class="p">,</span>
                                                                                <span class="n">limb_network_stating_info</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">],</span>
                                                                                <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                               <span class="p">)</span>   



            <span class="n">limb_concept_networks</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_to_soma_concept_networks</span>
            <span class="n">limb_labels</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;calculating limb networks = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_concept_networks</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_labels</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_network_stating_info</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        h) get the segment ids and the original description</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;computed_attribute_dict&quot;</span> <span class="ow">in</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">computed_attribute_dict</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;computed_attribute_dict&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">computed_attribute_dict</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#return computed_attribute_dict</span>
        
        <span class="c1"># ------ 6/11: Adding in the nucleus id </span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">recovered_preprocessed_data</span><span class="p">[</span><span class="s2">&quot;split_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;split_index&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        
        <span class="n">pipeline_products</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pipeline_products&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Now create the neuron from preprocessed data</span>
        <span class="n">decompressed_neuron</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span>
            <span class="n">mesh</span><span class="o">=</span><span class="n">original_mesh</span><span class="p">,</span>
            <span class="n">segment_id</span><span class="o">=</span><span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;segment_id&quot;</span><span class="p">],</span>
            <span class="n">description</span><span class="o">=</span><span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">],</span>
            <span class="n">decomposition_type</span> <span class="o">=</span> <span class="n">loaded_compression</span><span class="p">[</span><span class="s2">&quot;decomposition_type&quot;</span><span class="p">],</span>
            <span class="n">preprocessed_data</span><span class="o">=</span><span class="n">recovered_preprocessed_data</span><span class="p">,</span>
            <span class="n">computed_attribute_dict</span> <span class="o">=</span> <span class="n">computed_attribute_dict</span><span class="p">,</span>
            <span class="n">suppress_output</span><span class="o">=</span><span class="n">suppress_output</span><span class="p">,</span>
            <span class="n">calculate_spines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">widths_to_calculate</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">original_mesh_idx</span><span class="o">=</span><span class="n">original_mesh_idx</span><span class="p">,</span>
            <span class="n">pipeline_products</span><span class="o">=</span><span class="n">pipeline_products</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sending to Neuron Object = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decompr_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">decompr_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            
        
    <span class="c1"># if pipeline_products is not None:</span>
    <span class="c1">#     decompressed_neuron.pipeline_products = pipeline_products</span>
    
    <span class="k">return</span> <span class="n">decompressed_neuron</span></div>

<span class="c1"># --------------  END OF COMPRESSION OF NEURON ---------------- #</span>

<span class="c1"># --------------  7/23 To help with visualizations of neuron ---------------- #</span>

<div class="viewcode-block" id="get_whole_neuron_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_whole_neuron_skeleton">[docs]</a><span class="k">def</span> <span class="nf">get_whole_neuron_skeleton</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                             <span class="n">check_connected_component</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate the entire skeleton with limbs stitched to the somas</span>
<span class="sd">    of a neuron object</span>
<span class="sd">    </span>
<span class="sd">    Example Use: </span>
<span class="sd">    </span>
<span class="sd">    total_neuron_skeleton = nru.get_whole_neuron_skeleton(current_neuron = recovered_neuron)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[current_neuron.mesh],</span>
<span class="sd">                              other_skeletons = [total_neuron_skeleton])</span>
<span class="sd">                              </span>
<span class="sd">    Ex 2: </span>
<span class="sd">    nru = reload(nru)</span>
<span class="sd">    returned_skeleton = nru.get_whole_neuron_skeleton(recovered_neuron,print_flag=True)</span>
<span class="sd">    sk.graph_skeleton_and_mesh(other_skeletons=[returned_skeleton])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_skeletons_total</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Working on limb: </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        <span class="c1">#stack the new skeleton pieces with the current skeleton </span>
        <span class="n">curr_limb_skeleton</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">(</span><span class="n">check_connected_component</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb_skeleton.shape = </span><span class="si">{</span><span class="n">curr_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">limb_skeletons_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_skeleton</span><span class="p">)</span>

    <span class="c1">#get the soma skeletons</span>
    <span class="n">soma_skeletons_total</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">soma_idx</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Working on soma: </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#get the soma skeletons</span>
        <span class="n">curr_soma_skeleton</span> <span class="o">=</span> <span class="n">get_soma_skeleton</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">soma_name</span><span class="o">=</span><span class="n">soma_idx</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for soma </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">, curr_soma_skeleton.shape = </span><span class="si">{</span><span class="n">curr_soma_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">soma_skeletons_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_soma_skeleton</span><span class="p">)</span>

    <span class="n">total_neuron_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">limb_skeletons_total</span> <span class="o">+</span> <span class="n">soma_skeletons_total</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_connected_component</span><span class="p">:</span>
        <span class="n">sk</span><span class="o">.</span><span class="n">check_skeleton_one_component</span><span class="p">(</span><span class="n">total_neuron_skeleton</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total_neuron_skeleton</span></div>

<div class="viewcode-block" id="get_soma_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_soma_skeleton">[docs]</a><span class="k">def</span> <span class="nf">get_soma_skeleton</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">soma_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to return the skeleton for a soma that goes from the </span>
<span class="sd">    soma center to all of the connecting limb</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get all of the limbs connecting to the soma (through the concept network)</span>
<span class="sd">    2) get the starting coordinate for that soma</span>
<span class="sd">    For all of the limbs connected</span>
<span class="sd">    3) Make the soma center to that starting coordinate a segment</span>
<span class="sd">    </span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) get all of the limbs connecting to the soma (through the concept network)</span>
    <span class="n">limbs_connected_to_soma</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">soma_name</span><span class="p">,</span><span class="n">int_label</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#2) get the starting coordinate for that soma</span>
    <span class="n">curr_soma_center</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
    
    <span class="c1">#For all of the limbs connected</span>
    <span class="c1">#3) Make the soma center to that starting coordinate a segment</span>
    <span class="n">soma_skeleton_pieces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limbs_connected_to_soma</span><span class="p">:</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        
        <span class="n">curr_starting_coordinate</span> <span class="o">=</span> <span class="p">[</span><span class="n">cn_data</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cn_data</span> <span class="ow">in</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span>
                                                    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">cn_data</span><span class="p">[</span><span class="s1">&#39;starting_soma&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">==</span> <span class="n">soma_name</span><span class="p">]</span>
<span class="c1">#         if len(curr_starting_coordinate) != 1:</span>
<span class="c1">#             raise Exception(f&quot;curr_starting_coordinate not exactly one element: {curr_starting_coordinate}&quot;)</span>
        
        <span class="k">for</span> <span class="n">curr_endpoint</span> <span class="ow">in</span> <span class="n">curr_starting_coordinate</span><span class="p">:</span>
            <span class="n">new_skeleton_piece</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">curr_soma_center</span><span class="p">,</span><span class="n">curr_endpoint</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">soma_skeleton_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_skeleton_piece</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">soma_skeleton_pieces</span><span class="p">)</span></div>


<span class="c1"># def get_soma_skeleton_for_limb(current_neuron,limb_idx):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Purpose: To get the extra piece of skeleton</span>
<span class="c1">#     associated with that limb for all of those soma it connects to</span>
    

<span class="c1">#     &quot;&quot;&quot;</span>
    
<span class="c1">#     #</span>
    
<span class="c1">#     soma_to_starting_dict = dict()</span>
<span class="c1">#     for cn_data in curr_limb_obj.all_concept_network_data:</span>
<span class="c1">#         soma_to_starting_dict[cn_data[&quot;starting_soma&quot;]] = cn_data[&quot;starting_coordinate&quot;]</span>

<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     will generate the new skeleton stitches</span>


<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     new_skeleton_pieces = []</span>
<span class="c1">#     for curr_soma,curr_endpoint in soma_to_starting_dict.items():</span>
<span class="c1">#         curr_soma_center = current_neuron.concept_network.nodes[f&quot;S{curr_soma}&quot;][&quot;data&quot;].mesh_center</span>
<span class="c1">#         #print(f&quot;curr_soma_center = {curr_soma_center}&quot;)</span>
<span class="c1">#         new_skeleton_piece = np.vstack([curr_soma_center,curr_endpoint]).reshape(-1,2,3)</span>
<span class="c1">#         new_skeleton_pieces.append(new_skeleton_piece)</span>
<span class="c1">#         #print(f&quot;new_skeleton_piece = {new_skeleton_piece}&quot;)</span>

    
<span class="c1">#     return new_skeleton_pieces</span>


<div class="viewcode-block" id="soma_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.soma_label">[docs]</a><span class="k">def</span> <span class="nf">soma_label</span><span class="p">(</span><span class="n">name_input</span><span class="p">,</span> <span class="n">force_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name_input</span>
    <span class="k">if</span> <span class="n">force_int</span><span class="p">:</span>
        <span class="n">name_input</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">name_input</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved unexpected type (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span><span class="si">}</span><span class="s2">) for soma name&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="limb_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_label">[docs]</a><span class="k">def</span> <span class="nf">limb_label</span><span class="p">(</span><span class="n">name_input</span><span class="p">,</span><span class="n">force_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name_input</span>
    <span class="k">if</span> <span class="n">force_int</span><span class="p">:</span>
        <span class="n">name_input</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved unexpected type (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span><span class="si">}</span><span class="s2">) for limb name&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="limb_idx"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_idx">[docs]</a><span class="k">def</span> <span class="nf">limb_idx</span><span class="p">(</span><span class="n">name_input</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">name_input</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved unexpected type (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name_input</span><span class="p">)</span><span class="si">}</span><span class="s2">) for limb name&quot;</span><span class="p">)</span></div>
    
    
<span class="c1"># --------------- 8/5 --------------------------#</span>
<div class="viewcode-block" id="branch_mesh_no_spines"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_mesh_no_spines">[docs]</a><span class="k">def</span> <span class="nf">branch_mesh_no_spines</span><span class="p">(</span><span class="n">branch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the branch mesh without any spines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_mesh_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">branch</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">spines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ex_branch_no_spines_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">spines</span><span class="p">),</span>
                                   <span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                                                            <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">original_mesh_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">original_mesh_flag</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">original_mesh_flag</span><span class="p">:</span>
        <span class="n">ex_branch_no_spines_mesh</span> <span class="o">=</span> <span class="n">branch</span><span class="o">.</span><span class="n">mesh</span>
        
    <span class="k">return</span> <span class="n">ex_branch_no_spines_mesh</span></div>

<span class="c1">#xu.endpoint_connectivity(end_1,end_2)</span>


<span class="c1"># ---------------------- 8/31: For querying and axon searching --------------------------- #</span>
<div class="viewcode-block" id="branch_skeletal_distance_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_skeletal_distance_from_soma">[docs]</a><span class="k">def</span> <span class="nf">branch_skeletal_distance_from_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                       <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">dict_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">use_limb_copy</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                      <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the distance of a branch from the specified somas</span>
<span class="sd">    as measured by the skeletal distance</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode</span>
<span class="sd">    1) Make a copy of the current limb</span>
<span class="sd">    2) Get all of the somas that will be processed </span>
<span class="sd">    (either specified or by default will )</span>
<span class="sd">    3) For each soma, find the skeletal distance from that branch to that soma and save in dictioanry</span>
<span class="sd">    4) if not asked to return dictionary then just return the minimum distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">use_limb_copy</span><span class="p">:</span>
        <span class="n">curr_limb_copy</span> <span class="o">=</span>  <span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_copy</span> <span class="o">=</span> <span class="n">curr_limb</span>
    
    <span class="c1">#0) Create dictionary that will store all of the results</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="c1">#For each directional concept network</span>
    <span class="k">if</span> <span class="n">somas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">somas</span><span class="p">):</span>
            <span class="n">somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">somas</span><span class="p">]</span>
        <span class="n">touching_somas</span> <span class="o">=</span> <span class="n">somas</span>
        
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;touching_somas = </span><span class="si">{</span><span class="n">touching_somas</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">curr_st_data</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
        <span class="n">sm_start</span> <span class="o">=</span> <span class="n">curr_st_data</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">sm_group_start</span> <span class="o">=</span> <span class="n">curr_st_data</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">sm_start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
            <span class="k">continue</span>
            
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Working on soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">sm_start</span><span class="p">,</span><span class="n">sm_group_start</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb (</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">) was not connected to soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2"> accordinag to all concept networks&quot;</span><span class="p">)</span>
        
        <span class="n">curr_directional_network</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network_directional</span>
        <span class="n">starting_node</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">current_starting_node</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_node = </span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_directional_network</span><span class="p">,</span><span class="n">starting_node</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_idx </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> did not have a path to soma </span><span class="si">{</span><span class="n">sm</span><span class="si">}</span><span class="s2">, so making distance np.inf&quot;</span><span class="p">)</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">sm_start</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">continue</span>
            
        <span class="n">path_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_directional_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_length = </span><span class="si">{</span><span class="n">path_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">return_dict</span><span class="p">[</span><span class="n">sm_start</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_length</span>
    
    <span class="c1">#once have the final dictionary either return the dictionary or the minimum path</span>
    <span class="k">if</span> <span class="n">dict_return</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_dict</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1">#return the minimum path length</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">return_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div>
    

<span class="c1"># ------------------------------ 9/1 To help with mesh correspondence -----------------------------------------------------#</span>


<div class="viewcode-block" id="apply_adaptive_mesh_correspondence_to_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.apply_adaptive_mesh_correspondence_to_neuron">[docs]</a><span class="k">def</span> <span class="nf">apply_adaptive_mesh_correspondence_to_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                                <span class="n">apply_sdf_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="n">n_std_dev</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">()):</span>
        
        <span class="n">ex_limb</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">apply_sdf_filter</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using SDF filter&quot;</span><span class="p">)</span>
            <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            
        
        <span class="n">segment_mesh_faces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---- Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> ------&quot;</span><span class="p">)</span>
            <span class="n">ex_branch</span> <span class="o">=</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>

            <span class="c1">#1) get all the neighbors 1 hop away in connectivity</span>
            <span class="c1">#2) Assemble a mesh of all the surrounding neighbors</span>
            <span class="n">one_hop_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">one_hop_neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">two_hop_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">one_hop_neighbors</span><span class="p">])</span>
                <span class="n">branches_for_surround</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">one_hop_neighbors</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">two_hop_neighbors</span><span class="p">))</span>


                <span class="n">surround_mesh_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches_for_surround</span><span class="p">])</span>
                <span class="n">surrounding_mesh</span> <span class="o">=</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">surround_mesh_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1">#3) Send the skeleton and the surrounding mesh to the mesh adaptive distance --&gt; gets back indices</span>
                <span class="n">return_value</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="o">=</span><span class="n">ex_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                     <span class="n">curr_branch_mesh</span><span class="o">=</span><span class="n">surrounding_mesh</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">remaining_indices</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">return_value</span>
                    <span class="n">final_limb_indices</span> <span class="o">=</span> <span class="n">surround_mesh_faces</span><span class="p">[</span><span class="n">remaining_indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#if mesh correspondence couldn&#39;t be found</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh correspondence couldn&#39;t be found so using defaults&quot;</span><span class="p">)</span>
                    <span class="n">final_limb_indices</span> <span class="o">=</span> <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="n">ex_branch</span><span class="o">.</span><span class="n">width</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1">#if mesh correspondence couldn&#39;t be found</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mesh correspondence couldn&#39;t be found so using defaults&quot;</span><span class="p">)</span>
                <span class="n">final_limb_indices</span> <span class="o">=</span> <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">ex_branch</span><span class="o">.</span><span class="n">width</span>



<span class="w">            </span><span class="sd">&quot;&quot;&quot;  How we would get the final mesh  </span>
<span class="sd">            branch_mesh_filtered = ex_limb.mesh.submesh([final_limb_indices],append=True,repair=False) </span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1">#5b) store the width measurement based back in the mesh object</span>
            <span class="n">ex_branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;adaptive&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span>

            <span class="k">if</span> <span class="n">apply_sdf_filter</span><span class="p">:</span>
                <span class="c1">#---------- New step:  Further filter the limb indices</span>
                <span class="n">new_branch_mesh</span> <span class="o">=</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">final_limb_indices</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">new_branch_obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ex_branch</span><span class="p">)</span>
                <span class="n">new_branch_obj</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">new_branch_mesh</span>
                <span class="n">new_branch_obj</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">final_limb_indices</span>

                <span class="n">filtered_branch_mesh</span><span class="p">,</span><span class="n">filtered_branch_mesh_idx</span><span class="p">,</span><span class="n">filtered_branch_sdf_mean</span><span class="o">=</span> <span class="n">sdf_filter</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">=</span><span class="n">new_branch_obj</span><span class="p">,</span>
                                                                                                       <span class="n">curr_limb</span><span class="o">=</span><span class="n">ex_limb</span><span class="p">,</span>
                                                                                                       <span class="n">return_sdf_mean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                                                       <span class="n">ray_inter</span><span class="o">=</span><span class="n">ray_inter</span><span class="p">,</span>
                                                                                                      <span class="n">n_std_dev</span><span class="o">=</span><span class="n">n_std_dev</span><span class="p">)</span>
                <span class="n">final_limb_indices</span> <span class="o">=</span> <span class="n">final_limb_indices</span><span class="p">[</span><span class="n">filtered_branch_mesh_idx</span><span class="p">]</span>
            
            <span class="n">segment_mesh_faces</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_limb_indices</span>

        <span class="c1">#This ends up fixing any conflicts in labeling</span>
        <span class="n">face_lookup</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">segment_mesh_faces</span><span class="p">,</span><span class="n">total_keys</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)))</span>
        <span class="c1">#original_labels = set(list(itertools.chain.from_iterable(list(face_lookup.values()))))</span>
        <span class="c1">#original_labels = gu.get_unique_values_dict_of_lists(face_lookup)</span>
        <span class="n">original_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ex_limb</span><span class="p">))</span>

        <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span><span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                                                        <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                                                                                        <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_labels</span><span class="p">),</span>
                                                                     <span class="n">max_submesh_threshold</span><span class="o">=</span><span class="mi">50000</span><span class="p">)</span>

        <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">face_coloring_copy</span><span class="p">)</span>

        <span class="c1">#now reassign the new divided supmeshes</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">ex_branch</span> <span class="o">=</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>

            <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">divided_submeshes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
            <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
            <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
            
            <span class="c1">#need to change the preprocessed_data to reflect the change</span>
            <span class="n">limb_idx_used</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">current_neuron</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">][</span><span class="n">limb_idx_used</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh</span> 
            <span class="n">current_neuron</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">][</span><span class="n">limb_idx_used</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ex_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span></div>
            
            

<span class="c1"># --- 9/2: Mesh correspondence that helps deal with the meshparty data  ----</span>
<div class="viewcode-block" id="sdf_filter"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.sdf_filter">[docs]</a><span class="k">def</span> <span class="nf">sdf_filter</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">size_threshold</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
               <span class="n">return_sdf_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">ray_inter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">n_std_dev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to eliminate edge parts of meshes that should</span>
<span class="sd">    not be on the branch mesh correspondence</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode</span>
<span class="sd">    The filtering step (Have a size threshold for this maybe?):</span>
<span class="sd">    1) Calculate the sdf values for all parts of the mesh</span>
<span class="sd">    2) Restrict the faces to only thos under mean + 1.5*std_dev</span>
<span class="sd">    3) split the mesh and only keep the biggest one</span>

<span class="sd">    Example: </span>
<span class="sd">    </span>
<span class="sd">    limb_idx = 0</span>
<span class="sd">    branch_idx = 20</span>
<span class="sd">    branch_idx = 3</span>
<span class="sd">    #branch_idx=36</span>
<span class="sd">    filtered_branch_mesh, filtered_branch_mesh_idx = sdf_filter(double_neuron_processed[limb_idx][branch_idx],double_neuron_processed[limb_idx],</span>
<span class="sd">                                                               n_std_dev=1)</span>
<span class="sd">    filtered_branch_mesh.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    

    
    <span class="c1">#1) Calculate the sdf values for all parts of the mesh</span>
    <span class="n">ray_trace_width_array</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">face_inds</span><span class="o">=</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span><span class="n">ray_inter</span><span class="o">=</span><span class="n">ray_inter</span><span class="p">)</span>
    <span class="n">ray_trace_width_array_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ray_trace_width_array</span><span class="p">[</span><span class="n">ray_trace_width_array</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1">#apply the size threshold</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_sdf_mean</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">)),</span><span class="n">ray_trace_width_array_mean</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">))</span>
    
    <span class="c1">#2) Restrict the faces to only thos under mean + 1.5*std_dev</span>
    <span class="n">ray_trace_mask</span> <span class="o">=</span> <span class="n">ray_trace_width_array</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">ray_trace_width_array_mean</span> <span class="o">+</span> <span class="n">n_std_dev</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ray_trace_width_array</span><span class="p">))</span>
    <span class="n">filtered_mesh</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">[</span><span class="n">ray_trace_mask</span><span class="p">]],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    
    <span class="c1">#3) split the mesh and only keep the biggest one</span>
    <span class="n">filtered_split_meshes</span><span class="p">,</span> <span class="n">filtered_split_meshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">filtered_mesh</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_sdf_mean</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filtered_split_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">filtered_split_meshes_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ray_trace_width_array_mean</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filtered_split_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">filtered_split_meshes_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
    
    
<span class="c1"># --------- 9/9 Helps with splitting the mesh limbs ------------ #</span>
<div class="viewcode-block" id="get_limb_to_soma_border_vertices"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_limb_to_soma_border_vertices">[docs]</a><span class="k">def</span> <span class="nf">get_limb_to_soma_border_vertices</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a lookup dictionary indexed by </span>
<span class="sd">    - soma</span>
<span class="sd">    - limb name</span>
<span class="sd">    The will return the vertex coordinates on the border of the soma and limb</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">limb_to_soma_border_by_soma</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">soma_name</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">():</span>

        <span class="n">soma_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">soma_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>


        <span class="n">curr_soma_mesh</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="p">[</span><span class="n">soma_label</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)]</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">touching_limbs</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limbs_touching_soma</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)</span>
        <span class="n">touching_limb_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_neuron</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">touching_limbs</span><span class="p">]</span>

        <span class="n">touching_limbs_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">touching_limb_objs</span><span class="p">]</span>
        <span class="n">touching_pieces</span><span class="p">,</span><span class="n">touching_vertices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                <span class="n">central_piece</span> <span class="o">=</span> <span class="n">curr_soma_mesh</span><span class="p">,</span>
                                                <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">touching_limbs_meshes</span><span class="p">,</span>
                                                                 <span class="n">return_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">return_central_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                        <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span>
                                                                                         <span class="p">)</span>
        <span class="n">limb_to_soma_border</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">touching_limbs</span><span class="p">)[</span><span class="n">touching_pieces</span><span class="p">],</span><span class="n">touching_vertices</span><span class="p">)])</span>
        <span class="n">limb_to_soma_border_by_soma</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_to_soma_border</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">limb_to_soma_border_by_soma</span></div>


        
<div class="viewcode-block" id="compute_all_concept_network_data_from_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.compute_all_concept_network_data_from_limb">[docs]</a><span class="k">def</span> <span class="nf">compute_all_concept_network_data_from_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">current_neuron_mesh</span><span class="p">,</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">soma_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                              <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">ex_limb</span> <span class="o">=</span> <span class="n">curr_limb</span>
    
    <span class="n">curr_limb_divided_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ex_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()]</span>
    <span class="n">curr_limb_divided_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">ex_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ex_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()]</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot; Old way of doing it which required the neuron</span>
<span class="sd">    if soma_restriction is None:</span>
<span class="sd">        soma_restriction_names = current_neuron.get_soma_node_names()</span>
<span class="sd">    else:</span>
<span class="sd">        soma_restriction_names = [soma_label(k) for k in soma_restriction]</span>

<span class="sd">    soma_restriction_names_ints = [int(k[1:]) for k in soma_restriction_names]</span>
<span class="sd">    soma_mesh_list = [current_neuron.concept_network.nodes[k][&quot;data&quot;].mesh for k in soma_restriction_names]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">soma_restriction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_mesh_list</span> <span class="o">=</span> <span class="n">soma_meshes</span>
        <span class="n">soma_restriction_names_ints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">soma_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">soma_meshes</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">soma_restriction</span><span class="p">]</span>
        <span class="n">soma_restriction_names_ints</span> <span class="o">=</span> <span class="n">soma_restriction</span>


    <span class="n">derived_concept_network_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_mesh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_restriction_names_ints</span><span class="p">,</span><span class="n">soma_mesh_list</span><span class="p">):</span>
        <span class="n">periph_filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">original_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_divided_meshes</span><span class="p">))</span>


        <span class="n">distances_periphery_to_soma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">closest_distance_between_meshes</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_divided_meshes</span><span class="p">])</span>
        <span class="n">periphery_distance_threshold</span> <span class="o">=</span> <span class="mi">2000</span>

        <span class="n">original_idxs</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">distances_periphery_to_soma</span><span class="o">&lt;</span><span class="n">periphery_distance_threshold</span><span class="p">]</span>
        <span class="n">filtered_periphery_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_limb_divided_meshes</span><span class="p">)[</span><span class="n">distances_periphery_to_soma</span><span class="o">&lt;</span><span class="n">periphery_distance_threshold</span><span class="p">]</span>


        <span class="n">touching_pieces</span><span class="p">,</span><span class="n">touching_vertices</span><span class="p">,</span><span class="n">central_piece_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">current_neuron_mesh</span><span class="p">,</span>
                                    <span class="n">central_piece</span> <span class="o">=</span> <span class="n">soma_mesh</span><span class="p">,</span>
                                    <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">filtered_periphery_meshes</span><span class="p">,</span>
                                                     <span class="n">return_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">return_central_faces</span><span class="o">=</span><span class="kc">True</span>
                                                                             <span class="p">)</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh connectivity = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">periph_filter_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#print(f&quot;touching_pieces = {original_idxs[touching_pieces[0]]}&quot;)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">touching_pieces</span> <span class="o">=</span> <span class="n">original_idxs</span><span class="p">[</span><span class="n">touching_pieces</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;touching_pieces = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**More than one touching point to soma, touching_pieces = </span><span class="si">{touching_pieces}</span><span class="s2">**&quot;</span><span class="p">)</span>
                <span class="c1"># picking the piece with the most shared vertices</span>
                <span class="n">len_touch_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">touching_vertices</span><span class="p">]</span>
                <span class="n">winning_piece_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">len_touch_vertices</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_piece_idx = </span><span class="si">{</span><span class="n">winning_piece_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">touching_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">touching_pieces</span><span class="p">[</span><span class="n">winning_piece_idx</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning touching piece = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">touching_pieces_soma_vertices</span> <span class="o">=</span> <span class="n">touching_vertices</span><span class="p">[</span><span class="n">winning_piece_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">touching_pieces_soma_vertices</span> <span class="o">=</span> <span class="n">touching_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touching_pieces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No touching pieces&quot;</span><span class="p">)</span>

            <span class="c1">#3) With the one that is touching the soma, find the enpoints of the skeleton</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using touching_pieces[0] = </span><span class="si">{</span><span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">touching_branch</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">curr_limb_divided_skeletons</span><span class="p">[</span><span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">endpoints</span> <span class="o">=</span> <span class="n">touching_branch</span><span class="o">.</span><span class="n">endpoints</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;  # -----------  9/1 -------------- #</span>
<span class="sd">            New method for finding </span>
<span class="sd">            1) Build a KDTree of the winning touching piece soma boundary vertices</span>
<span class="sd">            2) query the endpoints against the vertices</span>
<span class="sd">            3) pick the endpoint that has the closest match</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">ex_branch_KDTree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">touching_pieces_soma_vertices</span><span class="p">)</span>
            <span class="n">distances</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">ex_branch_KDTree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
            <span class="n">closest_endpoint</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)]</span>

            <span class="n">derived_concept_network_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">soma_idx</span><span class="p">,</span>
                                                    <span class="n">starting_node</span><span class="o">=</span><span class="n">touching_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="n">starting_endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">,</span>
                                                     <span class="n">starting_coordinate</span><span class="o">=</span><span class="n">closest_endpoint</span><span class="p">,</span>
                                                    <span class="n">touching_soma_vertices</span><span class="o">=</span><span class="n">touching_pieces_soma_vertices</span>
                                               <span class="p">))</span>
    <span class="k">return</span> <span class="n">derived_concept_network_data</span></div>

<div class="viewcode-block" id="error_limb_indexes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.error_limb_indexes">[docs]</a><span class="k">def</span> <span class="nf">error_limb_indexes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="same_soma_multi_touching_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.same_soma_multi_touching_limbs">[docs]</a><span class="k">def</span> <span class="nf">same_soma_multi_touching_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">return_n_touches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">same_soma_multi_touch_limbs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">touch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
            <span class="n">soma_mapping</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">touching_somas</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">touch_idxs</span> <span class="ow">in</span> <span class="n">soma_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">touch_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">touch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">touch_dict</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                    <span class="n">same_soma_multi_touch_limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>
                    <span class="n">touch_dict</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">][</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">touch_idxs</span><span class="p">)</span>
                    <span class="k">break</span>
                
    <span class="k">if</span> <span class="n">return_n_touches</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">touch_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">same_soma_multi_touch_limbs</span><span class="p">)</span></div>
                     

<div class="viewcode-block" id="multi_soma_touching_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.multi_soma_touching_limbs">[docs]</a><span class="k">def</span> <span class="nf">multi_soma_touching_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">multi_soma_touch_limbs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
            <span class="n">soma_mapping</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">touching_somas</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">multi_soma_touch_limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">multi_soma_touch_limbs</span><span class="p">)</span></div>

<div class="viewcode-block" id="error_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.error_limbs">[docs]</a><span class="k">def</span> <span class="nf">error_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return all of the </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">multi_soma_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">multi_touch_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">multi_soma_limbs</span><span class="p">,</span><span class="n">multi_touch_limbs</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span></div>


<span class="c1"># ---- 11/20 functions that will help compute statistics of the neuron object -----------</span>



<div class="viewcode-block" id="n_error_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_error_limbs">[docs]</a><span class="k">def</span> <span class="nf">n_error_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_limb_indexes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span></div>

<div class="viewcode-block" id="n_somas"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_somas">[docs]</a><span class="k">def</span> <span class="nf">n_somas</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="n_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_limbs">[docs]</a><span class="k">def</span> <span class="nf">n_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">())</span></div>

<div class="viewcode-block" id="n_branches_per_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_branches_per_limb">[docs]</a><span class="k">def</span> <span class="nf">n_branches_per_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ex_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">())</span> <span class="k">for</span> <span class="n">ex_limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">]</span></div>

<div class="viewcode-block" id="n_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_branches">[docs]</a><span class="k">def</span> <span class="nf">n_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches_per_limb</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_length_per_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_length_per_limb">[docs]</a><span class="k">def</span> <span class="nf">skeleton_length_per_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">limb</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">]</span></div>

<div class="viewcode-block" id="skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeletal_length">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeleton_length_per_limb</span><span class="p">)</span></div>


<div class="viewcode-block" id="max_limb_n_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.max_limb_n_branches">[docs]</a><span class="k">def</span> <span class="nf">max_limb_n_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches_per_limb</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches_per_limb</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="max_limb_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.max_limb_skeletal_length">[docs]</a><span class="k">def</span> <span class="nf">max_limb_skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeleton_length_per_limb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeleton_length_per_limb</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="all_skeletal_lengths"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_skeletal_lengths">[docs]</a><span class="k">def</span> <span class="nf">all_skeletal_lengths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">all_skeletal_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">:</span>
            <span class="n">curr_branch_sk_len</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
            <span class="n">all_skeletal_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_branch_sk_len</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_skeletal_lengths</span><span class="p">)</span></div>

<div class="viewcode-block" id="median_branch_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.median_branch_length">[docs]</a><span class="k">def</span> <span class="nf">median_branch_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_skeletal_lengths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_skeletal_lengths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)),</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>
    

<span class="c1"># -- width data --</span>
<div class="viewcode-block" id="all_medain_mesh_center_widths"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_medain_mesh_center_widths">[docs]</a><span class="k">def</span> <span class="nf">all_medain_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">all_widths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">:</span>
            <span class="n">curr_width</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curr_width</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">all_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_widths</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_no_spine_median_mesh_center_widths"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_no_spine_median_mesh_center_widths">[docs]</a><span class="k">def</span> <span class="nf">all_no_spine_median_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">all_widths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">:</span>
            <span class="n">curr_width</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curr_width</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">all_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_widths</span><span class="p">)</span></div>

<div class="viewcode-block" id="width_median"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.width_median">[docs]</a><span class="k">def</span> <span class="nf">width_median</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_medain_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_medain_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)),</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="width_no_spine_median"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.width_no_spine_median">[docs]</a><span class="k">def</span> <span class="nf">width_no_spine_median</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_no_spine_median_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">all_no_spine_median_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)),</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="width_perc"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.width_perc">[docs]</a><span class="k">def</span> <span class="nf">width_perc</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">perc</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_medain_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">all_medain_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">),</span><span class="n">perc</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="width_no_spine_perc"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.width_no_spine_perc">[docs]</a><span class="k">def</span> <span class="nf">width_no_spine_perc</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">perc</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_no_spine_median_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">all_no_spine_median_mesh_center_widths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">),</span><span class="n">perc</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<span class="c1"># -- spine data --</span>

<div class="viewcode-block" id="calculate_spines_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.calculate_spines_skeletal_length">[docs]</a><span class="k">def</span> <span class="nf">calculate_spines_skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">sk_len_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_skeletal_length</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">surface_skeleton</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">curr_skeletal_length</span> <span class="o">=</span> <span class="mi">0</span> 

        <span class="n">sk_len_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_skeletal_length</span><span class="p">)</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_skeletal_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk_len_array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sk_len_array</span></div>
    

<div class="viewcode-block" id="n_spines"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_spines">[docs]</a><span class="k">def</span> <span class="nf">n_spines</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">skeletal_length_max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">skeletal_length_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeletal_length_max</span> <span class="o">=</span> <span class="n">skeletal_length_max_n_spines_global</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">skeletal_length_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="s2">&quot;spines_skeletal_length&quot;</span><span class="p">)</span>  <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_skeletal_length</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines</span><span class="p">):</span>
<span class="c1">#                 sk_len_array = []</span>
<span class="c1">#                 for k in neuron_obj.spines:</span>
<span class="c1">#                     try:</span>
<span class="c1">#                         curr_skeletal_length = sk.calculate_skeleton_distance(sk.surface_skeleton(k))</span>
<span class="c1">#                     except:</span>
<span class="c1">#                         curr_skeletal_length = 0 </span>
                        
<span class="c1">#                     sk_len_array.append(curr_skeletal_length)</span>
<span class="c1">#                 neuron_obj.spines_skeletal_length = np.array(sk_len_array)</span>
                
                <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_skeletal_length</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">calculate_spines_skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
                                                                            
                <span class="c1">#neuron_obj.spines_skeletal_length = np.array([sk.calculate_skeleton_distance(sk.surface_skeleton(k)) for k in neuron_obj.spines])</span>
            <span class="n">valid_spine_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_skeletal_length</span><span class="p">)</span><span class="o">&lt;</span><span class="n">skeletal_length_max</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_spine_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="n_boutons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_boutons">[docs]</a><span class="k">def</span> <span class="nf">n_boutons</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">boutons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">boutons</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="n_web"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_web">[docs]</a><span class="k">def</span> <span class="nf">n_web</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">boutons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span></div>
    
<div class="viewcode-block" id="compute_mesh_attribute_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.compute_mesh_attribute_volume">[docs]</a><span class="k">def</span> <span class="nf">compute_mesh_attribute_volume</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                  <span class="n">mesh_attribute</span><span class="p">,</span>
                                 <span class="n">max_hole_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                 <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s2">_volume&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vol_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span>
                   <span class="nb">getattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)]</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s2">_volume&quot;</span><span class="p">,</span><span class="n">vol_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="feature_list_over_object"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.feature_list_over_object">[docs]</a><span class="k">def</span> <span class="nf">feature_list_over_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span>
                            <span class="n">feature_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will compile a list of all of the </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">total_feature</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">feature_name</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">total_feature</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">feature_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">total_feature</span></div>

<div class="viewcode-block" id="compute_feature_over_object"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.compute_feature_over_object">[docs]</a><span class="k">def</span> <span class="nf">compute_feature_over_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span>
                               <span class="n">feature_name</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;compute_</span><span class="si">{</span><span class="n">feature_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)()</span></div>
    
<div class="viewcode-block" id="spine_density"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_density">[docs]</a><span class="k">def</span> <span class="nf">spine_density</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length</span>
    <span class="k">if</span> <span class="n">skeletal_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spine_density</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span><span class="o">/</span><span class="n">skeletal_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_density</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">spine_density</span></div>

<div class="viewcode-block" id="spines_per_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spines_per_branch">[docs]</a><span class="k">def</span> <span class="nf">spines_per_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spines_per_branch</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span><span class="o">/</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spines_per_branch</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">spines_per_branch</span></div>
    
<div class="viewcode-block" id="n_spine_eligible_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_spine_eligible_branches">[docs]</a><span class="k">def</span> <span class="nf">n_spine_eligible_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">n_spine_eligible_branches</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n_spine_eligible_branches</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n_spine_eligible_branches</span></div>

<div class="viewcode-block" id="spine_eligible_branch_lengths"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_eligible_branch_lengths">[docs]</a><span class="k">def</span> <span class="nf">spine_eligible_branch_lengths</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">spine_eligible_branch_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_limb</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">curr_branch_sk_len</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                <span class="n">spine_eligible_branch_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_branch_sk_len</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spine_eligible_branch_lengths</span></div>

<div class="viewcode-block" id="skeletal_length_eligible"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeletal_length_eligible">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_eligible</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_eligible_branch_lengths</span><span class="p">),</span><span class="mi">3</span><span class="p">)</span></div>

<div class="viewcode-block" id="spine_density_eligible"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_density_eligible">[docs]</a><span class="k">def</span> <span class="nf">spine_density_eligible</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="c1">#spine eligible density and per branch</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length_eligible</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spine_density_eligible</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span><span class="o">/</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length_eligible</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_density_eligible</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">return</span> <span class="n">spine_density_eligible</span></div>

<div class="viewcode-block" id="spines_per_branch_eligible"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spines_per_branch_eligible">[docs]</a><span class="k">def</span> <span class="nf">spines_per_branch_eligible</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spines_per_branch_eligible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span><span class="o">/</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spines_per_branch_eligible</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">return</span> <span class="n">spines_per_branch_eligible</span></div>


<span class="c1"># ------- all the spine volume stuff -----------</span>
<div class="viewcode-block" id="total_spine_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.total_spine_volume">[docs]</a><span class="k">def</span> <span class="nf">total_spine_volume</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spines_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_volume</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spines_vol</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="spine_volume_median"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_volume_median">[docs]</a><span class="k">def</span> <span class="nf">spine_volume_median</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">spines_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_volume</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#spine_volume_median</span>
        <span class="n">valid_spine_vol</span> <span class="o">=</span> <span class="n">spines_vol</span><span class="p">[</span><span class="n">spines_vol</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_spine_vol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spine_volume_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">valid_spine_vol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spine_volume_median</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="n">spine_volume_median</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>
    
<div class="viewcode-block" id="spine_volume_density"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_volume_density">[docs]</a><span class="k">def</span> <span class="nf">spine_volume_density</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length_eligible</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spine_volume_density_eligible</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="o">/</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spine_volume_density_eligible</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="n">spine_volume_density_eligible</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="spine_volume_density_eligible"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_volume_density_eligible">[docs]</a><span class="k">def</span> <span class="nf">spine_volume_density_eligible</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spine_volume_density</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="o">/</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length_eligible</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spine_volume_density</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="n">spine_volume_density</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>
    
<div class="viewcode-block" id="spine_volume_per_branch_eligible"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.spine_volume_per_branch_eligible">[docs]</a><span class="k">def</span> <span class="nf">spine_volume_per_branch_eligible</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spine_volume_per_branch_eligible</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="o">/</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spine_volume_per_branch_eligible</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="n">spine_volume_per_branch_eligible</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>
    
    
<span class="c1"># -------------- 11 / 26 To help with erroring------------------------------#</span>


<div class="viewcode-block" id="align_and_restrict_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.align_and_restrict_branch">[docs]</a><span class="k">def</span> <span class="nf">align_and_restrict_branch</span><span class="p">(</span><span class="n">base_branch</span><span class="p">,</span>
                              <span class="n">common_endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">width_name</span><span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                              <span class="n">width_name_backup</span><span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                             <span class="n">offset</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                             <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                             <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_branch</span><span class="o">.</span><span class="n">width_array</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">width_name</span> <span class="o">=</span> <span class="n">width_name_backup</span>
        
    <span class="c1">#Now just need to do the resizing (and so the widths calculated will match this)</span>
    <span class="n">base_skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">base_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">skeleton_segment_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">common_endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#figure out if need to flip or not:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">,</span><span class="n">base_skeleton_ordered</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>

            <span class="n">base_width_ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">base_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">])</span>
            <span class="n">base_skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">base_skeleton_ordered</span><span class="p">)</span>
            <span class="n">flip_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Base needs flipping&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skeleton after flip = </span><span class="si">{</span><span class="n">base_skeleton_ordered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">,</span><span class="n">base_skeleton_ordered</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">base_width_ordered</span> <span class="o">=</span> <span class="n">base_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span>
            <span class="n">flip_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching endpoint&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base_width_ordered</span> <span class="o">=</span> <span class="n">base_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span>
        
    <span class="c1"># apply the cutoff distance</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Base offset = </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    
    <span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">,</span>
     <span class="n">offset_indexes</span><span class="p">,</span>
     <span class="n">offset_success</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">base_skeleton_ordered</span><span class="p">,</span>
                                                                    <span class="n">offset</span><span class="p">,</span>
                                                                     <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
   
    
    <span class="n">base_final_skeleton</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">base_final_indexes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">offset_success</span><span class="p">:</span>
        
        <span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">,</span>
         <span class="n">comparison_indexes</span><span class="p">,</span>
         <span class="n">comparison_success</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">,</span>
                                                                        <span class="n">comparison_distance</span><span class="p">,</span>
                                                                         <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">comparison_success</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Base: Long enough for offset and comparison length&quot;</span><span class="p">)</span>
            <span class="n">base_final_skeleton</span> <span class="o">=</span> <span class="n">skeleton_comparison</span>
            <span class="n">base_final_indexes</span> <span class="o">=</span> <span class="n">offset_indexes</span><span class="p">[</span><span class="n">comparison_indexes</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Base: Passed the offset phase but was not long enough for comparison&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Base: Was not long enough for offset&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">base_final_skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Base: Not using offset &quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">base_final_skeleton</span><span class="p">,</span>
         <span class="n">base_final_indexes</span><span class="p">,</span>
         <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">base_skeleton_ordered</span><span class="p">,</span>
                                                                        <span class="n">comparison_distance</span><span class="p">,</span>
                                                                         <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        

    
    <span class="n">base_final_widths</span> <span class="o">=</span> <span class="n">base_width_ordered</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">base_final_indexes</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">base_width_ordered</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">base_final_seg_lengths</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">base_final_skeleton</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">base_final_skeleton</span><span class="p">,</span><span class="n">base_final_widths</span><span class="p">,</span><span class="n">base_final_seg_lengths</span></div>

<div class="viewcode-block" id="branch_boundary_transition_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_boundary_transition_old">[docs]</a><span class="k">def</span> <span class="nf">branch_boundary_transition_old</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                              <span class="n">edge</span><span class="p">,</span>
                              <span class="n">width_name</span><span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                            <span class="n">width_name_backup</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                              <span class="n">offset</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                              <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                              <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                              <span class="n">return_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the boundary skeletons and width average at the boundary</span>
<span class="sd">    with some specified boundary skeletal length (with an optional offset)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">base_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">upstream_node</span><span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">upstream_node_original</span> <span class="o">=</span> <span class="n">upstream_node</span>

    <span class="n">base_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">base_node</span><span class="p">]</span>
    <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span>


    <span class="c1"># 0) make sure the two nodes are connected in the concept network</span>
    <span class="k">if</span> <span class="n">base_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;base_node (</span><span class="si">{</span><span class="n">base_node</span><span class="si">}</span><span class="s2">) and upstream_node (</span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">) are not connected in the concept network&quot;</span><span class="p">)</span>

    <span class="c1"># ----- Part 1: Do the processing on the base node -------------- #</span>
    <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">base_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">common_endpoint_original</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;common_endpoint = </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="p">(</span><span class="n">base_final_skeleton</span><span class="p">,</span>
    <span class="n">base_final_widths</span><span class="p">,</span>
    <span class="n">base_final_seg_lengths</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_and_restrict_branch</span><span class="p">(</span><span class="n">base_branch</span><span class="p">,</span>
                              <span class="n">common_endpoint</span><span class="o">=</span><span class="n">common_endpoint</span><span class="p">,</span>
                                 <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                                <span class="n">width_name_backup</span><span class="o">=</span><span class="n">width_name_backup</span><span class="p">,</span>
                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                             <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                             <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="n">skeleton_segment_size</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                             <span class="p">)</span>
    
    
    
    
    
    

    <span class="c1"># ----- Part 2: Do the processing on the upstream nodes -------------- #</span>
    <span class="n">upstream_offset</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="n">upstream_comparison</span> <span class="o">=</span> <span class="n">comparison_distance</span>
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">previous_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">upstream_skeleton</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upstream_seg_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upstream_seg_widths</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">upstream_comparison</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        1) Get shared endpoint of upstream and previous node</span>
<span class="sd">        2) resize the upstream skeleton to get it ordered and right scale of width</span>
<span class="sd">        3) Flip the skeleton and width array if needs to be flipped</span>
<span class="sd">        4) if current offset is greater than 0, then restrict skeelton to offset:</span>
<span class="sd">        5a) if it was not long enough:</span>
<span class="sd">            - subtact total length from buffer</span>
<span class="sd">        5b) If successful:</span>
<span class="sd">            - restrit skeleton by comparison distance</span>
<span class="sd">            - Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            - subtract new distance from comparison distance</span>
<span class="sd">            - if comparison distance is 0 or less then break</span>
<span class="sd">        6)  change out upstream node and previous node (because at this point haven&#39;t broken outside loop)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Upstream iteration: </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> -----&quot;</span><span class="p">)</span>
        <span class="n">prev_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">previous_node</span><span class="p">]</span>
        <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span>

        <span class="c1">#1) Get shared endpoint of upstream and previous node</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">prev_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

        <span class="c1">#2) resize the upstream skeleton to get it ordered and right scale of width</span>
        <span class="n">upstream_skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">skeleton_segment_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_skeleton_ordered </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">upstream_skeleton_ordered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        
          <span class="c1"># ----------- 1 /5 : To prevent from erroring when indexing into width</span>
<span class="c1">#         #accounting for the fact that the skeleton might be a little longer thn the width array now</span>
<span class="c1">#         upstream_width = upstream_branch.width_array[width_name]</span>
<span class="c1">#         extra_width_segment = [upstream_width[-1]]*(len(upstream_skeleton_ordered)-len(upstream_width))</span>
<span class="c1">#         upstream_width = np.hstack([upstream_width,extra_width_segment])</span>
         

        <span class="c1">#3) Flip the skeleton and width array if needs to be flipped</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">,</span><span class="n">upstream_skeleton_ordered</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">upstream_width_ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">])</span>
            <span class="n">upstream_skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">)</span>
            <span class="n">flip_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">,</span><span class="n">upstream_skeleton_ordered</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">upstream_width_ordered</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span>
            <span class="n">flip_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching endpoint&quot;</span><span class="p">)</span>

            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;flip_flag = </span><span class="si">{</span><span class="n">flip_flag</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_offset = </span><span class="si">{</span><span class="n">upstream_offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#4) if current offset is greater than 0, then restrict skeelton to offset:</span>
        <span class="k">if</span> <span class="n">upstream_offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Restricting to offset&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">,</span>
             <span class="n">offset_indexes</span><span class="p">,</span>
             <span class="n">offset_success</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">,</span>
                                                                            <span class="n">upstream_offset</span><span class="p">,</span>
                                                                             <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the upstream offset because 0&quot;</span><span class="p">)</span>
            <span class="n">skeleton_minus_buffer</span> <span class="o">=</span> <span class="n">upstream_skeleton_ordered</span>
            <span class="n">offset_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">))</span>
            <span class="n">offset_success</span> <span class="o">=</span> <span class="kc">True</span>
        
        
        <span class="c1">#print(f&quot;skeleton_minus_buffer {sk.calculate_skeleton_distance(skeleton_minus_buffer)} = {skeleton_minus_buffer}&quot;)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        5a) if it was not long enough:</span>
<span class="sd">        - subtact total length from buffer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offset_success</span><span class="p">:</span>
            <span class="n">upstream_offset</span> <span class="o">-=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subtracting the offset was not successful so changing to </span><span class="si">{</span><span class="n">upstream_offset</span><span class="si">}</span><span class="s2"> and reiterating&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            5b) If successful:</span>
<span class="sd">            - restrit skeleton by comparison distance</span>
<span class="sd">            - Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            - subtract new distance from comparison distance</span>
<span class="sd">            - if comparison distance is 0 or less then break</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1">#making sure the upstream offset is 0 if we were successful</span>
            <span class="n">upstream_offset</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After subtracting the offset the length is: </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#- restrit skeleton by comparison distance</span>
            <span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">,</span>
             <span class="n">comparison_indexes</span><span class="p">,</span>
             <span class="n">comparison_success</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">,</span>
                                                                            <span class="n">upstream_comparison</span><span class="p">,</span>
                                                                             <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#- Add skeleton, width and skeelton lengths to list</span>
            <span class="n">upstream_skeleton</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">)</span>
            <span class="n">upstream_seg_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

            
            <span class="n">upstream_indices</span> <span class="o">=</span> <span class="n">offset_indexes</span><span class="p">[</span><span class="n">comparison_indexes</span><span class="p">]</span>
            <span class="n">upstream_seg_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upstream_width_ordered</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">upstream_indices</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">upstream_width_ordered</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">])</span>

            <span class="c1"># - subtract new distance from comparison distance</span>
            <span class="n">upstream_comparison</span> <span class="o">-=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comparison_success</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subtracting the comparison was successful and exiting&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subtracting the comparison was not successful so changing to </span><span class="si">{</span><span class="n">upstream_comparison</span><span class="si">}</span><span class="s2"> and reiterating&quot;</span><span class="p">)</span>

        <span class="c1">#6)  change out upstream node and previous node (because at this point haven&#39;t broken outside loop)</span>
        <span class="n">previous_node</span> <span class="o">=</span> <span class="n">upstream_node</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New upstream_node = </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Breaking because hit None upstream node&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">upstream_final_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">upstream_skeleton</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_final_skeleton = </span><span class="si">{</span><span class="n">upstream_final_skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Do a check at the very end and if no skeleton then just take that branches</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upstream_final_skeleton</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No upstream skeletons so doing backup&quot;</span><span class="p">)</span>
        <span class="n">resize_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                       <span class="n">skeleton_segment_size</span><span class="p">)</span>
        <span class="n">upstream_skeleton</span> <span class="o">=</span> <span class="p">[</span><span class="n">resize_sk</span><span class="p">]</span>
        <span class="n">upstream_seg_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">resize_sk</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
        <span class="n">upstream_seg_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">]</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">]]</span>
        
        <span class="p">(</span><span class="n">upstream_final_skeleton</span><span class="p">,</span>
         <span class="n">upstream_final_widths</span><span class="p">,</span>
        <span class="n">upstream_final_seg_lengths</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_and_restrict_branch</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">],</span>
                                  <span class="n">common_endpoint</span><span class="o">=</span><span class="n">common_endpoint_original</span><span class="p">,</span>
                                <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                                 <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                 <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                 <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="n">skeleton_segment_size</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                 <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upstream_final_seg_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">upstream_seg_lengths</span><span class="p">)</span>
        <span class="n">upstream_final_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">upstream_seg_widths</span><span class="p">)</span>




    <span class="c1">#Final results</span>
    <span class="n">base_final_skeleton</span>
    <span class="n">base_final_widths</span>
    <span class="n">base_final_seg_lengths</span>

    <span class="n">upstream_skeleton</span> 
    <span class="n">upstream_seg_lengths</span> 
    <span class="n">upstream_seg_widths</span>

    <span class="n">base_final_skeleton</span>
    

    <span class="n">base_width_average</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">average_by_weights</span><span class="p">(</span><span class="n">weights</span> <span class="o">=</span> <span class="n">base_final_seg_lengths</span><span class="p">,</span>
                                <span class="n">values</span> <span class="o">=</span> <span class="n">base_final_widths</span><span class="p">)</span>
    <span class="n">upstream_width_average</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">average_by_weights</span><span class="p">(</span><span class="n">weights</span> <span class="o">=</span> <span class="n">upstream_final_seg_lengths</span><span class="p">,</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="n">upstream_final_widths</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_skeletons</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">upstream_width_average</span><span class="p">,</span><span class="n">base_width_average</span><span class="p">,</span><span class="n">upstream_final_skeleton</span><span class="p">,</span><span class="n">base_final_skeleton</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">upstream_width_average</span><span class="p">,</span><span class="n">base_width_average</span></div>
    
    
<div class="viewcode-block" id="branch_boundary_transition"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_boundary_transition">[docs]</a><span class="k">def</span> <span class="nf">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                              <span class="n">edge</span><span class="p">,</span>
                                   <span class="n">upstream_common_endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">downstream_common_endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">width_name</span><span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                               <span class="n">width_name_backup</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                              <span class="n">offset</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                              <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                              <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                              <span class="n">return_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">error_on_no_network_connection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the boundary skeletons and width average at the boundary</span>
<span class="sd">    with some specified boundary skeletal length (with an optional offset)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">base_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">upstream_node</span><span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">upstream_node_original</span> <span class="o">=</span> <span class="n">upstream_node</span>

    <span class="n">base_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">base_node</span><span class="p">]</span>
    
    <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span>


    <span class="c1"># 0) make sure the two nodes are connected in the concept network</span>
    
    <span class="k">if</span> <span class="n">base_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">):</span>
        <span class="n">warning_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;base_node (</span><span class="si">{</span><span class="n">base_node</span><span class="si">}</span><span class="s2">) and upstream_node (</span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">) are not connected in the concept network&quot;</span>
        <span class="k">if</span> <span class="n">error_on_no_network_connection</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>

    <span class="c1"># ----- Part 1: Do the processing on the base node -------------- #</span>
    
    <span class="k">if</span> <span class="n">upstream_common_endpoint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">downstream_common_endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">base_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">common_endpoint_original</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;common_endpoint = </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">non_common_endpoints_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_common_endpoint = </span><span class="si">{</span><span class="n">upstream_common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_common_endpoint = </span><span class="si">{</span><span class="n">downstream_common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">common_endpoint_original</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">upstream_common_endpoint</span><span class="p">)</span>
        <span class="n">non_common_endpoints_flag</span> <span class="o">=</span> <span class="kc">True</span>
            
    
    <span class="k">if</span> <span class="n">non_common_endpoints_flag</span><span class="p">:</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">downstream_common_endpoint</span>
        
        
    <span class="p">(</span><span class="n">base_final_skeleton</span><span class="p">,</span>
    <span class="n">base_final_widths</span><span class="p">,</span>
    <span class="n">base_final_seg_lengths</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_and_restrict_branch</span><span class="p">(</span><span class="n">base_branch</span><span class="p">,</span>
                              <span class="n">common_endpoint</span><span class="o">=</span><span class="n">common_endpoint</span><span class="p">,</span>
                                 <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                                 <span class="n">width_name_backup</span><span class="o">=</span><span class="n">width_name_backup</span><span class="p">,</span>
                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                             <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                             <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="n">skeleton_segment_size</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                             <span class="p">)</span>
<span class="c1">#     print(f&quot;base_node = {base_node}&quot;)</span>
<span class="c1">#     su.compressed_pickle(base_branch,&quot;base_branch&quot;)</span>
<span class="c1">#     su.compressed_pickle(base_final_skeleton,&quot;base_final_skeleton&quot;)</span>
    
    
    
    
    
    

    <span class="c1"># ----- Part 2: Do the processing on the upstream nodes -------------- #</span>
    <span class="n">upstream_offset</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="n">upstream_comparison</span> <span class="o">=</span> <span class="n">comparison_distance</span>
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">previous_node</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">upstream_skeleton</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upstream_seg_lengths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">upstream_seg_widths</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">upstream_comparison</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        1) Get shared endpoint of upstream and previous node</span>
<span class="sd">        2) resize the upstream skeleton to get it ordered and right scale of width</span>
<span class="sd">        3) Flip the skeleton and width array if needs to be flipped</span>
<span class="sd">        4) if current offset is greater than 0, then restrict skeelton to offset:</span>
<span class="sd">        5a) if it was not long enough:</span>
<span class="sd">            - subtact total length from buffer</span>
<span class="sd">        5b) If successful:</span>
<span class="sd">            - restrit skeleton by comparison distance</span>
<span class="sd">            - Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            - subtract new distance from comparison distance</span>
<span class="sd">            - if comparison distance is 0 or less then break</span>
<span class="sd">        6)  change out upstream node and previous node (because at this point haven&#39;t broken outside loop)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Upstream iteration: </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> -----&quot;</span><span class="p">)</span>
        <span class="n">prev_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">previous_node</span><span class="p">]</span>
        <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span>

        <span class="c1">#1) Get shared endpoint of upstream and previous node</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">non_common_endpoints_flag</span><span class="p">:</span>
            <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">upstream_common_endpoint</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">prev_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

        <span class="c1">#2) resize the upstream skeleton to get it ordered and right scale of width</span>
        <span class="n">upstream_skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">skeleton_segment_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_skeleton_ordered </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">upstream_skeleton_ordered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        
          <span class="c1"># ----------- 1 /5 : To prevent from erroring when indexing into width</span>
<span class="c1">#         #accounting for the fact that the skeleton might be a little longer thn the width array now</span>
<span class="c1">#         upstream_width = upstream_branch.width_array[width_name]</span>
<span class="c1">#         extra_width_segment = [upstream_width[-1]]*(len(upstream_skeleton_ordered)-len(upstream_width))</span>
<span class="c1">#         upstream_width = np.hstack([upstream_width,extra_width_segment])</span>
         

        <span class="c1">#3) Flip the skeleton and width array if needs to be flipped</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">,</span><span class="n">upstream_skeleton_ordered</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">upstream_width_ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">upstream_width_ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name_backup</span><span class="p">])</span>
                
            <span class="n">upstream_skeleton_ordered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">)</span>
            <span class="n">flip_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">,</span><span class="n">upstream_skeleton_ordered</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">upstream_width_ordered</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">upstream_width_ordered</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name_backup</span><span class="p">]</span>
                
            <span class="n">flip_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching endpoint&quot;</span><span class="p">)</span>

            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;flip_flag = </span><span class="si">{</span><span class="n">flip_flag</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_offset = </span><span class="si">{</span><span class="n">upstream_offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#4) if current offset is greater than 0, then restrict skeelton to offset:</span>
        <span class="k">if</span> <span class="n">upstream_offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Restricting to offset&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">,</span>
             <span class="n">offset_indexes</span><span class="p">,</span>
             <span class="n">offset_success</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">,</span>
                                                                            <span class="n">upstream_offset</span><span class="p">,</span>
                                                                             <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the upstream offset because 0&quot;</span><span class="p">)</span>
            <span class="n">skeleton_minus_buffer</span> <span class="o">=</span> <span class="n">upstream_skeleton_ordered</span>
            <span class="n">offset_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">))</span>
            <span class="n">offset_success</span> <span class="o">=</span> <span class="kc">True</span>
        
        
        <span class="c1">#print(f&quot;skeleton_minus_buffer {sk.calculate_skeleton_distance(skeleton_minus_buffer)} = {skeleton_minus_buffer}&quot;)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        5a) if it was not long enough:</span>
<span class="sd">        - subtact total length from buffer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offset_success</span><span class="p">:</span>
            <span class="n">upstream_offset</span> <span class="o">-=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">upstream_skeleton_ordered</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subtracting the offset was not successful so changing to </span><span class="si">{</span><span class="n">upstream_offset</span><span class="si">}</span><span class="s2"> and reiterating&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            5b) If successful:</span>
<span class="sd">            - restrit skeleton by comparison distance</span>
<span class="sd">            - Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            - subtract new distance from comparison distance</span>
<span class="sd">            - if comparison distance is 0 or less then break</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1">#making sure the upstream offset is 0 if we were successful</span>
            <span class="n">upstream_offset</span> <span class="o">=</span> <span class="mi">0</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After subtracting the offset the length is: </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#- restrit skeleton by comparison distance</span>
            <span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">,</span>
             <span class="n">comparison_indexes</span><span class="p">,</span>
             <span class="n">comparison_success</span><span class="p">)</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start</span><span class="p">(</span><span class="n">skeleton_minus_buffer</span><span class="p">,</span>
                                                                            <span class="n">upstream_comparison</span><span class="p">,</span>
                                                                             <span class="n">subtract_cutoff</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1">#- Add skeleton, width and skeelton lengths to list</span>
            <span class="n">upstream_skeleton</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">)</span>
            <span class="n">upstream_seg_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

            
            <span class="n">upstream_indices</span> <span class="o">=</span> <span class="n">offset_indexes</span><span class="p">[</span><span class="n">comparison_indexes</span><span class="p">]</span>
            <span class="n">upstream_seg_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upstream_width_ordered</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">upstream_indices</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">upstream_width_ordered</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">])</span>

            <span class="c1"># - subtract new distance from comparison distance</span>
            <span class="n">upstream_comparison</span> <span class="o">-=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">skeleton_comparison</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">comparison_success</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subtracting the comparison was successful and exiting&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Subtracting the comparison was not successful so changing to </span><span class="si">{</span><span class="n">upstream_comparison</span><span class="si">}</span><span class="s2"> and reiterating&quot;</span><span class="p">)</span>

        <span class="c1">#6)  change out upstream node and previous node (because at this point haven&#39;t broken outside loop)</span>
        <span class="n">previous_node</span> <span class="o">=</span> <span class="n">upstream_node</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New upstream_node = </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Breaking because hit None upstream node&quot;</span><span class="p">)</span>
            <span class="k">break</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">upstream_final_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">upstream_skeleton</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_final_skeleton = </span><span class="si">{</span><span class="n">upstream_final_skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Do a check at the very end and if no skeleton then just take that branches</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upstream_final_skeleton</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No upstream skeletons so doing backup&quot;</span><span class="p">)</span>
        <span class="n">resize_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                       <span class="n">skeleton_segment_size</span><span class="p">)</span>
        <span class="n">upstream_skeleton</span> <span class="o">=</span> <span class="p">[</span><span class="n">resize_sk</span><span class="p">]</span>
        <span class="n">upstream_seg_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">resize_sk</span><span class="p">,</span><span class="n">cumsum</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">upstream_seg_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">]</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name</span><span class="p">]]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">upstream_seg_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">]</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="n">width_name_backup</span><span class="p">]]</span>
        
        <span class="p">(</span><span class="n">upstream_final_skeleton</span><span class="p">,</span>
         <span class="n">upstream_final_widths</span><span class="p">,</span>
        <span class="n">upstream_final_seg_lengths</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_and_restrict_branch</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node_original</span><span class="p">],</span>
                                  <span class="n">common_endpoint</span><span class="o">=</span><span class="n">common_endpoint_original</span><span class="p">,</span>
                                <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
                                 <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                 <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                 <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="n">skeleton_segment_size</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                 <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upstream_final_seg_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">upstream_seg_lengths</span><span class="p">)</span>
        <span class="n">upstream_final_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">upstream_seg_widths</span><span class="p">)</span>




    <span class="c1">#Final results</span>
    <span class="n">base_final_skeleton</span>
    <span class="n">base_final_widths</span>
    <span class="n">base_final_seg_lengths</span>

    <span class="n">upstream_skeleton</span> 
    <span class="n">upstream_seg_lengths</span> 
    <span class="n">upstream_seg_widths</span>

    <span class="n">base_final_skeleton</span>
    

    <span class="n">base_width_average</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">average_by_weights</span><span class="p">(</span><span class="n">weights</span> <span class="o">=</span> <span class="n">base_final_seg_lengths</span><span class="p">,</span>
                                <span class="n">values</span> <span class="o">=</span> <span class="n">base_final_widths</span><span class="p">)</span>
    <span class="n">upstream_width_average</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">average_by_weights</span><span class="p">(</span><span class="n">weights</span> <span class="o">=</span> <span class="n">upstream_final_seg_lengths</span><span class="p">,</span>
                            <span class="n">values</span> <span class="o">=</span> <span class="n">upstream_final_widths</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_skeletons</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">upstream_width_average</span><span class="p">,</span><span class="n">base_width_average</span><span class="p">,</span><span class="n">upstream_final_skeleton</span><span class="p">,</span><span class="n">base_final_skeleton</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">upstream_width_average</span><span class="p">,</span><span class="n">base_width_average</span></div>
    

<span class="n">global_comparison_distance</span> <span class="o">=</span> <span class="mi">3000</span>
<div class="viewcode-block" id="find_parent_child_skeleton_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.find_parent_child_skeleton_angle">[docs]</a><span class="k">def</span> <span class="nf">find_parent_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span>
                            <span class="n">child_node</span><span class="p">,</span>   
                            <span class="n">parent_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="c1">#comparison_distance=3000,</span>
                            <span class="n">comparison_distance</span><span class="o">=</span><span class="n">global_comparison_distance</span><span class="p">,</span>
                            <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">check_upstream_network_connectivity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">plot_extracted_skeletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
<span class="c1">#     print(f&quot;comparison_distance = {comparison_distance}&quot;)</span>
<span class="c1">#     print(f&quot;offset = {offset}&quot;)</span>
    <span class="k">if</span> <span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parent_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">child_node</span><span class="p">)</span>
        
    <span class="c1"># -------Doing the parent calculation---------</span>
    <span class="n">parent_child_edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_node</span><span class="p">,</span><span class="n">child_node</span><span class="p">]</span>

    <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span>
                                      <span class="n">edge</span><span class="o">=</span><span class="n">parent_child_edge</span><span class="p">,</span>
                                      <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1">#check_upstream_network_connectivity=check_upstream_network_connectivity</span>
                                                            <span class="p">)</span>
    <span class="n">up_sk_flipped</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">flip_skeleton</span><span class="p">(</span><span class="n">up_sk</span><span class="p">)</span>

    <span class="n">up_vec</span> <span class="o">=</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">up_sk_flipped</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">d_vec_child</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">parent_child_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">up_vec</span><span class="p">,</span><span class="n">d_vec_child</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_extracted_skeletons</span><span class="p">:</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_node</span><span class="p">,</span><span class="n">child_node</span><span class="p">]</span>
        <span class="n">parent_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">child_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parent (</span><span class="si">{</span><span class="n">parent_node</span><span class="si">}</span><span class="s2">):</span><span class="si">{</span><span class="n">parent_color</span><span class="si">}</span><span class="s2">, child (</span><span class="si">{</span><span class="n">child_node</span><span class="si">}</span><span class="s2">):</span><span class="si">{</span><span class="n">child_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_color</span><span class="p">,</span><span class="n">child_color</span><span class="p">]</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">curr_limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bs</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                         <span class="n">skeletons</span> <span class="o">=</span><span class="p">[</span><span class="n">up_sk_flipped</span><span class="p">,</span><span class="n">d_sk</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        
       

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parent_child_angle = </span><span class="si">{</span><span class="n">parent_child_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">parent_child_angle</span>    </div>



<div class="viewcode-block" id="find_sibling_child_skeleton_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.find_sibling_child_skeleton_angle">[docs]</a><span class="k">def</span> <span class="nf">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span>
                            <span class="n">child_node</span><span class="p">,</span>
                            <span class="n">parent_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="c1">#comparison_distance=3000,</span>
                         <span class="n">comparison_distance</span><span class="o">=</span><span class="n">global_comparison_distance</span><span class="p">,</span>
                            <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    
    <span class="c1"># -------Doing the parent calculation---------</span>
    <span class="k">if</span> <span class="n">parent_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parent_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">child_node</span><span class="p">)</span>
        
    <span class="n">parent_child_edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_node</span><span class="p">,</span><span class="n">child_node</span><span class="p">]</span>

    <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span>
                                      <span class="n">edge</span><span class="o">=</span><span class="n">parent_child_edge</span><span class="p">,</span>
                                      <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="n">d_vec_child</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># -------Doing the child calculation---------</span>
    <span class="n">sibling_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                    <span class="n">child_node</span><span class="p">)</span>
    
    <span class="n">sibl_angles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s_n</span> <span class="ow">in</span> <span class="n">sibling_nodes</span><span class="p">:</span>
        <span class="n">sibling_child_edge</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_node</span><span class="p">,</span><span class="n">s_n</span><span class="p">]</span>

        <span class="n">up_width</span><span class="p">,</span><span class="n">d_width</span><span class="p">,</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span> <span class="o">=</span> <span class="n">branch_boundary_transition</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span>
                                          <span class="n">edge</span><span class="o">=</span><span class="n">sibling_child_edge</span><span class="p">,</span>
                                          <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">up_vec</span> <span class="o">=</span> <span class="n">up_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">up_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">d_vec_sibling</span> <span class="o">=</span> <span class="n">d_sk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">sibling_child_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">d_vec_child</span><span class="p">,</span><span class="n">d_vec_sibling</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="n">sibl_angles</span><span class="p">[</span><span class="n">s_n</span><span class="p">]</span> <span class="o">=</span> <span class="n">sibling_child_angle</span>
        
    <span class="k">return</span> <span class="n">sibl_angles</span></div>
    

<div class="viewcode-block" id="all_concept_network_data_to_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_concept_network_data_to_dict">[docs]</a><span class="k">def</span> <span class="nf">all_concept_network_data_to_dict</span><span class="p">(</span><span class="n">all_concept_network_data</span><span class="p">):</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">st_info</span> <span class="ow">in</span> <span class="n">all_concept_network_data</span><span class="p">:</span>
        <span class="n">curr_soma_idx</span> <span class="o">=</span> <span class="n">st_info</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">curr_soma_group_idx</span> <span class="o">=</span> <span class="n">st_info</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
        <span class="n">curr_endpoint</span> <span class="o">=</span> <span class="n">st_info</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>
        <span class="n">curr_touching_soma_vertices</span> <span class="o">=</span> <span class="n">st_info</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">curr_soma_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">curr_soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="n">return_dict</span><span class="p">[</span><span class="n">curr_soma_idx</span><span class="p">][</span><span class="n">curr_soma_group_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">touching_verts</span><span class="o">=</span><span class="n">curr_touching_soma_vertices</span><span class="p">,</span>
                                                         <span class="n">endpoint</span><span class="o">=</span><span class="n">curr_endpoint</span>
                                                        <span class="p">)</span>
        

            
    <span class="k">return</span> <span class="n">return_dict</span></div>
            
    
<div class="viewcode-block" id="limb_to_soma_mapping"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_to_soma_mapping">[docs]</a><span class="k">def</span> <span class="nf">limb_to_soma_mapping</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will create a mapping of </span>
<span class="sd">    limb --&gt; soma_idx --&gt; list of soma touching groups</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_soma_touch_dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">):</span>
        <span class="n">limb_soma_touch_dictionary</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">st_info</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">curr_soma_idx</span> <span class="o">=</span> <span class="n">st_info</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
            <span class="n">curr_soma_group_idx</span> <span class="o">=</span> <span class="n">st_info</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curr_soma_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_soma_touch_dictionary</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">limb_soma_touch_dictionary</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">][</span><span class="n">curr_soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">limb_soma_touch_dictionary</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">][</span><span class="n">curr_soma_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_soma_group_idx</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">limb_soma_touch_dictionary</span></div>

    
    
<div class="viewcode-block" id="all_starting_dicts_by_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_starting_dicts_by_soma">[docs]</a><span class="k">def</span> <span class="nf">all_starting_dicts_by_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">soma_idx</span><span class="p">]</span></div>
<div class="viewcode-block" id="all_starting_attr_by_limb_and_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_starting_attr_by_limb_and_soma">[docs]</a><span class="k">def</span> <span class="nf">all_starting_attr_by_limb_and_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">attr</span><span class="o">=</span><span class="s2">&quot;starting_node&quot;</span><span class="p">):</span>
    <span class="n">starting_dicts</span> <span class="o">=</span> <span class="n">all_starting_dicts_by_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">soma_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_dicts</span><span class="p">]</span></div>

<div class="viewcode-block" id="convert_int_names_to_string_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.convert_int_names_to_string_names">[docs]</a><span class="k">def</span> <span class="nf">convert_int_names_to_string_names</span><span class="p">(</span><span class="n">limb_names</span><span class="p">,</span><span class="n">start_letter</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">start_letter</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_names</span><span class="p">]</span></div>

<div class="viewcode-block" id="convert_string_names_to_int_names"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.convert_string_names_to_int_names">[docs]</a><span class="k">def</span> <span class="nf">convert_string_names_to_int_names</span><span class="p">(</span><span class="n">limb_names</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_names</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_limb_string_name"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_limb_string_name">[docs]</a><span class="k">def</span> <span class="nf">get_limb_string_name</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">start_letter</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="s2">&quot;int&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">))</span> <span class="ow">or</span> <span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">start_letter</span><span class="si">}{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span> 
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">limb_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not int or string input&quot;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="get_limb_int_name"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_limb_int_name">[docs]</a><span class="k">def</span> <span class="nf">get_limb_int_name</span><span class="p">(</span><span class="n">limb_name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_name</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not int or string input&quot;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="get_soma_string_name"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_soma_string_name">[docs]</a><span class="k">def</span> <span class="nf">get_soma_string_name</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">start_letter</span><span class="o">=</span><span class="s2">&quot;S&quot;</span><span class="p">):</span>
    <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">soma_idx</span>
    <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="s2">&quot;int&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">))</span> <span class="ow">or</span> <span class="s2">&quot;float&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">start_letter</span><span class="si">}{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span> 
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">limb_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not int or string input&quot;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="get_soma_int_name"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_soma_int_name">[docs]</a><span class="k">def</span> <span class="nf">get_soma_int_name</span><span class="p">(</span><span class="n">soma_name</span><span class="p">):</span>
    <span class="n">limb_name</span> <span class="o">=</span> <span class="n">soma_name</span>
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_name</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not int or string input&quot;</span><span class="p">)</span></div>
        


<div class="viewcode-block" id="filter_limbs_below_soma_percentile"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.filter_limbs_below_soma_percentile">[docs]</a><span class="k">def</span> <span class="nf">filter_limbs_below_soma_percentile</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">above_percentile</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span>
                                         <span class="n">return_string_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">visualize_remianing_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will only keep those limbs that have </span>
<span class="sd">    a mean touching vertices lower than the soma faces percentile specified</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the soma mesh</span>
<span class="sd">    2) Get all of the face midpoints</span>
<span class="sd">    3) Get only the y coordinates of the face midpoints  and turn negative</span>
<span class="sd">    4) Get the x percentile of those y coordinates</span>
<span class="sd">    5) Get all those faces above that percentage</span>
<span class="sd">    6) Get those faces as a submesh and show</span>

<span class="sd">    -- How to cancel out the the limbs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keep_limb_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>

        <span class="n">touching_somas</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()</span>

        <span class="n">keep_limb</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">sm_idx</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_limb</span> <span class="p">:</span>
                <span class="n">sm_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">sm_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>

                <span class="n">tri_centers_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">sm_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">perc_y_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tri_centers_y</span><span class="p">,</span><span class="n">above_percentile</span><span class="p">)</span>


<span class="w">                </span><span class="sd">&quot;&quot;&quot; Don&#39;t need this: just for verification that was working with soma</span>
<span class="sd">                kept_faces = np.where(tri_centers_y &lt;= perc_y_position)[0]</span>

<span class="sd">                soma_top = sm_mesh.submesh([kept_faces],append=True)</span>
<span class="sd">                &quot;&quot;&quot;</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Pseudocode for adding limb as possible:</span>
<span class="sd">                1) Get all starting dictionaries for that soma</span>
<span class="sd">                For each starting dict:</span>
<span class="sd">                a) Get the mean of the touching_soma_vertices (and turn negative)</span>
<span class="sd">                b) If mean is less than the perc_y_position then set keep_limb to True and break</span>


<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">all_soma_starting_dicts</span> <span class="o">=</span> <span class="n">all_starting_dicts_by_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">sm_idx</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_start_dict</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_soma_starting_dicts</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on touching group </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">t_verts_mean</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">curr_start_dict</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">t_verts_mean</span> <span class="o">&lt;=</span> <span class="n">perc_y_position</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Keeping limb because less than y position&quot;</span><span class="p">)</span>
                        <span class="n">keep_limb</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">keep_limb</span><span class="p">:</span>
                    <span class="k">break</span>
                    
        <span class="c1">#decide whether or not to keep limb</span>
        <span class="k">if</span> <span class="n">keep_limb</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keeping Limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">keep_limb_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">visualize_remianing_neuron</span><span class="p">:</span>
        <span class="n">remaining_limbs</span> <span class="o">=</span> <span class="n">convert_int_names_to_string_names</span><span class="p">(</span><span class="n">keep_limb_idx</span><span class="p">)</span>
        <span class="n">ret_col</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">remaining_limbs</span><span class="p">]),</span>
                     <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Total removed Limbs = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">())),</span><span class="n">keep_limb_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_string_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">convert_int_names_to_string_names</span><span class="p">(</span><span class="n">keep_limb_idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">keep_limb_idx</span></div>

<div class="viewcode-block" id="limb_branch_dict_to_faces"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_dict_to_faces">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_to_faces</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the face indices of the main</span>
<span class="sd">    mesh that correspond to the limb/branches indicated by dictionary</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Have a final face indices list</span>
<span class="sd">    </span>
<span class="sd">    Iterate through all of the limbs</span>
<span class="sd">        Iterate through all of the branches</span>
<span class="sd">            1) Get the original indices of the branch on main mesh</span>
<span class="sd">            2) Add to the list</span>
<span class="sd">            </span>
<span class="sd">    3) Concatenate List and return</span>
<span class="sd">    </span>
<span class="sd">    ret_val = nru.limb_branch_dict_to_faces(neuron_obj,dict(L1=[0,1,2]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">final_face_indices</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_names</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="n">all_branch_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_names</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_branch_meshes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">match_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                        <span class="n">all_branch_meshes</span><span class="p">,</span>
                                                           <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">match_faces</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">final_face_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_faces</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_face_indices</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">match_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">final_face_indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">match_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
    <span class="k">return</span> <span class="n">match_faces_idx</span></div>
 
    
    
<div class="viewcode-block" id="skeleton_touching_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_touching_branches">[docs]</a><span class="k">def</span> <span class="nf">skeleton_touching_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                              <span class="n">return_endpoint_groupings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Can find all the branch numbers</span>
<span class="sd">    that touch a certain branch object based on the skeleton endpoints</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_short_seg</span> <span class="o">=</span> <span class="n">branch_idx</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">limb_obj</span>
    <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>

    <span class="n">network_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">network_nodes</span> <span class="o">=</span> <span class="n">network_nodes</span><span class="p">[</span><span class="n">network_nodes</span><span class="o">!=</span> <span class="n">curr_short_seg</span><span class="p">]</span>

    <span class="n">network_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">network_nodes</span><span class="p">]</span>
    <span class="n">neighbor_branches_by_endpoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">network_nodes</span><span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">network_branches</span><span class="p">,</span><span class="n">e</span><span class="p">)]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoints</span><span class="p">]</span>
    
    
    
    <span class="k">if</span> <span class="n">return_endpoint_groupings</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neighbor_branches_by_endpoint</span><span class="p">,</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoints</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">neighbor_branches_by_endpoint</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="all_soma_connnecting_endpionts_from_starting_info"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_soma_connnecting_endpionts_from_starting_info">[docs]</a><span class="k">def</span> <span class="nf">all_soma_connnecting_endpionts_from_starting_info</span><span class="p">(</span><span class="n">starting_info</span><span class="p">):</span>
    <span class="n">all_endpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">limb_start_v</span> <span class="ow">in</span> <span class="n">starting_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_v</span> <span class="ow">in</span> <span class="n">limb_start_v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">soma_group_idx</span><span class="p">,</span><span class="n">group_v</span> <span class="ow">in</span> <span class="n">soma_v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">all_endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_v</span><span class="p">[</span><span class="s2">&quot;endpoint&quot;</span><span class="p">])</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_v</span> <span class="ow">in</span> <span class="n">starting_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">soma_group_idx</span><span class="p">,</span><span class="n">group_v</span> <span class="ow">in</span> <span class="n">soma_v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">all_endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_v</span><span class="p">[</span><span class="s2">&quot;endpoint&quot;</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_endpoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">all_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_endpoints</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_endpoints</span></div>
    
    

<div class="viewcode-block" id="skeleton_points_along_path"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_points_along_path">[docs]</a><span class="k">def</span> <span class="nf">skeleton_points_along_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_path</span><span class="p">,</span>
                               <span class="n">skeletal_distance_per_coordinate</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                               <span class="n">return_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will give skeleton coordinates for the endpoints of the </span>
<span class="sd">    branches along the specified path</span>
<span class="sd">    </span>
<span class="sd">    if skeletal_distance_per_coordinate is None then will just endpoints</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">skeletal_distance_per_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_path</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span>
                                        <span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                        <span class="n">segment_width</span><span class="o">=</span><span class="n">skeletal_distance_per_coordinate</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_path</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_unique</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">skeleton_coordinates</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skeleton_coordinates</span></div>
    
    
<div class="viewcode-block" id="get_matching_concept_network_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_matching_concept_network_data">[docs]</a><span class="k">def</span> <span class="nf">get_matching_concept_network_data</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">soma_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">soma_group_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">starting_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">soma_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    
    <span class="k">if</span> <span class="n">soma_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">soma_group_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">starting_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;All soma, soma_group and starting node descriptions are None&quot;</span><span class="p">)</span>
        
    <span class="n">matching_concept_network_dicts_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">))</span>
  
    <span class="k">if</span> <span class="n">soma_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">soma_idx</span><span class="p">])</span>
        <span class="n">matching_concept_network_dicts_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">matching_concept_network_dicts_idx</span><span class="p">,</span><span class="n">soma_matches</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">soma_group_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">soma_group_idx</span><span class="p">])</span>
        <span class="n">matching_concept_network_dicts_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">matching_concept_network_dicts_idx</span><span class="p">,</span><span class="n">soma_matches</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">starting_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">starting_node</span><span class="p">])</span>
        <span class="n">matching_concept_network_dicts_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">matching_concept_network_dicts_idx</span><span class="p">,</span><span class="n">soma_matches</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matching_concept_network_dicts_idx = </span><span class="si">{</span><span class="n">matching_concept_network_dicts_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="p">[</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">matching_concept_network_dicts_idx</span><span class="p">]</span></div>
    
    
    
<span class="c1"># ----------- 1/15: For Automatic Axon and Apical Classification ---------------#</span>
<div class="viewcode-block" id="add_branch_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.add_branch_label">[docs]</a><span class="k">def</span> <span class="nf">add_branch_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                    <span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will go through and apply a label to the branches</span>
<span class="sd">    specified</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">limb_name</span> <span class="p">,</span><span class="n">branch_array</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_array</span><span class="p">:</span>
            <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
                    <span class="n">branch_obj</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span></div>
                    
<div class="viewcode-block" id="clear_all_branch_labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.clear_all_branch_labels">[docs]</a><span class="k">def</span> <span class="nf">clear_all_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">labels_to_clear</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">labels_to_clear</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">labels_to_clear</span><span class="p">):</span>
        <span class="n">labels_to_clear</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels_to_clear</span><span class="p">]</span>
        
    <span class="k">for</span> <span class="n">l_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        
        <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">b_name</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">l_name</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l_name</span><span class="p">][</span><span class="n">b_name</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">labels_to_clear</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span><span class="n">labels_to_clear</span><span class="p">))</span></div>

<div class="viewcode-block" id="clear_certain_branch_labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.clear_certain_branch_labels">[docs]</a><span class="k">def</span> <span class="nf">clear_certain_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">labels_to_clear</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">clear_all_branch_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">labels_to_clear</span><span class="o">=</span><span class="n">labels_to_clear</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="viable_axon_limbs_by_starting_angle_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.viable_axon_limbs_by_starting_angle_old">[docs]</a><span class="k">def</span> <span class="nf">viable_axon_limbs_by_starting_angle_old</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">axon_soma_angle_threshold</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>
                                       <span class="n">return_starting_angles</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is method that does not use neuron querying (becuase just simple iterating through limbs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">possible_axon_limbs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Find the limb find the soma angle AND Filter away all limbs with a soma starting angle above threshold</span>
    <span class="n">limb_to_starting_angle</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">):</span>
        <span class="n">curr_soma_angle</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="p">)</span>
        <span class="n">limb_to_starting_angle</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_soma_angle</span>

        <span class="k">if</span> <span class="n">curr_soma_angle</span> <span class="o">&gt;</span> <span class="n">axon_soma_angle_threshold</span><span class="p">:</span>
            <span class="n">possible_axon_limbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_starting_angles</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">possible_axon_limbs</span><span class="p">,</span><span class="n">limb_to_starting_angle</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">possible_axon_limbs</span></div>
    
<div class="viewcode-block" id="viable_axon_limbs_by_starting_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.viable_axon_limbs_by_starting_angle">[docs]</a><span class="k">def</span> <span class="nf">viable_axon_limbs_by_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">soma_angle_threshold</span><span class="p">,</span>
                                        <span class="n">above_threshold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">soma_name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                        <span class="n">return_int_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    <span class="n">soma_center</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">soma_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>

    <span class="k">if</span> <span class="n">above_threshold</span><span class="p">:</span>
        <span class="n">curr_query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;soma_starting_angle&gt;</span><span class="si">{</span><span class="n">soma_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;soma_starting_angle&lt;</span><span class="si">{</span><span class="n">soma_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="n">possible_axon_limbs_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                        <span class="n">query</span><span class="o">=</span><span class="n">curr_query</span><span class="p">,</span>
                       <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;soma_starting_angle&quot;</span><span class="p">],</span>
                       <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">soma_center</span><span class="o">=</span><span class="n">soma_center</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

    <span class="n">possible_axon_limbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">possible_axon_limbs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">return_int_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_int_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">possible_axon_limbs</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">possible_axon_limbs</span></div>
    
<div class="viewcode-block" id="get_limb_starting_angle_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_limb_starting_angle_dict">[docs]</a><span class="k">def</span> <span class="nf">get_limb_starting_angle_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return a dictionary mapping</span>
<span class="sd">    limb_idx --&gt; soma_idx --&gt; soma_group --&gt; starting angle</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Iterate through all of the limbs</span>
<span class="sd">    2) Iterate through all of the starting dict information</span>
<span class="sd">    3) compute the staritng angle</span>
<span class="sd">    4) Save in a dictionary</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">starting_angle_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">st_dict</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">st_soma</span> <span class="o">=</span> <span class="n">st_dict</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
            <span class="n">st_soma_group</span> <span class="o">=</span> <span class="n">st_dict</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>

            <span class="n">st_angle</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">soma_idx</span><span class="o">=</span><span class="n">st_soma</span><span class="p">,</span>
                           <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">st_soma_group</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">starting_angle_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">starting_angle_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">st_soma</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">starting_angle_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">starting_angle_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">st_soma</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


            <span class="n">starting_angle_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">st_soma</span><span class="p">][</span><span class="n">st_soma_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">st_angle</span>

    <span class="k">return</span> <span class="n">starting_angle_dict</span></div>
    
    
<div class="viewcode-block" id="skeletal_distance_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeletal_distance_from_soma">[docs]</a><span class="k">def</span> <span class="nf">skeletal_distance_from_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                    <span class="n">limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">error_if_all_nodes_not_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                            
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the skeletal distance away from </span>
<span class="sd">    a soma a branch piece is</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Create dictionary that will store all of the results</span>
<span class="sd">    For each directional concept network</span>
<span class="sd">    1) Find the starting node</span>
<span class="sd">    For each node: </span>
<span class="sd">    1)find the shortest path from starting node to that node</span>
<span class="sd">    2) convert the path into skeletal distance of each node </span>
<span class="sd">    and then add up</span>
<span class="sd">    3) Map of each of distances to the node in a dictionary and return</span>
<span class="sd">    - replace a previous one if smaller</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    skeletal_distance_from_soma(</span>
<span class="sd">                    limb_name = &quot;L1&quot;</span>
<span class="sd">                    curr_limb = uncompressed_neuron.concept_network.nodes[limb_name][&quot;data&quot;]</span>
<span class="sd">                    print_flag = True</span>
<span class="sd">                    #soma_list=None</span>
<span class="sd">                    somas = [0,1]</span>
<span class="sd">                    check_all_nodes_in_return=True</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">------Working on Limb (</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">)-------&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting nodes BEFORE copy = </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">curr_limb_copy</span> <span class="o">=</span>  <span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting nodes after copy = </span><span class="si">{</span><span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#0) Create dictionary that will store all of the results</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1">#For each directional concept network</span>
    <span class="k">if</span> <span class="n">somas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">somas</span><span class="p">):</span>
            <span class="n">somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">somas</span><span class="p">]</span>
        <span class="n">touching_somas</span> <span class="o">=</span> <span class="n">somas</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Performing analysis for somas: </span><span class="si">{</span><span class="n">touching_somas</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="n">nodes_to_process</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>
        
    <span class="k">for</span> <span class="n">sm_start</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
        <span class="c1">#1) Find the starting node</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; Working on soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">sm_start</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb (</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">) was not connected to soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2"> accordinag to all concept networks&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">curr_directional_network</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network_directional</span>
        <span class="n">starting_node</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">current_starting_node</span>
        
        <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes_to_process</span> <span class="o">=</span> <span class="n">branches</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes_to_process</span> <span class="o">=</span> <span class="n">curr_directional_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>

        <span class="c1">#For each node: </span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_process</span><span class="p">:</span>
            <span class="c1">#1)find the shortest path from starting node to that node</span>
            <span class="c1">#( could potentially not be there because it is directional)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_directional_network</span><span class="p">,</span><span class="n">starting_node</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1">#return_dict[n] = np.inf</span>
                <span class="k">continue</span>
            <span class="c1">#2) convert the path into skeletal distance of each node and then add up</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">include_node_skeleton_dist</span><span class="p">:</span>
                <span class="n">path_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_directional_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">path_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_directional_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_shortest_path</span><span class="p">])</span>


            <span class="c1">#3) Map of each of distances to the node in a dictionary and return</span>
            <span class="c1">#- replace a previous one if smaller</span>

            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">path_length</span> <span class="o">&lt;</span> <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_length</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Before Doing the dictionary correction, return_dict=</span><span class="si">{</span><span class="n">return_dict</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#check that the return dict has all of the nodes</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_process</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
   
    <span class="k">if</span> <span class="n">error_if_all_nodes_not_return</span><span class="p">:</span>
        <span class="c1">#if set(list(return_dict.keys())) != set(list(curr_limb_copy.concept_network.nodes())):</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">return_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes_to_process</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;return_dict keys do not exactly match the curr limb nodes&quot;</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">return_dict</span></div>
    

<div class="viewcode-block" id="find_branch_with_specific_coordinate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.find_branch_with_specific_coordinate">[docs]</a><span class="k">def</span> <span class="nf">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">coordinates</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all branch idxs whos skeleton contains a certain coordinate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="n">network_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">]</span>
    
    <span class="n">final_branch_idxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
        <span class="n">curr_branch_idx</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">network_branches</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">final_branch_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_branch_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">final_branch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">final_branch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">final_branch_idxs</span></div>

<div class="viewcode-block" id="find_branch_with_specific_endpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.find_branch_with_specific_endpoint">[docs]</a><span class="k">def</span> <span class="nf">find_branch_with_specific_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">coordinates</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all branch idxs whos skeleton contains a certain coordinate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="n">network_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">]</span>
    
    <span class="n">final_branch_idxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
        <span class="n">curr_branch_idx</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">network_branches</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">final_branch_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_branch_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">final_branch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">final_branch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">final_branch_idxs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">final_branch_idxs</span></div>



<div class="viewcode-block" id="neuron_spine_density"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.neuron_spine_density">[docs]</a><span class="k">def</span> <span class="nf">neuron_spine_density</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">lower_width_bound</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>
                        <span class="n">upper_width_bound</span> <span class="o">=</span> <span class="mi">520</span><span class="p">,</span><span class="c1">#380,</span>
                        <span class="n">spine_threshold</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">skeletal_distance_threshold</span> <span class="o">=</span> <span class="mi">110000</span><span class="p">,</span><span class="c1">#30000,</span>
                        <span class="n">skeletal_length_threshold</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span><span class="c1">#10000</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">plot_candidate_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_branch_processed_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Calculate the spine density used to classify</span>
<span class="sd">    a neuron as one of the following categories based on the spine</span>
<span class="sd">    density of high interest branches</span>
<span class="sd">    </span>
<span class="sd">    1) no_spine</span>
<span class="sd">    2) sparsely_spine</span>
<span class="sd">    3) densely_spine</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_neuron_obj</span><span class="o">=</span> <span class="n">neuron_obj</span>
    
    
    
    
    <span class="k">if</span> <span class="n">plot_candidate_branches</span><span class="p">:</span>
        <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">close_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                            <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;skeletal_distance_from_soma_excluding_node&quot;</span><span class="p">,</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                                                            <span class="s2">&quot;n_spines&quot;</span><span class="p">,</span><span class="s2">&quot;spine_density&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">],</span>
                                            <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(skeletal_distance_from_soma_excluding_node&lt;</span><span class="si">{</span><span class="n">skeletal_distance_threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                   <span class="sa">f</span><span class="s2">&quot; and (no_spine_median_mesh_center &gt; </span><span class="si">{</span><span class="n">lower_width_bound</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                   <span class="sa">f</span><span class="s2">&quot; and (no_spine_median_mesh_center &lt; </span><span class="si">{</span><span class="n">upper_width_bound</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                  <span class="sa">f</span><span class="s2">&quot; and (n_spines &gt; </span><span class="si">{</span><span class="n">spine_threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                   <span class="sa">f</span><span class="s2">&quot; and skeletal_length &gt; </span><span class="si">{</span><span class="n">skeletal_length_threshold</span><span class="si">}</span><span class="s2"> &quot;</span>
                                                  <span class="p">),</span>
                                             <span class="n">return_dataframe</span><span class="o">=</span><span class="n">return_dataframe</span>


                                          <span class="p">)</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">close_limb_branch_dict</span><span class="p">,</span>
                              <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        
    
    
    <span class="n">return_dataframe</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">close_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                            <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;skeletal_distance_from_soma_excluding_node&quot;</span><span class="p">,</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
                                                            <span class="s2">&quot;n_spines&quot;</span><span class="p">,</span><span class="s2">&quot;spine_density&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">],</span>
                                            <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(skeletal_distance_from_soma_excluding_node&lt;</span><span class="si">{</span><span class="n">skeletal_distance_threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                   <span class="sa">f</span><span class="s2">&quot; and (no_spine_median_mesh_center &gt; </span><span class="si">{</span><span class="n">lower_width_bound</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                   <span class="sa">f</span><span class="s2">&quot; and (no_spine_median_mesh_center &lt; </span><span class="si">{</span><span class="n">upper_width_bound</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                  <span class="sa">f</span><span class="s2">&quot; and (n_spines &gt; </span><span class="si">{</span><span class="n">spine_threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                   <span class="sa">f</span><span class="s2">&quot; and skeletal_length &gt; </span><span class="si">{</span><span class="n">skeletal_length_threshold</span><span class="si">}</span><span class="s2"> &quot;</span>
                                                  <span class="p">),</span>
                                             <span class="n">return_dataframe</span><span class="o">=</span><span class="n">return_dataframe</span>


                                          <span class="p">)</span>
    
    <span class="n">total_branches_in_search_radius</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                            <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;skeletal_distance_from_soma_excluding_node&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">],</span>
                                            <span class="n">query</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(skeletal_distance_from_soma_excluding_node&lt;</span><span class="si">{</span><span class="n">skeletal_distance_threshold</span><span class="si">}</span><span class="s2">)&quot;</span>
                                                  <span class="p">),</span>
                                             <span class="n">return_dataframe</span><span class="o">=</span><span class="n">return_dataframe</span>


                                          <span class="p">)</span>
    
    
    <span class="c1"># ---- 1/24: Calculating the skeletal length of the viable branches --- #</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_branches_in_search_radius</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">total_skeletal_length_in_search_radius</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">total_branches_in_search_radius</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="n">processed_skeletal_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">close_limb_branch_dict</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">close_limb_branch_dict</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">median_spine_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">close_limb_branch_dict</span><span class="p">[</span><span class="s2">&quot;spine_density&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">median_spine_density</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;median spine density = </span><span class="si">{</span><span class="n">median_spine_density</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">close_limb_branch_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches in radius = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_branches_in_search_radius</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;processed_skeletal_length = </span><span class="si">{</span><span class="n">processed_skeletal_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_skeletal_length_in_search_radius = </span><span class="si">{</span><span class="n">total_skeletal_length_in_search_radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_skeletal_length_in_search_radius</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">processed_skeletal_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">median_spine_density</span><span class="o">=</span><span class="mi">0</span>
        
        
    <span class="k">if</span> <span class="n">return_branch_processed_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">median_spine_density</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">close_limb_branch_dict</span><span class="p">),</span><span class="n">processed_skeletal_length</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">total_branches_in_search_radius</span><span class="p">),</span><span class="n">total_skeletal_length_in_search_radius</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">median_spine_density</span></div>
    
<div class="viewcode-block" id="all_concept_network_data_to_limb_network_stating_info"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_concept_network_data_to_limb_network_stating_info">[docs]</a><span class="k">def</span> <span class="nf">all_concept_network_data_to_limb_network_stating_info</span><span class="p">(</span><span class="n">all_concept_network_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will conver the concept network data list of dictionaries into a </span>
<span class="sd">    the dictionary representation of only the limb touching vertices and</span>
<span class="sd">    endpoints of the limb_network_stating_info in the preprocessed data</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through all of the network dicts and store as</span>
<span class="sd">    soma--&gt; soma_group_idx --&gt; dict(touching_verts,</span>
<span class="sd">                                    endpoint)</span>
<span class="sd">                                    </span>
<span class="sd">    stored in the concept network as </span>
<span class="sd">    touching_soma_vertices</span>
<span class="sd">    starting_coordinate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_network</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_concept_network_data</span><span class="p">:</span>
        <span class="n">soma_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">soma_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_network</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_network</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            
        <span class="n">limb_network</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">][</span><span class="n">soma_group_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">touching_verts</span><span class="o">=</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">],</span>
                                                     <span class="n">endpoint</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">limb_network</span></div>
    

<div class="viewcode-block" id="clean_all_concept_network_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.clean_all_concept_network_data">[docs]</a><span class="k">def</span> <span class="nf">clean_all_concept_network_data</span><span class="p">(</span><span class="n">all_concept_network_data</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To make sure that there are</span>
<span class="sd">    no duplicate entries of that starting nodes</span>
<span class="sd">    and either to combine the soma touching points</span>
<span class="sd">    or just keep the largest one</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Start with an empty dictionary</span>
<span class="sd">    For all the dictionaries:</span>
<span class="sd">    2)  store the result</span>
<span class="sd">    indexed by starting soma and starting node</span>
<span class="sd">    3) If an entry already existent --&gt; then either add the soma touching</span>
<span class="sd">    vertices (and unique) to the list or replace it if longer</span>

<span class="sd">    4) Turn the one dictionary into a list of dictionaries</span>
<span class="sd">    like the all_concept_network_data attribute</span>

<span class="sd">    5) Replace the all_concept_network_data</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_network_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">n_dict</span> <span class="ow">in</span> <span class="n">all_concept_network_data</span><span class="p">:</span>
        <span class="n">starting_soma</span> <span class="o">=</span> <span class="n">n_dict</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">starting_node</span> <span class="o">=</span> <span class="n">n_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">starting_soma</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_network_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new_network_data</span><span class="p">[</span><span class="n">starting_soma</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">starting_node</span> <span class="ow">in</span> <span class="n">new_network_data</span><span class="p">[</span><span class="n">starting_soma</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_network_data</span><span class="p">[</span><span class="n">starting_soma</span><span class="p">][</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">])</span> <span class="o">&lt;</span> 
                <span class="nb">len</span><span class="p">(</span><span class="n">n_dict</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Replacing the Soma_</span><span class="si">{</span><span class="n">starting_soma</span><span class="si">}</span><span class="s2">_Node_</span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2"> dictionary&quot;</span><span class="p">)</span>
                <span class="n">new_network_data</span><span class="p">[</span><span class="n">starting_soma</span><span class="p">][</span><span class="n">starting_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping the Soma_</span><span class="si">{</span><span class="n">starting_soma</span><span class="si">}</span><span class="s2">_Node_</span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2"> dictionary because smaller&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_network_data</span><span class="p">[</span><span class="n">starting_soma</span><span class="p">][</span><span class="n">starting_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dict</span>

    <span class="c1">#4) Turn the one dictionary into a list of dictionaries</span>
    <span class="c1">#like the all_concept_network_data attribute</span>

    <span class="n">new_network_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_info</span> <span class="ow">in</span> <span class="n">new_network_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,(</span><span class="n">starting_node</span><span class="p">,</span><span class="n">node_info</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_info</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">node_info</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">new_network_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_info</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_network_list</span></div>



<div class="viewcode-block" id="clean_neuron_all_concept_network_data"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.clean_neuron_all_concept_network_data">[docs]</a><span class="k">def</span> <span class="nf">clean_neuron_all_concept_network_data</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will go through and clean all of the concept network data</span>
<span class="sd">    in all the limbs of a Neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---- Working on Limb </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> ----&quot;</span><span class="p">)</span>
            
            
        <span class="n">cleaned_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">clean_all_concept_network_data</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">,</span>
                                                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cleaned_network = </span><span class="si">{</span><span class="n">cleaned_network</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="n">cleaned_network</span>
        
        <span class="c1">#setting the concept network</span>
        <span class="n">st_soma</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
        <span class="n">st_node</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span>
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">st_soma</span><span class="p">,</span>
                                                 <span class="n">starting_node</span><span class="o">=</span><span class="n">st_node</span><span class="p">)</span>
        
        <span class="c1"># --------- 1/24: Cleaning the preprocessed data as well -----------#</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cleaned_network = </span><span class="si">{</span><span class="n">cleaned_network</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">new_limb_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_concept_network_data_to_limb_network_stating_info</span><span class="p">(</span><span class="n">cleaned_network</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---------</span><span class="se">\n</span><span class="s2">new_limb_network = </span><span class="si">{</span><span class="n">new_limb_network</span><span class="si">}</span><span class="se">\n</span><span class="s2">---------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_limb_network</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb.all_concept_network_data = </span><span class="si">{</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span></div>
            
<span class="c1">#         neuron_obj[j] = curr_limb</span>
    
<span class="c1">#     return neuron_obj</span>

<div class="viewcode-block" id="connected_components_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.connected_components_from_branches">[docs]</a><span class="k">def</span> <span class="nf">connected_components_from_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">use_concept_network_directional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find the connected components on a branch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">use_concept_network_directional</span><span class="p">:</span>
        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
        <span class="c1">#curr_network = limb_obj.concept_network</span>

    <span class="n">axon_subgraph</span> <span class="o">=</span> <span class="n">curr_network</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span>
    <span class="n">conn_comp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">axon_subgraph</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp = </span><span class="si">{</span><span class="n">conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">conn_comp</span></div>

<div class="viewcode-block" id="limb_branch_dict_to_connected_components"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_dict_to_connected_components">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_to_connected_components</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                             <span class="n">limb_branch_dict</span><span class="p">,</span>
            <span class="n">use_concept_network_directional</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To turn the limb branch dict into a</span>
<span class="sd">    list of all the connected components described by the</span>
<span class="sd">    limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">axon_connected_comps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span> <span class="n">axon_branches</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">conn_comp_pre</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">connected_components_from_branches</span><span class="p">(</span>
            <span class="n">limb_obj</span><span class="p">,</span><span class="n">axon_branches</span><span class="p">,</span>
            <span class="n">use_concept_network_directional</span><span class="o">=</span><span class="n">use_concept_network_directional</span><span class="p">)</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">limb_name</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp_pre</span><span class="p">]</span>
        <span class="n">axon_connected_comps</span> <span class="o">+=</span> <span class="n">conn_comp</span>

    <span class="k">return</span> <span class="n">axon_connected_comps</span></div>


        
<div class="viewcode-block" id="empty_limb_object"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.empty_limb_object">[docs]</a><span class="k">def</span> <span class="nf">empty_limb_object</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;empty&quot;</span><span class="p">]):</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                         <span class="n">concept_network_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                        <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">curr_limb</span></div>

<div class="viewcode-block" id="limb_true_false_dict_to_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_true_false_dict_to_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">limb_true_false_dict_to_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_true_false_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To convert a dictionary that has limb_idx --&gt; branch --&gt; True or False</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    For each limb</span>
<span class="sd">    1) Make sure that the true false dict lenght matches the number of branches</span>
<span class="sd">    Iterate through all the branches</span>
<span class="sd">        2) if true then add to local list</span>
<span class="sd">    3) store the local list in new limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_true_false_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_limbs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_true_false_dict (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_true_false_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">) not match neuron_obj.n_limbs (</span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_limbs</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">true_false_dict</span> <span class="ow">in</span> <span class="n">limb_true_false_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_false_dict</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True False Dict length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">true_false_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">) not match len(neuron_obj[limb_idx]) (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
        <span class="n">local_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">true_false_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_list</span>
        
    <span class="k">return</span> <span class="n">limb_branch_dict</span></div>

<div class="viewcode-block" id="limb_branch_dict_to_limb_true_false_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_dict_to_limb_true_false_dict">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_to_limb_true_false_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                            <span class="n">limb_branch_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To convert limb branch dict to a dictionary of:</span>
<span class="sd">        limb_idx --&gt; branch --&gt; True or False</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Iterate through the neuron limbs</span>
<span class="sd">        a) </span>
<span class="sd">        if the limb is not in limb branch dict: </span>
<span class="sd">            make the limb list empty</span>
<span class="sd">        else:</span>
<span class="sd">            get limb list</span>
<span class="sd">            </span>
<span class="sd">        b) Get the branch node names from neuron</span>
<span class="sd">        c) Get a diff of the list to find the false values</span>
<span class="sd">        d) Iterate through limb_list and make true,</span>
<span class="sd">        e) Iterate through diff list and make false</span>
<span class="sd">        f) store the local dictionary in the true_false dict for return</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">true_false_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        
        <span class="n">limb_list</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">limb_name</span><span class="p">,[])</span>
        <span class="n">branch_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">())</span>
        
        <span class="n">true_false_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_names</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">true_false_list</span><span class="p">[</span><span class="n">limb_list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="n">output_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">true_false_list</span><span class="p">)}</span>
        <span class="n">true_false_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_dict</span>
        
        
<span class="c1">#         false_list = np.setdiff1d(branch_names,limb_list)</span>
<span class="c1">#         true_dict = {int(k):True for k in limb_list}</span>
<span class="c1">#         false_dict = {int(k):False for k in false_list}</span>
<span class="c1">#         true_dict.update(false_dict)</span>
<span class="c1">#          true_false_dict[limb_name] = true_dict</span>
        
    <span class="k">return</span> <span class="n">true_false_dict</span></div>
        
    
    
<div class="viewcode-block" id="concatenate_feature_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.concatenate_feature_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">concatenate_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict</span><span class="p">,</span>
                                       <span class="n">feature</span><span class="p">,</span>
                                     <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To sum the value of some feature over the branches</span>
<span class="sd">    specified by the limb branch dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">feature_total</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span> <span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
            <span class="n">feature_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">],</span><span class="n">feature</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">feature_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">feature_value</span> <span class="o">=</span> <span class="n">feature_function</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>
                
            
            <span class="n">feature_total</span> <span class="o">+=</span> <span class="n">feature_value</span>
            
    <span class="k">return</span> <span class="n">feature_total</span>        </div>

<div class="viewcode-block" id="sum_feature_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.sum_feature_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict</span><span class="p">,</span>
                                       <span class="n">feature</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">branch_func_instead_of_feature</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To sum the value of some feature over the branches</span>
<span class="sd">    specified by the limb branch dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">feature_total</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span> <span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature</span> <span class="o">==</span> <span class="s2">&quot;n_branches&quot;</span><span class="p">:</span>
                <span class="n">feature_value</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">branch_func_instead_of_feature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">feature_value</span> <span class="o">=</span> <span class="n">branch_func_instead_of_feature</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">feature_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">],</span><span class="n">feature</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">feature_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">feature_value</span> <span class="o">=</span> <span class="n">feature_function</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>
            <span class="n">feature_total</span> <span class="o">+=</span> <span class="n">feature_value</span>
            
    <span class="k">return</span> <span class="n">feature_total</span></div>

<div class="viewcode-block" id="feature_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.feature_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict</span><span class="p">,</span>
                                       <span class="n">feature</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">feature_from_fuction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">feature_from_fuction_kwargs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">keep_seperate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">branch_func_instead_of_feature</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">skip_None</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To sum the value of some feature over the branches</span>
<span class="sd">    specified by the limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">feature_total</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span> <span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature_from_fuction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">feature_from_fuction_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">feature_from_fuction_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">feature_value</span> <span class="o">=</span> <span class="n">feature_from_fuction</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">],</span><span class="o">**</span><span class="n">feature_from_fuction_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">branch_func_instead_of_feature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">feature_value</span> <span class="o">=</span> <span class="n">branch_func_instead_of_feature</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">feature_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">],</span><span class="n">feature</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">feature_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">feature_value</span> <span class="o">=</span> <span class="n">feature_function</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">skip_None</span> <span class="ow">and</span> <span class="n">feature_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">keep_seperate</span><span class="p">:</span>
                <span class="n">feature_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">feature_value</span><span class="p">):</span>
                    <span class="n">feature_total</span><span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">feature_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_value</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">feature_total</span></div>


<div class="viewcode-block" id="limb_branch_removed_after_limb_branch_removal"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_removed_after_limb_branch_removal">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_removed_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict</span><span class="p">,</span>
                             <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a branches that should be deleted from</span>
<span class="sd">    different limbs in a limb branch dict then to determine all of the</span>
<span class="sd">    branches that were removed from this deletion due to </span>
<span class="sd">    disconnecting from starting branch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict</span><span class="p">,</span>
                             <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_after_limb_branch_removal"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_after_limb_branch_removal">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict</span><span class="p">,</span>
                             <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a branches that should be deleted from</span>
<span class="sd">    different limbs in a limb branch dict then to determine the leftover branches</span>
<span class="sd">    of each limb that are still connected to the starting node</span>



<span class="sd">    Pseudocode:</span>
<span class="sd">    For each starting node</span>
<span class="sd">    1) Get the starting node</span>
<span class="sd">    2) Get the directional conept network and turn it undirected</span>
<span class="sd">    3) Find the total branches that will be deleted and kept</span>
<span class="sd">    once the desired branches are removed (only keeping the ones </span>
<span class="sd">    still connected to the starting branch)</span>
<span class="sd">    4) add the removed and kept branches to the running limb branch dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="n">limb_branch_dict_kept</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_branch_dict_removed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">branch_names</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_branch_dict_kept</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_names</span>
            <span class="k">continue</span>



        <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
        <span class="n">nodes_to_keep</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span>

        <span class="n">kept_branches</span><span class="p">,</span><span class="n">removed_branches</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_in_kept_groups_after_deletion</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                            <span class="n">nodes_to_keep</span><span class="p">,</span>
                                               <span class="n">nodes_to_remove</span><span class="o">=</span><span class="n">nodes_to_remove</span><span class="p">,</span>
                                            <span class="n">return_removed_nodes</span> <span class="o">=</span> <span class="kc">True</span>
                                               <span class="p">)</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kept_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_kept</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kept_branches</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_removed</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_removed_limb_branch</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict_removed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict_kept</span></div>
    
<span class="c1"># ------ 2/1: Utils for a lot of the edge functions ----------- #</span>
<div class="viewcode-block" id="limb_edge_dict_with_function"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_edge_dict_with_function">[docs]</a><span class="k">def</span> <span class="nf">limb_edge_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">edge_function</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a limb_edge dictionary</span>
<span class="sd">    based on a function that generates cuts for a certain limb</span>
<span class="sd">    </span>
<span class="sd">    Funciton must pass back: edges_to_create,edges_to_delete</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through all of the limbs of a neuron</span>
<span class="sd">    a. Get the cuts that should be created and deleted</span>
<span class="sd">    b. If either is non-empty then add to the limb_edge dictionary</span>

<span class="sd">    return limb_edge dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">limb_edge_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>

        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>

        <span class="n">edges_to_create</span><span class="p">,</span><span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">edge_function</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> ---</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;edges_to_create = </span><span class="si">{</span><span class="n">edges_to_create</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;edges_to_create = </span><span class="si">{</span><span class="n">edges_to_create</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">unique_rows</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">))</span>
        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">unique_rows</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">):</span>
            <span class="n">limb_edge_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">edges_to_create</span><span class="o">=</span><span class="n">edges_to_create</span><span class="p">,</span>
                                            <span class="n">edges_to_delete</span><span class="o">=</span><span class="n">edges_to_delete</span><span class="p">)</span>
        
            

    <span class="k">return</span> <span class="n">limb_edge_dict</span>    </div>



<div class="viewcode-block" id="branches_on_limb_after_edges_deleted_and_created"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branches_on_limb_after_edges_deleted_and_created">[docs]</a><span class="k">def</span> <span class="nf">branches_on_limb_after_edges_deleted_and_created</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">edges_to_delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edges_to_create</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_removed_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>                       

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a edges of concept network that should </span>
<span class="sd">    be created or destroyed and then returning the branches that still remain</span>
<span class="sd">    and those that were deleted</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">original_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">edges_to_create</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">)</span>
        

    <span class="n">new_concept_network</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">create_and_delete_edges</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
        <span class="n">edges_to_delete</span><span class="o">=</span><span class="n">edges_to_delete</span><span class="p">,</span>
        <span class="n">edges_to_create</span><span class="o">=</span><span class="n">edges_to_create</span><span class="p">,</span>
        <span class="n">return_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="n">kept_branches</span><span class="p">,</span><span class="n">removed_branches</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_in_kept_group</span><span class="p">(</span><span class="n">new_concept_network</span><span class="p">,</span>
                                                <span class="n">nodes_to_keep</span><span class="o">=</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">,</span>
                                                <span class="n">return_removed_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After edges deleted and created: &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kept_branches= </span><span class="si">{</span><span class="n">kept_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;removed_branches = </span><span class="si">{</span><span class="n">removed_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_removed_branches</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kept_branches</span><span class="p">,</span><span class="n">removed_branches</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kept_branches</span>    </div>
    
<div class="viewcode-block" id="limb_branch_after_limb_edge_removal"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_after_limb_edge_removal">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_after_limb_edge_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">limb_edge_dict</span><span class="p">,</span>
                             <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a branches that should be deleted from</span>
<span class="sd">    different limbs in a limb branch dict then to determine the leftover branches</span>
<span class="sd">    of each limb that are still connected to the starting node</span>



<span class="sd">    Pseudocode:</span>
<span class="sd">    For each starting node</span>
<span class="sd">    1) Get the starting node</span>
<span class="sd">    2) Get the directional conept network and turn it undirected</span>
<span class="sd">    3) Find the total branches that will be deleted and kept</span>
<span class="sd">    once the desired branches are removed (only keeping the ones </span>
<span class="sd">    still connected to the starting branch)</span>
<span class="sd">    4) add the removed and kept branches to the running limb branch dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="n">limb_branch_dict_kept</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_branch_dict_removed</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> ---</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                  
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">branch_names</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_branch_dict_kept</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_names</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;skipping because was not in the limb_edge dict&quot;</span><span class="p">)</span>
            <span class="k">continue</span>



        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">limb_edge_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edges_to_delete&quot;</span><span class="p">,[])</span>
        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="n">limb_edge_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;edges_to_create&quot;</span><span class="p">,[])</span>


        <span class="n">kept_branches</span><span class="p">,</span><span class="n">removed_branches</span> <span class="o">=</span> <span class="n">branches_on_limb_after_edges_deleted_and_created</span><span class="p">(</span>
                                            <span class="n">limb_obj</span><span class="p">,</span>
                                            <span class="n">edges_to_delete</span><span class="o">=</span><span class="n">edges_to_delete</span><span class="p">,</span>
                                            <span class="n">edges_to_create</span><span class="o">=</span><span class="n">edges_to_create</span><span class="p">,</span>
                                            <span class="n">return_removed_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kept_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_kept</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kept_branches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_removed</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">removed_branches</span>

    <span class="k">if</span> <span class="n">return_removed_limb_branch</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict_removed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict_kept</span></div>
    
<div class="viewcode-block" id="limb_branch_from_edge_function"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_from_edge_function">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_from_edge_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">edge_function</span><span class="p">,</span>
                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate a limb branch dict of nodes</span>
<span class="sd">    from a function that generates cuts for a neuron_limb</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Generate a limb_edge dictionary</span>
<span class="sd">    2) Generate a limb branch dictionary and return that</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">limb_edge_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_edge_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                    <span class="n">edge_function</span><span class="p">,</span>
                                                      <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_after_limb_edge_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_edge_dict</span><span class="o">=</span><span class="n">limb_edge_dict</span><span class="p">,</span>
                                        <span class="n">return_removed_limb_branch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                       <span class="p">)</span>
    <span class="k">return</span> <span class="n">limb_branch_dict</span></div>
    

<div class="viewcode-block" id="branches_within_skeletal_distance"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branches_within_skeletal_distance">[docs]</a><span class="k">def</span> <span class="nf">branches_within_skeletal_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">start_branch</span><span class="p">,</span>
                                    <span class="n">max_distance_from_start</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">include_start_branch_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">include_node_branch_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">only_consider_downstream</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find nodes within a cetain skeletal distance of a certain </span>
<span class="sd">    node (can be restricted to only those downstream)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the directed concept grpah</span>
<span class="sd">    2) Get all of the downstream nodes of the node</span>
<span class="sd">    3) convert directed concept graph into an undirected one</span>
<span class="sd">    4) Get a subgraph using all of the downstream nodes</span>
<span class="sd">    5) For each node: </span>
<span class="sd">    - get the shortest path from the node to the starting node</span>
<span class="sd">    - add up the skeleton distance (have options for including each endpoint)</span>
<span class="sd">    - if below the max distance then add</span>
<span class="sd">    6) Return nodes</span>


<span class="sd">    Ex: </span>
<span class="sd">    start_branch = 53</span>
<span class="sd">        </span>
<span class="sd">    viable_downstream_nodes = nru.branches_within_skeletal_distance(limb_obj = current_neuron[6],</span>
<span class="sd">                                start_branch = start_branch,</span>
<span class="sd">                                max_distance_from_start = 50000,</span>
<span class="sd">                                verbose = False,</span>
<span class="sd">                                include_start_branch_length = False,</span>
<span class="sd">                                include_node_branch_length = False,</span>
<span class="sd">                                only_consider_downstream = True)</span>

<span class="sd">    limb_branch_dict=dict(L6=viable_downstream_nodes+[start_branch])</span>

<span class="sd">    nviz.plot_limb_branch_dict(current_neuron,</span>
<span class="sd">                              limb_branch_dict)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">limb_obj</span>



    <span class="n">viable_downstream_nodes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">dir_nx</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span>

    <span class="c1">#2) Get all of the downstream nodes of the node</span>

    <span class="k">if</span> <span class="n">only_consider_downstream</span><span class="p">:</span>
        <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">dir_nx</span><span class="p">,</span><span class="n">start_branch</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dir_nx</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="n">all_downstream_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">start_branch</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_downstream_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No downstream nodes to test&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of downstream nodes = </span><span class="si">{</span><span class="n">all_downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) convert directed concept graph into an undirected one</span>
    <span class="n">G_whole</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">dir_nx</span><span class="p">)</span>

    <span class="c1">#4) Get a subgraph using all of the downstream nodes</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G_whole</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">all_downstream_nodes</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_branch</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">all_downstream_nodes</span><span class="p">:</span>

        <span class="c1">#- get the shortest path from the node to the starting node</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start_branch</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Continuing because No path between start node (</span><span class="si">{</span><span class="n">start_branch</span><span class="si">}</span><span class="s2">) and node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span> 


        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_node_branch_length</span><span class="p">:</span>
            <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">curr_shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_start_branch_length</span><span class="p">:</span>
            <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">curr_shortest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">total_sk_length_of_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_shortest_path</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">total_sk_length_of_path</span> <span class="o">&lt;=</span> <span class="n">max_distance_from_start</span><span class="p">:</span>
            <span class="n">viable_downstream_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> was too far from the start node : </span><span class="si">{</span><span class="n">total_sk_length_of_path</span><span class="si">}</span><span class="s2"> (threshold = </span><span class="si">{</span><span class="n">max_distance_from_start</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">viable_downstream_nodes</span></div>

<div class="viewcode-block" id="low_branch_length_clusters"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.low_branch_length_clusters">[docs]</a><span class="k">def</span> <span class="nf">low_branch_length_clusters</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
                                <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
                               <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">skeletal_distance_from_soma_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">use_axon_like_restriction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">remove_starting_node</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                               <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               
                               <span class="o">**</span><span class="n">kwargs</span>
                                <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find parts of neurons with lots of nodes</span>
<span class="sd">    close together on concept network with low branch length</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the concept graph of a limb </span>
<span class="sd">    2) Eliminate all of the nodes that are too long skeletal length</span>
<span class="sd">    3) Divide the remaining axon into connected components</span>
<span class="sd">    - if too many nodes are in the connected component then it is</span>
<span class="sd">    an axon mess and should delete all those nodes</span>
<span class="sd">    </span>
<span class="sd">    Application: Helps filter away axon mess</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_skeletal_length = </span><span class="si">{</span><span class="n">max_skeletal_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_n_nodes_in_cluster= </span><span class="si">{</span><span class="n">min_n_nodes_in_cluster</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict_restriction = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">use_deletion</span><span class="o">=</span><span class="kc">False</span>
    
    <span class="n">curr_neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span>

    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
    <span class="k">if</span> <span class="n">skeletal_distance_from_soma_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeletal_distance_from_soma_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    
    
    <span class="c1"># ---------- Getting the restriction that we will check over ---- #</span>
    <span class="k">if</span> <span class="n">use_axon_like_restriction</span><span class="p">:</span>
        <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_like_limb_branch_dict</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict_restriction</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict_restriction before query = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_deletion</span><span class="p">:</span>
        <span class="n">limb_branch_restriction</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                        <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
                                       <span class="s2">&quot;skeletal_distance_from_soma&quot;</span><span class="p">],</span>
                       <span class="n">query</span> <span class="o">=</span> <span class="p">(</span> <span class="sa">f</span><span class="s2">&quot; (skeletal_length &lt; </span><span class="si">{</span><span class="n">max_skeletal_length</span><span class="si">}</span><span class="s2">) and &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; (median_mesh_center &lt; </span><span class="si">{</span><span class="n">width_max</span><span class="si">}</span><span class="s2">) &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; and (skeletal_distance_from_soma &gt; </span><span class="si">{</span><span class="n">skeletal_distance_from_soma_min</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">),</span>
                       <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_restriction = </span><span class="si">{</span><span class="n">limb_branch_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limb_branch_restriction</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_limb_branch_dict</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">nodes_to_keep</span> <span class="ow">in</span> <span class="n">limb_branch_restriction</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">curr_starting_node</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">current_starting_node</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_deletion</span><span class="p">:</span>
        <span class="c1">#1) Get the branches that are below a certain threshold</span>
            <span class="n">nodes_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">jj</span> <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">branch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span> 
                               <span class="k">if</span> <span class="p">((</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="o">&gt;</span> <span class="n">max_skeletal_length</span> <span class="p">))]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_delete = </span><span class="si">{</span><span class="n">nodes_to_delete</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1">#2) Elimnate the nodes from the concept graph</span>
            <span class="n">G_short</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
            <span class="n">G_short</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_delete</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#2) Elimnate the nodes from the concept graph</span>
            <span class="n">G</span><span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
            <span class="n">G_short</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes_to_keep</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_keep = </span><span class="si">{</span><span class="n">nodes_to_keep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
        <span class="c1">#3) Divide the remaining graph into connected components</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G_short</span><span class="p">)]</span>

        <span class="n">potential_error_branches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">remove_starting_node</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">c</span> <span class="o">!=</span> <span class="n">curr_starting_node</span><span class="p">]</span>
                
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_n_nodes_in_cluster</span><span class="p">:</span>
                <span class="n">potential_error_branches</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="c1">#4)  If found any error nodes then add to limb branch dict</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">potential_error_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">potential_error_branches</span>

            
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting final low_branch clusters = </span><span class="si">{</span><span class="n">limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---- Nothing to plot -------&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">limb_branch_dict</span></div>

<div class="viewcode-block" id="neuron_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.neuron_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">neuron_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To develop a limb branch dict represnetation</span>
<span class="sd">    of the limbs and branchs of a neuron</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_branch_dict_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Neuron&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
            <span class="n">limb_branch_dict_new</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">neuron_obj</span>
        <span class="n">curr_limb_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">net</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">curr_limb_names</span><span class="p">:</span>
            <span class="n">limb_branch_dict_new</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">net</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>

        
    <span class="k">return</span> <span class="n">limb_branch_dict_new</span></div>

<div class="viewcode-block" id="limb_branch_invert"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_invert">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_invert</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">limb_branch_dict</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get every node that is not in limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    invert_limb_branch_dict(curr_neuron_obj,limb_branch_return,</span>
<span class="sd">                       verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">limb_branch_dict_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        
        <span class="n">limb_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">:</span>
            <span class="n">curr_branches</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_branches</span> <span class="o">=</span> <span class="p">[]</span>
            
        
            
        <span class="n">leftover_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">(),</span><span class="n">curr_branches</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_branches = </span><span class="si">{</span><span class="n">curr_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover_branches = </span><span class="si">{</span><span class="n">leftover_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total combined branches = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_branches</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">leftover_branches</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">, len(limb) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_new</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">leftover_branches</span>
            
    <span class="k">return</span> <span class="n">limb_branch_dict_new</span></div>

<div class="viewcode-block" id="limb_branch_combining"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_combining">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_combining</span><span class="p">(</span>
                           <span class="n">limb_branch_dict_list</span><span class="p">,</span>
                           <span class="n">combining_function</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get every node that is not in limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    invert_limb_branch_dict(curr_neuron_obj,limb_branch_return,</span>
<span class="sd">                       verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">union1d_multi_list</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_branch_dict_list</span><span class="p">])</span>
    
    
    <span class="n">limb_branch_dict_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">curr_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">limb_name</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_branch_dict_list</span><span class="p">]</span>
        
        <span class="n">leftover_branches</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">function_over_multi_lists</span><span class="p">(</span><span class="n">curr_branches</span><span class="p">,</span><span class="n">combining_function</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;combining_function = </span><span class="si">{</span><span class="n">combining_function</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_branches = </span><span class="si">{</span><span class="n">curr_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover_branches = </span><span class="si">{</span><span class="n">leftover_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">limb_branch_dict_new</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">leftover_branches</span>
            
    <span class="k">return</span> <span class="n">limb_branch_dict_new</span></div>

<div class="viewcode-block" id="limb_branch_setdiff"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_setdiff">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_setdiff</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">limb_branch_combining</span><span class="p">(</span>
                           <span class="n">limb_branch_dict_list</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_union"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_union">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_union</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">limb_branch_combining</span><span class="p">(</span>
                           <span class="n">limb_branch_dict_list</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_intersection"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_intersection">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_intersection</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">limb_branch_combining</span><span class="p">(</span>
                           <span class="n">limb_branch_dict_list</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_dict_valid"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_dict_valid">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_valid</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">limb_branch_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will convert a limb branch dict input with shortcuts</span>
<span class="sd">    (like &quot;axon&quot; or &quot;all&quot;) into a valid limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    limb_branch_dict_valid(neuron_obj,</span>
<span class="sd">                      limb_branch_dict = dict(L2=&quot;all&quot;,L3=[3,4,5]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">:</span>
        <span class="n">ax_name</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_name</span>
        <span class="k">if</span> <span class="n">ax_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">ax_name</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">}</span>
    
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>
    
    <span class="n">final_limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">branch_list</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">branch_list</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>
        <span class="n">final_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_list</span>
    
    <span class="k">return</span> <span class="n">final_limb_branch_dict</span></div>

<div class="viewcode-block" id="limb_branch_get"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_get">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_get</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">,</span><span class="n">limb_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will get the branches associated with a certain limb idx or limb name </span>
<span class="sd">    (with checks for it not being there)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    limb_idx = 0</span>
<span class="sd">    short_thick_limb_branch = au.short_thick_branches_limb_branch_dict(neuron_obj_exc_syn_sp,</span>
<span class="sd">                                            plot_limb_branch_dict = False)</span>
<span class="sd">    nodes_to_exclude = nru.limb_branch_get(short_thick_limb_branch,limb_idx)</span>
<span class="sd">    nodes_to_exclude</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></div>

<div class="viewcode-block" id="in_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.in_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">in_limb_branch_dict</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">,</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return true or false if limb and branch in limb branch dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_in</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">branch_in</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
    
    <span class="n">limb_in</span> <span class="o">=</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_in</span>
    
    <span class="k">if</span> <span class="n">limb_in</span><span class="p">:</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">branch_in</span> <span class="o">=</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">branches</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For limb = </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">, branch_idx = </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_in = </span><span class="si">{</span><span class="n">limb_in</span><span class="si">}</span><span class="s2">, branch_in = </span><span class="si">{</span><span class="n">branch_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">branch_in</span> <span class="ow">and</span> <span class="n">limb_in</span></div>
<span class="c1"># ----------- For rules with doubling back, width jumps, high degree nodes, train track crossings -------- #</span>

<div class="viewcode-block" id="high_degree_branching_coordinates_on_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.high_degree_branching_coordinates_on_limb">[docs]</a><span class="k">def</span> <span class="nf">high_degree_branching_coordinates_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                              <span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                             <span class="n">exactly_equal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find high degree coordinates on a limb</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="c1">#1) Get the limb skeleton</span>
    <span class="c1">#2) Convert the limb skeleton to a graph</span>
    <span class="c1">#limb_sk_gr = sk.convert_skeleton_to_graph(limb.skeleton)</span>
    
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">high_degree_coordinates_on_skeleton</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                 <span class="n">min_degree_to_find</span><span class="o">=</span><span class="n">min_degree_to_find</span><span class="p">,</span>
                                                  <span class="n">exactly_equal</span><span class="o">=</span><span class="n">exactly_equal</span><span class="p">,</span>
                                                 <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

    

<div class="viewcode-block" id="branches_at_high_degree_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branches_at_high_degree_coordinates">[docs]</a><span class="k">def</span> <span class="nf">branches_at_high_degree_coordinates</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                        
                                        <span class="o">**</span><span class="n">kwargs</span>
                                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To identify branches groups that are touching </span>
<span class="sd">    skeleton nodes that have nax_degree or more branches touching them</span>


<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the coordinates wtih max_degree</span>
<span class="sd">    For each coordinate</span>
<span class="sd">    2) Find branches that correspond to that coordinate and store as group</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_degree_to_find = </span><span class="si">{</span><span class="n">min_degree_to_find</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">curr_high_degree_coordinates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">high_degree_branching_coordinates_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                <span class="n">min_degree_to_find</span> <span class="o">=</span> <span class="n">min_degree_to_find</span><span class="p">,</span>
                                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">high_degree_groups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">c_coord</span><span class="p">))</span> 
                                  <span class="k">for</span> <span class="n">c_coord</span> <span class="ow">in</span> <span class="n">curr_high_degree_coordinates</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">high_degree_groups</span></div>
    
    
<div class="viewcode-block" id="high_degree_branching_coordinates_on_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.high_degree_branching_coordinates_on_neuron">[docs]</a><span class="k">def</span> <span class="nf">high_degree_branching_coordinates_on_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                 <span class="n">min_degree_to_find</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                      <span class="n">exactly_equal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find coordinate where high degree branching coordinates occur</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">limb_high_degree_coordinates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">limb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on Limb </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>

        <span class="n">curr_high_degree_coordinates</span> <span class="o">=</span> <span class="n">high_degree_branching_coordinates_on_limb</span><span class="p">(</span><span class="n">limb</span><span class="p">,</span>
                                              <span class="n">min_degree_to_find</span><span class="o">=</span><span class="n">min_degree_to_find</span><span class="p">,</span>
                                             <span class="n">exactly_equal</span><span class="o">=</span><span class="n">exactly_equal</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_high_degree_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            
            <span class="n">limb_high_degree_coordinates</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_high_degree_coordinates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_high_degree_coordinates</span></div>
    
    
<div class="viewcode-block" id="ordered_endpoints_on_branch_path"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.ordered_endpoints_on_branch_path">[docs]</a><span class="k">def</span> <span class="nf">ordered_endpoints_on_branch_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="n">starting_endpoint_coordinate</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the ordered endpoints of the skeletons </span>
<span class="sd">    of a path of branches starting at one endpoint</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">branch_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">]</span>

    <span class="n">ordered_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">order_skeletons_connecting_endpoints</span><span class="p">(</span><span class="n">branch_skeletons</span><span class="p">,</span>
    <span class="n">starting_endpoint_coordinate</span><span class="o">=</span><span class="n">starting_endpoint_coordinate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ordered_endpoints</span></div>


<div class="viewcode-block" id="axon_only_group"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.axon_only_group">[docs]</a><span class="k">def</span> <span class="nf">axon_only_group</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                   <span class="n">branches</span><span class="p">,</span>
                   <span class="n">use_axon_like</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks group or branches and returns true if all are axon</span>
<span class="sd">    or axon-dependent</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">use_axon_like</span><span class="p">:</span>
        <span class="n">labels_to_check</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;axon-like&quot;</span><span class="p">)</span>
        
    <span class="n">return_value</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span><span class="n">labels_to_check</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2"> did not have one of the following in their labels : </span><span class="si">{</span><span class="n">labels_to_check</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">return_value</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">break</span>
            
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="max_soma_volume"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.max_soma_volume">[docs]</a><span class="k">def</span> <span class="nf">max_soma_volume</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1_000_000_000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the largest number of faces out of all the somas</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#soma_volumes = [neuron_obj[k].volume/divisor for k in neuron_obj.get_soma_node_names()] </span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">soma_volumes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">/</span><span class="n">divisor</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()]</span> 
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">largest_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">soma_volumes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">largest_volume</span></div>

<div class="viewcode-block" id="max_soma_n_faces"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.max_soma_n_faces">[docs]</a><span class="k">def</span> <span class="nf">max_soma_n_faces</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the largest number of faces out of all the somas</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">soma_areas</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()]</span> 
    <span class="n">largest_soma_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">soma_areas</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">largest_soma_area</span></div>

<div class="viewcode-block" id="max_soma_area"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.max_soma_area">[docs]</a><span class="k">def</span> <span class="nf">max_soma_area</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the largest number of faces out of all the somas</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">soma_n_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()]</span> 
    <span class="n">largest_n_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">soma_n_faces</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">largest_n_faces</span></div>



<div class="viewcode-block" id="soma_centers"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.soma_centers">[docs]</a><span class="k">def</span> <span class="nf">soma_centers</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">soma_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">voxel_adjustment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">return_int_form</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_single</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will come up with the centers predicted for each of the somas in the neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">voxel_adjustment_vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="n">voxel_to_nm_scaling</span>
    
    <span class="k">if</span> <span class="n">soma_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="c1">#         current_soma_means = np.array([tu.mesh_center_vertex_average(neuron_obj[s_name].mesh) </span>
<span class="c1">#                                for s_name in neuron_obj.get_soma_node_names()])</span>
        <span class="n">current_soma_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">soma_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
                               <span class="k">for</span> <span class="n">s_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">current_soma_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">soma_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">voxel_adjustment</span> <span class="ow">and</span> <span class="n">voxel_adjustment_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">current_soma_means</span> <span class="o">=</span> <span class="n">current_soma_means</span><span class="o">/</span><span class="n">voxel_adjustment_vector</span>
        
    <span class="k">if</span> <span class="n">return_int_form</span><span class="p">:</span>
        <span class="n">current_soma_means</span> <span class="o">=</span> <span class="n">current_soma_means</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_single</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_soma_means</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not just one soma center: </span><span class="si">{</span><span class="n">current_soma_means</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_soma_means</span><span class="o">=</span><span class="n">current_soma_means</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">current_soma_means</span></div>
    
<div class="viewcode-block" id="check_points_inside_soma_bbox"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.check_points_inside_soma_bbox">[docs]</a><span class="k">def</span> <span class="nf">check_points_inside_soma_bbox</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">coordinates</span><span class="p">,</span>
                            <span class="n">soma_name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                            <span class="n">voxel_adjustment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Test if points are inside soma bounding box</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">voxel_adjustment</span><span class="p">:</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="n">voxel_to_nm_scaling</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">divisor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">inside_point_idxs</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">check_coordinates_inside_bounding_box</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">soma_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                         <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
                                          <span class="n">bbox_coordinate_divisor</span><span class="o">=</span><span class="n">divisor</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inside_point_idxs</span></div>

<div class="viewcode-block" id="pair_neuron_obj_to_nuclei"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.pair_neuron_obj_to_nuclei">[docs]</a><span class="k">def</span> <span class="nf">pair_neuron_obj_to_nuclei</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">soma_name</span><span class="p">,</span>
    <span class="n">nucleus_ids</span><span class="p">,</span>
    <span class="n">nucleus_centers</span><span class="p">,</span>
    <span class="n">nuclei_distance_threshold</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span>
    <span class="n">return_matching_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_id_0_if_no_matches</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_nuclei_within_radius</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_inside_nuclei</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">default_nuclei_id</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the Soma Center</span>
<span class="sd">    2) Get all Nuclei within a certain distance of the Soma Center</span>
<span class="sd">    3) If any Nuclei Found, Get the closest one and the distance</span>
<span class="sd">    4) Get the number of nuceli within the bouding box:</span>
<span class="sd">    -if No Nuclei were found and one was found within the bounding</span>
<span class="sd">    box then use that one</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">nucleus_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">winning_nuclei</span> <span class="o">=</span> <span class="n">default_nuclei_id</span>
        <span class="n">nuclei_distance</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">n_nuclei_in_radius</span><span class="o">=</span><span class="kc">None</span>
        <span class="n">n_nuclei_in_bbox</span><span class="o">=</span><span class="kc">None</span>
        
        <span class="n">matching_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nucleus_id</span><span class="o">=</span><span class="n">winning_nuclei</span><span class="p">,</span>
                        <span class="n">nuclei_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">n_nuclei_in_radius</span><span class="o">=</span><span class="n">n_nuclei_in_radius</span><span class="p">,</span>
                        <span class="n">n_nuclei_in_bbox</span><span class="o">=</span><span class="n">n_nuclei_in_bbox</span><span class="p">)</span>

        

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#1) Get the Soma Center</span>
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">soma_centers</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">soma_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_center = </span><span class="si">{</span><span class="n">soma_center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nucleus_centers= </span><span class="si">{</span><span class="n">nucleus_centers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



        <span class="c1">#2) Get all Nuclei within a certain distance of the Soma Center</span>


        <span class="n">nuclei_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nucleus_centers</span><span class="o">-</span><span class="n">soma_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nuclei_distances = </span><span class="si">{</span><span class="n">nuclei_distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">nuclei_within_radius_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nuclei_distances</span><span class="o">&lt;</span><span class="n">nuclei_distance_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nuclei_within_radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">nucleus_ids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nuclei_within_radius_idx</span><span class="p">]</span>
        <span class="n">nuclei_within_radius_distance</span> <span class="o">=</span> <span class="n">nuclei_distances</span><span class="p">[</span><span class="n">nuclei_within_radius_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nuclei_within_radius = </span><span class="si">{</span><span class="n">nuclei_within_radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nuclei_within_radius_distance = </span><span class="si">{</span><span class="n">nuclei_within_radius_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="n">n_nuclei_in_radius</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_within_radius</span><span class="p">)</span>

        <span class="n">winning_nuclei</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">winning_nuclei_distance</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1">#3) If any Nuclei Found, Get the closest one and the distance</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_within_radius</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

            <span class="n">winning_nuclei_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">nuclei_within_radius_distance</span><span class="p">)</span>
            <span class="n">winning_nuclei</span> <span class="o">=</span> <span class="n">nuclei_within_radius</span><span class="p">[</span><span class="n">winning_nuclei_idx</span><span class="p">]</span>
            <span class="n">winning_nuclei_distance</span> <span class="o">=</span> <span class="n">nuclei_within_radius_distance</span><span class="p">[</span><span class="n">winning_nuclei_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">There were </span><span class="si">{</span><span class="n">n_nuclei_in_radius</span><span class="si">}</span><span class="s2"> nuclei found within the radius of </span><span class="si">{</span><span class="n">nuclei_distance_threshold</span><span class="si">}</span><span class="s2"> nm&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nuclei = </span><span class="si">{</span><span class="n">winning_nuclei</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nuclei_distance = </span><span class="si">{</span><span class="n">winning_nuclei_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1">#4) Get the number of nuceli within the bouding box:</span>
        <span class="n">inside_nuclei_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">check_points_inside_soma_bbox</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">coordinates</span><span class="o">=</span><span class="n">nucleus_centers</span><span class="p">,</span>
                                    <span class="n">soma_name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                    <span class="p">)</span>

        <span class="n">inside_nuclei</span> <span class="o">=</span> <span class="p">[</span><span class="n">nucleus_ids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">inside_nuclei_idx</span><span class="p">]</span>
        <span class="n">inside_nuclei_distance</span> <span class="o">=</span> <span class="n">nuclei_distances</span><span class="p">[</span><span class="n">inside_nuclei_idx</span><span class="p">]</span>

        <span class="n">n_nuclei_in_bbox</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inside_nuclei</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> For Bounding Box Search:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside_nuclei = </span><span class="si">{</span><span class="n">inside_nuclei</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">winning_nuclei</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">inside_nuclei</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">winning_nuclei_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">inside_nuclei_distance</span><span class="p">)</span>
            <span class="n">winning_nuclei</span> <span class="o">=</span> <span class="n">inside_nuclei</span><span class="p">[</span><span class="n">winning_nuclei_idx</span><span class="p">]</span>
            <span class="n">winning_nuclei_distance</span> <span class="o">=</span> <span class="n">inside_nuclei_distance</span><span class="p">[</span><span class="n">winning_nuclei_idx</span><span class="p">]</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Used the Bounding Box to find the winning Nuclei&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nuclei = </span><span class="si">{</span><span class="n">winning_nuclei</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nuclei_distance = </span><span class="si">{</span><span class="n">winning_nuclei_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_id_0_if_no_matches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">winning_nuclei</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">winning_nuclei</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">winning_nuclei_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">winning_nuclei_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nuclei_distances</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">winning_nuclei_distance</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">At End: using return_id_0_if_no_matches = </span><span class="si">{</span><span class="n">return_id_0_if_no_matches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nuclei = </span><span class="si">{</span><span class="n">winning_nuclei</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nuclei_distance = </span><span class="si">{</span><span class="n">winning_nuclei_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_nuclei_in_radius = </span><span class="si">{</span><span class="n">n_nuclei_in_radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_nuclei_in_bbox = </span><span class="si">{</span><span class="n">n_nuclei_in_bbox</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">matching_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">nucleus_id</span><span class="o">=</span><span class="n">winning_nuclei</span><span class="p">,</span>
                            <span class="n">nuclei_distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">winning_nuclei_distance</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
                            <span class="n">n_nuclei_in_radius</span><span class="o">=</span><span class="n">n_nuclei_in_radius</span><span class="p">,</span>
                            <span class="n">n_nuclei_in_bbox</span><span class="o">=</span><span class="n">n_nuclei_in_bbox</span><span class="p">)</span>
        
        
        
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">return_matching_info</span> <span class="o">+</span> <span class="n">return_nuclei_within_radius</span> <span class="o">+</span> <span class="n">return_inside_nuclei</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">winning_nuclei</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_nuclei</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">return_matching_info</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matching_info</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_nuclei_within_radius</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nuclei_within_radius</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_inside_nuclei</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inside_nuclei</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>
    

<span class="c1"># ---- 2/15: For helping with backtracking synapses back to the somas -------- #</span>

<div class="viewcode-block" id="original_mesh_face_to_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.original_mesh_face_to_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">original_mesh_face_to_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">original_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">add_soma_label</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pupose: To create a mapping from the original mesh faces</span>
<span class="sd">    to which limb and branch it corresponds to </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    original_mesh_face_idx_to_limb_branch = nru.original_mesh_face_to_limb_branch(neuron_obj,</span>
<span class="sd">                                 original_mesh)</span>
<span class="sd">    </span>
<span class="sd">    matching_faces  = np.where((original_mesh_face_idx_to_limb_branch[:,0]==3) &amp; </span>
<span class="sd">            (original_mesh_face_idx_to_limb_branch[:,1]== 2))[0]</span>
<span class="sd">    nviz.plot_objects(original_mesh.submesh([matching_faces],append=True))</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">original_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="n">original_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Having ot generate KDTree from scratch&quot;</span><span class="p">)</span>
        <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>

    <span class="n">original_mesh_face_idx_to_limb_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>    
    
    <span class="n">t_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">limb_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Starting Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">branch_idx</span><span class="p">,</span><span class="n">branch_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
            <span class="c1">#1) Can create a mapping of the original mesh face</span>
            <span class="n">original_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                    <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                    <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>



            <span class="c1">#2) Map original mesh face --&gt; [limb,branch]</span>
            <span class="n">original_mesh_face_idx_to_limb_branch</span><span class="p">[</span><span class="n">original_mesh_faces</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">]</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Time for L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">_B</span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">add_soma_label</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">soma_face_offset</span>
        <span class="n">soma_idxs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">convert_string_names_to_int_names</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">s_idx</span> <span class="ow">in</span> <span class="n">soma_idxs</span><span class="p">:</span>
            <span class="n">curr_label</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">s_idx</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Applying Soma Label </span><span class="si">{</span><span class="n">s_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
            <span class="c1">#1) Can create a mapping of the original mesh face</span>
            <span class="n">original_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                    <span class="n">neuron_obj</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">s_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                    <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>



            <span class="c1">#2) Map original mesh face --&gt; [limb,branch]</span>
            <span class="n">original_mesh_face_idx_to_limb_branch</span><span class="p">[</span><span class="n">original_mesh_faces</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_label</span><span class="p">,</span><span class="n">curr_label</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Time for Soma Label </span><span class="si">{</span><span class="n">s_idx</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
                
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Total time for mapping: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">original_mesh_face_idx_to_limb_branch</span></div>
        
    
    

<div class="viewcode-block" id="distance_to_soma_from_coordinate_close_to_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.distance_to_soma_from_coordinate_close_to_branch">[docs]</a><span class="k">def</span> <span class="nf">distance_to_soma_from_coordinate_close_to_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">coordinate</span><span class="p">,</span>
                                                    <span class="n">limb_idx</span><span class="p">,</span>
                                                    <span class="n">branch_idx</span><span class="p">,</span>
                                                    <span class="n">limb_graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                    <span class="n">destination_node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the distance traced along the skeleton to the soma</span>
<span class="sd">    of a coordinate close to a specific branch on a limb of a neuron</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">limb_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">destination_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_starting_coordinate</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span>
        <span class="n">destination_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">curr_limb_graph</span><span class="p">,</span>
                                    <span class="n">curr_starting_coordinate</span><span class="p">,</span>
                                    <span class="n">return_single_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="n">curr_branch_skeleton</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span>

    <span class="n">syn_coord_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">closest_skeleton_coordinate</span><span class="p">(</span><span class="n">curr_branch_skeleton</span><span class="p">,</span>
                            <span class="n">coordinate</span><span class="p">)</span>

    <span class="n">output_distance</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_path_between_skeleton_coordinates</span><span class="p">(</span>
                <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">syn_coord_sk</span><span class="p">,</span>
                <span class="n">skeleton_graph</span> <span class="o">=</span> <span class="n">limb_graph</span><span class="p">,</span>
                <span class="n">destination_node</span> <span class="o">=</span> <span class="n">destination_node</span><span class="p">,</span>
                <span class="n">only_skeleton_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,)</span>
    
    <span class="k">return</span> <span class="n">output_distance</span></div>



<div class="viewcode-block" id="synapse_skeletal_distances_to_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.synapse_skeletal_distances_to_soma">[docs]</a><span class="k">def</span> <span class="nf">synapse_skeletal_distances_to_soma</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">synapse_coordinates</span><span class="p">,</span>
                                       <span class="n">original_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">scale</span><span class="o">=</span><span class="s2">&quot;um&quot;</span>
                                       
                                      <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the distance of synapses to the soma</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    A) Create the mapping of original face idx to (limb,branch)</span>
<span class="sd">    B) Map Synapses to the original face idx to get</span>
<span class="sd">        synapse --&gt; (limb,branch)</span>
<span class="sd">    C) Calculate the limb skeleton graphs before hand</span>
<span class="sd">    D) For each synapse coordinate:</span>
<span class="sd">    1) Calculate the closest skeleton point on the (limb,branch)</span>
<span class="sd">    2) Calculate distance from skeleton point to the starting coordinate of branch</span>
<span class="sd">    </span>
<span class="sd">    ** The soma distances that are -1 are usually the ones that are errored or </span>
<span class="sd">    are on the actual soma *****</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">original_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="n">original_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Having ot generate KDTree from scratch&quot;</span><span class="p">)</span>
        <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">synapse_coordinates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">filtered_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    <span class="n">all_syn_coord</span> <span class="o">=</span> <span class="n">synapse_coordinates</span>

    <span class="c1"># Part A: Get Mapping from original mesh faces to limb/branch</span>
    <span class="n">face_to_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">original_mesh_face_to_limb_branch</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                                               <span class="n">original_mesh</span><span class="p">,</span>
                                                               <span class="n">original_mesh_kdtree</span><span class="p">)</span>

    <span class="c1"># Part B: Map Synapses to the original faces</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">all_syn_coord</span><span class="p">)</span>
    <span class="n">coord_limb_branch_map</span> <span class="o">=</span> <span class="n">face_to_limb_branch</span><span class="p">[</span><span class="n">closest_face</span><span class="p">]</span>


    <span class="c1">#Part C: Calculate the limb skeletons as graph</span>

    <span class="n">unique_limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">coord_limb_branch_map</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">unique_limbs</span> <span class="o">=</span> <span class="n">unique_limbs</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_limbs</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>

    <span class="n">limb_graphs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_destination_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_limbs</span><span class="p">:</span>

        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">filtered_neuron</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">curr_limb_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">limb_graphs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb_graph</span>

        <span class="n">curr_starting_coordinate</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span>
        <span class="n">limb_destination_nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">curr_limb_graph</span><span class="p">,</span>
                                    <span class="n">curr_starting_coordinate</span><span class="p">,</span>
                                    <span class="n">return_single_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Part D: get closest skeleton point to coordinate and then distance to starting coordinate</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Turn the synapse coordinate into closest branch skeleton coordinate</span>
<span class="sd">    2) Find the skeleton distance between starting coordinate and closest skeleton coordinate</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">synapse_to_soma_distance</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">syn_idx</span><span class="p">,</span><span class="n">syn_coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_syn_coord</span><span class="p">):</span>
        <span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="n">coord_limb_branch_map</span><span class="p">[</span><span class="n">syn_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">):</span>
            <span class="n">synapse_to_soma_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">continue</span>
            
        <span class="c1"># --------- 6/4: Accounts for the labels given to the somas --------</span>
        <span class="k">if</span> <span class="n">limb_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">branch_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">synapse_to_soma_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>

        <span class="n">limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
        <span class="n">branch_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">)</span>

        <span class="n">output_distance</span> <span class="o">=</span> <span class="n">distance_to_soma_from_coordinate_close_to_branch</span><span class="p">(</span>
                                                    <span class="n">filtered_neuron</span><span class="p">,</span>
                                                     <span class="n">coordinate</span><span class="o">=</span><span class="n">syn_coord</span><span class="p">,</span>
                                                    <span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span>
                                                    <span class="n">branch_idx</span><span class="o">=</span><span class="n">branch_idx</span><span class="p">,</span>
                                            <span class="n">limb_graph</span><span class="o">=</span><span class="n">limb_graphs</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">],</span>
                                <span class="n">destination_node</span><span class="o">=</span><span class="n">limb_destination_nodes</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;um&quot;</span><span class="p">:</span>
            <span class="n">output_distance</span> <span class="o">=</span> <span class="n">output_distance</span><span class="o">/</span><span class="mi">1000</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Synapse </span><span class="si">{</span><span class="n">syn_idx</span><span class="si">}</span><span class="s2"> distance: </span><span class="si">{</span><span class="n">output_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">synapse_to_soma_distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_distance</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">synapse_to_soma_distance</span><span class="p">)</span></div>

<div class="viewcode-block" id="axon_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.axon_length">[docs]</a><span class="k">def</span> <span class="nf">axon_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;um&quot;</span><span class="p">):</span>
    
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="n">axon_skeletal_length</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                     <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;um&quot;</span><span class="p">:</span>
        <span class="n">axon_skeletal_length</span> <span class="o">=</span> <span class="n">axon_skeletal_length</span><span class="o">/</span><span class="mi">1000</span>
        
    <span class="k">return</span> <span class="n">axon_skeletal_length</span></div>

<div class="viewcode-block" id="axon_area"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.axon_area">[docs]</a><span class="k">def</span> <span class="nf">axon_area</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">units</span><span class="o">=</span><span class="s2">&quot;um&quot;</span><span class="p">):</span>
    
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="n">axon_mesh_area</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                         <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;nm&quot;</span><span class="p">:</span>
        <span class="n">axon_mesh_area</span> <span class="o">=</span> <span class="n">axon_mesh_area</span><span class="o">*</span><span class="mi">1_000_000</span>
        
    <span class="k">return</span> <span class="n">axon_mesh_area</span></div>


<div class="viewcode-block" id="axon_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.axon_mesh">[docs]</a><span class="k">def</span> <span class="nf">axon_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">axon_meshes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                     <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;mesh&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">axon_meshes</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">axon_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">axon_meshes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                     <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeleton&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">axon_meshes</span><span class="p">)</span>
    
    
<div class="viewcode-block" id="shared_skeleton_endpoints_for_connected_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.shared_skeleton_endpoints_for_connected_branches">[docs]</a><span class="k">def</span> <span class="nf">shared_skeleton_endpoints_for_connected_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branch_1</span><span class="p">,</span>
                                                    <span class="n">branch_2</span><span class="p">,</span>
                                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">check_concept_network_connectivity</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the shared skeleton endpoint of </span>
<span class="sd">    branches that are connected in the concept network</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    nru.shared_skeleton_endpoints_for_connected_branches(neuron_obj[5],</span>
<span class="sd">                                                0,1,</span>
<span class="sd">                                                verbose=True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span>
    <span class="k">if</span> <span class="n">check_concept_network_connectivity</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">branch_1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">branch_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branches </span><span class="si">{</span><span class="n">branch_1</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">branch_2</span><span class="si">}</span><span class="s2"> are not connected in the concept network&quot;</span><span class="p">)</span>

    <span class="n">shared_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_1</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                          <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_2</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                          <span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shared_endpoints = </span><span class="si">{</span><span class="n">shared_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">shared_endpoints</span></div>


<div class="viewcode-block" id="closest_branch_endpoint_to_limb_starting_coordinate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.closest_branch_endpoint_to_limb_starting_coordinate">[docs]</a><span class="k">def</span> <span class="nf">closest_branch_endpoint_to_limb_starting_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                        <span class="n">branches</span><span class="p">,</span>
                                                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will get the closest endpoints</span>
<span class="sd">    out of all the branches to the starting coordinate</span>
<span class="sd">    of limb</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the limb graph and starting coordinate</span>
<span class="sd">    2) Get the endpoints of all of the branches</span>
<span class="sd">    3) Find the closest endpoint to the starting coordinate</span>
<span class="sd">    using the skeleton search function</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    </span>
<span class="sd">    axon_limb_dict = neuron_obj.axon_limb_branch_dict</span>
<span class="sd">    axon_limb_name = list(axon_limb_dict.keys())[0]</span>

<span class="sd">    limb_obj = neuron_obj[axon_limb_name]</span>
<span class="sd">    branches = axon_limb_dict[axon_limb_name]</span>

<span class="sd">    nru.closest_branch_endpoint_to_limb_starting_coordinate(limb_obj,</span>
<span class="sd">                                                        branches,</span>
<span class="sd">                                                           )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="c1">#1) Get the limb graph and starting coordinate</span>
    <span class="n">curr_limb_sk</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">skeleton</span>
    <span class="n">curr_limb_st_coord</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_coordinate</span>

    <span class="c1">#2) Get the endpoints of all of the branches</span>
    <span class="n">all_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1">#3) Find the closest endpoint to the starting coordinate</span>
    <span class="c1">#using the skeleton search function</span>
    <span class="n">coord_1</span><span class="p">,</span><span class="n">coord_2</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_skeleton_coordiantes</span><span class="p">(</span><span class="n">curr_limb_sk</span><span class="p">,</span>
                                                            <span class="p">[</span><span class="n">curr_limb_st_coord</span><span class="p">],</span>
                                                             <span class="n">all_endpoints</span><span class="p">,</span>
                                                             <span class="n">return_closest_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coord_2</span></div>

<div class="viewcode-block" id="neuron_limb_overwrite"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.neuron_limb_overwrite">[docs]</a><span class="k">def</span> <span class="nf">neuron_limb_overwrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_name</span><span class="p">,</span><span class="n">limb_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to overwrite the limb object in a neuron</span>
<span class="sd">    with another limb object</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_obj</span></div>
    

<div class="viewcode-block" id="limb_branch_dict_to_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_dict_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_to_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: turn a limb_branch_dict into</span>
<span class="sd">    the corresponding skeleton of branches</span>
<span class="sd">    stacked together</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the skeletons over the limb branch dict</span>
<span class="sd">    2) Stack the skeletons</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branch_skeletons</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict</span><span class="p">,</span>
                                       <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
                                  <span class="n">keep_seperate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">skip_None</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">branch_skeletons</span><span class="p">))</span></div>

<div class="viewcode-block" id="axon_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.axon_skeleton">[docs]</a><span class="k">def</span> <span class="nf">axon_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_dict_to_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">axon_limb_branch_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="dendrite_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.dendrite_skeleton">[docs]</a><span class="k">def</span> <span class="nf">dendrite_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">dendrite_limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_dict_to_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">dendrite_limb_branch_dict</span><span class="p">)</span></div>


<div class="viewcode-block" id="mesh_without_mesh_attribute"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.mesh_without_mesh_attribute">[docs]</a><span class="k">def</span> <span class="nf">mesh_without_mesh_attribute</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span>
                               <span class="n">mesh_attribute</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the branch mesh without any spines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">original_mesh_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ex_branch_no_spines_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                    <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)),</span>
                                   <span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                                                            <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">original_mesh_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">original_mesh_flag</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">original_mesh_flag</span><span class="p">:</span>
        <span class="n">ex_branch_no_spines_mesh</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">mesh</span>
        
    <span class="k">return</span> <span class="n">ex_branch_no_spines_mesh</span></div>

<div class="viewcode-block" id="mesh_without_boutons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.mesh_without_boutons">[docs]</a><span class="k">def</span> <span class="nf">mesh_without_boutons</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">mesh_without_mesh_attribute</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span>
                                      <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;boutons&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="coordinates_to_closest_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.coordinates_to_closest_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">coordinates_to_closest_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">coordinates</span><span class="p">,</span>
                                      <span class="n">original_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="n">return_distances_to_limb_branch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">return_closest_faces</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To map a coordinate to the closest limb branch idx</span>
<span class="sd">    of a neuron object</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    A) Create the mapping of original face idx to (limb,branch)</span>
<span class="sd">    B) Map Coordinate to the original face idx to get</span>
<span class="sd">    c) Find mapping of Coordinate to --&gt; (limb,branch)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">coord_limb_branch_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">distance_to_limb_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">closest_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_closest_faces</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_distances_to_limb_branch</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coord_limb_branch_map</span>
        
        <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_limb_branch_map</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_distances_to_limb_branch</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_to_limb_branch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_closest_faces</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_faces</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">return_value</span>
    
    <span class="k">if</span> <span class="n">original_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh_from_branches</span>
    <span class="k">if</span> <span class="n">original_mesh_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Having ot generate KDTree from scratch&quot;</span><span class="p">)</span>
        <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>
        
    <span class="c1"># Part A: Get Mapping from original mesh faces to limb/branch</span>
    <span class="n">face_to_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">original_mesh_face_to_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                               <span class="n">original_mesh</span><span class="p">,</span>
                                                               <span class="n">original_mesh_kdtree</span><span class="p">)</span>
    
    
    
    <span class="n">all_syn_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># Part B: Map Synapses to the original faces</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">all_syn_coord</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dist = </span><span class="si">{</span><span class="n">dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_face = </span><span class="si">{</span><span class="n">closest_face</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#c) Find mapping of Coordinate to --&gt; (limb,branch)</span>
    <span class="n">coord_limb_branch_map</span> <span class="o">=</span> <span class="n">face_to_limb_branch</span><span class="p">[</span><span class="n">closest_face</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_closest_faces</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_distances_to_limb_branch</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coord_limb_branch_map</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord_limb_branch_map</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_distances_to_limb_branch</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_closest_faces</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_face</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<span class="n">closest_branch_to_coordinates</span> <span class="o">=</span> <span class="n">coordinates_to_closest_limb_branch</span>

<div class="viewcode-block" id="limb_branch_list_to_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_list_to_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_list_to_limb_branch_dict</span><span class="p">(</span><span class="n">limb_branch_list</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l_b</span> <span class="ow">in</span> <span class="n">limb_branch_list</span><span class="p">:</span>
        
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">l_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">continue</span>
        <span class="n">limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_label</span><span class="p">(</span><span class="n">l_b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;l_b = </span><span class="si">{</span><span class="n">l_b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_name = </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">l_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]:</span>
            <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict = </span><span class="si">{</span><span class="n">limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">limb_branch_dict_final</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="n">limb_branch_dict_final</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">limb_branch_dict_final</span></div>

<div class="viewcode-block" id="filter_limb_branch_dict_by_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.filter_limb_branch_dict_by_limb">[docs]</a><span class="k">def</span> <span class="nf">filter_limb_branch_dict_by_limb</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">limb_names</span><span class="p">,</span>
                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To filter a limb branch dict to only those limbs specified</span>
<span class="sd">    in the limb name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">limb_names</span><span class="p">):</span>
        <span class="n">limb_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_names</span><span class="p">]</span>
        
    <span class="n">limb_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_label</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_names</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_names = </span><span class="si">{</span><span class="n">limb_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_names</span><span class="p">}</span></div>

<div class="viewcode-block" id="boutons_above_thresholds"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.boutons_above_thresholds">[docs]</a><span class="k">def</span> <span class="nf">boutons_above_thresholds</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To filter the boutons using some measurement</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">    ns.n_boutons_above_thresholds(neuron_obj_with_boutons[axon_limb_name][5],</span>
<span class="sd">                             faces=100,</span>
<span class="sd">                            ray_trace_percentile=200)</span>
<span class="sd">                            </span>
<span class="sd">    threshodls to set: </span>
<span class="sd">    &quot;faces&quot;,&quot;ray_trace_percentile&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">n_boutons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">boutons_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">)</span>
    
    <span class="n">size_params</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span><span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">size_params</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="s2">&quot;ray_trace_percentile&quot;</span><span class="p">:</span>
                <span class="n">bouton_n_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">boutons_cdfs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bouton_n_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">boutons</span><span class="p">])</span>
            
            <span class="n">bouton_n_faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bouton_n_faces</span> <span class="o">&gt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
            <span class="n">boutons_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">boutons_idx</span><span class="p">,</span><span class="n">bouton_n_faces_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">boutons_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">boutons</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">boutons_idx</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="skeleton_coordinate_connecting_to_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_coordinate_connecting_to_downstream_branches">[docs]</a><span class="k">def</span> <span class="nf">skeleton_coordinate_connecting_to_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                         <span class="n">branch_idx</span><span class="p">,</span>
                                                          <span class="n">return_downstream_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Psuedocode:</span>
<span class="sd">    1) Will find the skeleton point that connects </span>
<span class="sd">    the current branch to the downstream branches</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_obj_nx</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj_nx</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No downstream branches&quot;</span><span class="p">)</span>
        
    <span class="n">shared_skeleton_pt</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">shared_skeleton_endpoints_for_connected_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                <span class="n">branch_idx</span><span class="p">,</span>         
                                                    <span class="n">downstream_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shared_skeleton_pt= </span><span class="si">{</span><span class="n">shared_skeleton_pt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_downstream_branches</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shared_skeleton_pt</span><span class="p">,</span><span class="n">downstream_branches</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shared_skeleton_pt</span></div>
    
<div class="viewcode-block" id="filter_branches_by_restriction_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.filter_branches_by_restriction_mesh">[docs]</a><span class="k">def</span> <span class="nf">filter_branches_by_restriction_mesh</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                       <span class="n">restriction_mesh</span><span class="p">,</span>
                                       <span class="n">percentage_threshold</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                                       <span class="n">size_measure</span><span class="o">=</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span>
                                       <span class="n">match_threshold</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Find the branches that overlap with a restriction mesh</span>
<span class="sd">    up to a certain percentage</span>
<span class="sd">    </span>
<span class="sd">    Purpose: To select a group of meshes</span>
<span class="sd">    from one other mesh based on matching threshold</span>

<span class="sd">    Pseudocode: </span>

<span class="sd">    0) Build a KDTree of the error mesh</span>
<span class="sd">    Iterate through all of the branches in that limb</span>
<span class="sd">    1) Get the mesh of the branch</span>
<span class="sd">    2) Map the branch mesh to the error mesh</span>
<span class="sd">    3) Compute the percent match of faces</span>
<span class="sd">    4) If above certain threshold then add to list</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh_list_names</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">())</span>
    <span class="n">mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_list_names</span><span class="p">]</span>

    <span class="n">mesh_idx_match</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">restrict_mesh_list_by_mesh</span><span class="p">(</span><span class="n">mesh_list</span><span class="p">,</span>
                                  <span class="n">restriction_mesh</span><span class="p">,</span>
                                   <span class="n">size_measure</span> <span class="o">=</span> <span class="n">size_measure</span><span class="p">,</span>
                                <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_threshold</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                 <span class="n">percentage_threshold</span><span class="o">=</span><span class="n">percentage_threshold</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mesh_list_names</span><span class="p">[</span><span class="n">mesh_idx_match</span><span class="p">]</span></div>

<div class="viewcode-block" id="limb_mesh_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_mesh_from_branches">[docs]</a><span class="k">def</span> <span class="nf">limb_mesh_from_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    
    <span class="n">neuron_mesh_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">branch_obj</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">:</span>
        <span class="n">neuron_mesh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
        
    <span class="n">neuron_mesh_from_branches</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">neuron_mesh_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">neuron_mesh_from_branches</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neuron_mesh_from_branches</span></div>
    
<div class="viewcode-block" id="neuron_mesh_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.neuron_mesh_from_branches">[docs]</a><span class="k">def</span> <span class="nf">neuron_mesh_from_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">plot_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To reconstruct the mesh of neuron</span>
<span class="sd">    from all of the branch obejcts</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    Iterate through all the limbs:</span>
<span class="sd">        iterate through all the branches</span>
<span class="sd">            add to big list</span>

<span class="sd">    Add some to big list</span>

<span class="sd">    concatenate list into mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

    <span class="n">neuron_mesh_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_obj</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">branch_obj</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">:</span>
            <span class="n">neuron_mesh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">neuron_mesh_list</span> <span class="o">+=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_meshes</span><span class="p">()</span>

    <span class="n">neuron_mesh_from_branches</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">neuron_mesh_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">neuron_mesh_from_branches</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neuron_mesh_from_branches</span></div>

<div class="viewcode-block" id="non_soma_touching_meshes_not_stitched"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.non_soma_touching_meshes_not_stitched">[docs]</a><span class="k">def</span> <span class="nf">non_soma_touching_meshes_not_stitched</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">return_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">                                          </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find floating meshes not used</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) construct the neuron mesh from branches</span>
<span class="sd">    2) restrict the non_soma touching pieces by the neuron_mesh</span>
<span class="sd">    3) Return either the meshes or indexes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) construct the neuron mesh from branches</span>
    <span class="n">n_mesh</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_mesh_from_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="c1">#2) restrict the non_soma touching pieces by the neuron_mesh</span>
    <span class="n">floating_meshes_non_incorporated</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">restrict_mesh_list_by_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                  <span class="n">restriction_mesh</span><span class="o">=</span><span class="n">n_mesh</span><span class="p">,</span>
                                  <span class="n">percentage_threshold</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                                  <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                  <span class="n">return_under_threshold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_meshes</span><span class="o">=</span><span class="n">return_meshes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">floating_meshes_non_incorporated</span></div>

<div class="viewcode-block" id="non_soma_touching_meshes_stitched"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.non_soma_touching_meshes_stitched">[docs]</a><span class="k">def</span> <span class="nf">non_soma_touching_meshes_stitched</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">return_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">                                          </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find floating meshes not used</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) construct the neuron mesh from branches</span>
<span class="sd">    2) restrict the non_soma touching pieces by the neuron_mesh</span>
<span class="sd">    3) Return either the meshes or indexes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) construct the neuron mesh from branches</span>
    <span class="n">n_mesh</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_mesh_from_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="c1">#2) restrict the non_soma touching pieces by the neuron_mesh</span>
    <span class="n">floating_meshes_incorporated</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">restrict_mesh_list_by_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                  <span class="n">restriction_mesh</span><span class="o">=</span><span class="n">n_mesh</span><span class="p">,</span>
                                  <span class="n">percentage_threshold</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                                  <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                  <span class="n">return_under_threshold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">return_meshes</span><span class="o">=</span><span class="n">return_meshes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">floating_meshes_incorporated</span></div>

<div class="viewcode-block" id="all_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_downstream_branches">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branch_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return all of the branches that are downstream</span>
<span class="sd">    of the branch_idx</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="feature_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.feature_over_branches">[docs]</a><span class="k">def</span> <span class="nf">feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">branch_list</span><span class="p">,</span>
                                 <span class="n">feature_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">use_limb_obj_and_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">combining_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To calculate a certain feature over </span>
<span class="sd">    all the branches in a list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">feature_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">feature_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">feature_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">feature_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_limb_obj_and_branch_idx</span><span class="p">:</span>
                <span class="n">curr_val</span> <span class="o">=</span> <span class="n">feature_function</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_val</span> <span class="o">=</span> <span class="n">feature_function</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="o">=</span><span class="n">b</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to set either feature_name or feature function&quot;</span><span class="p">)</span>
            
        <span class="n">feature_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_val</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;feature_list (before combining) = </span><span class="si">{</span><span class="n">feature_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">combining_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">feature_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">feature_list</span> <span class="o">=</span> <span class="n">combining_function</span><span class="p">(</span><span class="n">feature_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">feature_list</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;feature_list (after combining) = </span><span class="si">{</span><span class="n">feature_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">feature_list</span></div>

<div class="viewcode-block" id="sum_feature_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.sum_feature_over_branches">[docs]</a><span class="k">def</span> <span class="nf">sum_feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">branch_list</span><span class="p">,</span>
                                 <span class="n">feature_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">branch_list</span><span class="p">,</span>
                                 <span class="n">feature_name</span><span class="o">=</span><span class="n">feature_name</span><span class="p">,</span>
                                  <span class="n">feature_function</span><span class="o">=</span><span class="n">feature_function</span><span class="p">,</span>
                                 <span class="n">combining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_over_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeletal_length_over_downstream_branches">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_over_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                            <span class="n">branch_idx</span><span class="p">,</span>
                                            <span class="n">combining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
                                             <span class="n">include_branch_skeletal_length</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will compute how much skeleton there is downstream of a certain node</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">all_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">include_branch_skeletal_length</span><span class="p">:</span>
        <span class="n">downstream_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">)</span>
        
    <span class="n">sk_sum</span> <span class="o">=</span><span class="n">nru</span><span class="o">.</span><span class="n">feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                              <span class="n">branch_list</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">,</span>
                              <span class="n">feature_name</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
                              <span class="n">combining_function</span> <span class="o">=</span> <span class="n">combining_function</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                             <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total skeleton downstream = </span><span class="si">{</span><span class="n">sk_sum</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sk_sum</span></div>

<div class="viewcode-block" id="classify_upstream_downsream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.classify_upstream_downsream">[docs]</a><span class="k">def</span> <span class="nf">classify_upstream_downsream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                               <span class="n">branch_list</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Psuedocode: Given a list of branches that are all touching a certain coordinate,</span>
<span class="sd">    determine which of the branches are the upstream and which are the downstream</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Pick the first branch</span>
<span class="sd">    2) Get the sibling nodes</span>
<span class="sd">    3) Get overlap, if no overlap between sibling nodes and rest of the group</span>
<span class="sd">    yes --&gt; it is upstream --&gt; get downstream by filtering out upstream</span>
<span class="sd">    no --&gt; it is downstream --&gt; get upstream by filtering out all of siblings and sel</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">branch_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>
    <span class="c1">#1) Pick the first branch</span>
    <span class="n">test_node</span> <span class="o">=</span> <span class="n">branch_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1">#2) Get the sibling nodes</span>
    <span class="n">sib_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">test_node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For test node </span><span class="si">{</span><span class="n">test_node</span><span class="si">}</span><span class="s2">, sibling nodes were: </span><span class="si">{</span><span class="n">sib_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) Getting overlap</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">branch_list</span><span class="p">,</span><span class="n">sib_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;overlap = </span><span class="si">{</span><span class="n">overlap</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">test_node</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">branch_list</span><span class="p">[</span><span class="n">branch_list</span> <span class="o">!=</span> <span class="n">test_node</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With test node equal to the upstream node&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream = </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">, downstream_nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">sib_nodes</span><span class="p">,[</span><span class="n">test_node</span><span class="p">]])</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">branch_list</span><span class="p">,</span><span class="n">downstream_nodes</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With test node equal to the downstream node&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream = </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">, downstream_nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span>
    <span class="c1">#xu.downstream_nodes(limb_obj.concept_network_directional,upstream_node)</span>
    <span class="k">return</span> <span class="n">upstream_node</span><span class="p">,</span><span class="n">downstream_nodes</span></div>


<div class="viewcode-block" id="is_limb_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.is_limb_obj">[docs]</a><span class="k">def</span> <span class="nf">is_limb_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if the object is a limb object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.is_neuron_obj">[docs]</a><span class="k">def</span> <span class="nf">is_neuron_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if the object is a limb object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_branch_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.is_branch_obj">[docs]</a><span class="k">def</span> <span class="nf">is_branch_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if the object is a limb object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="branches_combined_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branches_combined_mesh">[docs]</a><span class="k">def</span> <span class="nf">branches_combined_mesh</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branches</span><span class="p">,</span>
                          <span class="n">plot_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To combine the mesh objects of branch indexes</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    branches_combined_mesh(limb_obj,branches=[45, 58, 61,66],</span>
<span class="sd">                          plot_mesh=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
    <span class="n">mesh_inter</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh_inter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh_inter</span></div>

<div class="viewcode-block" id="coordinate_to_offset_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.coordinate_to_offset_skeletons">[docs]</a><span class="k">def</span> <span class="nf">coordinate_to_offset_skeletons</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                  <span class="n">coordinate</span><span class="p">,</span>
                                   <span class="n">branches</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                   <span class="n">offset</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
                                    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                                   <span class="n">plot_offset_skeletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="n">return_skeleton_endpoints</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return the offset skeletons of branches</span>
<span class="sd">    that all intersect at a coordinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">coordinate</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches = </span><span class="si">{</span><span class="n">branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">skeletons</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">])</span>
    <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">unique_comb</span> <span class="o">=</span> <span class="p">[[</span><span class="n">upstream_branch</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unique_comb = </span><span class="si">{</span><span class="n">unique_comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">aligned_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">unique_comb</span><span class="p">:</span>
        <span class="n">edge_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">skeletons</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">skeletons</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="n">aligned_sk_parts</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">offset_skeletons_aligned_at_shared_endpoint</span><span class="p">(</span><span class="n">edge_skeletons</span><span class="p">,</span>
                                                                                 <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                                                 <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                                                 <span class="n">common_endpoint</span><span class="o">=</span><span class="n">coordinate</span><span class="p">)</span>
        <span class="n">aligned_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aligned_sk_parts</span><span class="p">)</span>

    <span class="n">offset_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">aligned_skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aligned_skeletons</span><span class="p">]</span>
    
    <span class="n">skeleton_offset_end_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">offset_skeletons</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot_offset_skeletons</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offset_skeletons</span><span class="p">),</span>
                                                         <span class="n">user_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">,</span><span class="s2">&quot;red&quot;</span><span class="p">,])</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="n">colors</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                          <span class="n">skeletons</span><span class="o">=</span><span class="n">offset_skeletons</span><span class="p">,</span>
                          <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="n">skeleton_offset_end_points</span><span class="p">,</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_skeleton_endpoints</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">offset_skeletons</span><span class="p">,</span><span class="n">skeleton_offset_end_points</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">offset_skeletons</span></div>
    
    
<div class="viewcode-block" id="upstream_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.upstream_node">[docs]</a><span class="k">def</span> <span class="nf">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch</span><span class="p">)</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def upstream_endpoint(limb_obj,</span>
<span class="sd">                     branch_idx,</span>
<span class="sd">                     verbose = False,</span>
<span class="sd">                     return_endpoint_index=False):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the upsream node</span>
<span class="sd">    2a) if upstream node is None then use the current current starting node</span>
<span class="sd">    2b) if upstream node, find the common skeleton point between the 2</span>

<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    limb_obj = neuron_obj[2]</span>
<span class="sd">    for branch_idx in limb_obj.get_branch_names():</span>
<span class="sd">        k = nru.upstream_endpoint(limb_obj = limb_obj,</span>
<span class="sd">        branch_idx = branch_idx,</span>
<span class="sd">        verbose = True,</span>
<span class="sd">                             return_endpoint_index = True)</span>
<span class="sd">        total_dist = nst.total_upstream_skeletal_length(limb_obj,branch_idx)</span>
<span class="sd">        print(f&quot;k = {k}&quot;)</span>
<span class="sd">        print(f&quot;total upstream dist = {total_dist}\n&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    upstream_node = nru.upstream_node(limb_obj,branch_idx)</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;upstream_node for {branch_idx}: {upstream_node}&quot;)</span>

<span class="sd">    if upstream_node is None:</span>
<span class="sd">        common_endpoint = limb_obj.current_starting_coordinate</span>
<span class="sd">    else:</span>
<span class="sd">        shared_endooints = nru.shared_skeleton_endpoints_for_connected_branches(limb_obj,</span>
<span class="sd">                                                        branch_idx,</span>
<span class="sd">                                                        upstream_node,</span>
<span class="sd">                                                        check_concept_network_connectivity=False).reshape(-1,3)</span>
<span class="sd">        common_endpoint = shared_endooints[0]</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;shared_endooints = {shared_endooints}&quot;)</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;common_endpoint = {common_endpoint}&quot;)</span>
<span class="sd">        </span>
<span class="sd">    if return_endpoint_index:</span>
<span class="sd">        endpoint_index = nu.matching_row_index(limb_obj[branch_idx].endpoints,common_endpoint)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;endpoints = {limb_obj[branch_idx].endpoints}&quot;)</span>
<span class="sd">            print(f&quot;return_endpoint_index = {endpoint_index}&quot;)</span>
<span class="sd">        return endpoint_index</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    return common_endpoint</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="neighbor_endpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.neighbor_endpoint">[docs]</a><span class="k">def</span> <span class="nf">neighbor_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                     <span class="n">branch_idx</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">return_endpoint_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">neighbor_type</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the upsream node</span>
<span class="sd">    2a) if upstream node is None then use the current current starting node</span>
<span class="sd">    2b) if upstream node, find the common skeleton point between the 2</span>

<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    limb_obj = neuron_obj[2]</span>
<span class="sd">    for branch_idx in limb_obj.get_branch_names():</span>
<span class="sd">        k = nru.upstream_endpoint(limb_obj = limb_obj,</span>
<span class="sd">        branch_idx = branch_idx,</span>
<span class="sd">        verbose = True,</span>
<span class="sd">                             return_endpoint_index = True)</span>
<span class="sd">        total_dist = nst.total_upstream_skeletal_length(limb_obj,branch_idx)</span>
<span class="sd">        print(f&quot;k = {k}&quot;)</span>
<span class="sd">        print(f&quot;total upstream dist = {total_dist}\n&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_node for </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_coordinate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shared_endooints</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">shared_skeleton_endpoints_for_connected_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                        <span class="n">branch_idx</span><span class="p">,</span>
                                                        <span class="n">upstream_node</span><span class="p">,</span>
                                                        <span class="n">check_concept_network_connectivity</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">shared_endooints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shared_endooints = </span><span class="si">{</span><span class="n">shared_endooints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;common_endpoint = </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">neighbor_type</span> <span class="o">==</span> <span class="s2">&quot;upstream&quot;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">neighbor_type</span> <span class="o">==</span> <span class="s2">&quot;downstream&quot;</span><span class="p">:</span>
        <span class="n">endpoint_index</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_row_index</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span><span class="n">common_endpoint</span><span class="p">)</span>
        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">endpoint_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The donwsream endpoint is </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown neighbor_type: </span><span class="si">{</span><span class="n">neighbor_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_endpoint_index</span><span class="p">:</span>
        <span class="n">endpoint_index</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">matching_row_index</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span><span class="n">common_endpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints = </span><span class="si">{</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_endpoint_index = </span><span class="si">{</span><span class="n">endpoint_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">endpoint_index</span>
        
        
    <span class="k">return</span> <span class="n">common_endpoint</span></div>


<div class="viewcode-block" id="upstream_endpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.upstream_endpoint">[docs]</a><span class="k">def</span> <span class="nf">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                     <span class="n">branch_idx</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">return_endpoint_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the coordinate of the part of the </span>
<span class="sd">    skeleton connecting to the upstream branch</span>
<span class="sd">    </span>
<span class="sd">    branch_idx = 263</span>
<span class="sd">    nviz.plot_objects(main_mesh = neuron_obj[0].mesh,</span>
<span class="sd">                     skeletons=[neuron_obj[0][branch_idx].skeleton],</span>
<span class="sd">                      scatters=[nru.upstream_endpoint(neuron_obj[0],</span>
<span class="sd">                         branch_idx),</span>
<span class="sd">                               nru.downstream_endpoint(neuron_obj[0],</span>
<span class="sd">                         branch_idx)],</span>
<span class="sd">                      scatters_colors=[&quot;red&quot;,&quot;blue&quot;]</span>
<span class="sd">                     )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">neighbor_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                     <span class="n">branch_idx</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">,</span>
                     <span class="n">return_endpoint_index</span><span class="p">,</span>
                     <span class="n">neighbor_type</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="downstream_endpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.downstream_endpoint">[docs]</a><span class="k">def</span> <span class="nf">downstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                     <span class="n">branch_idx</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">return_endpoint_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">neighbor_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                     <span class="n">branch_idx</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">,</span>
                     <span class="n">return_endpoint_index</span><span class="p">,</span>
                     <span class="n">neighbor_type</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="upstream_downstream_endpoint_idx"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.upstream_downstream_endpoint_idx">[docs]</a><span class="k">def</span> <span class="nf">upstream_downstream_endpoint_idx</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To get the upstream and downstream endpoint idx</span>
<span class="sd">    returned (upstream_idx,downstream_idx)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">up_idx</span> <span class="o">=</span> <span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                     <span class="n">branch_idx</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                     <span class="n">return_endpoint_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">up_idx</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="n">up_idx</span><span class="p">)</span></div>
    
    

<div class="viewcode-block" id="downstream_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_downstream_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">n_downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.width">[docs]</a><span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
         <span class="n">axon_flag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">width_name_backup</span><span class="o">=</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
         <span class="n">width_name_backup_2</span> <span class="o">=</span> <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will extract the width from a branch that</span>
<span class="sd">    tries different width types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axon_flag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">or</span> <span class="s2">&quot;axon-like&quot;</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="n">axon_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axon_flag</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">if</span> <span class="n">axon_flag</span><span class="p">:</span>
        <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;no_bouton_median&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span>
    
    <span class="n">widths_to_try</span> <span class="o">=</span> <span class="p">[</span><span class="n">width_name</span><span class="p">,</span><span class="n">width_name_backup</span><span class="p">,</span><span class="n">width_name_backup_2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">w_name</span> <span class="ow">in</span> <span class="n">widths_to_try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">w_name</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using width </span><span class="si">{</span><span class="n">w_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">w_name</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using generic width because None of the widths found: </span><span class="si">{</span><span class="n">widths_to_try</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">width</span></div>
    
    
<div class="viewcode-block" id="branch_path_to_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_path_to_node">[docs]</a><span class="k">def</span> <span class="nf">branch_path_to_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">start_idx</span><span class="p">,</span>
                            <span class="n">destination_idx</span><span class="p">,</span>
                             <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">include_last_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">reverse_di_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">starting_soma_for_di_graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the branch objects on the path</span>
<span class="sd">    from current branch to the starting coordinate</span>

<span class="sd">    Application: Will know what width objects to compare to</span>
<span class="sd">    for width jump</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the starting coordinate of brnach</span>
<span class="sd">    2) Find the shortest path from branch_idx to starting branch</span>
<span class="sd">    3) Have option to include starting branch or not</span>
<span class="sd">    3) If skeletal length threshold is set then:</span>
<span class="sd">    a. get skeletal length of all branches on path</span>
<span class="sd">    b. Filter out all branches that are not above the skeletal length threshold</span>

<span class="sd">    Example: </span>
<span class="sd">    for k in limb_obj.get_branch_names():</span>
<span class="sd">        nru.branch_path_to_start_node(limb_obj = neuron_obj[0],</span>
<span class="sd">        branch_idx = k,</span>
<span class="sd">        include_branch_idx = False,</span>
<span class="sd">        skeletal_length_min = 2000,</span>
<span class="sd">        verbose = False)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Ex: How to find path from one branch to another after starting</span>
<span class="sd">    from a certain soma</span>
<span class="sd">    </span>
<span class="sd">    nru.branch_path_to_node(neuron_obj[0],</span>
<span class="sd">                       start_idx = 109,</span>
<span class="sd">                       destination_idx = 164,</span>
<span class="sd">                       starting_soma_for_di_graph = &quot;S0&quot;,</span>
<span class="sd">                       include_branch_idx = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">starting_soma_for_di_graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">soma_group_idx</span><span class="o">=</span><span class="n">starting_soma_for_di_graph</span><span class="p">,</span>
                                                <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>
    <span class="k">elif</span> <span class="n">reverse_di_graph</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">reverse_DiGraph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>

    <span class="c1">#2) Find the shortest path from branch_idx to starting branch</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                         <span class="n">start_idx</span><span class="p">,</span><span class="n">destination_idx</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path = </span><span class="si">{</span><span class="n">shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">shortest_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No path between Nodes so returning None&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shortest_path</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_branch_idx</span><span class="p">:</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shortest_path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_last_branch_idx</span><span class="p">:</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">skeletal_length_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sk_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shortest_path</span><span class="p">])</span>
        <span class="n">shortest_path</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">sk_len</span><span class="o">&gt;</span><span class="n">skeletal_length_min</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shortest_path AFTER skeletal length filtering above&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot; skeletal_length_min (</span><span class="si">{</span><span class="n">skeletal_length_min</span><span class="si">}</span><span class="s2">): </span><span class="se">\n</span><span class="s2">   </span><span class="si">{</span><span class="n">shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">shortest_path</span></div>

<div class="viewcode-block" id="branch_path_to_start_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_path_to_start_node">[docs]</a><span class="k">def</span> <span class="nf">branch_path_to_start_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">include_last_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    <span class="n">start_idx</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_idx = </span><span class="si">{</span><span class="n">start_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">destination_idx</span><span class="o">=</span><span class="n">start_idx</span><span class="p">,</span>
                             <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                              <span class="n">include_last_branch_idx</span> <span class="o">=</span> <span class="n">include_last_branch_idx</span><span class="p">,</span>
                            <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="n">skeletal_length_min</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="branch_path_to_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_path_to_soma">[docs]</a><span class="k">def</span> <span class="nf">branch_path_to_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">),</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_path</span><span class="p">(</span>
            <span class="n">limb_obj</span><span class="p">,</span><span class="n">path</span><span class="p">,</span> 
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">path</span></div>
    
<div class="viewcode-block" id="min_width_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.min_width_upstream">[docs]</a><span class="k">def</span> <span class="nf">min_width_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">branch_idx</span><span class="p">,</span>
                      <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                       <span class="n">default_value</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">remove_first_branch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">remove_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find the width jump from </span>
<span class="sd">    the minimum of all of the branches proceeding</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the nodes that proceed the branch</span>
<span class="sd">    2) Find the minimum of these branches</span>
<span class="sd">    3) Subtrack the minimum from the current branch width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">path_to_start</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_start_node</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
        <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="n">skeletal_length_min</span><span class="p">,</span>
        <span class="n">include_last_branch_idx</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">remove_first_branch</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_to_start = </span><span class="si">{</span><span class="n">path_to_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">path_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path_to_start</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_widths = </span><span class="si">{</span><span class="n">path_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">remove_zeros</span><span class="p">:</span>
        <span class="n">path_widths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">path_widths</span><span class="p">[</span><span class="n">path_widths</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;path_widths AFTER REMOVING ZEROS= </span><span class="si">{</span><span class="n">path_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">path_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_value</span><span class="p">)</span>
    <span class="n">min_path_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">path_widths</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_path_width = </span><span class="si">{</span><span class="n">min_path_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">min_path_width</span></div>

<div class="viewcode-block" id="pair_branch_connected_components"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.pair_branch_connected_components">[docs]</a><span class="k">def</span> <span class="nf">pair_branch_connected_components</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_conn_comp_before_combining</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pair_method</span> <span class="o">=</span> <span class="s2">&quot;skeleton_angle&quot;</span><span class="p">,</span>

        <span class="c1">#for the skeleton angle pairing</span>
        <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span>
        <span class="n">thick_width_threshold</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">comparison_distance_thick</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
        <span class="n">offset_thick</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">comparison_distance_thin</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span>
        <span class="n">offset_thin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">plot_intermediates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To pair branches of a subgraph</span>
<span class="sd">    together if they match skeleton angles </span>
<span class="sd">    or some other criteria</span>

<span class="sd">    Application: for grouping </span>
<span class="sd">    red/blue splits together</span>

<span class="sd">    Arguments: </span>
<span class="sd">    1) Limb object</span>
<span class="sd">    2) branches to check for connectivity (or the connected components precomputed)</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Compute the connected components if not already done</span>
<span class="sd">    1) For each connected component: </span>
<span class="sd">    a. Find path of connected component back to the starting node</span>
<span class="sd">    b. If path only of size 1 then just return either error branches or connected components</span>
<span class="sd">    c. Get the border error branch and the border parent branch from the path</span>
<span class="sd">    d) add the border error branch to a dictionary mapping parent to border branch and the conn comp it belongs to</span>

<span class="sd">    2) For each parent branch:</span>
<span class="sd">    - if list is longer than 1</span>
<span class="sd">      a. match the border error branches to each other to see if should be connected</span>
<span class="sd">      ( have argument to set the function to use for this)</span>
<span class="sd">      b. If have any matches then add the pairings to a list of lists, else add to a seperate list</span>

<span class="sd">    3. Use the pairings to create new connected components if any should be combined</span>


<span class="sd">    Example: </span>
<span class="sd">    nru.pair_branch_connected_components(limb_obj=neuron_obj[1],</span>
<span class="sd">    branches = limb_branch_dict[&quot;L1&quot;],</span>
<span class="sd">    conn_comp = None,</span>
<span class="sd">    plot_conn_comp_before_combining = False,</span>
<span class="sd">    pair_method = &quot;pair_all&quot;,</span>
<span class="sd">                                verbose = True)</span>
<span class="sd">                                </span>
<span class="sd">                                </span>
<span class="sd">    Example 2: </span>
<span class="sd">    nru.pair_branch_connected_components(limb_obj=neuron_obj[1],</span>
<span class="sd">    #branches = limb_branch_dict[&quot;L1&quot;],</span>
<span class="sd">    conn_comp = xu.connected_components(limb_obj.concept_network_directional.subgraph(limb_branch_dict[&quot;L1&quot;]),</span>
<span class="sd">                       ),</span>
<span class="sd">    plot_conn_comp_before_combining = False,</span>
<span class="sd">                                verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
    <span class="c1">#0) Compute the connected components if not already done</span>
    <span class="k">if</span> <span class="n">conn_comp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">branches</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">branches</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">concatenate_lists</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">branches</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp = </span><span class="si">{</span><span class="n">conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches = </span><span class="si">{</span><span class="n">branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_conn_comp_before_combining</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot connected components before combined&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">branches</span><span class="p">),</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;    </span>
<span class="sd">    1) For each connected component: </span>
<span class="sd">    a. Find path of connected component back to the starting node</span>
<span class="sd">    b. If path only of size 1 then just return either error branches or connected components</span>
<span class="sd">    c. Get the border error branch and the border parent branch from the path</span>
<span class="sd">    d) add the border error branch to a dictionary mapping parent to border branch and the conn comp it belongs to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent_to_branch_borders</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">):</span>
        <span class="n">short_path</span><span class="p">,</span><span class="n">st</span><span class="p">,</span><span class="n">end</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">c</span><span class="p">,[</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">])</span>
    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(f&quot;short_path,st,end= {short_path,st,end}&quot;)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">short_path</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">parent_border</span> <span class="o">=</span> <span class="n">short_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">branch_border</span> <span class="o">=</span> <span class="n">st</span>

        <span class="k">if</span> <span class="n">parent_border</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent_to_branch_borders</span><span class="p">:</span>
            <span class="n">parent_to_branch_borders</span><span class="p">[</span><span class="n">parent_border</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_border</span><span class="p">],</span>
                                                         <span class="n">conn_comp_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                                          <span class="n">branch_to_comp_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">branch_border</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent_to_branch_borders</span><span class="p">[</span><span class="n">parent_border</span><span class="p">][</span><span class="s2">&quot;branch_idx&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_border</span><span class="p">)</span>
            <span class="n">parent_to_branch_borders</span><span class="p">[</span><span class="n">parent_border</span><span class="p">][</span><span class="s2">&quot;conn_comp_idx&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">parent_to_branch_borders</span><span class="p">[</span><span class="n">parent_border</span><span class="p">][</span><span class="s2">&quot;branch_to_comp_map&quot;</span><span class="p">][</span><span class="n">branch_border</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parent_to_branch_borders = </span><span class="si">{</span><span class="n">parent_to_branch_borders</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2) For each parent branch:</span>
<span class="sd">    - if list is longer than 1</span>
<span class="sd">      a. match the border error branches to each other to see if should be connected</span>
<span class="sd">      ( have argument to set the function to use for this)</span>
<span class="sd">      b. If have any matches then add the pairings to a list of lists, else add to a seperate list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conn_comp_pairings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">parent_idx</span><span class="p">,</span><span class="n">border_info</span> <span class="ow">in</span> <span class="n">parent_to_branch_borders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">border_info</span><span class="p">[</span><span class="s2">&quot;branch_idx&quot;</span><span class="p">])</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1">#a. match the border error branches to each other to see if should be connected</span>
        <span class="k">if</span> <span class="n">pair_method</span> <span class="o">==</span> <span class="s2">&quot;pair_all&quot;</span><span class="p">:</span>
            <span class="n">conn_comp_pairings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">border_info</span><span class="p">[</span><span class="s2">&quot;conn_comp_idx&quot;</span><span class="p">])</span>
            <span class="c1">#conn_comp_pairings.append(border_info[&quot;branch_idx&quot;])</span>
        <span class="k">elif</span> <span class="n">pair_method</span> <span class="o">==</span> <span class="s2">&quot;skeleton_angle&quot;</span><span class="p">:</span>
            <span class="n">parent_width</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">parent_idx</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">parent_width</span> <span class="o">&gt;</span> <span class="n">thick_width_threshold</span><span class="p">:</span>
                <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_thick</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_thick</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_thin</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_thin</span>


            <span class="n">curr_branches</span> <span class="o">=</span> <span class="n">border_info</span><span class="p">[</span><span class="s2">&quot;branch_idx&quot;</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">matched_edges</span><span class="p">,</span> <span class="n">matched_edges_angles</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">matched_branches_by_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                               <span class="n">branches</span> <span class="o">=</span> <span class="n">border_info</span><span class="p">[</span><span class="s2">&quot;branch_idx&quot;</span><span class="p">],</span>
                                                            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                            <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                                            <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_threshold</span><span class="p">,</span>
                                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                            <span class="n">plot_intermediates</span> <span class="o">=</span> <span class="n">plot_intermediates</span><span class="p">,</span>
                                                            <span class="n">plot_match_intermediates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                            <span class="n">less_than_threshold</span> <span class="o">=</span> <span class="kc">True</span>
                                                            <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hit an error when doing matched_branches_by_angle: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">matched_edges</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_edges</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">match_G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges_and_weights_to_graph</span><span class="p">(</span><span class="n">matched_edges</span><span class="p">)</span>
                <span class="n">match_G_conn_comp</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">match_G</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">m_comp</span> <span class="ow">in</span> <span class="n">match_G_conn_comp</span><span class="p">:</span>
                    <span class="n">m_comp_conn_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">border_info</span><span class="p">[</span><span class="s2">&quot;branch_to_comp_map&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m_comp</span><span class="p">]</span>

                    <span class="n">conn_comp_pairings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_comp_conn_idx</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parent_width = </span><span class="si">{</span><span class="n">parent_width</span><span class="si">}</span><span class="s2">, comparison_distance = </span><span class="si">{</span><span class="n">comparison_distance</span><span class="si">}</span><span class="s2">, offset = </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matched_edges = </span><span class="si">{</span><span class="n">matched_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented pair_method = </span><span class="si">{</span><span class="n">pair_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp_pairings = </span><span class="si">{</span><span class="n">conn_comp_pairings</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3. Use the pairings to create new connected components if any should be combined</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_conn_comp_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">))</span>
    <span class="n">conn_comp_ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span>
    <span class="n">final_comp_comp_from_pair</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">conn_comp_ar</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                                 <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp_pairings</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_comp_comp_from_pair</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">conn_comp_idx_from_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">conn_comp_pairings</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conn_comp_idx_from_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">conn_comp_idx_leftover</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">all_conn_comp_idx</span><span class="p">,</span><span class="n">conn_comp_idx_from_pairs</span><span class="p">)</span>
    <span class="n">conn_comp_from_leftover</span> <span class="o">=</span> <span class="p">[</span><span class="n">conn_comp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp_idx_leftover</span><span class="p">]</span>

    <span class="n">conn_comp_combined</span> <span class="o">=</span> <span class="n">final_comp_comp_from_pair</span> <span class="o">+</span> <span class="n">conn_comp_from_leftover</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_comp_comp_from_pair = </span><span class="si">{</span><span class="n">final_comp_comp_from_pair</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp_idx_leftover = </span><span class="si">{</span><span class="n">conn_comp_idx_leftover</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp_from_leftover = </span><span class="si">{</span><span class="n">conn_comp_from_leftover</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_comp_combined = </span><span class="si">{</span><span class="n">conn_comp_combined</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">conn_comp_combined</span></div>

<span class="sd">&#39;&#39;&#39;def restrict_skeleton_from_start_plus_offset_upstream_old(</span>
<span class="sd">    limb_obj,</span>
<span class="sd">    branch_idx,</span>
<span class="sd">    starting_endpoint=None,</span>
<span class="sd">    offset=500,</span>
<span class="sd">    comparison_distance=2000,</span>
<span class="sd">    skeleton_segment_size=100,</span>
<span class="sd">    width_name= &quot;no_spine_median_mesh_center&quot;,</span>
<span class="sd">    width_name_backup = &quot;no_spine_median_mesh_center&quot;,</span>
<span class="sd">    return_width = False,</span>
<span class="sd">    plot_skeleton = False,</span>
<span class="sd">    verbose = False):</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Get the upstream skeleton (that potentially goes past the current branch itself)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    restrict_skeleton_from_start_plus_offset_upstream(</span>
<span class="sd">    limb_obj,</span>
<span class="sd">    branch_idx=100,</span>
<span class="sd">    starting_endpoint=None,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    plot_skeleton=True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    if starting_endpoint is None:</span>
<span class="sd">        upstream_common_endpoint = nru.downstream_endpoint(limb_obj,branch_idx)</span>
<span class="sd">    else:</span>
<span class="sd">        upstream_common_endpoint = starting_endpoint</span>

<span class="sd">    # ----- Part 2: Do the processing on the upstream nodes -------------- #</span>
<span class="sd">    upstream_offset = offset</span>
<span class="sd">    upstream_comparison = comparison_distance</span>
<span class="sd">    upstream_node = branch_idx</span>
<span class="sd">    upstream_skeleton = []</span>
<span class="sd">    upstream_seg_lengths = []</span>
<span class="sd">    upstream_seg_widths = []</span>
<span class="sd">    curr_limb = limb_obj</span>
<span class="sd">    previous_node = None</span>

<span class="sd">    count = 0</span>
<span class="sd">    while upstream_comparison &gt; 0:</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        1) Get shared endpoint of upstream and previous node</span>
<span class="sd">        2) resize the upstream skeleton to get it ordered and right scale of width</span>
<span class="sd">        3) Flip the skeleton and width array if needs to be flipped</span>
<span class="sd">        4) if current offset is greater than 0, then restrict skeelton to offset:</span>
<span class="sd">        5a) if it was not long enough:</span>
<span class="sd">            - subtact total length from buffer</span>
<span class="sd">        5b) If successful:</span>
<span class="sd">            - restrit skeleton by comparison distance</span>
<span class="sd">            - Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            - subtract new distance from comparison distance</span>
<span class="sd">            - if comparison distance is 0 or less then break</span>
<span class="sd">        6)  change out upstream node and previous node (because at this point haven&#39;t broken outside loop)</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;--- Upstream iteration: {count} -----&quot;)</span>
<span class="sd">        upstream_branch = curr_limb[upstream_node]</span>

<span class="sd">        #1) Get shared endpoint of upstream and previous node</span>
<span class="sd">        if count == 0:</span>
<span class="sd">            common_endpoint = upstream_common_endpoint</span>
<span class="sd">        else:</span>
<span class="sd">            prev_branch = curr_limb[previous_node]</span>
<span class="sd">            common_endpoint = sk.shared_endpoint(prev_branch.skeleton,upstream_branch.skeleton)</span>

<span class="sd">        #2) resize the upstream skeleton to get it ordered and right scale of width</span>
<span class="sd">        upstream_skeleton_ordered = sk.resize_skeleton_branch(upstream_branch.skeleton,skeleton_segment_size)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;upstream_skeleton_ordered {sk.calculate_skeleton_distance(upstream_skeleton_ordered)} = {upstream_skeleton_ordered}&quot;)</span>


<span class="sd">          # ----------- 1 /5 : To prevent from erroring when indexing into width</span>
<span class="sd">    #         #accounting for the fact that the skeleton might be a little longer thn the width array now</span>
<span class="sd">    #         upstream_width = upstream_branch.width_array[width_name]</span>
<span class="sd">    #         extra_width_segment = [upstream_width[-1]]*(len(upstream_skeleton_ordered)-len(upstream_width))</span>
<span class="sd">    #         upstream_width = np.hstack([upstream_width,extra_width_segment])</span>

<span class="sd">        #3) Flip the skeleton and width array if needs to be flipped</span>
<span class="sd">        if np.array_equal(common_endpoint,upstream_skeleton_ordered[-1][-1]):</span>
<span class="sd">            if return_width:</span>
<span class="sd">                try:</span>
<span class="sd">                    upstream_width_ordered = np.flip(upstream_branch.width_array[width_name])</span>
<span class="sd">                except:</span>
<span class="sd">                    upstream_width_ordered = np.flip(upstream_branch.width_array[width_name_backup])</span>

<span class="sd">            upstream_skeleton_ordered = sk.flip_skeleton(upstream_skeleton_ordered)</span>
<span class="sd">            flip_flag = True</span>
<span class="sd">        elif np.array_equal(common_endpoint,upstream_skeleton_ordered[0][0]):</span>
<span class="sd">            if return_width:</span>
<span class="sd">                try:</span>
<span class="sd">                    upstream_width_ordered = upstream_branch.width_array[width_name]</span>
<span class="sd">                except:</span>
<span class="sd">                    upstream_width_ordered = upstream_branch.width_array[width_name_backup]</span>

<span class="sd">            flip_flag = False</span>
<span class="sd">        else:</span>
<span class="sd">            raise Exception(&quot;No matching endpoint&quot;)</span>


<span class="sd">        if verbose: </span>
<span class="sd">            print(f&quot;flip_flag = {flip_flag}&quot;)</span>
<span class="sd">            print(f&quot;upstream_offset = {upstream_offset}&quot;)</span>

<span class="sd">        #4) if current offset is greater than 0, then restrict skeelton to offset:</span>
<span class="sd">        if upstream_offset &gt; 0:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(&quot;Restricting to offset&quot;)</span>
<span class="sd">            (skeleton_minus_buffer,</span>
<span class="sd">             offset_indexes,</span>
<span class="sd">             offset_success) = sk.restrict_skeleton_from_start(upstream_skeleton_ordered,</span>
<span class="sd">                                                                            upstream_offset,</span>
<span class="sd">                                                                             subtract_cutoff=True)</span>
<span class="sd">        else:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(&quot;Skipping the upstream offset because 0&quot;)</span>
<span class="sd">            skeleton_minus_buffer = upstream_skeleton_ordered</span>
<span class="sd">            offset_indexes = np.arange(len(upstream_skeleton_ordered))</span>
<span class="sd">            offset_success = True</span>


<span class="sd">        #print(f&quot;skeleton_minus_buffer {sk.calculate_skeleton_distance(skeleton_minus_buffer)} = {skeleton_minus_buffer}&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        5a) if it was not long enough:</span>
<span class="sd">        - subtact total length from buffer</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        if not offset_success:</span>
<span class="sd">            upstream_offset -= sk.calculate_skeleton_distance(upstream_skeleton_ordered)</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Subtracting the offset was not successful so changing to {upstream_offset} and reiterating&quot;)</span>
<span class="sd">        else:</span>
<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            5b) If successful:</span>
<span class="sd">            - restrit skeleton by comparison distance</span>
<span class="sd">            - Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            - subtract new distance from comparison distance</span>
<span class="sd">            - if comparison distance is 0 or less then break</span>

<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            #making sure the upstream offset is 0 if we were successful</span>
<span class="sd">            upstream_offset = 0</span>

<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;After subtracting the offset the length is: {sk.calculate_skeleton_distance(skeleton_minus_buffer)}&quot;)</span>

<span class="sd">            #- restrit skeleton by comparison distance</span>
<span class="sd">            (skeleton_comparison,</span>
<span class="sd">             comparison_indexes,</span>
<span class="sd">             comparison_success) = sk.restrict_skeleton_from_start(skeleton_minus_buffer,</span>
<span class="sd">                                                                            upstream_comparison,</span>
<span class="sd">                                                                             subtract_cutoff=False)</span>
<span class="sd">            #- Add skeleton, width and skeelton lengths to list</span>
<span class="sd">            upstream_skeleton.append(skeleton_comparison)</span>
<span class="sd">            upstream_seg_lengths.append(sk.calculate_skeleton_segment_distances(skeleton_comparison,cumsum=False))</span>

<span class="sd">            if return_width:</span>
<span class="sd">                upstream_indices = offset_indexes[comparison_indexes]</span>
<span class="sd">                upstream_seg_widths.append(upstream_width_ordered[np.clip(upstream_indices,0,len(upstream_width_ordered)-1) ])</span>

<span class="sd">            # - subtract new distance from comparison distance</span>
<span class="sd">            upstream_comparison -= sk.calculate_skeleton_distance(skeleton_comparison)</span>

<span class="sd">            if comparison_success:</span>
<span class="sd">                if verbose:</span>
<span class="sd">                    print(f&quot;Subtracting the comparison was successful and exiting&quot;)</span>
<span class="sd">                break</span>
<span class="sd">            else:</span>
<span class="sd">                if verbose:</span>
<span class="sd">                    print(f&quot;Subtracting the comparison was not successful so changing to {upstream_comparison} and reiterating&quot;)</span>

<span class="sd">        #6)  change out upstream node and previous node (because at this point haven&#39;t broken outside loop)</span>
<span class="sd">        previous_node = upstream_node</span>
<span class="sd">        upstream_node = xu.upstream_node(curr_limb.concept_network_directional,upstream_node)</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;New upstream_node = {upstream_node}&quot;)</span>

<span class="sd">        if upstream_node is None:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(&quot;Breaking because hit None upstream node&quot;)</span>
<span class="sd">            break</span>

<span class="sd">        count += 1</span>

<span class="sd">    upstream_final_skeleton = sk.stack_skeletons(upstream_skeleton)</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;upstream_final_skeleton = {upstream_final_skeleton}&quot;)</span>

<span class="sd">    # Do a check at the very end and if no skeleton then just take that branches</span>
<span class="sd">    if len(upstream_final_skeleton) &lt;= 0:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(&quot;No upstream skeletons so doing backup&quot;)</span>
<span class="sd">        resize_sk = sk.resize_skeleton_branch(curr_limb[upstream_node_original].skeleton,</span>
<span class="sd">                                                       skeleton_segment_size)</span>
<span class="sd">        upstream_skeleton = [resize_sk]</span>
<span class="sd">        upstream_seg_lengths = [sk.calculate_skeleton_segment_distances(resize_sk,cumsum=False)]</span>
<span class="sd">        </span>
<span class="sd">        if return_width:</span>
<span class="sd">            try:</span>
<span class="sd">                upstream_seg_widths = [curr_limb[upstream_node_original].width_array[width_name]]</span>
<span class="sd">            except:</span>
<span class="sd">                upstream_seg_widths = [curr_limb[upstream_node_original].width_array[width_name_backup]]</span>

<span class="sd">        (upstream_final_skeleton,</span>
<span class="sd">         upstream_final_widths,</span>
<span class="sd">        upstream_final_seg_lengths) = nru.align_and_restrict_branch(curr_limb[upstream_node_original],</span>
<span class="sd">                                  common_endpoint=common_endpoint_original,</span>
<span class="sd">                                width_name=width_name,</span>
<span class="sd">                                 offset=offset,</span>
<span class="sd">                                 comparison_distance=comparison_distance,</span>
<span class="sd">                                 skeleton_segment_size=skeleton_segment_size,</span>
<span class="sd">                                  verbose=verbose,</span>
<span class="sd">                                 )</span>
<span class="sd">    else:</span>
<span class="sd">        upstream_final_seg_lengths = np.concatenate(upstream_seg_lengths)</span>
<span class="sd">        if return_width:</span>
<span class="sd">            upstream_final_widths = np.concatenate(upstream_seg_widths)</span>


<span class="sd">    if return_width:</span>
<span class="sd">        upstream_width_average = nu.average_by_weights(weights = upstream_final_seg_lengths,</span>
<span class="sd">                                values = upstream_final_widths)</span>
<span class="sd">    </span>

<span class="sd">    if plot_skeleton:</span>
<span class="sd">        upstream_node = nru.upstream_node(limb_obj,branch_idx)</span>
<span class="sd">        if upstream_node is None:</span>
<span class="sd">            upstream_node = []</span>
<span class="sd">        else:</span>
<span class="sd">            upstream_node = [upstream_node]</span>
<span class="sd">            </span>
<span class="sd">        downstream_nodes = list(nru.downstream_nodes(limb_obj,branch_idx))</span>
<span class="sd">        total_branches_to_mesh = upstream_node + downstream_nodes</span>
<span class="sd">        </span>
<span class="sd">        nviz.plot_objects(main_mesh = limb_obj[branch_idx].mesh,</span>
<span class="sd">                         main_mesh_color=&quot;red&quot;,</span>
<span class="sd">                         skeletons=[upstream_final_skeleton],</span>
<span class="sd">                         skeletons_colors=&quot;red&quot;,</span>
<span class="sd">                          meshes=[limb_obj[k].mesh for k in total_branches_to_mesh],</span>
<span class="sd">                          meshes_colors=&quot;blue&quot;,</span>
<span class="sd">                          scatters=[upstream_common_endpoint],</span>
<span class="sd">                          scatters_colors=[&quot;red&quot;]</span>
<span class="sd">                         )</span>
<span class="sd">    </span>
<span class="sd">    if return_width:</span>
<span class="sd">        return upstream_final_skeleton,upstream_width_average</span>
<span class="sd">    else:</span>
<span class="sd">        return upstream_final_skeleton&#39;&#39;&#39;</span>
    
<div class="viewcode-block" id="restrict_skeleton_from_start_plus_offset_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.restrict_skeleton_from_start_plus_offset_upstream">[docs]</a><span class="k">def</span> <span class="nf">restrict_skeleton_from_start_plus_offset_upstream</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">start_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
    <span class="n">skeleton_resolution</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">min_comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the upstream skeleton using the new subgraph around node function</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the upstream subgraph around the node that is a little more than the offset </span>
<span class="sd">    and comparison distance</span>
<span class="sd">    2) Get the skeleton of all of the </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">start_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        
    <span class="n">upstream_node_list</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">subgraph_around_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">downstream_distance</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">upstream_distance</span><span class="o">=</span><span class="n">comparison_distance</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">,</span>
                          <span class="n">include_branch_in_upstream_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_branch_idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                          <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_node_list = </span><span class="si">{</span><span class="n">upstream_node_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">upstream_skeleton_total</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">upstream_node_list</span><span class="p">])</span>
    <span class="n">upstream_final_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">upstream_skeleton_total</span><span class="p">,</span>
                                                   <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                    <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                 <span class="n">start_coordinate</span><span class="o">=</span><span class="n">start_coordinate</span><span class="p">,</span>
                                                <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="n">skeleton_resolution</span>
                                                   <span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upstream_node</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upstream_node</span> <span class="o">=</span> <span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span>
            
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">))</span>
        <span class="n">total_branches_to_mesh</span> <span class="o">=</span> <span class="n">upstream_node</span> <span class="o">+</span> <span class="n">downstream_nodes</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">main_mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">upstream_final_skeleton</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                          <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_branches_to_mesh</span><span class="p">],</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                          <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">start_coordinate</span><span class="p">],</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]</span>
                         <span class="p">)</span>
    <span class="k">return</span> <span class="n">upstream_final_skeleton</span></div>


<div class="viewcode-block" id="restrict_skeleton_from_start_plus_offset_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.restrict_skeleton_from_start_plus_offset_downstream">[docs]</a><span class="k">def</span> <span class="nf">restrict_skeleton_from_start_plus_offset_downstream</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">start_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
    <span class="n">skeleton_resolution</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">min_comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the upstream skeleton using the new subgraph around node function</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the upstream subgraph around the node that is a little more than the offset </span>
<span class="sd">    and comparison distance</span>
<span class="sd">    2) Get the skeleton of all of the </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.restrict_skeleton_from_start_plus_offset_downstream(limb_obj,97,</span>
<span class="sd">                                                      comparison_distance=100000,</span>
<span class="sd">                                                     plot_skeleton=True,</span>
<span class="sd">                                                       verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">start_coordinate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        
    <span class="n">upstream_node_list</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">subgraph_around_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branch_idx</span><span class="p">,</span>
                           <span class="n">downstream_distance</span><span class="o">=</span><span class="n">comparison_distance</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">,</span>
                            <span class="n">upstream_distance</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">only_non_branching_downstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">include_branch_in_upstream_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_branch_idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                          <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_node_list = </span><span class="si">{</span><span class="n">upstream_node_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">upstream_skeleton_total</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">upstream_node_list</span><span class="p">])</span>
    
    <span class="n">upstream_final_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">upstream_skeleton_total</span><span class="p">,</span>
                                                   <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                    <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                 <span class="n">start_coordinate</span><span class="o">=</span><span class="n">start_coordinate</span><span class="p">,</span>
                                                <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="n">skeleton_resolution</span>
                                                   <span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upstream_node</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upstream_node</span> <span class="o">=</span> <span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span>
            
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">))</span>
        <span class="n">total_branches_to_mesh</span> <span class="o">=</span> <span class="n">upstream_node</span> <span class="o">+</span> <span class="n">downstream_nodes</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">main_mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">upstream_final_skeleton</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                          <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_branches_to_mesh</span><span class="p">],</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                          <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">start_coordinate</span><span class="p">],</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]</span>
                         <span class="p">)</span>
    <span class="k">return</span> <span class="n">upstream_final_skeleton</span></div>

<div class="viewcode-block" id="copy_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.copy_neuron">[docs]</a><span class="k">def</span> <span class="nf">copy_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span></div>

<span class="c1"># --------- 7/28: For the apical classification ------------</span>
<div class="viewcode-block" id="candidate_groups_from_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.candidate_groups_from_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">candidate_groups_from_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span><span class="p">,</span>
    <span class="n">print_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1"># arguments for determining connected component manner</span>
    <span class="n">connected_component_method</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span> <span class="c1">#other options: &quot;local_radius&quot;</span>
    
    <span class="n">radius</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span><span class="c1">#5000,</span>
    
    <span class="n">require_connected_components</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">max_distance_from_soma_for_start_node</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_one</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To group a limb branch dict</span>
<span class="sd">    into a group of candidates based on </span>
<span class="sd">    upstream connectivity </span>
<span class="sd">    (leader of the group will be the most upstream member)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    apical_candidates = nru.candidate_groups_from_limb_branch(neuron_obj,</span>
<span class="sd">                                      {&#39;L0&#39;: np.array([14, 11, 5])},</span>
<span class="sd">                                      verbose = verbose,</span>
<span class="sd">                                    print_candidates=print_candidates,</span>
<span class="sd">                                                         require_connected_components = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#raise Exception(&quot;NEED TO MAKE SURE THERE CAN&#39;T BE GAPS BETWEEN THE CANDIDATES&quot;)</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l_idx</span><span class="p">,</span><span class="n">b_idxs</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l_idx</span><span class="p">]</span>
        
        <span class="c1">#G = limb_obj.concept_network_directional</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">G_weighted_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">connected_component_method</span> <span class="o">==</span> <span class="s2">&quot;downstream&quot;</span><span class="p">:</span>
            <span class="n">limb_conn_comp</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_conn_comps</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">b_idxs</span><span class="p">,</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">connected_component_method</span> <span class="o">==</span> <span class="s2">&quot;local_radius&quot;</span><span class="p">:</span>
            <span class="c1">#print(f&quot;Inside local radius&quot;)</span>
            <span class="n">limb_conn_comp</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">local_radius_conn_comps</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                                       <span class="n">nodes</span> <span class="o">=</span> <span class="n">b_idxs</span><span class="p">,</span>
                                                        <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">,</span>
                                                        <span class="n">return_upstream_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented connected_component_method: </span><span class="si">{</span><span class="n">connected_component_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">l_idx</span><span class="si">}</span><span class="s2"> : limb_conn_comp = </span><span class="si">{</span><span class="n">limb_conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">limb_candidates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">limb_idx</span> <span class="o">=</span> <span class="n">l_idx</span><span class="p">,</span><span class="n">start_node</span><span class="o">=</span><span class="n">k</span><span class="p">,</span><span class="n">branches</span><span class="o">=</span><span class="n">v</span><span class="p">,)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">limb_conn_comp</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    
    
        <span class="k">if</span> <span class="n">require_connected_components</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Purpose: Will reduce the branches in the group to only </span>
<span class="sd">            those that are in a connected component with the starter branch</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;require_connected_components set&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_candidates before = </span><span class="si">{</span><span class="n">limb_candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">new_limb_candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_candidates</span><span class="p">):</span>
                <span class="n">new_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">new_d</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_component_with_node</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="s2">&quot;start_node&quot;</span><span class="p">],</span>
                                                 <span class="n">G</span><span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">]),</span>
                                                 <span class="n">return_only_one</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">new_limb_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_d</span><span class="p">)</span>
            <span class="n">limb_candidates</span> <span class="o">=</span> <span class="n">new_limb_candidates</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_candidates AFTER  = </span><span class="si">{</span><span class="n">limb_candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
 
        <span class="n">candidates</span> <span class="o">+=</span> <span class="n">limb_candidates</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of candidates = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_candidates</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;candidates = </span><span class="si">{</span><span class="n">candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_candidates</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
               <span class="n">candidates</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">max_distance_from_soma_for_start_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Filter candidates for only those with starting branches within a certain </span>
<span class="sd">        distance of the soma (BECAUSE WE ARE ASSUMING THE APICAL HAD TO HAVE SPLIT OFF BY THAT POINT)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering canddiates for only those starting less than </span><span class="si">{</span><span class="n">max_distance_from_soma_for_start_node</span><span class="si">}</span><span class="s2"> away from soma&quot;</span><span class="p">)</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>  <span class="n">candidates</span> <span class="k">if</span> <span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]],</span>
                                                                                  <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;start_node&quot;</span><span class="p">],</span>
                                                                                  <span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                                <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_distance_from_soma_for_start_node</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After filtering for starting node distances&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of candidates = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_candidates</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;candidates = </span><span class="si">{</span><span class="n">candidates</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_candidates</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After filtering candidates for starting node distances, candidates are&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">candidates</span><span class="p">,</span>
                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            
            
    <span class="k">if</span> <span class="n">return_one</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">return</span> <span class="n">candidates</span></div>
<div class="viewcode-block" id="most_upstream_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.most_upstream_branch">[docs]</a><span class="k">def</span> <span class="nf">most_upstream_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branches</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the most upstream branch in </span>
<span class="sd">    a group of branches</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    most_upstream_branch(limb_obj,[ 2,  6, 20, 23, 24, 25, 26, 33])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">most_upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                 <span class="n">branches</span><span class="p">,</span>
                                 <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                <span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_from_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_from_candidate">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_from_candidate</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">candidate</span><span class="p">[</span><span class="s1">&#39;limb_idx&#39;</span><span class="p">]:</span><span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">]}</span></div>

<div class="viewcode-block" id="candidate_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.candidate_from_branches">[docs]</a><span class="k">def</span> <span class="nf">candidate_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branches</span><span class="p">,</span>
                            <span class="n">limb_idx</span><span class="p">,</span>
                           <span class="p">):</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">limb_idx</span><span class="o">=</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">),</span>
                    <span class="n">branches</span><span class="o">=</span><span class="n">branches</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">most_upstream</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">most_upstream_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branches</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">most_upstream</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;start_node&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">most_upstream</span>
    <span class="k">return</span> <span class="n">candidate</span></div>
    
<div class="viewcode-block" id="candidates_from_limb_branch_candidates"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.candidates_from_limb_branch_candidates">[docs]</a><span class="k">def</span> <span class="nf">candidates_from_limb_branch_candidates</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_candidates</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to convert a dictionary of all the candidates into</span>
<span class="sd">    a list of candidate dictionaries</span>
<span class="sd">    </span>
<span class="sd">    Application: </span>
<span class="sd">    --original</span>
<span class="sd">    {1: array([list([0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 13, 16, 17, 18, 20, 21, 22, 23, 24, 25, 52, 53, 54]),</span>
<span class="sd">            list([8, 11, 12, 14, 15, 19, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51])],</span>
<span class="sd">           dtype=object),</span>
<span class="sd">     2: array([list([1, 5, 6, 7, 8]), list([0, 10, 11, 12]), list([9, 2])],</span>
<span class="sd">           dtype=object),</span>
<span class="sd">     3: array([[0, 1, 2, 3, 4, 5, 6, 7]]),</span>
<span class="sd">     5: array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,</span>
<span class="sd">             16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]])}</span>
<span class="sd">             </span>
<span class="sd">    Output: </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">branch_groups</span> <span class="ow">in</span> <span class="n">limb_branch_candidates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_groups</span><span class="p">:</span>
            <span class="n">all_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">candidate_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                <span class="n">b</span><span class="p">,</span>
                                                                <span class="n">limb_idx</span><span class="p">))</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total # of candidates = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_candidates</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">all_candidates</span></div>
    

<div class="viewcode-block" id="skeleton_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">skeleton_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict</span><span class="p">,</span>
                                   <span class="n">stack_skeletons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                   <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To collect the meshes over a limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    nru.mesh_over_limb_branch_dict(neuron_obj,</span>
<span class="sd">                              nru.limb_branch_from_candidate(apical_candidates[0]),</span>
<span class="sd">                              plot_mesh=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">individual_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                                      <span class="n">keep_seperate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeleton&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stack_skeletons</span><span class="p">:</span>
        <span class="n">individual_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">individual_sk</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">stack_skeletons</span><span class="p">:</span>
            <span class="n">p_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">individual_sk</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_sk</span> <span class="o">=</span> <span class="n">individual_sk</span>
            
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">skeletons</span> <span class="o">=</span> <span class="n">p_sk</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">individual_sk</span></div>


<div class="viewcode-block" id="mesh_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.mesh_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">mesh_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict</span><span class="p">,</span>
                                   <span class="n">combine_meshes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                   <span class="n">plot_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To collect the skeletons over a limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    nru.skeleton_over_limb_branch_dict(neuron_obj,</span>
<span class="sd">                              nru.limb_branch_from_candidate(apical_candidates[0]),</span>
<span class="sd">                              plot_skeleton=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">individual_mesh</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                                      <span class="n">keep_seperate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;mesh&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">combine_meshes</span><span class="p">:</span>
        <span class="n">individual_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">individual_mesh</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">combine_meshes</span><span class="p">:</span>
            <span class="n">p_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">individual_mesh</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_sk</span> <span class="o">=</span> <span class="n">individual_mesh</span>
            
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">meshes</span> <span class="o">=</span> <span class="n">p_sk</span><span class="p">,</span>
                         <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">individual_mesh</span></div>

<div class="viewcode-block" id="mesh_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.mesh_over_candidate">[docs]</a><span class="k">def</span> <span class="nf">mesh_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                       <span class="n">candidate</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.mesh_over_candidate(neuron_obj,</span>
<span class="sd">                        apical_candidates[0],</span>
<span class="sd">                       plot_mesh = True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">mesh_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">candidate</span><span class="p">),</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_over_candidate">[docs]</a><span class="k">def</span> <span class="nf">skeleton_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                       <span class="n">candidate</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.skeleton_over_candidate(neuron_obj,</span>
<span class="sd">                        apical_candidates[0],</span>
<span class="sd">                       plot_skeleton = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">candidate</span><span class="p">),</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_over_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeletal_length_over_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_over_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.skeletal_length_over_limb_branch(neuron_obj,</span>
<span class="sd">                                nru.limb_branch_from_candidate(ap_cand))</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="area_over_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.area_over_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">area_over_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.skeletal_length_over_limb_branch(neuron_obj,</span>
<span class="sd">                                nru.limb_branch_from_candidate(ap_cand))</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;area&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="volume_over_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.volume_over_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">volume_over_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.skeletal_length_over_limb_branch(neuron_obj,</span>
<span class="sd">                                nru.limb_branch_from_candidate(ap_cand))</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;mesh_volume&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeletal_length_over_candidate">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">candidate</span><span class="p">,</span>
                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                               <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">candidate</span><span class="p">),</span>
                                               <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_downstream_branches_from_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_downstream_branches_from_candidate">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_branches_from_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">candidate</span><span class="p">,</span>
                                        <span class="n">include_candidate_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all of the branches downstream of a candidate</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    all_downs = np.concatenate([cnu.all_downtream_branches(neuron_obj[candidate[&quot;limb_idx&quot;]],</span>
<span class="sd">                                           k) for k in candidate[&quot;branches&quot;]])</span>
<span class="sd">    if include_candidate_branches:</span>
<span class="sd">        all_downs = np.concatenate([all_downs,candidate[&quot;branches&quot;]])</span>
<span class="sd">    else:</span>
<span class="sd">        all_downs = np.setdiff1d(all_downs,candidate[&quot;branches&quot;])</span>
<span class="sd">        </span>
<span class="sd">    downstream_nodes = np.unique(all_downs)</span>
<span class="sd">    </span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;downstream_nodes = {downstream_nodes}&quot;)</span>
<span class="sd">        </span>
<span class="sd">    return downstream_nodes</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">all_downstream_branches_from_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]],</span>
                                                    <span class="n">branches</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">],</span>
                                                    <span class="n">include_original_branches</span><span class="o">=</span><span class="n">include_candidate_branches</span><span class="p">,</span>
                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>



<div class="viewcode-block" id="all_donwstream_branches_from_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_donwstream_branches_from_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">all_donwstream_branches_from_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                            <span class="n">limb_branch_dict</span><span class="p">,</span>
                                            <span class="n">include_limb_branch_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                             <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="p">):</span>
    <span class="n">disconn_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                   <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                                   <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_limb_branch_dict</span><span class="p">:</span>
        <span class="n">disconn_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_setdiff</span><span class="p">([</span><span class="n">disconn_limb_branch</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream limb_branch = </span><span class="si">{</span><span class="n">disconn_limb_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">disconn_limb_branch</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">disconn_limb_branch</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def fill_in_and_filter_branch_groups_from_upstream_without_branching(limb_obj,</span>
<span class="sd">                                                  branches,</span>
<span class="sd">                                                  start_branch=None,</span>
<span class="sd">                                                   skip_distance = 5000,</span>
<span class="sd">                                                   plot_filtered_branches = False,</span>
<span class="sd">                                                  verbose = False,):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter a branches in </span>
<span class="sd">    a candidate for only those</span>
<span class="sd">    within a certain distance of the closest</span>
<span class="sd">    upstream branch (and optimally not the result of a branching point)</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Compute with the starting branch if not determined</span>
<span class="sd">    2) Make the start branch the current branch</span>
<span class="sd">    3) For range of the number of branches:</span>
<span class="sd">    a. Get the branches that are within certain distance downstream (that also belong to the branches list)</span>
<span class="sd">    b. If no branches then break</span>
<span class="sd">    c. If yes then make sure on the same path</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.fill_in_and_filter_branch_groups_from_upstream_without_branching(</span>
<span class="sd">    limb_obj =  neuron_obj[6],</span>
<span class="sd">    branches = [24, 25, 26],</span>
<span class="sd">    start_branch = None,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    skip_distance = 5000,</span>
<span class="sd">    plot_filtered_branches = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    if start_branch is None:</span>
<span class="sd">        start_branch = xu.most_upstream_node(limb_obj.concept_network_directional,</span>
<span class="sd">                                            branches)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Comptued start_branch = {start_branch}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    curr_branch = start_branch</span>
<span class="sd">    final_branches = [start_branch]</span>

<span class="sd">    G = limb_obj.concept_network_directional</span>

<span class="sd">    for i in range(len(branches)):</span>

<span class="sd">        down_nodes = cnu.nodes_downstream(limb_obj,</span>
<span class="sd">                        curr_branch,distance=skip_distance,</span>
<span class="sd">                                          nodes_to_include = branches)</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;For curr_branch: {curr_branch}&quot;)</span>
<span class="sd">            print(f&quot;down_nodes = {down_nodes}&quot;)</span>


<span class="sd">        if len(down_nodes) == 0:</span>
<span class="sd">            break</span>

<span class="sd">        if not xu.check_downstream_nodes_on_same_path(G,down_nodes,start_node=curr_branch) and skip_distance &gt; 0:</span>
<span class="sd">            skip_distance = 0</span>
<span class="sd">            down_nodes = cnu.nodes_downstream(limb_obj,</span>
<span class="sd">                        curr_branch,distance=skip_distance,</span>
<span class="sd">                                              nodes_to_include = branches)</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;After skip distance changed to 0: down_nodes = {down_nodes}&quot;)</span>
<span class="sd">                </span>
<span class="sd">        if len(down_nodes) == 0:</span>
<span class="sd">            break</span>

<span class="sd">        if not xu.check_downstream_nodes_on_same_path(G,down_nodes,start_node=curr_branch):</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Not all downstream nodes on same path so breaking&quot;)</span>
<span class="sd">            break</span>

<span class="sd">        most_downstream_node = xu.least_downstream_node(G,down_nodes)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;most_downstream_node= {most_downstream_node}&quot;)</span>

<span class="sd">        final_branches = np.union1d(final_branches,</span>
<span class="sd">                                    xu.shortest_path(G,curr_branch,most_downstream_node))</span>

<span class="sd">        curr_branch = most_downstream_node</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;final_branches = {final_branches} &quot;)</span>
<span class="sd">        </span>
<span class="sd">    if plot_filtered_branches:</span>
<span class="sd">        print(F&quot;Plotting final branches&quot;)</span>
<span class="sd">        nviz.plot_limb_path(limb_obj,final_branches)</span>
<span class="sd">        </span>
<span class="sd">    return final_branches</span>


<span class="sd">def candidate_filter_skeletal_length(neuron_obj,</span>
<span class="sd">                                    candidate,</span>
<span class="sd">                                    candidate_skeletal_length_min=18000,</span>
<span class="sd">                                     candidate_skeletal_length_max = None,</span>
<span class="sd">                                     verbose = False,</span>
<span class="sd">                                     **kwargs</span>
<span class="sd">                                    ):</span>
<span class="sd">    sk_len = nst.skeletal_length_over_candidate(neuron_obj,</span>
<span class="sd">                                  candidate)</span>
<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;skeletal length = {sk_len}&quot;)</span>
<span class="sd">        </span>
<span class="sd">    if  candidate_skeletal_length_min is not None and sk_len &lt; candidate_skeletal_length_min:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Filtered away candidate because skeletal length too small&quot;)</span>
<span class="sd">        return False</span>
<span class="sd">    </span>
<span class="sd">    if  candidate_skeletal_length_max is not None and sk_len &gt; candidate_skeletal_length_max:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Filtered away candidate because skeletal length too large&quot;)</span>
<span class="sd">        return False</span>
<span class="sd">    </span>
<span class="sd">    return True</span>


<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">def filter_candidates(neuron_obj,</span>
<span class="sd">                     candidates,</span>
<span class="sd">                      filters = (&quot;skeletal_length&quot;,),</span>
<span class="sd">                      </span>
<span class="sd">                      #-- arguments for the different filters --</span>
<span class="sd">                      candidate_skeletal_length_min = 18000,</span>
<span class="sd">                      verbose = False,</span>
<span class="sd">                      **kwargs</span>
<span class="sd">                     ):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter the apical shaft candidates </span>
<span class="sd">    for base characteristics:</span>
<span class="sd">    a) skeletal length</span>

<span class="sd">    -- Not yet implmented --</span>
<span class="sd">    Angle and length between the </span>
<span class="sd">    start of the candidate and the soma</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.filter_candidates(neuron_obj,</span>
<span class="sd">                 candidates=shaft_candidates,</span>
<span class="sd">                 verbose = verbose)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    filtered_cand = []</span>

<span class="sd">    for j,can in enumerate(candidates):</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;\nBase Filtering candidate {j}: {can}&quot;)</span>

<span class="sd">        cand_lb = nru.limb_branch_from_candidate(can)</span>

<span class="sd">        #filter 1) minimum skeletal length</span>
<span class="sd">        if &quot;skeletal_length&quot; in filters:</span>
<span class="sd">            if not nru.candidate_filter_skeletal_length(neuron_obj,</span>
<span class="sd">                                                       candidate=can,</span>
<span class="sd">                                                       candidate_skeletal_length_min=candidate_skeletal_length_min,</span>
<span class="sd">                                                        verbose = verbose,</span>
<span class="sd">                                                       **kwargs):</span>
<span class="sd">                continue</span>

<span class="sd">        # ------- more filters would be implemented here</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;candidate {j} made it through filtering&quot;)</span>
<span class="sd">        filtered_cand.append(can)</span>
<span class="sd">    return filtered_cand</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="upstream_labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.upstream_labels">[docs]</a><span class="k">def</span> <span class="nf">upstream_labels</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the labels of the upstream node</span>

<span class="sd">    Pseudoode: </span>
<span class="sd">    1) Find the upstream node</span>
<span class="sd">    2) return labels of that node</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_node = </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2"> with labels = </span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="upstream_node_has_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.upstream_node_has_label">[docs]</a><span class="k">def</span> <span class="nf">upstream_node_has_label</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                           <span class="n">label</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine if the </span>
<span class="sd">    upstream node has a certain label</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the upstream labels</span>
<span class="sd">    2) Return boolean if label of interest is in labels</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.upstream_node_has_label(limb_obj = n_test[1],</span>
<span class="sd">               branch_idx = 9,</span>
<span class="sd">                label = &quot;apical&quot;,</span>
<span class="sd">               verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">upstream_labels</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_labels</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                         <span class="n">branch_idx</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">upstream_labels</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    

    
<div class="viewcode-block" id="label_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.label_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">label_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">label</span><span class="p">,</span>
                           <span class="n">not_matching_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">match_type</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="c1">#ohter option is any</span>
                          <span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
    <span class="n">label_limb_branch</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span>
                        <span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">matching_labels</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                        <span class="n">not_matching_labels</span><span class="o">=</span><span class="n">not_matching_labels</span><span class="p">,</span>
                        <span class="n">match_type</span><span class="o">=</span><span class="n">match_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">label_limb_branch</span></div>

<div class="viewcode-block" id="downstream_labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.downstream_labels">[docs]</a><span class="k">def</span> <span class="nf">downstream_labels</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                      <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Get all of the downstream labels</span>
<span class="sd">    of a node</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the downstream nodes (optionally all downstream)</span>
<span class="sd">    2) get the labels over all the branches</span>
<span class="sd">    3) concatenate the labels</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">all_downstream_nodes</span><span class="p">:</span>
        <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;d_nodes = </span><span class="si">{</span><span class="n">d_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">d_nodes</span><span class="p">,</span><span class="s2">&quot;labels&quot;</span><span class="p">))</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;labels = </span><span class="si">{</span><span class="n">labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_from_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_from_limbs">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_from_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">limbs</span><span class="p">,</span>
                          <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert list of limbs to limb_branch_dict</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each limb</span>
<span class="sd">    1) Convert limb to name</span>
<span class="sd">    2) Get the branches for the limb and store in dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">limbs</span><span class="p">):</span>
        <span class="n">limbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">limbs</span><span class="p">]</span>

    <span class="n">final_lb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">limbs</span><span class="p">:</span>
        <span class="n">l_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>
        <span class="c1">#print(f&quot;branches = {branches}&quot;)</span>
        <span class="n">final_lb</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">branches</span>
    
    <span class="k">return</span> <span class="n">final_lb</span></div>

<div class="viewcode-block" id="set_branch_attribute_over_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.set_branch_attribute_over_neuron">[docs]</a><span class="k">def</span> <span class="nf">set_branch_attribute_over_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">branch_func</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To set attributes of </span>
<span class="sd">    synapes throughout neuron</span>

<span class="sd">    Psueodocde: </span>
<span class="sd">    Iterating through all branches</span>
<span class="sd">    1) run the branch func</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb </span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">b</span><span class="p">]</span>
            <span class="n">branch_func</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="n_branches_over_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.n_branches_over_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">n_branches_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span>
                                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to count up the number of branches in a compartment</span>
<span class="sd">    </span>
<span class="sd">    nru.n_branches_over_limb_branch_dict(neuron_obj_proof,</span>
<span class="sd">                                    apu.oblique_limb_branch_dict(neuron_obj_proof))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                <span class="n">feature</span> <span class="o">=</span> <span class="s2">&quot;n_branches&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_soma_soma_connections_from_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_soma_soma_connections_from_limb">[docs]</a><span class="k">def</span> <span class="nf">all_soma_soma_connections_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">only_multi_soma_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return all the soma soma paths on a limb</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    segment_id = 864691136174988806</span>

<span class="sd">    neuron_obj = du.neuron_obj_from_table(    </span>
<span class="sd">            segment_id = segment_id,</span>
<span class="sd">            table_name = &quot;Decomposition&quot;,</span>
<span class="sd">            verbose = False</span>
<span class="sd">        )</span>

<span class="sd">    nru.all_soma_soma_connections_from_limb(neuron_obj[0],</span>
<span class="sd">                                            only_multi_soma_paths = True,</span>
<span class="sd">                                           verbose = True,</span>
<span class="sd">                                           )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">all_starting_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s1">&#39;starting_soma&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s1">&#39;soma_group_idx&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>

    <span class="n">starting_node_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">all_starting_nodes</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="n">starting_node_combinations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nu</span><span class="o">.</span><span class="n">unique_non_self_pairings</span><span class="p">(</span><span class="n">starting_node_combinations</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_node_combinations = </span><span class="si">{</span><span class="n">starting_node_combinations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">only_multi_soma_paths</span><span class="p">:</span>
        <span class="n">starting_node_combinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_node_combinations</span> <span class="k">if</span>
                                         <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;starting_node_combinations (only_multi_soma_paths) = </span><span class="si">{</span><span class="n">starting_node_combinations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">starting_node_combinations</span></div>
            
<div class="viewcode-block" id="all_soma_names_from_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_soma_names_from_limb">[docs]</a><span class="k">def</span> <span class="nf">all_soma_names_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;S</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]))</span></div>

<div class="viewcode-block" id="all_soma_meshes_from_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_soma_meshes_from_limb">[docs]</a><span class="k">def</span> <span class="nf">all_soma_meshes_from_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">soma_names</span> <span class="o">=</span> <span class="n">all_soma_names_from_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">, soma_names = </span><span class="si">{</span><span class="n">soma_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">soma_names</span><span class="p">]</span></div>
    

<div class="viewcode-block" id="soma_idx_and_group_from_name"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.soma_idx_and_group_from_name">[docs]</a><span class="k">def</span> <span class="nf">soma_idx_and_group_from_name</span><span class="p">(</span><span class="n">soma_name</span><span class="p">):</span>
    <span class="n">split_name</span> <span class="o">=</span> <span class="n">soma_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">split_name</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]),</span><span class="nb">int</span><span class="p">(</span><span class="n">split_name</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>
<div class="viewcode-block" id="concept_network_data_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.concept_network_data_from_soma">[docs]</a><span class="k">def</span> <span class="nf">concept_network_data_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                   <span class="n">soma_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                   <span class="n">soma_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">soma_group_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">data_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">soma_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_group_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">soma_idx_and_group_from_name</span><span class="p">(</span><span class="n">soma_name</span><span class="p">)</span>
        
    <span class="n">concept_data</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_concept_network_data_by_soma_and_idx</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_group_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">data_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">concept_data</span><span class="p">[</span><span class="n">data_name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">concept_data</span></div>
    
<div class="viewcode-block" id="starting_node_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.starting_node_from_soma">[docs]</a><span class="k">def</span> <span class="nf">starting_node_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">soma_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">soma_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">soma_group_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">data_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: nru.starting_node_from_soma(limb_obj,&quot;S2_0&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">concept_network_data_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                   <span class="n">soma_idx</span><span class="o">=</span><span class="n">soma_idx</span><span class="p">,</span>
                                          <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">soma_group_idx</span><span class="p">,</span>
                                          <span class="n">soma_name</span> <span class="o">=</span> <span class="n">soma_name</span><span class="p">,</span>
                                  <span class="n">data_name</span><span class="o">=</span><span class="s2">&quot;starting_node&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="starting_node_combinations_of_limb_sorted_by_microns_midpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.starting_node_combinations_of_limb_sorted_by_microns_midpoint">[docs]</a><span class="k">def</span> <span class="nf">starting_node_combinations_of_limb_sorted_by_microns_midpoint</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">limb_idx</span><span class="p">,</span>
                                                        <span class="n">only_multi_soma_paths</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">return_soma_names</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To sort the error</span>
<span class="sd">    connections of a limb by the </span>
<span class="sd">    distance of the soma to the midpoint</span>
<span class="sd">    of the microns dataset</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Compute the distance of each some to the dataset midpoint</span>
<span class="sd">    1) Get all of the possible connection pathways</span>
<span class="sd">    2) Construct the distance matrix for the pathways</span>
<span class="sd">    3) Order the connection pathways across their rows independent</span>
<span class="sd">    4) Order the rows of the connections pathways</span>
<span class="sd">    5) Filter for only different soma pathways if requested</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#0) Compute the distance of each some to the dataset midpoint</span>
    <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
    <span class="n">midpoint_dist_dict</span> <span class="o">=</span> <span class="n">mru</span><span class="o">.</span><span class="n">soma_distances_from_microns_volume_bbox_midpoint</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;midpoint_dist_dict = </span><span class="si">{</span><span class="n">midpoint_dist_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All somas attached to limb = </span><span class="si">{</span><span class="n">nru</span><span class="o">.</span><span class="n">all_soma_names_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#1) Get all of the possible connection pathways</span>


    <span class="n">begginning_soma_paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">all_soma_soma_connections_from_limb</span><span class="p">(</span>
        <span class="n">limb_obj</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">only_multi_soma_paths</span> <span class="o">=</span> <span class="n">only_multi_soma_paths</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;begginning_soma_paths= </span><span class="se">\n</span><span class="si">{</span><span class="n">begginning_soma_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">begginning_soma_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
        <span class="n">midpoint_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">midpoint_dist_dict</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> 
                              <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">begginning_soma_paths</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;midpoint_dist =</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">midpoint_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1">#3) Order the connection pathways across their rows independent</span>

        <span class="n">row_idx</span><span class="p">,</span><span class="n">col_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">argsort_rows_of_2D_array_independently</span><span class="p">(</span><span class="n">midpoint_dist</span><span class="p">)</span>
        <span class="n">begginning_soma_paths_row_ord</span> <span class="o">=</span> <span class="n">begginning_soma_paths</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span><span class="n">col_idx</span><span class="p">]</span>
        <span class="n">midpoint_dist_row_ord</span> <span class="o">=</span> <span class="n">midpoint_dist</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span><span class="n">col_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;midpoint_dist_row_ord =</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">midpoint_dist_row_ord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;begginning_soma_paths_row_ord =</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">begginning_soma_paths_row_ord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#4) Order the rows of the connections pathways</span>
        <span class="n">row_order</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">argsort_multidim_array_by_rows</span><span class="p">(</span><span class="n">midpoint_dist_row_ord</span><span class="p">)</span>
        <span class="n">begginning_soma_paths_final</span> <span class="o">=</span> <span class="n">begginning_soma_paths_row_ord</span><span class="p">[</span><span class="n">row_order</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;begginning_soma_paths_final=</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">begginning_soma_paths_final</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">begginning_soma_paths_final</span><span class="o">=</span> <span class="n">begginning_soma_paths</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_soma_names</span><span class="p">:</span>
        <span class="n">begginning_soma_paths_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">nru</span><span class="o">.</span><span class="n">starting_node_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">begginning_soma_paths_final</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting path combinations = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">begginning_soma_paths_final</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">begginning_soma_paths_final</span></div>


<div class="viewcode-block" id="shortest_path"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.shortest_path">[docs]</a><span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">start_branch_idx</span><span class="p">,</span><span class="n">destiation_branch_idx</span><span class="p">,</span>
                 <span class="n">plot_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">shortest_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">start_branch_idx</span><span class="p">,</span><span class="n">destiation_branch_idx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">plot_path</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting path: </span><span class="si">{</span><span class="n">shortest_p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">shortest_p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shortest_p</span></div>

<div class="viewcode-block" id="get_soma_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_soma_meshes">[docs]</a><span class="k">def</span> <span class="nf">get_soma_meshes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_meshes</span><span class="p">()</span></div>
    
    
<span class="c1"># ---------- 10/22 -------------</span>
<div class="viewcode-block" id="skeleton_nodes_from_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_nodes_from_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">skeleton_nodes_from_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span><span class="p">,</span>
    <span class="n">downsample_size</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span>
    <span class="n">downsample_factor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_skeletons_before_downsampling</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">scatter_size</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert a limb branch dict</span>
<span class="sd">    into a list of points from the skeleton</span>
<span class="sd">    (and have an option to downsample the number of skeletons)</span>

<span class="sd">    downsample_facto</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">limb_branch_sks</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_limb_branch_dict</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">limb_branch_dict</span><span class="p">,</span>
            <span class="n">stack_skeletons</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">):</span>
        <span class="n">limb_branch_sks</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot_skeletons_before_downsampling</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="n">limb_branch_sks</span><span class="p">,</span>
            <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span>

        <span class="p">)</span>

    <span class="k">if</span> <span class="n">downsample_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downsampling nodes by a factor of </span><span class="si">{</span><span class="n">downsample_factor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes</span><span class="p">(</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">limb_branch_sks</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[::</span><span class="n">downsample_factor</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">downsample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downsampling to segment lengths of </span><span class="si">{</span><span class="n">downsample_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_branch_sks_resized</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span>
            <span class="n">segment_width</span><span class="o">=</span><span class="n">downsample_size</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_branch_sks</span><span class="p">]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes</span><span class="p">(</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">limb_branch_sks_resized</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No downsampling applied&quot;</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes</span><span class="p">(</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">limb_branch_sks</span><span class="p">)</span>
        <span class="p">)</span>


    <span class="k">if</span> <span class="n">plot_nodes</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting nodes extracted from limb branch&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">skeletons</span><span class="o">=</span><span class="n">limb_branch_sks</span><span class="p">,</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">nodes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
            <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">nodes</span></div>

<div class="viewcode-block" id="skeleton_nodes_from_branches_on_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.skeleton_nodes_from_branches_on_limb">[docs]</a><span class="k">def</span> <span class="nf">skeleton_nodes_from_branches_on_limb</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get skeleton nodes just from limb and list of branches</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.skeleton_nodes_from_branches_on_limb(neuron_obj[0],[0,1,2],plot_nodes = True)</span>
<span class="sd">    </span>
<span class="sd">    #checking</span>
<span class="sd">    nviz.plot_objects(</span>
<span class="sd">        meshes = [neuron_obj[0][k].mesh for k in [0,1,2]],</span>
<span class="sd">        skeletons = [neuron_obj[0][k].skeleton for k in [0,1,2]]</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_nodes_from_limb_branch</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="all_downstream_branches_from_multiple_branhes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.all_downstream_branches_from_multiple_branhes">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_branches_from_multiple_branhes</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches_idx</span><span class="p">,</span>
    <span class="n">include_branches_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Get all of the downstream branches of certain </span>
<span class="sd">    other branches that would be removed if those</span>
<span class="sd">    branches were deleted</span>

<span class="sd">    Ex: </span>
<span class="sd">    all_downstream_branches_from_multiple_branhes(</span>
<span class="sd">    neuron_obj[0],</span>
<span class="sd">    branches_idx=[20,24],</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branches_idx</span><span class="p">)</span>
    <span class="n">branches_idx</span> <span class="o">=</span> <span class="n">branches_idx</span><span class="p">[</span><span class="n">branches_idx</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">union1d_multi_list</span><span class="p">([</span><span class="n">nru</span><span class="o">.</span><span class="n">all_downstream_branches</span><span class="p">(</span>
        <span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches_idx</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">include_branches_idx</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">,</span><span class="n">branches_idx</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total downstream branches = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">downstream_nodes</span></div>


<div class="viewcode-block" id="branch_attr_dict_from_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_attr_dict_from_node">[docs]</a><span class="k">def</span> <span class="nf">branch_attr_dict_from_node</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">,</span>
    <span class="n">node_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">attr_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">include_node_name_as_top_key</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_branch_dynamics</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To output a dictionary of attributes of the node</span>
<span class="sd">    attributes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.branch_attr_dict_from_node(</span>
<span class="sd">    neuron_obj_proof,</span>
<span class="sd">    &quot;S0&quot;,</span>
<span class="sd">    #attr_list=branch_attributes_global,</span>
<span class="sd">    attr_list = soma_attributes_global,</span>
<span class="sd">    include_node_name_as_top_key=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_obj</span> <span class="o">=</span> <span class="n">obj</span>
    
    <span class="k">if</span> <span class="n">attr_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using all attributes as default&quot;</span><span class="p">)</span>
        <span class="n">attr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">curr_obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;_&quot;</span><span class="p">]</span>
    
    
    <span class="n">curr_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_obj</span><span class="p">,</span><span class="n">a</span><span class="p">))</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="k">else</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_obj</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attr_list</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">include_branch_dynamics</span><span class="p">:</span>
        <span class="n">branch_dyn_dict</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">branch_dynamics_attr_dict_dynamics_from_node</span><span class="p">(</span><span class="n">curr_obj</span><span class="p">)</span>
        <span class="n">curr_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">branch_dyn_dict</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">include_node_name_as_top_key</span><span class="p">:</span>
        <span class="n">curr_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_name</span><span class="p">:</span> <span class="n">curr_dict</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">curr_dict</span></div>

<div class="viewcode-block" id="branch_neighbors"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_neighbors">[docs]</a><span class="k">def</span> <span class="nf">branch_neighbors</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_parent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_siblings</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_children</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all the neighboring</span>
<span class="sd">    branches to current branch</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#neighbors = xu.get_neighbors(limb_obj.concept_network,branch_idx)</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">include_parent</span><span class="p">:</span>
        <span class="n">parent_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">parent_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent_node</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">include_siblings</span><span class="p">:</span>
        <span class="n">sibling_nodes</span><span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">+=</span> <span class="n">sibling_nodes</span>
        
    <span class="k">if</span> <span class="n">include_children</span><span class="p">:</span>
        <span class="n">children_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">children_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="n">neighbors</span> <span class="o">+=</span> <span class="n">children_nodes</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neighbors = </span><span class="si">{</span><span class="n">neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">neighbors</span></div>

<div class="viewcode-block" id="branch_neighbors_attribute"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_neighbors_attribute">[docs]</a><span class="k">def</span> <span class="nf">branch_neighbors_attribute</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">attr</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span>
                           <span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">attr</span><span class="p">)</span>  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> 
            <span class="n">nru</span><span class="o">.</span><span class="n">branch_neighbors</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span></div>

<div class="viewcode-block" id="branch_neighbors_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.branch_neighbors_mesh">[docs]</a><span class="k">def</span> <span class="nf">branch_neighbors_mesh</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                           <span class="p">):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">branch_neighbors_attribute</span><span class="p">(</span>
        <span class="n">limb_obj</span><span class="p">,</span>
        <span class="n">branch_idx</span><span class="p">,</span>
        <span class="s2">&quot;mesh&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="width_average_from_limb_correspondence"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.width_average_from_limb_correspondence">[docs]</a><span class="k">def</span> <span class="nf">width_average_from_limb_correspondence</span><span class="p">(</span>
    <span class="n">limb_correspondence</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate the average width based on a limb correspondence</span>
<span class="sd">    dictionary of branch_idx &gt; dict(width, skeleton, mesh)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">total_sk_lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">total_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">average_width</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">total_widths</span><span class="p">,</span><span class="n">total_sk_lens</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;average_width = </span><span class="si">{</span><span class="n">average_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">average_width</span></div>


<span class="c1"># ------- 12/27: </span>


<div class="viewcode-block" id="combined_somas_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.combined_somas_neuron_obj">[docs]</a><span class="k">def</span> <span class="nf">combined_somas_neuron_obj</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_soma_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_soma_limb_network</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To combine a neuron object with multiple somas</span>
<span class="sd">    into a neuron object with just one soma</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Redo the preprocessing data</span>
<span class="sd">    </span>
<span class="sd">    Inside: preprocessed_data</span>
<span class="sd">    soma_meshes:</span>
<span class="sd">    - just combine the meshes</span>

<span class="sd">    soma_to_piece_connectivity: </span>
<span class="sd">    - just make it a combined dict: </span>
<span class="sd">    Ex: {0: [1, 2, 3, 5, 6, 7, 11], 1: [0, 4, 8], 2: [9, 10]}</span>

<span class="sd">    soma_sdfs: just combine as weighted average</span>


<span class="sd">    limb_network_stating_info</span>
<span class="sd">    - structure: limb_idx &gt; soma_idx &gt; starting_idx &gt; </span>

<span class="sd">    Goal: keep the same but just map to soma_idx = 0</span>
<span class="sd">    and reorder the starting idx</span>

<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    2) Redo the concept network</span>
<span class="sd">    3) Adjust starting info for all limbs</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_utils as nru</span>
<span class="sd">    from neurd import neuron_utils as nru</span>
<span class="sd">    neuron_obj = nru.decompress_neuron(&quot;./3502576426_somas_seperate.pbz2&quot;,original_mesh=&quot;./3502576426_0_25.off&quot;)</span>

<span class="sd">    neuron_obj_comb = nru.combined_somas_neuron_obj(neuron_obj,</span>
<span class="sd">                                                    inplace = False,</span>
<span class="sd">                                                    verbose = True,</span>
<span class="sd">                                                    plot_soma_limb_network = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_obj</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    
    <span class="c1"># 1) --------Redo the preprocessing data--------</span>
    
    <span class="n">preprocessed_data_cp</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1">#1) Combine the soma meshes</span>
    <span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">])]</span>

    <span class="k">if</span> <span class="n">plot_soma_mesh</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1">#2) redo the soma to piece connectivity</span>
    <span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">union1d_multi_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New soma_to_piece_connectivity =  </span><span class="si">{</span><span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s1">&#39;soma_to_piece_connectivity&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) Combine the Soma sdfs</span>
    <span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_sdfs&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]])</span> <span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New soma_sdfs =  </span><span class="si">{</span><span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s1">&#39;soma_sdfs&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#4) Combine limb_network_stating_info</span>
    <span class="n">new_stating_info</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">reverse_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">limb_data</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(f&quot;Limb: {limb_idx}&quot;)</span>
        <span class="n">new_stating_info</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="nb">dict</span><span class="p">()}</span>
        <span class="n">reverse_mapping</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>  <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_data</span> <span class="ow">in</span> <span class="n">limb_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1">#         if verbose:</span>
    <span class="c1">#             print(f&quot; Soma: {soma_idx}&quot;)</span>
            <span class="k">for</span> <span class="n">group_idx</span><span class="p">,</span><span class="n">soma_group_data</span> <span class="ow">in</span> <span class="n">soma_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="c1">#             if verbose:</span>
    <span class="c1">#                 print(f&quot;   Group: {group_idx}&quot;)</span>
                <span class="n">new_stating_info</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_group_data</span>
                <span class="n">reverse_mapping</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][(</span><span class="n">soma_idx</span><span class="p">,</span><span class="n">group_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">counter</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reverse_mapping = </span><span class="si">{</span><span class="n">reverse_mapping</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">preprocessed_data_cp</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_stating_info</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span> <span class="o">=</span> <span class="n">preprocessed_data_cp</span>
    
    <span class="c1"># --------2) Fixing the concept network--------</span>
    <span class="k">if</span> <span class="n">plot_soma_limb_network</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BEFORE reorganization: &quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_soma_limb_concept_network</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="n">sdf_comb</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sdf</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()],</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sdf_comb= </span><span class="si">{</span><span class="n">sdf_comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">mesh_face_idx_comb</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">union1d_multi_list</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_face_idx_comb.shape = </span><span class="si">{</span><span class="n">mesh_face_idx_comb</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">mesh_comb</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()])</span>

    <span class="n">Soma_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Soma</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh_comb</span><span class="p">,</span><span class="n">mesh_face_idx</span><span class="o">=</span><span class="n">mesh_face_idx_comb</span><span class="p">,</span><span class="n">sdf</span><span class="o">=</span><span class="n">sdf_comb</span><span class="p">)</span>
    
    <span class="n">soma_temp_name</span> <span class="o">=</span> <span class="s2">&quot;S_new&quot;</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="n">soma_temp_name</span><span class="p">])</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">soma_temp_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Soma_obj</span>
    
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">soma_temp_name</span><span class="p">])</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">soma_temp_name</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
    
    <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">S_new</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">),</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_soma_limb_network</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER reorganization: &quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_soma_limb_concept_network</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    
    <span class="c1">#3) --------fixing the all_concept_network_data:--------</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="n">all_concept_network_data_revised</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reverse_mapping</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">],</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">])]</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Go through and recalculate all of the concept networkx</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span> <span class="o">=</span> <span class="s2">&quot;S0&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">neuron_obj</span></div>


<div class="viewcode-block" id="mesh_not_in_neuron_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.mesh_not_in_neuron_branches">[docs]</a><span class="k">def</span> <span class="nf">mesh_not_in_neuron_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To figure out what part of the mesh is not </span>
<span class="sd">    incorporated into the branches</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">leftover_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                <span class="n">nru</span><span class="o">.</span><span class="n">neuron_mesh_from_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">leftover_mesh</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">leftover_mesh</span></div>
    
    
<div class="viewcode-block" id="filter_away_neuron_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.filter_away_neuron_limbs">[docs]</a><span class="k">def</span> <span class="nf">filter_away_neuron_limbs</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_idx_to_filter</span><span class="p">,</span>
    <span class="n">plot_limbs_to_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away limbs </span>
<span class="sd">    specific</span>

<span class="sd">    Application: To filter away limbs that</span>
<span class="sd">    are below a certain skeletal length</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the new mapping of the old limb idx to new limb idx</span>
<span class="sd">    2) Create the new preprocessing dict of the neuron</span>

<span class="sd">    soma_to_piece_connectivity</span>
<span class="sd">    limb_correspondence</span>
<span class="sd">    limb_meshes</span>
<span class="sd">    limb_mehses_face_idx</span>
<span class="sd">    limb_labels</span>
<span class="sd">    limb_concept_networks</span>
<span class="sd">    limb_network_stating_info</span>


<span class="sd">    3) Delete and rename the nodes of the graph</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">in_place</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="n">limb_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot_limbs_to_filter</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limbs to filter away: </span><span class="si">{</span><span class="n">limb_idx_to_filter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="s2">&quot;all&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_idx_to_filter</span><span class="p">})</span>

    <span class="n">keep_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">limb_idxs</span><span class="p">,</span><span class="n">limb_idx_to_filter</span><span class="p">)</span>
    <span class="n">map_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keep_idx</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;map_idx= </span><span class="si">{</span><span class="n">map_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#2) Create the new preprocessing dict of the neuron</span>
    <span class="n">soma_to_piece_connectivity_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span><span class="n">soma_limbs</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">soma_to_piece_connectivity_new</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_limbs</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>

    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_to_piece_connectivity_new</span>

    <span class="n">list_attr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">,</span><span class="s2">&quot;limb_mehses_face_idx&quot;</span><span class="p">]</span>
    <span class="n">dict_attr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">,</span>     
                <span class="s2">&quot;limb_labels&quot;</span><span class="p">,</span>
                <span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">,</span>
                <span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">,</span>
                <span class="p">]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">list_attr</span><span class="p">:</span>
        <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s2">_new = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">l</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dict_attr</span><span class="p">:</span>
        <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">map_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> 
                               <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">_new = </span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#3) Delete and rename the nodes of the graph</span>
    <span class="n">map_idx_limbs_names</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">map_idx</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;map_idx_limbs_names= </span><span class="si">{</span><span class="n">map_idx_limbs_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_idx_to_filter</span><span class="p">])</span>
    <span class="n">xu</span><span class="o">.</span><span class="n">relabel_node_names</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">map_idx_limbs_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_obj.concept_network.nodes at end = </span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_neuron</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">neuron_obj</span></div>

<div class="viewcode-block" id="filter_away_neuron_limbs_by_min_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.filter_away_neuron_limbs_by_min_skeletal_length">[docs]</a><span class="k">def</span> <span class="nf">filter_away_neuron_limbs_by_min_skeletal_length</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">min_skeletal_length_limb</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#arguments for filtering neuron_limbs</span>
    <span class="n">plot_limbs_to_filter</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away neuron_limbs if below</span>
<span class="sd">    a certain skeletal length</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_sk_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">l_idx</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">l_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
    <span class="n">limb_idx_to_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">limb_sk_length</span><span class="o">&lt;</span><span class="n">min_skeletal_length_limb</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_idx_to_filter = </span><span class="si">{</span><span class="n">limb_idx_to_filter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n_obj</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">filter_away_neuron_limbs</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">limb_idx_to_filter</span><span class="p">,</span>
        <span class="n">plot_limbs_to_filter</span> <span class="o">=</span> <span class="n">plot_limbs_to_filter</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">in_place</span> <span class="o">=</span> <span class="n">in_place</span><span class="p">,</span>
        <span class="n">plot_final_neuron</span><span class="o">=</span> <span class="n">plot_final_neuron</span><span class="p">,</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">n_obj</span></div>

<div class="viewcode-block" id="order_branches_by_skeletal_distance_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.order_branches_by_skeletal_distance_from_soma">[docs]</a><span class="k">def</span> <span class="nf">order_branches_by_skeletal_distance_from_soma</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">verbose</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">closest_to_farthest</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To order branches from </span>
<span class="sd">    most upstream to most downstream</span>
<span class="sd">    accroding to skeletal distance from soma</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Calculate the skeletal distance from soma for branches</span>
<span class="sd">    2) Order and return</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span>
    <span class="n">soma_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">(</span>
                    <span class="n">limb_obj</span><span class="p">,</span><span class="n">k</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
    
    <span class="n">soma_dist_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">soma_dists</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">closest_to_farthest</span><span class="p">:</span>
        <span class="n">soma_dist_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">soma_dist_order</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for branches (</span><span class="si">{</span><span class="n">branches</span><span class="si">}</span><span class="s2">) soma_dists = </span><span class="si">{</span><span class="n">soma_dists</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_dist_order = </span><span class="si">{</span><span class="n">soma_dist_order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">branches</span><span class="p">[</span><span class="n">soma_dist_order</span><span class="p">]</span></div>


<div class="viewcode-block" id="parent_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.parent_node">[docs]</a><span class="k">def</span> <span class="nf">parent_node</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the parent </span>
<span class="sd">    branch of a branch_idx</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parent_node of branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> = branch </span><span class="si">{</span><span class="n">parent_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">parent_node</span></div>

<div class="viewcode-block" id="sibling_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.sibling_nodes">[docs]</a><span class="k">def</span> <span class="nf">sibling_nodes</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the parent </span>
<span class="sd">    branch of a branch_idx</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sibling_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sibling_nodes of branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">sibling_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">sibling_nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="children_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.children_nodes">[docs]</a><span class="k">def</span> <span class="nf">children_nodes</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to get the parent </span>
<span class="sd">    branch of a branch_idx</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.children_nodes(limb_obj,7)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">child_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;child_nodes of branch </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">child_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">child_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="neighborhood_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.neighborhood_mesh">[docs]</a><span class="k">def</span> <span class="nf">neighborhood_mesh</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span>  <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">neighborhood_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">branch_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the branch</span>
<span class="sd">    parent,siblings and children</span>
<span class="sd">    mesh around a mesh</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    neighborhood_mesh(</span>
<span class="sd">        limb_obj,</span>
<span class="sd">        branch_idx,</span>
<span class="sd">        plot = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_neighbors_mesh</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">include_siblings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_parent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_children</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Neighborhood mesh = </span><span class="si">{</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">mesh</span><span class="p">],</span>
            <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="n">branch_color</span><span class="p">,</span><span class="n">neighborhood_color</span><span class="p">]</span>
        <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mesh</span></div>

<div class="viewcode-block" id="is_branch_mesh_connected_to_neighborhood"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.is_branch_mesh_connected_to_neighborhood">[docs]</a><span class="k">def</span> <span class="nf">is_branch_mesh_connected_to_neighborhood</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Determine if a branch mesh</span>
<span class="sd">    has connectiviity to its neighborhood mesh</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the neighborhood mesh</span>
<span class="sd">    2) Find mesh connectivity</span>
<span class="sd">    3) Return True if connected</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    limb_idx = 1</span>
<span class="sd">    branch_idx = 10</span>
<span class="sd">    limb_obj = neuron_obj[limb_idx]</span>
<span class="sd">    nru.is_branch_mesh_connected_to_neighborhood(</span>
<span class="sd">        limb_obj,</span>
<span class="sd">        branch_idx,</span>
<span class="sd">        verbose = True</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>

    <span class="n">n_mesh</span>  <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">neighborhood_mesh</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span> 
                                    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default_value</span>

    <span class="n">mesh_conn</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_connectivity</span><span class="p">(</span>
        <span class="p">[</span><span class="n">n_mesh</span><span class="p">,</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">],</span>
        <span class="n">main_mesh</span><span class="o">=</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_conn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="pair_branch_connected_components_by_common_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.pair_branch_connected_components_by_common_upstream">[docs]</a><span class="k">def</span> <span class="nf">pair_branch_connected_components_by_common_upstream</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">conn_comp</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To group connected components</span>
<span class="sd">    of branches by a common upstream branch</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) For each connected component find the upstream branch</span>
<span class="sd">    and add the connected component to the dictionary book-keeping</span>
<span class="sd">    2) combine all the connected components in the dictionary</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.pair_branch_connected_components_by_common_upstream(</span>
<span class="sd">    neuron_obj[1],</span>
<span class="sd">    conn_comp = [[13], [14], [9, 12, 15, 16, 19], [51, 21, 22, 26, 27, 28], [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 46, 47, 49, 50, 20, 23, 24, 25, 31], [32], [48, 33, 45]],</span>
<span class="sd">    verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before connected components combined: </span><span class="si">{</span><span class="n">conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">upstream_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">):</span>
        <span class="n">most_up_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">most_upstream_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
        <span class="n">parent_b</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">parent_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">most_up_branch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent_b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;comp </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> most upstream branch </span><span class="si">{</span><span class="n">most_up_branch</span><span class="si">}</span><span class="s2"> had parent </span><span class="si">{</span><span class="n">parent_b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">parent_b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">upstream_dict</span><span class="p">:</span>
            <span class="n">upstream_dict</span><span class="p">[</span><span class="n">parent_b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">upstream_dict</span><span class="p">[</span><span class="n">parent_b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        
    <span class="n">final_comp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">conn_comp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">upstream_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER connected components combined: </span><span class="si">{</span><span class="n">final_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">final_comp</span></div>

<div class="viewcode-block" id="recalculate_endpoints_and_order_skeletons_for_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.recalculate_endpoints_and_order_skeletons_for_branch">[docs]</a><span class="k">def</span> <span class="nf">recalculate_endpoints_and_order_skeletons_for_branch</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">):</span>
    <span class="n">branch_obj</span><span class="o">.</span><span class="n">calculate_endpoints</span><span class="p">()</span>
    <span class="n">branch_obj</span><span class="o">.</span><span class="n">order_skeleton_by_smallest_endpoint</span><span class="p">()</span>
    <span class="n">branch_obj</span><span class="o">.</span><span class="n">_skeleton_graph</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">branch_obj</span><span class="o">.</span><span class="n">_endpoints_nodes</span> <span class="o">=</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="recalculate_endpoints_and_order_skeletons_over_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.recalculate_endpoints_and_order_skeletons_over_neuron">[docs]</a><span class="k">def</span> <span class="nf">recalculate_endpoints_and_order_skeletons_over_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Recalculate endpoints</span>
<span class="sd">    and order the skeletons</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="c1">#branch_obj = limb_obj[branch_idx]</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">recalculate_endpoints_and_order_skeletons_for_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">])</span></div>
            
<div class="viewcode-block" id="candidate_limb_branch_dict_branch_intersection"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.candidate_limb_branch_dict_branch_intersection">[docs]</a><span class="k">def</span> <span class="nf">candidate_limb_branch_dict_branch_intersection</span><span class="p">(</span>
    <span class="n">candidate</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span><span class="p">,</span>
    <span class="n">return_candidate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find which branches are in both the candidate and limb branch</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="p">:</span>
        <span class="n">return_branches</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">candidate</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">],</span><span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">])</span>
        
    <span class="k">if</span> <span class="n">return_candidate</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">branches</span><span class="o">=</span><span class="n">return_branches</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_branches</span></div>
    
<div class="viewcode-block" id="limb_branch_from_keywords"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_from_keywords">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_from_keywords</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To fill in the branches part of limb branch dict if</span>
<span class="sd">    used keywords instead of branches numbers</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    
    <span class="k">return</span> <span class="n">new_dict</span></div>
    

    
<div class="viewcode-block" id="limb_correspondence_on_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_correspondence_on_limb">[docs]</a><span class="k">def</span> <span class="nf">limb_correspondence_on_limb</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;width&quot;</span><span class="p">):</span>
    
    <span class="n">limb_corr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1">#for idx,b in enumerate(self):</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">width_name</span> <span class="o">==</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span>
            <span class="n">curr_width</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">width</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_width</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span>

        <span class="n">limb_corr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">branch_skeleton</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                              <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">curr_width</span><span class="p">,</span>
                             <span class="n">branch_mesh</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">branch_face_idx</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span>
                             <span class="p">)</span>


    <span class="k">return</span> <span class="n">limb_corr</span></div>

<div class="viewcode-block" id="limb_correspondence_on_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_correspondence_on_neuron">[docs]</a><span class="k">def</span> <span class="nf">limb_correspondence_on_neuron</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="p">{</span><span class="n">limb_idx</span><span class="p">:</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_correspondence_on_limb</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">(</span><span class="n">return_int</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span></div>

<div class="viewcode-block" id="get_starting_node_from_limb_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.get_starting_node_from_limb_concept_network">[docs]</a><span class="k">def</span> <span class="nf">get_starting_node_from_limb_concept_network</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">):</span>    
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span></div>

<div class="viewcode-block" id="set_preprocessed_data_from_limb_no_mesh_change"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.set_preprocessed_data_from_limb_no_mesh_change">[docs]</a><span class="k">def</span> <span class="nf">set_preprocessed_data_from_limb_no_mesh_change</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_idx</span><span class="p">,</span>
    <span class="n">limb_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">limb_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
    
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_correspondence_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">)</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_concept_network_data_to_limb_network_stating_info</span><span class="p">(</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span>
    <span class="p">)</span>
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">][</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span>
    
    <span class="k">return</span> <span class="n">neuron_obj</span></div>

<div class="viewcode-block" id="translate_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.translate_neuron_obj">[docs]</a><span class="k">def</span> <span class="nf">translate_neuron_obj</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">new_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">align_synapses</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To rotate all of the meshes</span>
<span class="sd">    and skeletons of a neuron object</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    neuron_obj_rot = copy.deepcopy(neuron_obj)</span>
<span class="sd">    mesh_center = neuron_obj[&quot;S0&quot;].mesh_center</span>
<span class="sd">    for i in range(0,10):</span>
<span class="sd">        neuron_obj_rot = hvu.align_neuron_obj(neuron_obj_rot,</span>
<span class="sd">                                             mesh_center=mesh_center,</span>
<span class="sd">                                             verbose =True)</span>
<span class="sd">    nviz.visualize_neuron(</span>
<span class="sd">        neuron_obj_rot,limb_branch_dict = &quot;all&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    neuron_obj_1 = nru.translate_neuron_obj(</span>
<span class="sd">        neuron_obj_h01_aligned,</span>
<span class="sd">        new_center=neuron_obj_m65[&quot;S0&quot;].mesh_center,</span>
<span class="sd">        plot_final_neuron = True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">in_place</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">new_center</span> <span class="o">-</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;translation = </span><span class="si">{</span><span class="n">translation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">limb_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">branch_obj</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="p">:</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">translate_mesh</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">translation</span> <span class="o">=</span> <span class="n">translation</span><span class="p">)</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

            <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">+</span> <span class="n">translation</span>
            <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">+</span> <span class="n">translation</span>
            
            
            <span class="k">if</span> <span class="n">align_synapses</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_coordinate_system_dependent_attributes</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span><span class="n">att</span><span class="p">,</span><span class="nb">getattr</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">translation</span><span class="p">)</span>
                        
            <span class="c1">#doing the spine alignment</span>
            <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">translate_mesh</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">translation</span> <span class="o">=</span> <span class="n">translation</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s_obj</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spines_obj</span><span class="p">:</span>
                    <span class="n">s_obj</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">translate_mesh</span><span class="p">(</span><span class="n">s_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">translation</span> <span class="o">=</span> <span class="n">translation</span><span class="p">)</span>
                
                        
        <span class="c1">#changing the concept network</span>
        <span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">att_to_change</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;starting_endpoints&quot;</span><span class="p">,</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">,</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">att_to_change</span><span class="p">:</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">att</span><span class="p">]</span> <span class="o">+</span> <span class="n">translation</span>
            <span class="n">all_concept_network_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">att_to_change</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;current_</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="nb">getattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;current_</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">translation</span><span class="p">)</span>

        <span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">translate_mesh</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">translation</span> <span class="o">=</span> <span class="n">translation</span><span class="p">)</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">all_concept_network_data</span><span class="p">)</span>
        <span class="n">limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">()</span>
        
    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">translate_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">translation</span><span class="p">)</span>

        
    <span class="c1">#finishing soma mesh stuff</span>
    <span class="k">for</span> <span class="n">s_name</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">():</span>
        <span class="n">neuron_obj</span><span class="p">[</span><span class="n">s_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">translate_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">s_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">translation</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">align_synapses</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">s_name</span><span class="p">]</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_coordinate_system_dependent_attributes</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span><span class="n">att</span><span class="p">,</span><span class="nb">getattr</span><span class="p">(</span><span class="n">syn</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">att</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">translation</span><span class="p">)</span>

        <span class="n">neuron_obj</span><span class="p">[</span><span class="n">s_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">s_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span> <span class="o">+</span> <span class="n">translation</span>
        
    <span class="k">if</span> <span class="n">plot_final_neuron</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">neuron_obj</span></div>

<div class="viewcode-block" id="align_neuron_objs_at_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.align_neuron_objs_at_soma">[docs]</a><span class="k">def</span> <span class="nf">align_neuron_objs_at_soma</span><span class="p">(</span>
    <span class="n">neuron_objs</span><span class="p">,</span>
    <span class="n">center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inplace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Align two neuron objects at their soma</span>

<span class="sd">    1) Get the mesh centers of both</span>
<span class="sd">    2) Find the translation needed</span>
<span class="sd">    3) Adjust all attributes by that amount</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">neuron_objs_trans</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_objs</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">neuron_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;center = </span><span class="si">{</span><span class="n">center</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">neuron_objs_trans</span> <span class="o">=</span> <span class="p">[</span> 
        <span class="n">nru</span><span class="o">.</span><span class="n">translate_neuron_obj</span><span class="p">(</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">new_center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> 
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_objs_trans</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_objs_trans</span><span class="p">],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">neuron_objs_trans</span></div>

<div class="viewcode-block" id="non_axon_like_limb_branch_on_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.non_axon_like_limb_branch_on_dendrite">[docs]</a><span class="k">def</span> <span class="nf">non_axon_like_limb_branch_on_dendrite</span><span class="p">(</span>
    <span class="n">n_obj</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

    <span class="n">non_axon_like_on_dendrite</span> <span class="o">=</span>  <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_setdiff</span><span class="p">(</span>
            <span class="p">[</span><span class="n">n_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">,</span>
            <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span>
                <span class="n">n_obj</span><span class="p">,</span>
                <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">],</span>
            <span class="p">)]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span>
            <span class="n">n_obj</span><span class="p">,</span>
            <span class="n">non_axon_like_on_dendrite</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">non_axon_like_on_dendrite</span></div>

<div class="viewcode-block" id="add_limb_branch_combined_name_to_df"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.add_limb_branch_combined_name_to_df">[docs]</a><span class="k">def</span> <span class="nf">add_limb_branch_combined_name_to_df</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">limb_column</span> <span class="o">=</span> <span class="s2">&quot;limb_idx&quot;</span><span class="p">,</span>
    <span class="n">branch_column</span> <span class="o">=</span> <span class="s2">&quot;branch_idx&quot;</span><span class="p">,</span>
    <span class="n">limb_branch_column</span> <span class="o">=</span> <span class="s2">&quot;limb_branch&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add the limb_branch column to</span>
<span class="sd">    a dataframe</span>

<span class="sd">    Pseudocode</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">limbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">limb_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()]</span>
    <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">branch_column</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()]</span>
    <span class="n">df</span><span class="p">[</span><span class="n">limb_branch_column</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">limbs</span><span class="p">,</span><span class="n">branches</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">df</span></div>
        
<div class="viewcode-block" id="limb_branch_str_names_from_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_str_names_from_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_str_names_from_limb_branch_dict</span><span class="p">(</span>
    <span class="n">limb_branch_dict</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpos: Creates names like</span>
<span class="sd">    </span>
<span class="sd">    [&#39;L0_0&#39;,</span>
<span class="sd">     &#39;L0_1&#39;,</span>
<span class="sd">     &#39;L0_2&#39;,</span>
<span class="sd">     &#39;L0_3&#39;,</span>
<span class="sd">     &#39;L0_4&#39;,</span>
<span class="sd">     &#39;L0_5&#39;,</span>
<span class="sd">     &#39;L0_6&#39;,</span>
<span class="sd">     &#39;L0_7&#39;,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span> <span class="n">branches</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">names</span></div>

<div class="viewcode-block" id="limb_branch_face_idx_dict_from_neuron_obj_overlap_with_face_idx_on_reference_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.limb_branch_face_idx_dict_from_neuron_obj_overlap_with_face_idx_on_reference_mesh">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_face_idx_dict_from_neuron_obj_overlap_with_face_idx_on_reference_mesh</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">mesh_reference</span><span class="p">,</span>
    <span class="n">faces_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh_reference_kdtree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">overlap_percentage_threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">return_limb_branch_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to find a limb branch dict of branches</span>
<span class="sd">    that have a certain level of face overlap with given</span>
<span class="sd">    faces</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    Generate a KDTree for the mesh_reference</span>
<span class="sd">    For each branch in limb branch:</span>
<span class="sd">        a. Get the faces corresponding to the mesh_reference</span>
<span class="sd">        b. Compute the percentage overlap with the faces_idx_list</span>
<span class="sd">        c. If above certain threshold then store the limb,branch,face-list </span>
<span class="sd">        in the dictionary</span>

<span class="sd">    return either the limb branch dict or limb-branch-facelist dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">faces_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">faces_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_reference</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>

    <span class="k">if</span> <span class="n">mesh_reference_kdtree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_reference_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh_reference</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>

    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">branches</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   -&gt; Working on branch </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">branch_obj_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="n">branch_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span>
                <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">mesh_reference</span><span class="p">,</span>
                <span class="n">submesh</span> <span class="o">=</span> <span class="n">branch_obj_mesh</span><span class="p">,</span>
                <span class="n">exact_match</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">mesh_reference_kdtree</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">overlap_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">faces_idx</span><span class="p">,</span><span class="n">branch_faces</span><span class="p">)</span>
            <span class="n">overlap_faces_perc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap_faces</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_faces</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;overlap_faces_perc = </span><span class="si">{</span><span class="n">overlap_faces_perc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap_faces_perc</span> <span class="o">&gt;</span> <span class="n">overlap_percentage_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding branch to final dict&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_dict</span><span class="p">:</span>
                    <span class="n">output_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">output_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">branch_faces</span>


    <span class="k">if</span> <span class="n">return_limb_branch_dict</span><span class="p">:</span>
        <span class="n">output_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">output_dict</span><span class="p">}</span>

    <span class="k">return</span> <span class="n">output_dict</span></div>
    <span class="c1">#package where can use the Branches class to help do branch skeleton analysis</span>
    
    
<div class="viewcode-block" id="calculate_decomposition_products"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_utils.calculate_decomposition_products">[docs]</a><span class="k">def</span> <span class="nf">calculate_decomposition_products</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">store_in_obj</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="c1"># ---- basic statistics of neuron</span>
    <span class="n">stats_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">neuron_stats</span><span class="p">(</span><span class="n">stats_to_ignore</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;n_boutons&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;axon_length&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;axon_area&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;max_soma_volume&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;max_soma_n_faces&quot;</span><span class="p">,],</span>
        <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_centroids</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="c1">#voxel_adjustment_vector=voxel_adjustment_vector,</span>
    <span class="p">)</span>
    
    <span class="c1"># --- generating the skeleton </span>
    <span class="n">skeleton</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeleton</span>
    
    <span class="c1"># --- skeleton stats</span>
    <span class="n">sk_stats</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_stats_from_neuron_obj</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">include_centroids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">stats_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sk_stats</span><span class="p">)</span>
    <span class="n">decomp_products</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">StageProducts</span><span class="p">(</span>
        <span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span>
        <span class="o">**</span><span class="n">stats_dict</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">store_in_obj</span><span class="p">:</span>
        <span class="n">neuron_obj</span><span class="o">.</span><span class="n">pipeline_products</span><span class="o">.</span><span class="n">set_stage_attrs</span><span class="p">(</span>
            <span class="n">decomp_products</span><span class="p">,</span>
            <span class="n">stage</span> <span class="o">=</span> <span class="s2">&quot;decomposition&quot;</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">decomp_products</span></div>


<span class="c1"># ------------- parameters for stats ---------------</span>




<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">skeletal_length_max_n_spines</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">voxel_to_nm_scaling</span> <span class="o">=</span> <span class="n">mvu</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span>
<span class="p">)</span>    


<span class="c1"># ------- microns -----------</span>
<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>


<span class="c1"># --------- h01 -------------</span>
<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">skeletal_length_max_n_spines</span> <span class="o">=</span> <span class="mi">6_000</span>
<span class="p">)</span>

<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">voxel_to_nm_scaling</span> <span class="o">=</span> <span class="n">hvu</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span>
<span class="p">)</span>

<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>
<span class="c1"># modules_to_set = [nru]</span>

<span class="c1"># modsetter = modu.ModuleDataTypeSetter(</span>
<span class="c1">#     module = modules_to_set,</span>
<span class="c1">#     algorithms = algorithms</span>
<span class="c1"># )</span>

<span class="c1"># set_global_parameters_and_attributes_by_data_type = modsetter.set_global_parameters_and_attributes_by_data_type</span>
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type=data_type,</span>
<span class="c1">#                                                    algorithms=algorithms)</span>

<span class="c1"># output_global_parameters_and_attributes_from_current_data_type = modsetter.output_global_parameters_and_attributes_from_current_data_type</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">branch_utils</span> <span class="k">as</span> <span class="n">bu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">classification_utils</span> <span class="k">as</span> <span class="n">clu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">error_detection</span> <span class="k">as</span> <span class="n">ed</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span> 
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocessing_vp2</span> <span class="k">as</span> <span class="n">pre</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">soma_extraction_utils</span> <span class="k">as</span> <span class="n">sm</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">width_utils</span> <span class="k">as</span> <span class="n">wu</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">compartment_utils</span> <span class="k">as</span> <span class="n">cu</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshparty_skeletonize</span> <span class="k">as</span> <span class="n">m_sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">pipeline</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">mesh_utils</span> <span class="k">as</span> <span class="n">meshu</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
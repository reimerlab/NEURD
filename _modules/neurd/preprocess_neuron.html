

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.preprocess_neuron &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.preprocess_neuron</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.preprocess_neuron</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">reload</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">meshparty</span> <span class="kn">import</span> <span class="n">trimesh_io</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">data_struct_utils</span> <span class="k">as</span> <span class="n">dsu</span>

<span class="c1">#importing at the bottom so don&#39;t get any conflicts</span>

<span class="c1">#for meshparty preprocessing</span>





<span class="n">process_version</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">#no skeleton jumping hopefully</span>

<span class="c1">#from neuron_utils import *</span>



<span class="c1"># else:</span>
<span class="c1">#     combine_close_skeleton_nodes_threshold_meshparty_axon = 1300</span>
<span class="c1">#     filter_end_node_length_meshparty_axon = 1500</span>
<span class="c1">#     filter_end_node_length_axon = 1500</span>
<span class="c1">#     invalidation_d_axon = 2000</span>
<span class="c1">#     smooth_neighborhood_axon = 1</span>
    
    





<span class="c1">#--------------- default arguments to use ----------#</span>
<div class="viewcode-block" id="plot_correspondence"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.plot_correspondence">[docs]</a><span class="k">def</span> <span class="nf">plot_correspondence</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">correspondence</span><span class="p">,</span>
    <span class="n">idx_to_show</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">submesh_from_face_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Want to plot mesh correspondence first pass</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each entry:</span>
<span class="sd">    1) Plot mesh (from idx)</span>
<span class="sd">    2) plot skeleton</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">idx_to_show</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">idx_to_show</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">idx_to_show</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">array_like</span><span class="p">(</span><span class="n">idx_to_show</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">idx_to_show</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">submesh_idx</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">submesh_idx</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span>
        <span class="n">subskeleton</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For branch </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: # of mesh faces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">submesh_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">, skeleton length = </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">subskeleton</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">submesh_from_face_idx</span><span class="p">:</span>
            <span class="n">submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">submesh_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">submesh</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">submesh</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span>

        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">mesh</span><span class="p">,</span>
            <span class="n">subskeleton</span><span class="p">,</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">submesh</span><span class="p">],</span>
            <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span></div>
        

<div class="viewcode-block" id="plot_correspondence_on_single_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.plot_correspondence_on_single_mesh">[docs]</a><span class="k">def</span> <span class="nf">plot_correspondence_on_single_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">correspondence</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot the correspondence dict</span>
<span class="sd">    once a 1 to 1 was generated</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        
    <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">))</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
        <span class="n">meshes_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
        <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
        <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span></div>
    
    
<div class="viewcode-block" id="mesh_correspondence_first_pass"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.mesh_correspondence_first_pass">[docs]</a><span class="k">def</span> <span class="nf">mesh_correspondence_first_pass</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">skeleton</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">remove_inside_pieces_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">initial_distance_threshold</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
    <span class="n">skeletal_buffer</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">backup_distance_threshold</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">,</span>
    <span class="n">backup_skeletal_buffer</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
    <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will come up with the mesh correspondences for all of the skeleton</span>
<span class="sd">    branches: where there can be overlaps and empty faces</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">curr_limb_sk</span> <span class="o">=</span> <span class="n">skeleton</span>
    
    <span class="k">if</span> <span class="n">remove_inside_pieces_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_limb_mesh_indices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span>
                                                 <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="n">remove_inside_pieces_threshold</span><span class="p">,</span>
                                                 <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="p">)</span>
        <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">curr_limb_mesh_indices</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_mesh_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">skeleton_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Both skeleton and skeleton_branches is None&quot;</span><span class="p">)</span>
        <span class="n">curr_limb_branches_sk_uneven</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">curr_limb_sk</span><span class="p">)</span> <span class="c1">#the line that is decomposing to branches</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_branches_sk_uneven</span> <span class="o">=</span> <span class="n">skeleton_branches</span> 

    <span class="c1">#Doing the limb correspondence for all of the branches of the skeleton</span>
    <span class="n">local_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_branch_sk</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_limb_branches_sk_uneven</span><span class="p">)):</span>
        <span class="n">local_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        
        <span class="n">returned_data</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">curr_branch_sk</span><span class="p">,</span>
                                      <span class="n">curr_limb_mesh</span><span class="p">,</span>
                                     <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="n">skeleton_segment_width</span><span class="p">,</span>
                                     <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                                    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">initial_distance_threshold</span><span class="p">,</span>
                                    <span class="n">buffer</span> <span class="o">=</span> <span class="n">skeletal_buffer</span><span class="p">,</span>
                                                                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">returned_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Got nothing from first pass so expanding the mesh correspondnece parameters &quot;</span><span class="p">)</span>
            <span class="n">returned_data</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">mesh_correspondence_adaptive_distance</span><span class="p">(</span><span class="n">curr_branch_sk</span><span class="p">,</span>
                                      <span class="n">curr_limb_mesh</span><span class="p">,</span>
                                     <span class="n">skeleton_segment_width</span> <span class="o">=</span> <span class="n">skeleton_segment_width</span><span class="p">,</span>
                                     <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                                    <span class="n">buffer</span><span class="o">=</span><span class="n">backup_skeletal_buffer</span><span class="p">,</span>
                                     <span class="n">distance_threshold</span><span class="o">=</span><span class="n">backup_distance_threshold</span><span class="p">,</span>
                                    <span class="n">return_closest_face_on_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
            
        <span class="c1"># Need to just pick the closest face is still didn&#39;t get anything</span>
        
        <span class="c1"># ------ 12/3 Addition: Account for correspondence that does not work so just picking the closest face</span>
        <span class="n">curr_branch_face_correspondence</span><span class="p">,</span> <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">returned_data</span>
        
            
<span class="c1">#             print(f&quot;curr_branch_sk.shape = {curr_branch_sk.shape}&quot;)</span>
<span class="c1">#             np.savez(&quot;saved_skeleton_branch.npz&quot;,curr_branch_sk=curr_branch_sk)</span>
<span class="c1">#             tu.write_neuron_off(curr_limb_mesh,&quot;curr_limb_mesh.off&quot;)</span>
<span class="c1">#             #print(f&quot;returned_data = {returned_data}&quot;)</span>
<span class="c1">#             raise Exception(f&quot;The output from mesh_correspondence_adaptive_distance was nothing: curr_branch_face_correspondence&quot;)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch_face_correspondence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_submesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_branch_face_correspondence</span><span class="p">)],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_submesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">faces</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>


        <span class="n">local_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_branch_sk</span>
        <span class="n">local_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_submesh</span>
        <span class="n">local_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb_mesh_indices</span><span class="p">[</span><span class="n">curr_branch_face_correspondence</span><span class="p">]</span>
        <span class="n">local_correspondence</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">width_from_skeleton</span>
        
        
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_correspondence</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">local_correspondence</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">local_correspondence</span></div>



<div class="viewcode-block" id="check_skeletonization_and_decomp"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.check_skeletonization_and_decomp">[docs]</a><span class="k">def</span> <span class="nf">check_skeletonization_and_decomp</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">local_correspondence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To check that the decomposition and skeletonization went well</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#couple of checks on how the decomposition went:  for each limb</span>
    <span class="c1">#1) if shapes of skeletons cleaned and divided match</span>
    <span class="c1">#2) if skeletons are only one component</span>
    <span class="c1">#3) if you downsample the skeletons then still only one component</span>
    <span class="c1">#4) if any empty meshes</span>
    <span class="n">cleaned_branch</span> <span class="o">=</span> <span class="n">skeleton</span>
    <span class="n">empty_submeshes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb decomposed into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">local_correspondence</span><span class="p">)</span><span class="si">}</span><span class="s2"> branches&quot;</span><span class="p">)</span>

    <span class="c1">#get all of the skeletons and make sure that they from a connected component</span>
    <span class="n">divided_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">local_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence</span><span class="p">]</span>
    <span class="n">divided_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span>
                                    <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">divided_branches</span><span class="p">))</span>

    <span class="n">divided_skeleton_graph_recovered</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">divided_skeleton_graph</span><span class="p">)</span>

    <span class="n">cleaned_limb_skeleton</span> <span class="o">=</span> <span class="n">cleaned_branch</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;divided_skeleton_graph_recovered = </span><span class="si">{</span><span class="n">divided_skeleton_graph_recovered</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="se">\n</span><span class="s2">&quot;</span>
          <span class="sa">f</span><span class="s2">&quot;current_mesh_data[0][&#39;branch_skeletons_cleaned&#39;].shape = </span><span class="si">{</span><span class="n">cleaned_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">divided_skeleton_graph_recovered</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">cleaned_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;****divided_skeleton_graph_recovered and cleaned_limb_skeleton shapes not match: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">divided_skeleton_graph_recovered</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs. </span><span class="si">{</span><span class="n">cleaned_limb_skeleton</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> *****&quot;</span><span class="p">)</span>


    <span class="c1">#check that it is all one component</span>
    <span class="n">divided_skeleton_graph_n_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">divided_skeleton_graph</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of connected components in deocmposed recovered graph = </span><span class="si">{</span><span class="n">divided_skeleton_graph_n_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">cleaned_limb_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">cleaned_limb_skeleton</span><span class="p">)</span>
    <span class="n">cleaned_limb_skeleton_graph_n_comp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">cleaned_limb_skeleton_graph</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of connected components in cleaned skeleton graph= </span><span class="si">{</span><span class="n">cleaned_limb_skeleton_graph_n_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">divided_skeleton_graph_n_comp</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">cleaned_limb_skeleton_graph_n_comp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;One of the decompose_skeletons or cleaned skeletons was not just one component : </span><span class="si">{</span><span class="n">divided_skeleton_graph_n_comp</span><span class="p">,</span><span class="n">cleaned_limb_skeleton_graph_n_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#check that when we downsample it is not one component:</span>
    <span class="n">curr_branch_meshes_downsampled</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">n_segments</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">divided_branches</span><span class="p">]</span>
    <span class="n">downsampled_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">curr_branch_meshes_downsampled</span><span class="p">)</span>
    <span class="n">curr_sk_graph_debug</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">downsampled_skeleton</span><span class="p">)</span>


    <span class="n">con_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_sk_graph_debug</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">con_comp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were more than 1 component when downsizing: </span><span class="si">{</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">con_comp</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The downsampled branches number of connected components = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">con_comp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">local_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">empty_submeshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Empty submeshes = </span><span class="si">{</span><span class="n">empty_submeshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empty_submeshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found empyt meshes after branch mesh correspondence: </span><span class="si">{</span><span class="n">empty_submeshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
        

        
        
<div class="viewcode-block" id="correspondence_1_to_1"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.correspondence_1_to_1">[docs]</a><span class="k">def</span> <span class="nf">correspondence_1_to_1</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">local_correspondence</span><span class="p">,</span>
    <span class="n">curr_limb_endpoints_must_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">must_keep_labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
    <span class="n">fill_to_soma_border</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will Fix the 1-to-1 Correspondence of the mesh</span>
<span class="sd">    correspondence for the limbs and make sure that the</span>
<span class="sd">    endpoints that are designated as touching the soma then </span>
<span class="sd">    make sure the mesh correspondnece reaches the soma limb border</span>
<span class="sd">    </span>
<span class="sd">    has an optional argument must_keep_labels that will allow you to specify some labels that are a must keep</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mesh</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="s2">&quot;mesh&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Mesh passed to correspondence_1_to_1 is not just one mesh&quot;</span><span class="p">)</span>
    
    <span class="n">mesh_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">--- Working on 1-to-1 correspondence-----&quot;</span><span class="p">)</span>

    <span class="c1">#geting the current limb mesh</span>

    <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">local_correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c1">#counts the number of divided branches which should be the total number of labels</span>
    <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">mesh</span>

    <span class="c1">#set up the face dictionary</span>
    <span class="n">face_lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">j</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))])</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">branch_piece</span> <span class="ow">in</span> <span class="n">local_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_faces_corresponded</span> <span class="o">=</span> <span class="n">branch_piece</span><span class="p">[</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">curr_faces_corresponded</span><span class="p">:</span>
            <span class="n">face_lookup</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="n">original_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">values</span><span class="p">()))))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max(original_labels),len(original_labels) = </span><span class="si">{</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(original_labels) != len(no_missing_labels) for original_labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">,no_missing_labels = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">no_missing_labels</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">original_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_labels</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There are some missing labels in the initial labeling&quot;</span><span class="p">)</span>



    <span class="c1">#here is where can call the function that resolves the face labels</span>
    <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span>
                     <span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">curr_limb_mesh</span><span class="p">,</span>
                     <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                     <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_labels</span><span class="p">),</span>
                    <span class="n">must_keep_labels</span><span class="o">=</span><span class="n">must_keep_labels</span><span class="p">,</span>
                    <span class="n">branch_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">local_correspondence</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">()],</span>
    <span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;  9/17 Addition: Will make sure that the desired starting node is touching the soma border &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    For each soma it is touching</span>
<span class="sd">    0) Get the soma border</span>
<span class="sd">    1) Find the label_to_expand based on the starting coordinate</span>
<span class="sd">    a. Get the starting coordinate</span>

<span class="sd">    soma_to_piece_touching_vertices=None</span>
<span class="sd">    endpoints_must_keep</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#curr_limb_endpoints_must_keep --&gt; stores the endpoints that should be connected to the soma</span>
    <span class="c1">#curr_soma_to_piece_touching_vertices --&gt; maps soma to  a list of grouped touching vertices</span>

    <span class="k">if</span> <span class="n">fill_to_soma_border</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">curr_limb_endpoints_must_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sm</span><span class="p">,</span><span class="n">soma_border_list</span> <span class="ow">in</span> <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">curr_soma_border</span><span class="p">,</span><span class="n">st_coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_border_list</span><span class="p">,</span><span class="n">curr_limb_endpoints_must_keep</span><span class="p">[</span><span class="n">sm</span><span class="p">]):</span>

                    <span class="c1">#1) Find the label_to_expand based on the starting coordinate</span>
                    <span class="n">divided_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">local_correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                    <span class="c1">#print(f&quot;st_coord = {st_coord}&quot;)</span>
                    <span class="n">label_to_expand</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="o">=</span><span class="n">divided_branches</span><span class="p">,</span>
                                                                                       <span class="n">current_coordinate</span><span class="o">=</span><span class="n">st_coord</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


                    <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">waterfill_starting_label_to_soma_border</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span>
                                                       <span class="n">border_vertices</span><span class="o">=</span><span class="n">curr_soma_border</span><span class="p">,</span>
                                                        <span class="n">label_to_expand</span><span class="o">=</span><span class="n">label_to_expand</span><span class="p">,</span>
                                                       <span class="n">total_face_labels</span><span class="o">=</span><span class="n">face_coloring_copy</span><span class="p">,</span>
                                                       <span class="n">print_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="c1"># -- splitting the mesh pieces into individual pieces</span>
    <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">curr_limb_mesh</span><span class="p">,</span><span class="n">face_coloring_copy</span><span class="p">)</span>

    <span class="c1">#-- check that all the split mesh pieces are one component --#</span>
    <span class="n">local_correspondence_revised</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">local_correspondence</span><span class="p">)</span>
    <span class="c1">#save off the new data as branch mesh</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence_revised</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divided_submeshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1">#clean the limb correspondence that we do not need</span>
        <span class="k">del</span> <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;correspondence_mesh&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;correspondence_face_idx&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_correspondence_on_single_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">local_correspondence_revised</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">local_correspondence_revised</span></div>



<div class="viewcode-block" id="filter_soma_touching_vertices_dict_by_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.filter_soma_touching_vertices_dict_by_mesh">[docs]</a><span class="k">def</span> <span class="nf">filter_soma_touching_vertices_dict_by_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                              <span class="n">curr_piece_to_soma_touching_vertices</span><span class="p">,</span>
                                              <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will take the soma to touching vertics</span>
<span class="sd">    and filter it for only those that touch the particular mesh piece</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Build a KDTree of the mesh</span>
<span class="sd">    2) Create an output dictionary to store the filtered soma touching vertices</span>
<span class="sd">    For the original soma touching vertices, iterating through all the somas</span>
<span class="sd">        For each soma_touching list:</span>
<span class="sd">            Query the mesh KDTree and only keep the coordinates whose distance is equal to 0</span>

<span class="sd">    If empty dictionary then return None? (have option for this)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    return_value = filter_soma_touching_vertices_dict_by_mesh(</span>
<span class="sd">    mesh = mesh_pieces_for_MAP[0],</span>
<span class="sd">    curr_piece_to_soma_touching_vertices = piece_to_soma_touching_vertices[1]</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">curr_piece_to_soma_touching_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In filter_soma_touching_vertices_dict_by_mesh: curr_piece_to_soma_touching_vertices was None so returning none&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1">#1) Build a KDTree of the mesh</span>
    <span class="n">curr_mesh_tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="c1">#2) Create an output dictionary to store the filtered soma touching vertices</span>
    <span class="n">output_soma_touching_vertices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">sm_idx</span><span class="p">,</span><span class="n">border_verts_list</span> <span class="ow">in</span> <span class="n">curr_piece_to_soma_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">b_verts</span> <span class="ow">in</span> <span class="n">border_verts_list</span><span class="p">:</span>
            <span class="n">dist</span><span class="p">,</span><span class="n">closest_nodes</span> <span class="o">=</span> <span class="n">curr_mesh_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">b_verts</span><span class="p">)</span>
            <span class="n">match_verts</span> <span class="o">=</span> <span class="n">b_verts</span><span class="p">[</span><span class="n">dist</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_verts</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sm_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_soma_touching_vertices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">output_soma_touching_vertices</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">output_soma_touching_vertices</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_verts</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_soma_touching_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output_soma_touching_vertices</span></div>
    
    
    
<span class="c1"># ----------------- When refactoring the limb decomposition function ------ #</span>

<div class="viewcode-block" id="find_if_stitch_point_on_end_or_branch"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.find_if_stitch_point_on_end_or_branch">[docs]</a><span class="k">def</span> <span class="nf">find_if_stitch_point_on_end_or_branch</span><span class="p">(</span><span class="n">matched_branches_skeletons</span><span class="p">,</span>
                                                              <span class="n">stitch_coordinate</span><span class="p">,</span>
                                                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                    
                    
                        <span class="c1"># Step A: Find if stitch point is on endpt/branch point or in middle</span>
                        <span class="n">stitch_point_on_end_or_branch</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_branches_skeletons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching branches found for soma extending point&quot;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_branches_skeletons</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiple Branches for MP soma extending connection point </span><span class="si">{</span><span class="n">matched_branches_skeletons</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">stitch_point_on_end_or_branch</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span><span class="c1"># len(match_sk_branches)==1:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only one Branch for MP soma Extending connection point </span><span class="si">{</span><span class="n">matched_branches_skeletons</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">matched_branches_skeletons</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                                    <span class="n">stitch_coordinate</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                                <span class="n">stitch_point_on_end_or_branch</span> <span class="o">=</span><span class="kc">True</span>

                        <span class="k">return</span> <span class="n">stitch_point_on_end_or_branch</span></div>
                    

                    




<div class="viewcode-block" id="closest_dist_from_floating_mesh_to_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.closest_dist_from_floating_mesh_to_skeleton">[docs]</a><span class="k">def</span> <span class="nf">closest_dist_from_floating_mesh_to_skeleton</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">floating_mesh</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_floating_mesh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_closest_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To see what the closest distance</span>
<span class="sd">    for a floating mesh would be for a given skeleton</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">preprocess_limb</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">floating_mesh</span><span class="p">,</span>
        <span class="n">return_concept_network</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">error_on_no_starting_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>


    <span class="n">float_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> 
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    <span class="n">float_sk_endpts</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">float_sk</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_floating_mesh</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_floating_mesh decomp&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">floating_mesh</span><span class="p">,</span>
            <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">float_sk</span><span class="p">],</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">float_sk_endpts</span><span class="p">],</span>
            <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="n">main_sk_coordinates</span> <span class="o">=</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">limb_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">main_sk_coordinates</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span><span class="n">idx</span> <span class="o">=</span> <span class="n">limb_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">float_sk_endpts</span><span class="p">)</span>
    <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
    <span class="n">closest_coord</span> <span class="o">=</span> <span class="n">main_sk_coordinates</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_dist = </span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">, closest_coord = </span><span class="si">{</span><span class="n">closest_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_closest_coordinate</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">floating_mesh</span><span class="p">,</span>
            <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">skeleton</span><span class="p">],</span>
            <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">float_sk_endpts</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span>
                     <span class="n">closest_coord</span><span class="p">],</span>
            <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">min_dist</span></div>

<div class="viewcode-block" id="attach_floating_pieces_to_limb_correspondence"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.attach_floating_pieces_to_limb_correspondence">[docs]</a><span class="k">def</span> <span class="nf">attach_floating_pieces_to_limb_correspondence</span><span class="p">(</span>
        <span class="n">limb_correspondence</span><span class="p">,</span>
        <span class="n">floating_meshes</span><span class="p">,</span>
        <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_stitch_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
    
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">excluded_node_coordinates</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_end_node_length_meshparty</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">error_on_bad_cgal_return</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_stitch_distance_CGAL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">size_threshold_MAP_stitch</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1">#invalidation_d = 2000,</span>
    
        
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">max_stitch_distance_CGAL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="n">max_stitch_distance_CGAL_global</span>
        
    <span class="k">if</span> <span class="n">max_stitch_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="n">max_stitch_distance_global</span>
        
    <span class="k">if</span> <span class="n">floating_piece_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_global</span>
        
    <span class="k">if</span> <span class="n">filter_end_node_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="n">filter_end_node_length_global</span>
        
    <span class="k">if</span> <span class="n">axon_width_preprocess_limb_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="n">axon_width_preprocess_limb_max_global</span>
        
    <span class="k">if</span> <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="n">limb_remove_mesh_interior_face_threshold_global</span>
        
    <span class="k">if</span> <span class="n">max_stitch_distance_CGAL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="n">max_stitch_distance_CGAL_global</span>
        
    <span class="k">if</span> <span class="n">size_threshold_MAP_stitch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size_threshold_MAP_stitch</span> <span class="o">=</span> <span class="n">size_threshold_MAP_stitch_global</span>
        
    <span class="k">if</span> <span class="n">use_adaptive_invalidation_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_adaptive_invalidation_d</span>  <span class="o">=</span> <span class="n">use_adaptive_invalidation_d_floating_global</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a limb correspondence and add on the floating pieces</span>
<span class="sd">    that are significant and close enough to a limb</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    0) Filter the floating pieces for only those above certain face count</span>
<span class="sd">    1) Run all significant floating pieces through preprocess_limb</span>
<span class="sd">    2) Get all full skeleton endpoints (degree 1) for all floating pieces</span>


<span class="sd">    Start loop until all floating pieces have been added</span>
<span class="sd">    a) Get full skeletons of limbs for all limbs in limb correspondence</span>
<span class="sd">    b) Find the minimum distance (and the node it corresponds to) for each floating piece between their </span>
<span class="sd">    endpoints and all skeleton points of limbs</span>
<span class="sd">    c) Find the floating piece that has the closest distance</span>
<span class="sd">    --&gt; winning piece</span>

<span class="sd">    For the winning piece</span>
<span class="sd">    d) Get the closest coordinate on the matching limb</span>
<span class="sd">    e) Try and move closest coordinate to an endpoint or high degree node</span>
<span class="sd">    f) Find the branch on the main limb that corresponds to the stitch point</span>
<span class="sd">    g) Find whether the stitch point is on an endpoint/high degree node or will end up splitting the branch</span>
<span class="sd">    AKA stitch_point_on_end_or_branch</span>
<span class="sd">    h) Find the branch on the floating limb where the closest end point is</span>

<span class="sd">    At this point have</span>
<span class="sd">    - main limb stitch point and branches (and whether not splitting will be required)  [like MAP]</span>
<span class="sd">    - floating limb stitch point and branch [like MP]</span>

<span class="sd">    Stitching process:</span>
<span class="sd">    i) if not stitch_point_on_end_or_branch</span>
<span class="sd">    - cut the main limb branch where stitch is</span>
<span class="sd">    - do mesh correspondence with the new stitches</span>
<span class="sd">    - (just give the both the same old width)</span>
<span class="sd">    - replace the old entry in the limb corresondence with one of the new skeleton cuts</span>
<span class="sd">    and add on the other skeletons cuts to the end</span>

<span class="sd">    j) Add a skeletal segment from floating limb stitch point to main limb stitch point</span>
<span class="sd">    k) Add the floating limb branches to the end of the limb correspondence</span>
<span class="sd">    l) Marks the floating piece as processed</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_correspondence_cp</span> <span class="o">=</span> <span class="n">limb_correspondence</span>
    <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="n">floating_meshes</span>
    <span class="n">floating_limbs_above_threshold</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">non_soma_touching_meshes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="o">&gt;</span><span class="n">floating_piece_face_threshold</span><span class="p">]</span>

    <span class="c1">#1) Run all significant floating pieces through preprocess_limb</span>
    
    <span class="n">debug_corr</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">debug_corr</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting the floating pieces preprocessing&quot;</span><span class="p">)</span>
    
    
    <span class="c1">#with su.suppress_stdout_stderr():</span>
    <span class="k">with</span> <span class="n">su</span><span class="o">.</span><span class="n">suppress_stdout_stderr</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">debug_corr</span> <span class="k">else</span> <span class="n">su</span><span class="o">.</span><span class="n">dummy_context_mgr</span><span class="p">():</span>
        
        <span class="n">floating_limbs_correspondence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">floating_limbs_above_threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug_corr</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Floating </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">st_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="n">curr_corr</span> <span class="o">=</span> <span class="n">preprocess_limb</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                           <span class="n">soma_touching_vertices_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">return_concept_network</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                            <span class="n">error_on_no_starting_coordinates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="n">filter_end_node_length</span><span class="p">,</span>
                            <span class="n">filter_end_node_length_meshparty</span> <span class="o">=</span> <span class="n">filter_end_node_length_meshparty</span><span class="p">,</span>
                            <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="n">use_adaptive_invalidation_d</span><span class="p">,</span>
                            <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="n">axon_width_preprocess_limb_max</span><span class="p">,</span>
                            <span class="n">remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="n">limb_remove_mesh_interior_face_threshold</span><span class="p">,</span>
                            <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="n">error_on_bad_cgal_return</span><span class="p">,</span>
                            <span class="n">max_stitch_distance_CGAL</span><span class="o">=</span><span class="n">max_stitch_distance_CGAL</span><span class="p">,</span>
                            <span class="n">size_threshold_MAP</span> <span class="o">=</span> <span class="n">size_threshold_MAP_stitch</span><span class="p">,</span>
                            <span class="c1">#invalidation_d=invalidation_d,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                           <span class="p">)</span>
                
            <span class="n">floating_limbs_correspondence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_corr</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug_corr</span><span class="p">:</span>
                <span class="c1">#if len(k.faces) == 129010:</span>
                <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_correspondence</span><span class="p">(</span><span class="n">curr_corr</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug_corr</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">st_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
<span class="c1">#         floating_limbs_correspondence = [ preprocess_limb(mesh=k,</span>
<span class="c1">#                            soma_touching_vertices_dict = None,</span>
<span class="c1">#                            return_concept_network = False, </span>
<span class="c1">#                             error_on_no_starting_coordinates=False,</span>
<span class="c1">#                                                           **kwargs,</span>
<span class="c1">#                            )  for k in floating_limbs_above_threshold]</span>

    <span class="c1">#2) Get all full skeleton endpoints (degree 1) for all floating pieces</span>
    <span class="n">floating_limbs_skeleton</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">l_c</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span> <span class="k">for</span> <span class="n">l_c</span> <span class="ow">in</span> <span class="n">floating_limbs_correspondence</span><span class="p">]</span>
    <span class="n">floating_limbs_skeleton_endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">floating_limbs_skeleton</span><span class="p">]</span>
    
<span class="c1">#     su.compressed_pickle(floating_limbs_skeleton,&quot;floating_limbs_skeleton&quot;)</span>
<span class="c1">#     su.compressed_pickle(floating_limbs_skeleton_endpoints,&quot;floating_limbs_skeleton_endpoints&quot;)</span>
<span class="c1">#     raise Exception(&quot;&quot;)</span>
    

<span class="c1">#     nviz.plot_objects(skeletons=floating_limb_skeletons,</span>
<span class="c1">#                      scatters=floating_limbs_skeleton_endpoints,</span>
<span class="c1">#                      scatter_size=1)</span>

    <span class="n">floating_limbs_to_process</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">floating_limbs_skeleton</span><span class="p">))</span>

    <span class="c1">#Start loop until all floating pieces have been added</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">floating_limbs_to_process</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

        <span class="c1">#a) Get full skeletons of limbs for all limbs in limb correspondence</span>
        <span class="n">main_limb_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">main_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_cp</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="n">main_limb_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">main_idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>

        <span class="c1">#b) Find the minimum distance (and the node it corresponds to) for each floating piece between their </span>
        <span class="c1">#endpoints and all skeleton points of limbs </span>
        <span class="n">floating_piece_min_distance_all_main_limbs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">float_idx</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">float_idx</span> <span class="ow">in</span> <span class="n">floating_limbs_to_process</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">main_idx</span><span class="p">,</span><span class="n">main_limb_sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">main_limb_skeletons</span><span class="p">):</span>

            <span class="n">main_skeleton_coordinates</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_unique_coordinates</span><span class="p">(</span><span class="n">main_limb_sk</span><span class="p">)</span>
            <span class="n">main_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">main_skeleton_coordinates</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">float_idx</span> <span class="ow">in</span> <span class="n">floating_piece_min_distance_all_main_limbs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="n">dist</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">main_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">floating_limbs_skeleton_endpoints</span><span class="p">[</span><span class="n">float_idx</span><span class="p">])</span>
                <span class="n">min_dist_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">min_dist_idx</span><span class="p">]</span>
                <span class="n">min_dist_closest_node</span> <span class="o">=</span> <span class="n">main_skeleton_coordinates</span><span class="p">[</span><span class="n">closest_node</span><span class="p">[</span><span class="n">min_dist_idx</span><span class="p">]]</span>
                <span class="n">floating_piece_min_distance_all_main_limbs</span><span class="p">[</span><span class="n">float_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">min_dist</span><span class="p">,</span><span class="n">min_dist_closest_node</span><span class="p">,</span><span class="n">floating_limbs_skeleton_endpoints</span><span class="p">[</span><span class="n">float_idx</span><span class="p">][</span><span class="n">min_dist_idx</span><span class="p">]])</span>



        <span class="n">winning_float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">winning_float_match_main_limb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">main_limb_stitch_point</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">floating_limb_stitch_point</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">winning_float_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>


        <span class="c1">#c) Find the floating piece that has the closest distance</span>
        <span class="c1">#--&gt; winning piece</span>

        <span class="c1">#For the winning piece</span>
        <span class="c1">#d) Get the closest coordinate on the matching limb</span>

        <span class="k">for</span> <span class="n">f_idx</span><span class="p">,</span><span class="n">dist_data</span> <span class="ow">in</span> <span class="n">floating_piece_min_distance_all_main_limbs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">dist_data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_data</span><span class="p">)</span>
            <span class="n">closest_main_limb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_data_array</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">closest_main_dist</span> <span class="o">=</span> <span class="n">dist_data_array</span><span class="p">[</span><span class="n">closest_main_limb</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">closest_main_dist</span> <span class="o">&lt;</span> <span class="n">winning_float_dist</span><span class="p">:</span>

                <span class="n">winning_float</span> <span class="o">=</span> <span class="n">f_idx</span>
                <span class="n">winning_float_match_main_limb</span> <span class="o">=</span> <span class="n">closest_main_limb</span>
                <span class="n">winning_float_dist</span> <span class="o">=</span> <span class="n">closest_main_dist</span>
                <span class="n">main_limb_stitch_point</span> <span class="o">=</span> <span class="n">dist_data_array</span><span class="p">[</span><span class="n">closest_main_limb</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">floating_limb_stitch_point</span> <span class="o">=</span> <span class="n">dist_data_array</span><span class="p">[</span><span class="n">closest_main_limb</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">winning_main_skeleton</span> <span class="o">=</span> <span class="n">main_limb_skeletons</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">]</span>
        <span class="n">winning_floating_correspondence</span> <span class="o">=</span> <span class="n">floating_limbs_correspondence</span><span class="p">[</span><span class="n">winning_float</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_float = </span><span class="si">{</span><span class="n">winning_float</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_float_match_main_limb = </span><span class="si">{</span><span class="n">winning_float_match_main_limb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_float_dist = </span><span class="si">{</span><span class="n">winning_float_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_limb_stitch_point = </span><span class="si">{</span><span class="n">main_limb_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;floating_limb_stitch_point = </span><span class="si">{</span><span class="n">floating_limb_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="c1">#print(f&quot;winning_floating_correspondence = {winning_floating_correspondence}&quot;)</span>
        
        <span class="c1">#print(f&quot;winning_floating_correspondence = {winning_floating_correspondence[&#39;branch_mesh&#39;]}&quot;)</span>

        
        <span class="k">if</span> <span class="n">winning_float_dist</span> <span class="o">&gt;</span> <span class="n">max_stitch_distance</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The closest float distance was </span><span class="si">{</span><span class="n">winning_float_dist</span><span class="si">}</span><span class="s2"> which was greater than the maximum stitch distance </span><span class="si">{</span><span class="n">max_stitch_distance</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="s2">&quot; --&gt; so ending the floating mesh stitch processs&quot;</span><span class="p">)</span>
            
<span class="c1">#             su.compressed_pickle(main_limb_skeletons,&quot;main_limb_skeletons&quot;)</span>
<span class="c1">#             su.compressed_pickle(floating_limbs_skeleton_endpoints,&quot;floating_limbs_skeleton_endpoints&quot;)</span>
<span class="c1">#             su.compressed_pickle(floating_piece_min_distance_all_main_limbs,&quot;floating_piece_min_distance_all_main_limbs&quot;)</span>
<span class="c1">#             su.compressed_pickle(limb_correspondence_cp,&#39;limb_correspondence_cp&#39;)</span>
<span class="c1">#             raise Exception(&quot;Done stitching&quot;)</span>
            
            <span class="k">return</span> <span class="n">limb_correspondence_cp</span>
        <span class="k">else</span><span class="p">:</span>
            
            
            <span class="c1">#e) Try and move closest coordinate to an endpoint or high degree node</span>

            <span class="n">main_limb_stitch_point</span><span class="p">,</span><span class="n">change_status</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">move_point_to_nearest_branch_end_point_within_threshold</span><span class="p">(</span>
                                                                <span class="n">skeleton</span><span class="o">=</span><span class="n">winning_main_skeleton</span><span class="p">,</span>
                                                                <span class="n">coordinate</span><span class="o">=</span><span class="n">main_limb_stitch_point</span><span class="p">,</span>
                                                                <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="n">distance_to_move_point_threshold</span><span class="p">,</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                <span class="n">consider_high_degree_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">excluded_node_coordinates</span><span class="o">=</span><span class="n">excluded_node_coordinates</span>

                                                                <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Status of Main limb stitch point moved = </span><span class="si">{</span><span class="n">change_status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#     #checking that match was right</span>
        <span class="c1">#     nviz.plot_objects(meshes=[floating_limbs_above_threshold[winning_float],current_mesh_data[0][&quot;branch_meshes&quot;][winning_float_match_main_limb]],</span>
        <span class="c1">#                   meshes_colors=[&quot;red&quot;,&quot;aqua&quot;],</span>
        <span class="c1">#                 skeletons=[floating_limbs_skeleton[winning_float],main_limb_skeletons[winning_float_match_main_limb]],</span>
        <span class="c1">#                  skeletons_colors=[&quot;red&quot;,&quot;aqua&quot;],</span>
        <span class="c1">#                  scatters=[floating_limb_stitch_point.reshape(-1,3),main_limb_stitch_point.reshape(-1,3)],</span>
        <span class="c1">#                  scatters_colors=[&quot;red&quot;,&quot;aqua&quot;])</span>


            <span class="c1">#f) Find the branch on the main limb that corresponds to the stitch point</span>
            <span class="n">main_limb_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="n">match_sk_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">main_limb_branches</span><span class="p">,</span>
                                <span class="n">current_coordinate</span><span class="o">=</span><span class="n">main_limb_stitch_point</span><span class="p">)</span>

            <span class="c1">#g) Find whether the stitch point is on an endpoint/high degree node or will end up splitting the branch</span>
            <span class="c1">#AKA stitch_point_on_end_or_branch</span>
            <span class="n">stitch_point_on_end_or_branch</span> <span class="o">=</span> <span class="n">find_if_stitch_point_on_end_or_branch</span><span class="p">(</span>
                                                                    <span class="n">matched_branches_skeletons</span><span class="o">=</span> <span class="n">main_limb_branches</span><span class="p">[</span><span class="n">match_sk_branches</span><span class="p">],</span>
                                                                     <span class="n">stitch_coordinate</span><span class="o">=</span><span class="n">main_limb_stitch_point</span><span class="p">,</span>
                                                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1">#h) Find the branch on the floating limb where the closest end point is</span>
            <span class="n">winning_float_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">winning_floating_correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="n">match_float_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">winning_float_branches</span><span class="p">,</span>
                                <span class="n">current_coordinate</span><span class="o">=</span><span class="n">floating_limb_stitch_point</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_float_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;len(match_float_branches) was greater than 1 in the floating pieces stitch&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_sk_branches = </span><span class="si">{</span><span class="n">match_sk_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_float_branches = </span><span class="si">{</span><span class="n">match_float_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stitch_point_on_end_or_branch = </span><span class="si">{</span><span class="n">stitch_point_on_end_or_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Stitching process:</span>
<span class="sd">            i) if not stitch_point_on_end_or_branch</span>
<span class="sd">               1. cut the main limb branch where stitch is</span>
<span class="sd">               2. do mesh correspondence with the new stitches</span>
<span class="sd">               3. (just give the both the same old width)</span>
<span class="sd">               4. replace the old entry in the limb corresondence with one of the new skeleton cuts</span>
<span class="sd">                  and add on the other skeletons cuts to the end</span>

<span class="sd">            j) Add a skeletal segment from floating limb stitch point to main limb stitch point</span>
<span class="sd">            k) Add the floating limb branches to the end of the limb correspondence</span>
<span class="sd">            l) Marks the floating piece as processed</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># ---------- Begin stitching process ---------------</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stitch_point_on_end_or_branch</span><span class="p">:</span>
                <span class="n">main_branch</span> <span class="o">=</span> <span class="n">match_sk_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#1. cut the main limb branch where stitch is</span>
                <span class="n">matching_branch_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">cut_skeleton_at_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">main_limb_branches</span><span class="p">[</span><span class="n">main_branch</span><span class="p">],</span>
                                                                           <span class="n">cut_coordinate</span> <span class="o">=</span> <span class="n">main_limb_stitch_point</span><span class="p">)</span>
                <span class="c1">#2. do mesh correspondence with the new stitchess</span>
                <span class="n">stitch_mesh</span> <span class="o">=</span> <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">][</span><span class="n">main_branch</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span>

                <span class="n">local_correspondnece</span> <span class="o">=</span> <span class="n">mesh_correspondence_first_pass</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">stitch_mesh</span><span class="p">,</span>
                                                          <span class="n">skeleton_branches</span><span class="o">=</span><span class="n">matching_branch_sk</span><span class="p">)</span>

                <span class="n">local_correspondence_revised</span> <span class="o">=</span> <span class="n">correspondence_1_to_1</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">stitch_mesh</span><span class="p">,</span>
                                                            <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondnece</span><span class="p">)</span>

                <span class="c1">#3. (just give the both the same old width)</span>
                <span class="n">old_width</span> <span class="o">=</span> <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">][</span><span class="n">main_branch</span><span class="p">][</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">local_correspondence_revised</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_width</span>

                <span class="c1">#4. replace the old entry in the limb corresondence with one of the new skeleton cuts</span>
                <span class="c1">#and add on the other skeletons cuts to the end</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;main_branch = </span><span class="si">{</span><span class="n">main_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">][</span><span class="n">main_branch</span><span class="p">]</span>


                <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">][</span><span class="n">main_branch</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">]</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">order_dict_by_keys</span><span class="p">(</span><span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">])</span>



            <span class="c1">#j) Add a skeletal segment from floating limb stitch point to main limb stitch point</span>
            <span class="n">skeleton</span> <span class="o">=</span> <span class="n">winning_floating_correspondence</span><span class="p">[</span><span class="n">match_float_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
            <span class="n">adjusted_floating_sk_branch</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">skeleton</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">floating_limb_stitch_point</span><span class="p">,</span><span class="n">main_limb_stitch_point</span><span class="p">])])</span>
            
<span class="c1">#             adjusted_floating_sk_branch = sk.add_and_smooth_segment_to_branch(skeleton,new_seg=np.array([floating_limb_stitch_point,main_limb_stitch_point]),</span>
<span class="c1">#                                                                              resize_mult=0.2,n_resized_cutoff=3)</span>

            <span class="n">winning_floating_correspondence</span><span class="p">[</span><span class="n">match_float_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjusted_floating_sk_branch</span>

            <span class="c1">#k) Add the floating limb branches to the end of the limb correspondence</span>
            <span class="n">curr_limb_key_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="k">for</span> <span class="n">float_idx</span><span class="p">,</span><span class="n">flaot_data</span> <span class="ow">in</span> <span class="n">winning_floating_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">limb_correspondence_cp</span><span class="p">[</span><span class="n">winning_float_match_main_limb</span><span class="p">][</span><span class="n">curr_limb_key_len</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">float_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">flaot_data</span>
        



        <span class="c1">#l) Marks the floating piece as processed</span>
        <span class="n">floating_limbs_to_process</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">floating_limbs_to_process</span><span class="p">,[</span><span class="n">winning_float</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">limb_correspondence_cp</span></div>



<div class="viewcode-block" id="calculate_limb_concept_networks"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.calculate_limb_concept_networks">[docs]</a><span class="k">def</span> <span class="nf">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">,</span>
                                    <span class="n">network_starting_info</span><span class="p">,</span>
                                   <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Can take a limb correspondence and the starting vertices and endpoints</span>
<span class="sd">    and create a list of concept networks organized by </span>
<span class="sd">    [soma_idx] --&gt; list of concept networks </span>
<span class="sd">                    (because could possibly have mulitple starting points on the same soma)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">limb_correspondence_individual</span> <span class="o">=</span> <span class="n">limb_correspondence</span>
    <span class="n">divided_skeletons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="o">.</span><span class="n">keys</span><span class="p">()))])</span>



    <span class="c1"># -------------- Part 18: Getting Concept Networks  [soma_idx] --&gt; list of concept networks -------#</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concept Network Pseudocode:</span>

<span class="sd">    Step 0: Compile the Limb correspondence into final form</span>

<span class="sd">    Make sure these have the same list</span>
<span class="sd">    limb_to_soma_touching_vertices_list,limb_to_endpoints_must_keep_list</span>

<span class="sd">    For every dictionary in zip(limb_to_soma_touching_vertices_list,</span>
<span class="sd">                            limb_to_endpoints_must_keep_list):</span>

<span class="sd">        #make sure the dicts have same keys</span>
<span class="sd">        For every key (represents the soma) in the dictionary:</span>

<span class="sd">            #make sure the lists have the same sizes</span>
<span class="sd">            For every item in the list (which would be a list of endpoints or list of groups of vertexes):</span>
<span class="sd">                #At this point have the soma, the endpoint and the touching vertices</span>

<span class="sd">                1) find the branch with the endoint that must keep</span>
<span class="sd">                    --&gt; if multiple endpoints then error</span>
<span class="sd">                2) Call the branches_to_concept_network with the</span>
<span class="sd">                   a. divided skeletons</span>
<span class="sd">                   b. closest endpoint</span>
<span class="sd">                   c. endpoints of branch (from the branch found)</span>
<span class="sd">                   d. touching soma vertices</span>

<span class="sd">                3) Run the checks on the concept network</span>

<span class="sd">    &quot;&quot;&quot;</span>

    

    <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">soma_idx</span> <span class="ow">in</span> <span class="n">network_starting_info</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        
        <span class="k">if</span> <span class="n">soma_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_to_soma_concept_networks</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">limb_to_soma_concept_networks</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">soma_group_idx</span><span class="p">,</span><span class="n">st_dict</span> <span class="ow">in</span> <span class="n">network_starting_info</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">t_verts</span> <span class="o">=</span> <span class="n">st_dict</span><span class="p">[</span><span class="s2">&quot;touching_verts&quot;</span><span class="p">]</span>
            <span class="n">endpt</span> <span class="o">=</span> <span class="n">st_dict</span><span class="p">[</span><span class="s2">&quot;endpoint&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---------Working on soma_idx = </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">, soma_group_idx </span><span class="si">{</span><span class="n">soma_group_idx</span><span class="si">}</span><span class="s2">, endpt = </span><span class="si">{</span><span class="n">endpt</span><span class="si">}</span><span class="s2">---------&quot;</span><span class="p">)</span>



            <span class="c1">#1) find the branch with the endoint that must keep</span>
            <span class="c1"># ---------------- 11/17 Addition: If the endpoint does not match a skeleton point anymore then just get the closest endpoint of mesh that has touching vertices</span>

            <span class="n">start_branch</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="o">=</span><span class="n">divided_skeletons</span><span class="p">,</span>
                                                            <span class="n">current_coordinate</span><span class="o">=</span><span class="n">endpt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>



            <span class="c1">#print(f&quot;Starting_branch = {start_branch}&quot;)</span>
            <span class="c1">#print(f&quot;Start endpt = {endpt}&quot;)</span>
            <span class="n">start_branch_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">divided_skeletons</span><span class="p">[</span><span class="n">start_branch</span><span class="p">])</span>
            <span class="c1">#print(f&quot;Starting_branch endpoints = {start_branch_endpoints}&quot;)</span>

            <span class="c1">#2) Call the branches_to_concept_network with the</span>
            <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_to_concept_network</span><span class="p">(</span><span class="n">curr_branch_skeletons</span><span class="o">=</span><span class="n">divided_skeletons</span><span class="p">,</span>
                                                                  <span class="n">starting_coordinate</span><span class="o">=</span><span class="n">endpt</span><span class="p">,</span>
                                                                  <span class="n">starting_edge</span><span class="o">=</span><span class="n">start_branch_endpoints</span><span class="p">,</span>
                                                                  <span class="n">touching_soma_vertices</span><span class="o">=</span><span class="n">t_verts</span><span class="p">,</span>
                                                                       <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">soma_group_idx</span><span class="p">,</span>
                                                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done generating concept network </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">run_concept_network_checks</span><span class="p">:</span>
                <span class="c1">#3) Run the checks on the concept network</span>
                <span class="c1">#3.1: check to make sure the starting coordinate was recovered</span>

                <span class="n">recovered_touching_piece</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">starting_coordinate</span><span class="o">=</span><span class="n">endpt</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;recovered_touching_piece = </span><span class="si">{</span><span class="n">recovered_touching_piece</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">recovered_touching_piece</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">start_branch</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For limb and soma </span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2"> the recovered_touching and original touching do not match</span><span class="se">\n</span><span class="s2">&quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;recovered_touching_piece = </span><span class="si">{</span><span class="n">recovered_touching_piece</span><span class="si">}</span><span class="s2">, original_touching_pieces = </span><span class="si">{</span><span class="n">start_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                <span class="c1">#3.2: Check number of nodes match the number of divided skeletons</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">divided_skeletons</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The number of nodes in the concept graph and number of branches passed to it did not match</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;len(curr_limb_concept_network.nodes())=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2">, len(curr_limb_divided_skeletons)= </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">divided_skeletons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#3.3: Check that concept network is a connected component</span>
                <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was more than 1 connected components in the concept network&quot;</span><span class="p">)</span>


                <span class="c1">#3.4 Make sure the oriiginal divided skeleton endpoints match the concept map endpoints</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">un_resized_b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">divided_skeletons</span><span class="p">):</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Pseudocode: </span>
<span class="sd">                    1) get the endpoints of the current branch</span>
<span class="sd">                    2) get the endpoints in the concept map</span>
<span class="sd">                    3) compare</span>
<span class="sd">                    - if not equalt then break</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="c1">#1) get the endpoints of the current branch</span>
                    <span class="n">b_endpoints</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Branch</span><span class="p">(</span><span class="n">un_resized_b</span><span class="p">)</span><span class="o">.</span><span class="n">endpoints</span>
                    <span class="c1">#2) get the endpoints in the concept map</span>
                    <span class="n">graph_endpoints</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">,</span><span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;endpoints&quot;</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1">#print(f&quot;original_branch_endpoints = {b_endpoints}, concept graph node endpoints = {graph_endpoints}&quot;)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">xu</span><span class="o">.</span><span class="n">compare_endpoints</span><span class="p">(</span><span class="n">b_endpoints</span><span class="p">,</span><span class="n">graph_endpoints</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> in concept graph endpoints do not match the endpoints of the original branch</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="sa">f</span><span class="s2">&quot;original_branch_endpoints = </span><span class="si">{</span><span class="n">b_endpoints</span><span class="si">}</span><span class="s2">, concept graph node endpoints = </span><span class="si">{</span><span class="n">graph_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">limb_to_soma_concept_networks</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_to_soma_concept_networks</span>                    </div>



<div class="viewcode-block" id="filter_limb_correspondence_for_end_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.filter_limb_correspondence_for_end_nodes">[docs]</a><span class="k">def</span> <span class="nf">filter_limb_correspondence_for_end_nodes</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">,</span>
                                             <span class="n">mesh</span><span class="p">,</span>
                                             <span class="n">starting_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                             <span class="n">filter_end_node_length</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span>
                                             <span class="n">error_on_no_starting_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                             <span class="n">plot_new_correspondence</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                             <span class="n">error_on_starting_coordinates_not_endnodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                             
                                             
                                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get all of the starting coordinates</span>
<span class="sd">    2) Assemble the entire skeleton and run the skeleton cleaning process</span>
<span class="sd">    3) Decompose skeleton into branches and find out mappin gof old branches to new ones</span>
<span class="sd">    4) Assemble the new width and mesh face idx for all new branches</span>
<span class="sd">    - width: do weighted average by skeletal length</span>
<span class="sd">    - face_idx: concatenate</span>
<span class="sd">    5) Make face_lookup and Run waterfilling algorithm to fill in rest</span>
<span class="sd">    6) Get the divided meshes and face idx from waterfilling</span>
<span class="sd">    7) Store everything back inside a correspondence dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">limb_correspondence_individual</span><span class="o">=</span><span class="n">limb_correspondence</span>
    <span class="n">limb_mesh_mparty</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">network_starting_info_revised_cleaned</span> <span class="o">=</span> <span class="n">starting_info</span>


    <span class="n">lc_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence_individual</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">lc_branch_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence_individual</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">lc_branch_face_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence_individual</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">lc_width_from_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;width_from_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence_individual</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="c1">#1) Get all of the starting coordinates</span>
<span class="c1">#     all_starting_coords = []</span>
<span class="c1">#     if not starting_info is None:</span>
<span class="c1">#         for soma_idx,soma_v in network_starting_info_revised_cleaned.items():</span>
<span class="c1">#             for soma_group_idx,soma_group_v in soma_v.items():</span>
<span class="c1">#                 all_starting_coords.append(soma_group_v[&quot;endpoint&quot;])</span>
                
    <span class="k">if</span> <span class="ow">not</span> <span class="n">starting_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_starting_coords</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_soma_connnecting_endpionts_from_starting_info</span><span class="p">(</span><span class="n">network_starting_info_revised_cleaned</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_starting_coords</span> <span class="o">=</span> <span class="p">[]</span>
                
    
    <span class="k">if</span> <span class="n">error_on_no_starting_coordinates</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_starting_coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No starting coordinates found: network_starting_info_revised_cleaned = </span><span class="si">{</span><span class="n">network_starting_info_revised_cleaned</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="c1"># ---------- 1/5/2021: Will check all starting points as end nodes and if not all degree 1 then error --------#</span>
    

    <span class="c1">#2) Assemble the entire skeleton and run the skeleton cleaning process</span>
    <span class="n">curr_limb_sk_cleaned</span><span class="p">,</span><span class="n">rem_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">clean_skeleton</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">lc_skeletons</span><span class="p">),</span>
                         <span class="n">distance_func</span><span class="o">=</span><span class="n">sk</span><span class="o">.</span><span class="n">skeletal_distance</span><span class="p">,</span>
                         <span class="n">min_distance_to_junction</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="p">,</span>
                        <span class="n">endpoints_must_keep</span><span class="o">=</span><span class="n">all_starting_coords</span><span class="p">,</span>
                         <span class="n">return_skeleton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_removed_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">error_if_endpoints_must_keep_not_endnode</span><span class="o">=</span><span class="n">error_on_starting_coordinates_not_endnodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">rem_branches</span><span class="p">)</span><span class="si">}</span><span class="s2"> skeletal branches&quot;</span><span class="p">)</span>

    <span class="c1">#3) Decompose skeleton into branches and find out mappin gof old branches to new ones</span>
    <span class="n">cleaned_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">curr_limb_sk_cleaned</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cleaned_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There were no branches after cleaning limb correspondence&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">limb_correspondence</span>
    
    <span class="n">original_br_mapping</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">map_between_branches_lists</span><span class="p">(</span><span class="n">lc_skeletons</span><span class="p">,</span><span class="n">cleaned_branches</span><span class="p">)</span>

    <span class="c1"># 4) Assemble the new width and mesh face idx for all new branches</span>
    <span class="c1"># - width: do weighted average by skeletal length</span>
    <span class="c1"># - face_idx: concatenate</span>

    <span class="n">new_width_from_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_branch_face_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">cl_b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cleaned_branches</span><span class="p">):</span>
        <span class="n">or_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">original_br_mapping</span><span class="o">==</span><span class="n">j</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#doing the width</span>
        <span class="n">total_skeletal_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">or_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print(f&quot;\n\nAverageing widths for {j}:&quot;)</span>
            <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="n">or_idx</span><span class="p">:</span>
                <span class="n">curr_sk_len</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">lc_skeletons</span><span class="p">[</span><span class="n">oi</span><span class="p">])</span>
                <span class="c1">#print(f&quot;curr_sk_len = {curr_sk_len}, curr_width = {lc_width_from_skeletons[oi]}&quot;)</span>
                <span class="n">weighted_width</span> <span class="o">+=</span> <span class="n">curr_sk_len</span><span class="o">*</span><span class="n">lc_width_from_skeletons</span><span class="p">[</span><span class="n">oi</span><span class="p">]</span>
                <span class="n">total_skeletal_length</span><span class="o">+=</span><span class="n">curr_sk_len</span>
            <span class="n">final_width</span> <span class="o">=</span> <span class="n">weighted_width</span><span class="o">/</span><span class="n">total_skeletal_length</span>
            <span class="c1">#print(f&quot;Final width = {final_width}&quot;)</span>
            <span class="n">new_width_from_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_width</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_width_from_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc_width_from_skeletons</span><span class="p">[</span><span class="n">or_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>


        <span class="c1">#doing the face_idx</span>
        <span class="n">new_branch_face_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">lc_branch_face_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">or_idx</span><span class="p">]))</span>


    <span class="c1">#5) Make face_lookup and Run waterfilling algorithm to fill in rest</span>

    <span class="n">face_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">faces</span><span class="p">))}</span>
    <span class="n">face_lookup_marked</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">invert_mapping</span><span class="p">(</span><span class="n">new_branch_face_idx</span><span class="p">)</span>
    <span class="n">ky</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">face_lookup</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For marked faces: </span><span class="si">{</span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ky</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ky</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">face_lookup</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">face_lookup_marked</span><span class="p">)</span>





    <span class="n">original_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cleaned_branches</span><span class="p">))</span>

    <span class="n">face_coloring_copy</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">resolve_empty_conflicting_face_labels</span><span class="p">(</span><span class="n">curr_limb_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="p">,</span>
                                                                    <span class="n">face_lookup</span><span class="o">=</span><span class="n">face_lookup</span><span class="p">,</span>
                                                                    <span class="n">no_missing_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">original_labels</span><span class="p">))</span>



    <span class="c1">#6) Get the divided meshes and face idx from waterfilling</span>
    <span class="c1"># -- splitting the mesh pieces into individual pieces</span>
    <span class="n">divided_submeshes</span><span class="p">,</span><span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">limb_mesh_mparty</span><span class="p">,</span><span class="n">face_coloring_copy</span><span class="p">,</span>
                                                                            <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


    <span class="c1">#7) Store everything back inside a correspondence dictionary</span>
    <span class="n">limb_correspondence_individual_filtered</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cleaned_branches</span><span class="p">):</span>
        <span class="n">local_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">branch_skeleton</span><span class="o">=</span><span class="n">curr_sk</span><span class="p">,</span>
                          <span class="n">width_from_skeleton</span><span class="o">=</span><span class="n">new_width_from_skeletons</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                         <span class="n">branch_mesh</span><span class="o">=</span><span class="n">divided_submeshes</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                         <span class="n">branch_face_idx</span><span class="o">=</span><span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">limb_correspondence_individual_filtered</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_dict</span>


    <span class="k">if</span> <span class="n">plot_new_correspondence</span><span class="p">:</span>
        <span class="n">plot_limb_correspondence</span><span class="p">(</span><span class="n">limb_correspondence_individual_filtered</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_correspondence_individual_filtered</span></div>




<div class="viewcode-block" id="preprocess_limb"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.preprocess_limb">[docs]</a><span class="k">def</span> <span class="nf">preprocess_limb</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                   <span class="n">soma_touching_vertices_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#how the distance is calculated for mesh correspondence</span>
                    <span class="n">meshparty_segment_size</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                   <span class="n">meshparty_n_surface_downsampling</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">combine_close_skeleton_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span>
                    <span class="n">filter_end_node_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">use_meshafterparty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">perform_cleaning_checks</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    
                    <span class="c1">#for controlling the pieces processed by MAP</span>
                    <span class="n">width_threshold_MAP</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">size_threshold_MAP</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    
                    <span class="c1">#parameters for MP skeletonization,</span>
                    
                    <span class="c1">#Parameters for setting how the MAP skeletonization takes place</span>
                    <span class="n">use_surface_after_CGAL</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">surface_reconstruction_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#500,</span>
                    
                    <span class="c1">#parametrers for stitching the MAP and MP pieces together</span>
                    <span class="n">move_MAP_stitch_to_end_or_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">distance_to_move_point_threshold</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                    
                    <span class="c1">#concept_network parameters</span>
                    <span class="n">run_concept_network_checks</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">return_concept_network</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">return_concept_network_starting_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    
                    <span class="c1">#printing controls</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">print_fusion_steps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    
                    <span class="n">check_correspondence_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">filter_end_nodes_from_correspondence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">error_on_no_starting_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    
                    <span class="n">prevent_MP_starter_branch_stitches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#will control if a MP soma extending branch is able to be stitched to</span>
                    <span class="n">combine_close_skeleton_nodes_threshold_meshparty</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">filter_end_node_length_meshparty</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">invalidation_d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">smooth_neighborhood</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                    
                    <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    
                    <span class="n">remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    
                   <span class="p">):</span>
    <span class="k">if</span> <span class="n">filter_end_node_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="n">filter_end_node_length_global</span>
    <span class="k">if</span> <span class="n">width_threshold_MAP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_threshold_MAP</span> <span class="o">=</span> <span class="n">width_threshold_MAP_global</span>
    <span class="k">if</span> <span class="n">size_threshold_MAP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size_threshold_MAP</span> <span class="o">=</span> <span class="n">size_threshold_MAP_global</span>
    <span class="k">if</span> <span class="n">invalidation_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">invalidation_d</span> <span class="o">=</span> <span class="n">invalidation_d_global</span>
    <span class="k">if</span> <span class="n">axon_width_preprocess_limb_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="n">axon_width_preprocess_limb_max_global</span>
    <span class="k">if</span> <span class="n">remove_mesh_interior_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="n">remove_mesh_interior_face_threshold_global</span>
    <span class="k">if</span> <span class="n">surface_reconstruction_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">surface_reconstruction_size</span> <span class="o">=</span> <span class="n">surface_reconstruction_size_global</span>
    <span class="k">if</span> <span class="n">max_stitch_distance_CGAL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="n">max_stitch_distance_CGAL_global</span>
        
    <span class="k">if</span> <span class="n">use_adaptive_invalidation_d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="n">use_adaptive_invalidation_d_global</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalidation_d = </span><span class="si">{</span><span class="n">invalidation_d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;use_adaptive_invalidation_d= </span><span class="si">{</span><span class="n">use_adaptive_invalidation_d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_width_preprocess_limb_max = </span><span class="si">{</span><span class="n">axon_width_preprocess_limb_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">combine_close_skeleton_nodes_threshold_meshparty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">combine_close_skeleton_nodes_threshold_meshparty</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes_threshold</span>
    <span class="k">if</span> <span class="n">filter_end_node_length_meshparty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_end_node_length_meshparty</span> <span class="o">=</span> <span class="n">filter_end_node_length</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_end_node_length= </span><span class="si">{</span><span class="n">filter_end_node_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_end_node_length_meshparty = </span><span class="si">{</span><span class="n">filter_end_node_length_meshparty</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalidation_d = </span><span class="si">{</span><span class="n">invalidation_d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;soma_touching_vertices_dict = {soma_touching_vertices_dict}&quot;)</span>
    <span class="c1">#print(f&quot;error_on_no_starting_coordinates = {error_on_no_starting_coordinates}&quot;)</span>
    <span class="n">curr_limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">limb_mesh_mparty</span> <span class="o">=</span> <span class="n">mesh</span>


    <span class="c1">#will store a list of all the endpoints tha tmust be kept:</span>
    <span class="n">limb_to_endpoints_must_keep_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">limb_to_soma_touching_vertices_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># --------------- Part 1 and 2: Getting Border Vertices and Setting the Root------------- #</span>
    <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#will eventually get the current root from soma_to_piece_touching_vertices[i]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">soma_touching_vertices_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root_curr</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">soma_touching_vertices_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root_curr</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;root_curr = </span><span class="si">{</span><span class="n">root_curr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for preparing soma vertices and root: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># --------------- Part 3: Meshparty skeletonization and Decomposition ------------- #</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">sk_meshparty_obj</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeletonize_mesh_largest_component</span><span class="p">(</span><span class="n">limb_mesh_mparty</span><span class="p">,</span>
                                                                <span class="n">root</span><span class="o">=</span><span class="n">root_curr</span><span class="p">,</span>
                                                                   <span class="n">invalidation_d</span><span class="o">=</span><span class="n">invalidation_d</span><span class="p">,</span>
                                                                   <span class="n">smooth_neighborhood</span><span class="o">=</span><span class="n">smooth_neighborhood</span><span class="p">,</span>
                                                                  <span class="n">filter_mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;meshparty_segment_size = </span><span class="si">{</span><span class="n">meshparty_segment_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for 1st pass MP skeletonization: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        
            
            
        <span class="p">(</span><span class="n">segment_branches</span><span class="p">,</span> <span class="c1">#skeleton branches</span>
        <span class="n">divided_submeshes</span><span class="p">,</span> <span class="n">divided_submeshes_idx</span><span class="p">,</span> <span class="c1">#mesh correspondence (mesh and indices)</span>
        <span class="n">segment_widths_median</span><span class="p">)</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">skeleton_obj_to_branches</span><span class="p">(</span><span class="n">sk_meshparty_obj</span><span class="p">,</span>
                                                              <span class="n">mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="p">,</span>
                                                              <span class="n">meshparty_segment_size</span><span class="o">=</span><span class="n">meshparty_segment_size</span><span class="p">,</span>
                        <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="n">combine_close_skeleton_nodes_threshold_meshparty</span><span class="p">,</span>
                                        <span class="n">filter_end_node_length</span><span class="o">=</span><span class="n">filter_end_node_length_meshparty</span><span class="p">)</span>
        
        <span class="n">debug_meshparty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">debug_meshparty</span><span class="p">:</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">,</span><span class="s2">&quot;segment_branches&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="p">,</span><span class="s2">&quot;divided_submeshes&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="p">,</span><span class="s2">&quot;divided_submeshes_idx&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">segment_widths_median</span><span class="p">,</span><span class="s2">&quot;segment_widths_median&quot;</span><span class="p">)</span>
        
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_adaptive_invalidation_d</span><span class="p">:</span>
            <span class="k">break</span>
            
        <span class="n">width_median</span> <span class="o">=</span> <span class="n">m_sk</span><span class="o">.</span><span class="n">width_median_weighted</span><span class="p">(</span><span class="n">segment_widths_median</span><span class="p">,</span><span class="n">segment_branches</span><span class="p">)</span>
        <span class="c1">#width_median = nu.weighted_average(segment_widths_median,[sk.calculate_skeleton_distance(k) for k in segment_branches])</span>
        
        
        <span class="k">if</span> <span class="kc">True</span><span class="p">:</span><span class="c1">#verbose:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_median= </span><span class="si">{</span><span class="n">width_median</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_widths_median = </span><span class="si">{</span><span class="n">segment_widths_median</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">width_median</span> <span class="o">&lt;=</span> <span class="n">axon_width_preprocess_limb_max</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using the axon parameters&quot;</span><span class="p">)</span>
            <span class="n">combine_close_skeleton_nodes_threshold_meshparty</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes_threshold_meshparty_axon_global</span>
            <span class="n">filter_end_node_length_meshparty</span> <span class="o">=</span> <span class="n">filter_end_node_length_meshparty_axon_global</span>
            <span class="n">filter_end_node_length</span><span class="o">=</span> <span class="n">filter_end_node_length_axon_global</span>
            <span class="n">invalidation_d</span><span class="o">=</span> <span class="n">invalidation_d_axon_global</span>
            <span class="n">smooth_neighborhood</span> <span class="o">=</span> <span class="n">smooth_neighborhood_axon_global</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
        




    <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decomposing first pass: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


    <span class="k">if</span> <span class="n">use_meshafterparty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempting to use MeshAfterParty Skeletonization and Mesh Correspondence&quot;</span><span class="p">)</span>
        <span class="c1"># --------------- Part 4: Find Individual Branches that could be MAP processed because of width ------------- #</span>
        <span class="c1">#gettin the branches that should be passed through MAP skeletonization</span>
        <span class="n">pieces_above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">segment_widths_median</span><span class="o">&gt;</span><span class="n">width_threshold_MAP</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#getting the correspondnece info for those MAP qualifying</span>
        <span class="n">width_large</span> <span class="o">=</span> <span class="n">segment_widths_median</span><span class="p">[</span><span class="n">pieces_above_threshold</span><span class="p">]</span>
        <span class="n">sk_large</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_branches</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pieces_above_threshold</span><span class="p">]</span>
        <span class="n">mesh_large_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pieces_above_threshold</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Only Using MeshParty Skeletonization and Mesh Correspondence&quot;</span><span class="p">)</span>
        <span class="n">mesh_large_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">width_large</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sk_large</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Another print&quot;</span><span class="p">)</span>
    <span class="n">mesh_pieces_for_MAP</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mesh_pieces_for_MAP_face_idx</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_large_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#will only continue processing if found MAP candidates</span>

        <span class="c1"># --------------- Part 5: Find mesh connectivity and group MAP branch candidates into MAP sublimbs ------------- #</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found len(mesh_large_idx) MAP candidates: </span><span class="si">{</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">mesh_large_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#finds the connectivity edges of all the MAP candidates</span>
        <span class="n">mesh_large_connectivity</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_connectivity</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">mesh_large_idx</span><span class="p">,</span>
                                                            <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                                <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="p">,</span>
                                <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; 1/3/21s</span>
<span class="sd">        Big Conclusion from debugging: the large mesh pieces themselves (before combining into map pieces)</span>
<span class="sd">        themselves aren&#39;t totally connected by edges (can be split)</span>

<span class="sd">        - so even if large pieces do have a shared edge and you combine them together,</span>
<span class="sd">        they can still be split by the edges into multiple pieces because the original pieces</span>
<span class="sd">        could be split into multiple pieces</span>

<span class="sd">        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_large_connectivity: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        --------------- Grouping MAP candidates ----------------</span>
<span class="sd">        Purpose: Will see what mesh pieces should be grouped together</span>
<span class="sd">        to pass through CGAL skeletonization</span>


<span class="sd">        Pseudocode: </span>
<span class="sd">        1) build a networkx graph with all nodes for mesh_large_idx indexes</span>
<span class="sd">        2) Add the edges</span>
<span class="sd">        3) Find the connected components</span>
<span class="sd">        4) Find sizes of connected components</span>
<span class="sd">        5) For all those connected components that are of a large enough size, </span>
<span class="sd">        add the mesh branches and skeletons to the final list</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_large_idx</span><span class="p">)))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">mesh_large_connectivity</span><span class="p">)</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

        <span class="n">filtered_pieces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">sk_large_size_filt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mesh_large_idx_size_filt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">width_large_size_filt</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">:</span>
            <span class="n">total_cc_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_large_idx</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">total_cc_size</span><span class="o">&gt;</span><span class="n">size_threshold_MAP</span><span class="p">:</span>
                <span class="c1">#print(f&quot;cc ({cc}) passed the size threshold because size was {total_cc_size}&quot;)</span>
                <span class="n">filtered_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pieces_above_threshold</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">cc</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding MAP candidates connected components: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1">#filtered_pieces: will have the indexes of all the branch candidates that should  be </span>
        <span class="c1">#grouped together and passed through MAP skeletonization</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_pieces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># --------------- Part 6: If Found MAP sublimbs, Get the meshes and mesh_idxs of the sublimbs ------------- #</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(filtered_pieces) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1">#all the pieces that will require MAP mesh correspondence and skeletonization</span>
            <span class="c1">#(already organized into their components)</span>
            <span class="n">mesh_pieces_for_MAP</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">])],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">filtered_pieces</span><span class="p">]</span>
            <span class="n">mesh_pieces_for_MAP_face_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">filtered_pieces</span><span class="p">]</span>



<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Old Way: Finding connectivity of pieces through</span>
<span class="sd">            mesh_idx_MP = [divided_submeshes_idx[k] for k in pieces_idx_MP]</span>

<span class="sd">            mesh_large_connectivity_MP = tu.mesh_list_connectivity(meshes = mesh_idx_MP,</span>
<span class="sd">                                    main_mesh = limb_mesh_mparty,</span>
<span class="sd">                                    print_flag = False)</span>

<span class="sd">            New Way: going to use skeleton connectivity to determine</span>
<span class="sd">            connectivity of pieces</span>

<span class="sd">            Pseudocode: </span>
<span class="sd">            1)</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># --------------- Part 7: If Found MAP sublimbs, Get the meshes and mesh_idxs of the sublimbs ------------- #</span>
            <span class="c1"># ********* if there are no pieces leftover then will automatically make all the lists below just empty (don&#39;t need to if.. else.. the case)****</span>
            <span class="n">pieces_idx_MP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">filtered_pieces</span><span class="p">))</span>

            <span class="n">skeleton_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_branches</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pieces_idx_MP</span><span class="p">]</span>
            <span class="n">skeleton_connectivity_MP</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeleton_list_connectivity</span><span class="p">(</span>
                                            <span class="n">skeletons</span><span class="o">=</span><span class="n">skeleton_MP</span>
                                            <span class="p">)</span>
            <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_connectivity_MP : </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">skeleton_MP</span><span class="p">)))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">skeleton_connectivity_MP</span><span class="p">)</span>
            <span class="n">sublimbs_MP</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
            <span class="n">sublimbs_MP_orig_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">pieces_idx_MP</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimbs_MP</span><span class="p">]</span>


            <span class="c1">#concatenate into sublimbs the skeletons and meshes</span>
            <span class="n">sublimb_mesh_idx_branches_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimbs_MP_orig_idx</span><span class="p">]</span>
            <span class="n">sublimb_mesh_branches_MP</span> <span class="o">=</span> <span class="p">[[</span><span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">ki</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                        <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimb_mesh_idx_branches_MP</span><span class="p">]</span>
            <span class="n">sublimb_meshes_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">k</span><span class="p">)],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimb_mesh_idx_branches_MP</span><span class="p">]</span>
            <span class="n">sublimb_meshes_MP_face_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimb_mesh_idx_branches_MP</span><span class="p">]</span>
            <span class="n">sublimb_skeleton_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_branches</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimbs_MP_orig_idx</span><span class="p">]</span>
            <span class="n">widths_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_widths_median</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sublimbs_MP_orig_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grouping MP Sublimbs by Graph: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


    <span class="c1"># else: #if no pieces were determine to need MAP processing</span>
    <span class="c1">#     print(&quot;No MAP processing needed: just returning the Meshparty skeletonization and mesh correspondence&quot;)</span>
    <span class="c1">#     raise Exception(&quot;Returning MP correspondence&quot;)</span>


    <span class="c1"># nviz.plot_objects(main_mesh=tu.combine_meshes([limb_mesh_mparty,current_neuron[&quot;S0&quot;].mesh]),</span>
    <span class="c1">#                   main_mesh_color=&quot;green&quot;,</span>
    <span class="c1">#     skeletons=sk_large_size_filt,</span>
    <span class="c1">#      meshes=[limb_mesh_mparty.submesh([k],append=True) for k in mesh_large_idx_size_filt],</span>
    <span class="c1">#       meshes_colors=&quot;red&quot;)</span>








    <span class="c1"># --------------- Part 8: If No MAP sublimbs found, set the MP sublimb lists to just the whole MP branch decomposition ------------- #</span>

    <span class="c1">#if no sublimbs need to be decomposed with MAP then just reassign all of the previous MP processing to the sublimb_MPs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_pieces_for_MAP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sublimb_meshes_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_mesh_mparty</span><span class="p">]</span> <span class="c1">#trimesh pieces that have already been passed through MP skeletonization (may not need)</span>
        <span class="c1"># -- the decomposition information ---</span>
        <span class="n">sublimb_mesh_branches_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">divided_submeshes</span><span class="p">]</span> <span class="c1">#the mesh branches for all the disconnected sublimbs</span>
        <span class="n">sublimb_mesh_idx_branches_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">divided_submeshes_idx</span><span class="p">]</span> <span class="c1">#The mesh branches idx that have already passed through MP skeletonization</span>
        <span class="n">sublimb_skeleton_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_branches</span><span class="p">]</span><span class="c1">#the skeleton bnraches for all the sublimbs</span>
        <span class="n">widths_MP</span> <span class="o">=</span> <span class="p">[</span><span class="n">segment_widths_median</span><span class="p">]</span> <span class="c1">#the mesh branches widths for all the disconnected groups</span>

        <span class="n">MAP_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">MAP_flag</span> <span class="o">=</span> <span class="kc">True</span>



    <span class="n">mesh_pieces_for_MAP</span> <span class="c1">#trimesh pieces that should go through CGAL skeletonization</span>
    <span class="n">sublimb_meshes_MP</span> <span class="c1">#trimesh pieces that have already been passed through MP skeletonization (may not need)</span>

    <span class="c1"># -- the decomposition information ---</span>
    <span class="n">sublimb_mesh_branches_MP</span> <span class="c1">#the mesh branches for all the disconnected sublimbs</span>
    <span class="n">sublimb_mesh_idx_branches_MP</span> <span class="c1">#The mesh branches idx that have already passed through MP skeletonization</span>
    <span class="n">sublimb_skeleton_branches</span> <span class="c1">#the skeleton bnraches for all the sublimbs</span>
    <span class="n">widths_MP</span> <span class="c1">#the mesh branches widths for all the disconnected groups</span>

    <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Divinding into MP and MAP pieces: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>



    <span class="c1"># ------------------- At this point have the correct division between MAP and MP ------------------------</span>

    <span class="c1"># -------------- Part 9: Doing the MAP decomposition ------------------ #</span>
    <span class="n">global_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>



    <span class="n">limb_correspondence_MAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">sublimb_idx</span><span class="p">,(</span><span class="n">mesh</span><span class="p">,</span><span class="n">mesh_idx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mesh_pieces_for_MAP</span><span class="p">,</span><span class="n">mesh_pieces_for_MAP_face_idx</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Working on MAP piece </span><span class="si">{</span><span class="n">sublimb_idx</span><span class="si">}</span><span class="s2">---&quot;</span><span class="p">)</span>
        <span class="c1">#print(f&quot;soma_touching_vertices_dict = {soma_touching_vertices_dict}&quot;)</span>
        <span class="n">mesh_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="n">filter_soma_touching_vertices_dict_by_mesh</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
        <span class="n">curr_piece_to_soma_touching_vertices</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MAP Filtering Soma Pieces: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># ---- 0) Generating the Clean skeletons  -------------------------------------------#</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_total_border_vertices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_total_border_vertices</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="n">cleaned_branch</span><span class="p">,</span><span class="n">curr_limb_endpoints_must_keep</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize_and_clean_connected_branch_CGAL</span><span class="p">(</span>
            <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">curr_soma_to_piece_touching_vertices</span><span class="p">,</span>
            <span class="n">total_border_vertices</span><span class="o">=</span><span class="n">curr_total_border_vertices</span><span class="p">,</span>
            <span class="n">filter_end_node_length</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="p">,</span>
            <span class="n">perform_cleaning_checks</span><span class="o">=</span><span class="n">perform_cleaning_checks</span><span class="p">,</span>
            <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes</span><span class="p">,</span>
            <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="n">combine_close_skeleton_nodes_threshold</span><span class="p">,</span>
        <span class="n">use_surface_after_CGAL</span><span class="o">=</span><span class="n">use_surface_after_CGAL</span><span class="p">,</span>
        <span class="n">surface_reconstruction_size</span><span class="o">=</span><span class="n">surface_reconstruction_size</span><span class="p">,</span>
        <span class="n">remove_mesh_interior_face_threshold</span><span class="o">=</span><span class="n">remove_mesh_interior_face_threshold</span><span class="p">,</span>
        <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="n">error_on_bad_cgal_return</span><span class="p">,</span>
        <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="n">max_stitch_distance_CGAL</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_limb_endpoints_must_keep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_to_endpoints_must_keep_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb_endpoints_must_keep</span><span class="p">)</span>
            <span class="n">limb_to_soma_touching_vertices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_soma_to_piece_touching_vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside MAP decomposition and curr_limb_endpoints_must_keep was None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cleaned_branch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found a zero length skeleton for limb </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2"> of trmesh </span><span class="si">{</span><span class="n">branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletonize_and_clean_connected_branch_CGAL: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># ---- 1) Generating Initial Mesh Correspondence -------------------------------------------#</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb correspondence for #</span><span class="si">{</span><span class="n">sublimb_idx</span><span class="si">}</span><span class="s2"> MAP piece&quot;</span><span class="p">)</span>
        <span class="n">local_correspondence</span> <span class="o">=</span> <span class="n">mesh_correspondence_first_pass</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                                                             <span class="n">skeleton</span><span class="o">=</span><span class="n">cleaned_branch</span><span class="p">,</span>
                                                             <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                                                             <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                                                             <span class="n">remove_inside_pieces_threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>


        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for decomposition = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_correspondence_first_pass: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


        <span class="c1">#------------- 2) Doing Some checks on the initial corespondence -------- #</span>


        <span class="k">if</span> <span class="n">perform_cleaning_checks</span><span class="p">:</span>
            <span class="n">check_skeletonization_and_decomp</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">cleaned_branch</span><span class="p">,</span>
                                            <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondence</span><span class="p">)</span>

        <span class="c1"># -------3) Finishing off the face correspondence so get 1-to-1 correspondence of mesh face to skeletal piece</span>
        <span class="n">local_correspondence_revised</span> <span class="o">=</span> <span class="n">correspondence_1_to_1</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                                        <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondence</span><span class="p">,</span>
                                        <span class="n">curr_limb_endpoints_must_keep</span><span class="o">=</span><span class="n">curr_limb_endpoints_must_keep</span><span class="p">,</span>
                                        <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">curr_soma_to_piece_touching_vertices</span><span class="p">)</span>

        <span class="c1"># -------3b) Fixing the mesh indices to correspond to the larger mesh as a whole</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">local_correspondence_revised</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_idx</span><span class="p">[</span><span class="n">local_correspondence_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for MAP sublimb #</span><span class="si">{</span><span class="n">sublimb_idx</span><span class="si">}</span><span class="s2"> mesh processing = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mesh_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;correspondence_1_to_1: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_revised</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for MAP sublimb processing </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>





    <span class="c1"># ----------------- Part 10: Doing the MP Decomposition ---------------------- #</span>




    <span class="n">sublimb_meshes_MP</span> <span class="c1">#trimesh pieces that have already been passed through MP skeletonization (may not need)</span>
    <span class="c1"># -- the decomposition information ---</span>
    <span class="n">sublimb_mesh_branches_MP</span> <span class="c1">#the mesh branches for all the disconnected sublimbs</span>
    <span class="n">sublimb_mesh_idx_branches_MP</span> <span class="c1">#The mesh branches idx that have already passed through MP skeletonization</span>
    <span class="n">sublimb_skeleton_branches</span> <span class="c1">#the skeleton bnraches for all the sublimbs</span>
    <span class="n">widths_MP</span> <span class="c1">#the mesh branches widths for all the disconnected groups</span>

    <span class="n">limb_correspondence_MP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">sublimb_idx</span><span class="p">,</span><span class="n">mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---- Working on MP Decomposition #</span><span class="si">{</span><span class="n">sublimb_idx</span><span class="si">}</span><span class="s2"> ----&quot;</span><span class="p">)</span>
        <span class="n">mesh_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">MAP_flag</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using Quicker soma_to_piece_touching_vertices because no MAP and only one sublimb_mesh piece &quot;</span><span class="p">)</span>
            <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">soma_touching_vertices_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the current soma touching verts dict manually&quot;</span><span class="p">)</span>
                <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="n">filter_soma_touching_vertices_dict_by_mesh</span><span class="p">(</span>
                                                    <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
                                                    <span class="n">curr_piece_to_soma_touching_vertices</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span>
                                                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP filtering soma verts: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1">#creating all of the sublimb groups</span>
        <span class="n">segment_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sublimb_skeleton_branches</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">])</span>
        <span class="n">whole_sk_MP</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">)</span>
        <span class="n">branch</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="n">divided_submeshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sublimb_mesh_branches_MP</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">])</span>
        <span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">sublimb_mesh_idx_branches_MP</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">]</span>
        <span class="n">segment_widths_median</span> <span class="o">=</span> <span class="n">widths_MP</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">]</span>


        <span class="k">if</span> <span class="n">curr_soma_to_piece_touching_vertices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Do Not Need to Fix MP Decomposition </span><span class="si">{</span><span class="n">sublimb_idx</span><span class="si">}</span><span class="s2"> so just continuing&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># ------- 11/9 addition: Fixing error where creating soma touching branch on mesh that doesn&#39;t touch border ------------------- #</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fixing Possible Soma Extension Branch for Sublimb </span><span class="si">{</span><span class="n">sublimb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">no_soma_extension_add</span> <span class="o">=</span> <span class="kc">True</span> 

            <span class="n">endpts_total</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">curr_soma_to_piece_touching_vertices_total</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sm_idx</span><span class="p">,</span><span class="n">sm_bord_verts_list</span> <span class="ow">in</span> <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1">#will be used for later</span>
                <span class="n">endpts_total</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">curr_soma_to_piece_touching_vertices_total</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">sm_bord_verts</span> <span class="ow">in</span> <span class="n">sm_bord_verts_list</span><span class="p">:</span>
                    <span class="c1">#1) Get the mesh pieces that are touching the border</span>
                    <span class="n">matching_mesh_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">mesh_list</span><span class="o">=</span><span class="n">divided_submeshes</span><span class="p">,</span>
                                               <span class="n">nullifying_points</span><span class="o">=</span><span class="n">sm_bord_verts</span><span class="p">,</span>
                                                <span class="n">filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                               <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1">#2) concatenate all meshes and skeletons that are touching</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_mesh_idx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;None of branches were touching the border vertices when fixing MP pieces&quot;</span><span class="p">)</span>

                    <span class="n">touch_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="p">[</span><span class="n">matching_mesh_idx</span><span class="p">])</span>
                    <span class="n">touch_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">[</span><span class="n">matching_mesh_idx</span><span class="p">])</span>

                    <span class="n">local_curr_soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="p">{</span><span class="n">sm_idx</span><span class="p">:[</span><span class="n">sm_bord_verts</span><span class="p">]}</span>
                    <span class="n">new_sk</span><span class="p">,</span><span class="n">endpts</span><span class="p">,</span><span class="n">new_branch_info</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">create_soma_extending_branches</span><span class="p">(</span><span class="n">current_skeleton</span><span class="o">=</span><span class="n">touch_sk</span><span class="p">,</span>
                                          <span class="n">skeleton_mesh</span><span class="o">=</span><span class="n">touch_mesh</span><span class="p">,</span>
                                          <span class="n">soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">local_curr_soma_to_piece_touching_vertices</span><span class="p">,</span>
                                          <span class="n">return_endpoints_must_keep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">return_created_branch_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">check_connected_skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    
                    <span class="c1"># ---- 12/30 Addition Check if the endpoint found is an endnode or not and if not then manually add branch ---</span>
                    <span class="n">curr_endnode</span> <span class="o">=</span> <span class="n">endpts</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">match_sk_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">,</span>
                        <span class="n">current_coordinate</span><span class="o">=</span><span class="n">curr_endnode</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_sk_branches = </span><span class="si">{</span><span class="n">match_sk_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_sk_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">border_average_coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sm_bord_verts</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">new_branch_sk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">curr_endnode</span><span class="p">,</span><span class="n">border_average_coordinate</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                        <span class="n">br_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">new_branch</span> <span class="o">=</span> <span class="n">new_branch_sk</span><span class="p">,</span><span class="n">border_verts</span><span class="o">=</span><span class="n">sm_bord_verts</span><span class="p">)</span>
                        <span class="n">endpts_total</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">border_average_coordinate</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        
                        <span class="n">br_info</span> <span class="o">=</span> <span class="n">new_branch_info</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">endpts_total</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endpts</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># -------------------- End of 12/30 Addition ------------------</span>

                    <span class="c1">#3) Add the info to the new running lists</span>
                    
                    <span class="n">curr_soma_to_piece_touching_vertices_total</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sm_bord_verts</span><span class="p">)</span>


                    <span class="c1">#4) Skip if no new branch was added</span>
                    <span class="k">if</span> <span class="n">br_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The new branch info was none so skipping </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="c1">#4 If new branch was made then </span>
                    <span class="n">no_soma_extension_add</span><span class="o">=</span><span class="kc">False</span>

                    <span class="c1">#1) Get the newly added branch (and the original vertex which is the first row)</span>
                    <span class="n">br_new</span><span class="p">,</span><span class="n">sm_bord_verts</span> <span class="o">=</span> <span class="n">br_info</span><span class="p">[</span><span class="s2">&quot;new_branch&quot;</span><span class="p">],</span><span class="n">br_info</span><span class="p">[</span><span class="s2">&quot;border_verts&quot;</span><span class="p">]</span> <span class="c1">#this will hold the new branch and the border vertices corresponding to it</span>

                    <span class="n">curr_soma_to_piece_touching_vertices_MP</span> <span class="o">=</span> <span class="p">{</span><span class="n">sm_idx</span><span class="p">:[</span><span class="n">sm_bord_verts</span><span class="p">]}</span>
                    <span class="n">endpoints_must_keep_MP</span> <span class="o">=</span> <span class="p">{</span><span class="n">sm_idx</span><span class="p">:[</span><span class="n">br_new</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]}</span>


                    <span class="n">orig_vertex</span> <span class="o">=</span> <span class="n">br_new</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;orig_vertex = </span><span class="si">{</span><span class="n">orig_vertex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1">#2) Find the branches that have that coordinate (could be multiple)</span>
                    <span class="n">match_sk_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">,</span>
                        <span class="n">current_coordinate</span><span class="o">=</span><span class="n">orig_vertex</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;match_sk_branches = </span><span class="si">{</span><span class="n">match_sk_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



<span class="w">                    </span><span class="sd">&quot;&quot;&quot; ******************* THIS NEEDS TO BE FIXED WITH THE SAME METHOD OF STITCHING ********************  &quot;&quot;&quot;</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Pseudocode:</span>
<span class="sd">                    1) Find if branch point will require split or not</span>
<span class="sd">                    2) If does require split then split the skeleton</span>
<span class="sd">                    3) Gather mesh pieces for correspondence and the skeletons</span>
<span class="sd">                    4) Run the mesh correspondence</span>
<span class="sd">                    - this case calculate the new widths after run </span>
<span class="sd">                    5) Replace the old branch parts with the new ones</span>



<span class="sd">                    &quot;&quot;&quot;</span>

                    <span class="n">stitch_point_on_end_or_branch</span> <span class="o">=</span> <span class="n">find_if_stitch_point_on_end_or_branch</span><span class="p">(</span>
                                                            <span class="n">matched_branches_skeletons</span><span class="o">=</span> <span class="n">segment_branches</span><span class="p">[</span><span class="n">match_sk_branches</span><span class="p">],</span>
                                                             <span class="n">stitch_coordinate</span><span class="o">=</span><span class="n">orig_vertex</span><span class="p">,</span>
                                                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


                    <span class="k">if</span> <span class="ow">not</span> <span class="n">stitch_point_on_end_or_branch</span><span class="p">:</span>
                        <span class="n">matching_branch_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">cut_skeleton_at_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">segment_branches</span><span class="p">[</span><span class="n">match_sk_branches</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                                          <span class="n">cut_coordinate</span> <span class="o">=</span> <span class="n">orig_vertex</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">matching_branch_sk</span> <span class="o">=</span> <span class="n">segment_branches</span><span class="p">[</span><span class="n">match_sk_branches</span><span class="p">]</span>


                    <span class="c1">#3) Find the mesh and skeleton of the winning branch</span>
                    <span class="n">matching_branch_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="p">)[</span><span class="n">match_sk_branches</span><span class="p">]</span>
                    <span class="n">matching_branch_mesh_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="p">)[</span><span class="n">match_sk_branches</span><span class="p">]</span>
                    <span class="n">extend_soma_mesh_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">matching_branch_mesh_idx</span><span class="p">)</span>
                    <span class="n">extend_soma_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">extend_soma_mesh_idx</span> <span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1">#4) Add newly created branch to skeleton and divide the skeleton into branches (could make 2 or 3)</span>
                    <span class="c1">#extended_skeleton_to_soma = sk.stack_skeletons([list(matching_branch_sk),br_new])</span>

                    <span class="n">sk</span><span class="o">.</span><span class="n">check_skeleton_connected_component</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">matching_branch_sk</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">br_new</span><span class="p">]))</span>

                    <span class="c1">#5) Run Adaptive mesh correspondnece using branches and mesh</span>
                    <span class="n">local_correspondnece_MP</span> <span class="o">=</span> <span class="n">mesh_correspondence_first_pass</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">extend_soma_mesh</span><span class="p">,</span>
                                                                             <span class="n">skeleton_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">matching_branch_sk</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">br_new</span><span class="p">]</span>
                                                  <span class="c1">#skeleton=extended_skeleton_to_soma</span>
                                                                            <span class="p">)</span>

                    <span class="c1"># GETTING MESHES THAT ARE NOT FULLY CONNECTED!!</span>
                    <span class="n">local_correspondence_revised</span> <span class="o">=</span> <span class="n">correspondence_1_to_1</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">extend_soma_mesh</span><span class="p">,</span>
                                                                <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondnece_MP</span><span class="p">,</span>
                                                                <span class="n">curr_limb_endpoints_must_keep</span><span class="o">=</span><span class="n">endpoints_must_keep_MP</span><span class="p">,</span>
                                                                <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="n">curr_soma_to_piece_touching_vertices_MP</span><span class="p">)</span>

                    <span class="c1"># All the things that should be revised:</span>
                <span class="c1">#     segment_branches, #skeleton branches</span>
                <span class="c1">#     divided_submeshes, divided_submeshes_idx, #mesh correspondence (mesh and indices)</span>
                <span class="c1">#     segment_widths_median</span>


                    <span class="n">new_submeshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence_revised</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                    <span class="n">new_submeshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">extend_soma_mesh_idx</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence_revised</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                    <span class="n">new_skeletal_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence_revised</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

                    <span class="c1">#calculate the new width</span>
                    <span class="n">ray_inter</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_pyembree</span><span class="o">.</span><span class="n">RayMeshIntersector</span><span class="p">(</span><span class="n">limb_mesh_mparty</span><span class="p">)</span>
                    <span class="n">new_widths</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">new_s_idx</span> <span class="ow">in</span> <span class="n">new_submeshes_idx</span><span class="p">:</span>
                        <span class="n">curr_ray_distance</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">ray_trace_distance</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">limb_mesh_mparty</span><span class="p">,</span> 
                                            <span class="n">face_inds</span><span class="o">=</span><span class="n">new_s_idx</span><span class="p">,</span>
                                           <span class="n">ray_inter</span><span class="o">=</span><span class="n">ray_inter</span><span class="p">)</span>
                        <span class="n">curr_width_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">curr_ray_distance</span><span class="p">[</span><span class="n">curr_ray_distance</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_width_median = </span><span class="si">{</span><span class="n">curr_width_median</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">curr_width_median</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">curr_width_median</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">new_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_width_median</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;USING A DEFAULT WIDTH BECAUSE THE NEWLY COMPUTED ONE WAS </span><span class="si">{</span><span class="n">curr_width_median</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">segment_widths_median</span><span class="p">[</span><span class="n">match_sk_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">new_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment_widths_median</span><span class="p">[</span><span class="n">match_sk_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>


                    <span class="c1">#6) Remove the original branch and mesh correspondence and replace with the multiples</span>
    <span class="c1">#                     print(f&quot;match_sk_branches BEFORE = {match_sk_branches}&quot;)</span>
    <span class="c1">#                     print(f&quot;segment_branches BEFORE = {segment_branches}&quot;)</span>
    <span class="c1">#                     print(f&quot;len(new_skeletal_branches) = {len(new_skeletal_branches)}&quot;)</span>
    <span class="c1">#                     print(f&quot;new_skeletal_branches BEFORE= {new_skeletal_branches}&quot;)</span>


                    <span class="c1">#segment_branches = np.delete(segment_branches,match_sk_branches,axis=0)</span>
                    <span class="c1">#segment_branches = np.append(segment_branches,new_skeletal_branches,axis=0)</span>

                    <span class="n">segment_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">match_sk_branches</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_skeletal_branches</span><span class="p">)</span>


                    <span class="n">divided_submeshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="p">,</span><span class="n">match_sk_branches</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">divided_submeshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">divided_submeshes</span><span class="p">,</span><span class="n">new_submeshes</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


                    <span class="c1">#divided_submeshes_idx = np.delete(divided_submeshes_idx,match_sk_branches,axis=0)</span>
                    <span class="c1">#divided_submeshes_idx = np.append(divided_submeshes_idx,new_submeshes_idx,axis=0)</span>
                    <span class="n">divided_submeshes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">divided_submeshes_idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">match_sk_branches</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_submeshes_idx</span><span class="p">)</span>

                    <span class="n">segment_widths_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">segment_widths_median</span><span class="p">,</span><span class="n">match_sk_branches</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">segment_widths_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment_widths_median</span><span class="p">,</span><span class="n">new_widths</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_branches.shape = </span><span class="si">{</span><span class="n">segment_branches</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;segment_branches = </span><span class="si">{</span><span class="n">segment_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_skeletal_branches = </span><span class="si">{</span><span class="n">new_skeletal_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">sk</span><span class="o">.</span><span class="n">check_skeleton_connected_component</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">local_correspondence_revised</span><span class="p">,</span><span class="s2">&quot;local_correspondence_revised&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;checked segment branches after soma add on&quot;</span><span class="p">)</span>
                    <span class="n">return_find</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">,</span>
                                                 <span class="n">orig_vertex</span><span class="p">)</span>



<span class="w">                    </span><span class="sd">&quot;&quot;&quot; ******************* END OF HOW CAN DO STITCHING ********************  &quot;&quot;&quot;</span>



            <span class="n">limb_to_endpoints_must_keep_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endpts_total</span><span class="p">)</span>
            <span class="n">limb_to_soma_touching_vertices_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_soma_to_piece_touching_vertices_total</span><span class="p">)</span>
            
            <span class="c1">#print(f&quot;limb_to_endpoints_must_keep_list = {limb_to_endpoints_must_keep_list}&quot;)</span>
            <span class="c1">#print(f&quot;limb_to_soma_touching_vertices_list = {limb_to_soma_touching_vertices_list}&quot;)</span>

            <span class="c1"># ------------------- 11/9 addition ------------------- #</span>

            <span class="k">if</span> <span class="n">no_soma_extension_add</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No soma extending branch was added for this sublimb even though it had a soma border (means they already existed)&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">print_fusion_steps</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP (because soma touching verts) soma extension add: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fusion_time</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">fusion_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1">#building the limb correspondence</span>
        <span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">b_sk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segment_branches</span><span class="p">):</span>
            <span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">sublimb_idx</span><span class="p">][</span><span class="n">zz</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">branch_skeleton</span> <span class="o">=</span> <span class="n">b_sk</span><span class="p">,</span>
                <span class="n">width_from_skeleton</span> <span class="o">=</span> <span class="n">segment_widths_median</span><span class="p">[</span><span class="n">zz</span><span class="p">],</span>
                <span class="n">branch_mesh</span> <span class="o">=</span> <span class="n">divided_submeshes</span><span class="p">[</span><span class="n">zz</span><span class="p">],</span>
                <span class="n">branch_face_idx</span> <span class="o">=</span> <span class="n">divided_submeshes_idx</span><span class="p">[</span><span class="n">zz</span><span class="p">]</span>
                <span class="p">)</span>



    <span class="c1">#limb_correspondence_MP_saved = copy.deepcopy(limb_correspondence_MP)</span>
    <span class="c1">#limb_correspondence_MAP_saved = copy.deepcopy(limb_correspondence_MAP)</span>

    <span class="c1"># ------------------------------------- Part C: Will make sure the correspondences can all be stitched together --------------- #</span>

    
    
<span class="c1">#     su.compressed_pickle(limb_correspondence_MAP,&quot;limb_correspondence_MAP_before_stitch&quot;)</span>
<span class="c1">#     su.compressed_pickle(limb_correspondence_MP,&quot;limb_correspondence_MP_before_stitch&quot;)</span>

    
    <span class="k">if</span> <span class="n">check_correspondence_branches</span><span class="p">:</span>
        <span class="n">sk</span><span class="o">.</span><span class="n">check_correspondence_branches_have_2_endpoints</span><span class="p">(</span><span class="n">limb_correspondence_MAP</span><span class="p">)</span>
        <span class="n">sk</span><span class="o">.</span><span class="n">check_correspondence_branches_have_2_endpoints</span><span class="p">(</span><span class="n">limb_correspondence_MP</span><span class="p">)</span>
        
    <span class="c1">#total_keep_endpoints = np.concatenate([np.array(list(v.values())).reshape(-1,3) for v in limb_to_endpoints_must_keep_list])</span>
    <span class="n">total_keep_endpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">limb_to_endpoints_must_keep_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">total_keep_endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_keep_endpoints</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">total_keep_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">total_keep_endpoints</span><span class="p">)</span>
        
    <span class="n">total_keep_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">total_keep_endpoints</span><span class="p">)</span>
    
    <span class="c1"># Only want to perform this step if both MP and MAP pieces</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence_MAP</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence_MP</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

        <span class="c1"># -------------- Part 11: Getting Sublimb Mesh and Skeletons and Gets connectivitiy by Mesh -------#</span>
        <span class="c1"># -------------(filtering connections to only MP to MAP edges)--------------- #</span>

        <span class="c1"># ---- Doing the mesh connectivity ---------#</span>
        <span class="n">sublimb_meshes_MP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sublimb_skeletons_MP</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">sublimb_key</span><span class="p">,</span><span class="n">sublimb_v</span> <span class="ow">in</span> <span class="n">limb_correspondence_MP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sublimb_meshes_MP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">branch_v</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">branch_v</span> <span class="ow">in</span> <span class="n">sublimb_v</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>
            <span class="n">sublimb_skeletons_MP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">branch_v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">branch_v</span> <span class="ow">in</span> <span class="n">sublimb_v</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>



        <span class="n">sublimb_meshes_MAP</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sublimb_skeletons_MAP</span> <span class="o">=</span> <span class="p">[]</span>


        <span class="k">for</span> <span class="n">sublimb_key</span><span class="p">,</span><span class="n">sublimb_v</span> <span class="ow">in</span> <span class="n">limb_correspondence_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sublimb_meshes_MAP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">branch_v</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">branch_v</span> <span class="ow">in</span> <span class="n">sublimb_v</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>
            <span class="n">sublimb_skeletons_MAP</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">branch_v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">branch_v</span> <span class="ow">in</span> <span class="n">sublimb_v</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>

        <span class="n">sublimb_skeletons_MP_saved</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sublimb_skeletons_MP</span><span class="p">)</span>
        <span class="n">sublimb_skeletons_MAP_saved</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sublimb_skeletons_MAP</span><span class="p">)</span>

        <span class="n">connectivity_type</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">mesh_conn</span><span class="p">,</span><span class="n">mesh_conn_vertex_groups</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_connectivity</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">sublimb_meshes_MP</span> <span class="o">+</span> <span class="n">sublimb_meshes_MAP</span><span class="p">,</span>
                                                <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="p">,</span>
                                                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity_type</span><span class="p">,</span>
                                                <span class="n">min_common_vertices</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                                <span class="n">return_vertex_connection_groups</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">return_largest_vertex_connection_group</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">mesh_conn_old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh_conn</span><span class="p">)</span>



            <span class="c1">#check that every MAP piece mapped to a MP piece</span>
            <span class="n">mesh_conn_filt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mesh_conn_vertex_groups_filt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh_conn</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m2</span> <span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">):</span>
                    <span class="n">mesh_conn_filt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">])</span>
                    <span class="n">mesh_conn_vertex_groups_filt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_conn_vertex_groups</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge </span><span class="si">{</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">)</span><span class="si">}</span><span class="s2"> was not kept&quot;</span><span class="p">)</span>
            <span class="n">mesh_conn_filt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_conn_filt</span><span class="p">)</span>

            <span class="n">mesh_conn</span> <span class="o">=</span> <span class="n">mesh_conn_filt</span>
            <span class="n">mesh_conn_vertex_groups</span> <span class="o">=</span> <span class="n">mesh_conn_vertex_groups_filt</span>

            <span class="c1">#check that the mapping should create only one connected component</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">mesh_conn</span><span class="p">)</span>



            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MAP</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Number of nodes in mesh connectivity graph is not equal to number of  MAP and MP sublimbs&quot;</span><span class="p">)</span>

                <span class="n">connect_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connect_comp</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh connectivity was not one component, instead it was (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">connect_comp</span><span class="p">)</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">connect_comp</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="n">connectivity_type</span> <span class="o">==</span> <span class="s2">&quot;vertices&quot;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_conn_filt = </span><span class="si">{</span><span class="n">mesh_conn_filt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_conn_old = </span><span class="si">{</span><span class="n">mesh_conn_old</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">mesh_conn_adjusted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh_conn</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">mesh_conn</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_conn_adjusted = </span><span class="si">{</span><span class="n">mesh_conn_adjusted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(sublimb_meshes_MP) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(sublimb_meshes_MAP) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MAP</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">meshes</span> <span class="o">=</span> <span class="n">sublimb_meshes_MP</span> <span class="o">+</span> <span class="n">sublimb_meshes_MAP</span>
                    <span class="c1">#su.compressed_pickle(meshes,&quot;meshes&quot;)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">,</span><span class="s2">&quot;sublimb_meshes_MP&quot;</span><span class="p">)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">sublimb_meshes_MAP</span><span class="p">,</span><span class="s2">&quot;sublimb_meshes_MAP&quot;</span><span class="p">)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">limb_mesh_mparty</span><span class="p">,</span><span class="s2">&quot;limb_mesh_mparty&quot;</span><span class="p">)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">sublimb_skeletons_MP</span><span class="p">,</span><span class="s2">&quot;sublimb_skeletons_MP&quot;</span><span class="p">)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">sublimb_skeletons_MAP</span><span class="p">,</span><span class="s2">&quot;sublimb_skeletons_MAP&quot;</span><span class="p">)</span>




                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong in the connectivity&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed on connection type </span><span class="si">{</span><span class="n">connectivity_type</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                    <span class="n">connectivity_type</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;so changing type to </span><span class="si">{</span><span class="n">connectivity_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successful mesh connectivity with type </span><span class="si">{</span><span class="n">connectivity_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">break</span>


        <span class="c1">#adjust the connection indices for MP and MAP indices</span>
        <span class="n">mesh_conn_adjusted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mesh_conn</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">mesh_conn</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">sublimb_meshes_MP</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>






<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        For each connection edge:</span>
<span class="sd">            For each vertex connection group:</span>
<span class="sd">                1) Get the endpoint vertices of the MP skeleton</span>
<span class="sd">                2) Find the closest endpoint vertex to the vertex connection group (this is MP stitch point)</span>
<span class="sd">                3) Find the closest skeletal point on MAP pairing (MAP stitch) </span>
<span class="sd">                4) Find the branches that have that MAP stitch point:</span>
<span class="sd">                5A) If the number of branches corresponding to stitch point is multipled</span>
<span class="sd">                    --&gt; then we are stitching at a branching oint</span>
<span class="sd">                    i) Just add the skeletal segment from MP_stitch to MAP stitch to the MP skeletal segment</span>
<span class="sd">                    ii) </span>

<span class="sd">        &quot;&quot;&quot;</span>



        <span class="c1"># -------------- STITCHING PHASE -------#</span>
        <span class="n">stitch_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">all_map_stitch_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">MP_idx</span><span class="p">,</span><span class="n">MAP_idx</span><span class="p">),</span><span class="n">v_g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mesh_conn_adjusted</span><span class="p">,</span><span class="n">mesh_conn_vertex_groups</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---- Working on </span><span class="si">{</span><span class="p">(</span><span class="n">MP_idx</span><span class="p">,</span><span class="n">MAP_idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> connection-----&quot;</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This old way of getting the endpoints was not good because could possibly just need</span>
<span class="sd">            a stitching done between original branch junction</span>

<span class="sd">            skeleton_MP_graph = sk.convert_skeleton_to_graph(curr_skeleton_MP)</span>
<span class="sd">            endpoint_nodes = xu.get_nodes_of_degree_k(skeleton_MP_graph,1)</span>
<span class="sd">            endpoint_nodes_coordinates = xu.get_node_attributes(skeleton_MP_graph,node_list=endpoint_nodes)</span>
<span class="sd">            &quot;&quot;&quot;</span>


            <span class="c1"># -------------- Part 12: Find the MP and MAP stitching point and branches that contain the stitching point-------#</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;  OLD WAY THAT ALLOWED STITICHING POINTS TO NOT BE CONNECTED AT THE CONNECTING BRANCHES</span>
<span class="sd">            #getting the skeletons that should be stitched</span>
<span class="sd">            curr_skeleton_MP = sk.stack_skeletons([branch_v[&quot;branch_skeleton&quot;] for branch_v in limb_correspondence_MP[MP_idx].values()])</span>
<span class="sd">            curr_skeleton_MAP = sk.stack_skeletons([branch_v[&quot;branch_skeleton&quot;] for branch_v in limb_correspondence_MAP[MAP_idx].values()])</span>

<span class="sd">            #1) Get the endpoint vertices of the MP skeleton branches (so every endpoint or high degree node)</span>
<span class="sd">            #(needs to be inside loop because limb correspondence will change)</span>
<span class="sd">            curr_MP_branch_skeletons = [limb_correspondence_MP[MP_idx][k][&quot;branch_skeleton&quot;] for k in np.sort(list(limb_correspondence_MP[MP_idx].keys()))]</span>
<span class="sd">            endpoint_nodes_coordinates = np.array([sk.find_branch_endpoints(k) for k in curr_MP_branch_skeletons])</span>
<span class="sd">            endpoint_nodes_coordinates = np.unique(endpoint_nodes_coordinates.reshape(-1,3),axis=0)</span>

<span class="sd">            #2) Find the closest endpoint vertex to the vertex connection group (this is MP stitch point)</span>
<span class="sd">            av_vert = np.mean(v_g,axis=0)</span>
<span class="sd">            winning_vertex = endpoint_nodes_coordinates[np.argmin(np.linalg.norm(endpoint_nodes_coordinates-av_vert,axis=1))]</span>
<span class="sd">            print(f&quot;winning_vertex = {winning_vertex}&quot;)</span>


<span class="sd">            #2b) Find the branch points where the winning vertex is located</span>
<span class="sd">            MP_branches_with_stitch_point = sk.find_branch_skeleton_with_specific_coordinate(</span>
<span class="sd">                divded_skeleton=curr_MP_branch_skeletons,</span>
<span class="sd">                current_coordinate = winning_vertex</span>
<span class="sd">            )</span>
<span class="sd">            print(f&quot;MP_branches_with_stitch_point = {MP_branches_with_stitch_point}&quot;)</span>


<span class="sd">            #3) Find the closest skeletal point on MAP pairing (MAP stitch)</span>
<span class="sd">            MAP_skeleton_coords = np.unique(curr_skeleton_MAP.reshape(-1,3),axis=0)</span>
<span class="sd">            MAP_stitch_point = MAP_skeleton_coords[np.argmin(np.linalg.norm(MAP_skeleton_coords-winning_vertex,axis=1))]</span>


<span class="sd">            #3b) Consider if the stitch point is close enough to end or branch node in skeleton:</span>
<span class="sd">            # and if so then reassign</span>
<span class="sd">            if move_MAP_stitch_to_end_or_branch:</span>
<span class="sd">                MAP_stitch_point_new,change_status = sk.move_point_to_nearest_branch_end_point_within_threshold(</span>
<span class="sd">                                                        skeleton=curr_skeleton_MAP,</span>
<span class="sd">                                                        coordinate=MAP_stitch_point,</span>
<span class="sd">                                                        distance_to_move_point_threshold = distance_to_move_point_threshold,</span>
<span class="sd">                                                        verbose=True</span>

<span class="sd">                                                        )</span>
<span class="sd">                MAP_stitch_point=MAP_stitch_point_new</span>


<span class="sd">            #4) Find the branches that have that MAP stitch point:</span>
<span class="sd">            curr_MAP_branch_skeletons = [limb_correspondence_MAP[MAP_idx][k][&quot;branch_skeleton&quot;]</span>
<span class="sd">                                             for k in np.sort(list(limb_correspondence_MAP[MAP_idx].keys()))]</span>

<span class="sd">            MAP_branches_with_stitch_point = sk.find_branch_skeleton_with_specific_coordinate(</span>
<span class="sd">                divded_skeleton=curr_MAP_branch_skeletons,</span>
<span class="sd">                current_coordinate = MAP_stitch_point</span>
<span class="sd">            )</span>



<span class="sd">            MAP_stitch_point_on_end_or_branch = False</span>
<span class="sd">            if len(MAP_branches_with_stitch_point)&gt;1:</span>
<span class="sd">                MAP_stitch_point_on_end_or_branch = True</span>
<span class="sd">            elif len(MAP_branches_with_stitch_point)==1:</span>
<span class="sd">                if len(nu.matching_rows(sk.find_branch_endpoints(curr_MAP_branch_skeletons[MAP_branches_with_stitch_point[0]]),</span>
<span class="sd">                                        MAP_stitch_point))&gt;0:</span>
<span class="sd">                    MAP_stitch_point_on_end_or_branch=True</span>
<span class="sd">            else:</span>
<span class="sd">                raise Exception(&quot;No matching MAP values&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>

            <span class="c1">#*****should only get branches that are touching....****</span>

            <span class="c1">#getting the skeletons that should be stitched</span>
            <span class="n">curr_skeleton_MP</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">branch_v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">branch_v</span> <span class="ow">in</span> <span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="n">curr_skeleton_MAP</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">branch_v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">branch_v</span> <span class="ow">in</span> <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>


            <span class="n">av_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v_g</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># ---------------- Doing the MAP part first -------------- #</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The previous way did not ensure that the MAP point found will have a branch mesh that is touching the border vertices</span>

<span class="sd">            #3) Find the closest skeletal point on MAP pairing (MAP stitch)</span>
<span class="sd">            MAP_skeleton_coords = np.unique(curr_skeleton_MAP.reshape(-1,3),axis=0)</span>

<span class="sd">            #this does not guarentee that the MAP branch associated with the MAP stitch point is touching the border group</span>
<span class="sd">            MAP_stitch_point = MAP_skeleton_coords[np.argmin(np.linalg.norm(MAP_skeleton_coords-av_vert,axis=1))]</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># -------------- 11/9 NEW METHOD FOR FINDING MAP STITCH POINT ------------ #</span>
            <span class="n">o_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">curr_MAP_branch_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span>
                                             <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">o_keys</span><span class="p">])</span>
            <span class="n">curr_MAP_branch_skeletons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
                                             <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">o_keys</span><span class="p">])</span>

            <span class="n">MAP_pieces_idx_touching_border</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">mesh_list</span><span class="o">=</span><span class="n">curr_MAP_branch_meshes</span><span class="p">,</span>
                                           <span class="n">nullifying_points</span><span class="o">=</span><span class="n">v_g</span><span class="p">,</span>
                                            <span class="n">filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                           <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">MAP_branches_considered</span> <span class="o">=</span> <span class="n">curr_MAP_branch_skeletons</span><span class="p">[</span><span class="n">MAP_pieces_idx_touching_border</span><span class="p">]</span>
            <span class="n">curr_skeleton_MAP_for_stitch</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">MAP_branches_considered</span><span class="p">)</span>

            <span class="c1">#3) Find the closest skeletal point on MAP pairing (MAP stitch)</span>
            <span class="n">MAP_skeleton_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_skeleton_MAP_for_stitch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            #------- OLD WAY: this does not guarentee that the MAP branch associated with the MAP stitch point is touching the border group</span>
<span class="sd">            #MAP_stitch_point = MAP_skeleton_coords[np.argmin(np.linalg.norm(MAP_skeleton_coords-av_vert,axis=1))]</span>

<span class="sd">            # ------- 1/1/21 Change to make sure never stitches to soma connecting point ----</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) Get all the closest coordinates and sort in order of distance</span>
<span class="sd">            2) Iterate through the top coordinates:</span>
<span class="sd">            - check if not in the endpoints</span>
<span class="sd">            a. if not --&gt; make that the winning MAP stitch point</span>
<span class="sd">            b. if not --&gt; continue to next</span>

<span class="sd">            3) if get to end and dont have winning coordinate then error</span>
<span class="sd">            closest_MAP_coords = MAP_skeleton_coords[np.argsort(np.linalg.norm(MAP_skeleton_coords-av_vert,axis=1))]</span>

<span class="sd">            MAP_stitch_point = None</span>
<span class="sd">            for c_map in closest_MAP_coords:</span>

<span class="sd">                if len(nu.matching_rows(total_keep_endpoints,c_map))==0:</span>
<span class="sd">                    MAP_stitch_point = c_map</span>
<span class="sd">                    break</span>


<span class="sd">            if MAP_stitch_point is None:</span>
<span class="sd">                raise Exception(&#39;Could not find a MAP_stitch_point that was not a keep_endpoint that was touching the soma&#39;)</span>

<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            # --------- 1/2/21: this functionality is now taken care of inside move point</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">MAP_stitch_point</span> <span class="o">=</span> <span class="n">MAP_skeleton_coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">MAP_skeleton_coords</span><span class="o">-</span><span class="n">av_vert</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))]</span>

            <span class="c1"># --------- 11/13: Making so could possibly stitch to another point that was already stitched to</span>
            <span class="n">curr_br_endpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">MAP_branches_considered</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">curr_br_endpts_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_br_endpts</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>



            <span class="c1">#3b) Consider if the stitch point is close enough to end or branch node in skeleton:</span>
            <span class="c1"># and if so then reassign</span>
            <span class="k">if</span> <span class="n">move_MAP_stitch_to_end_or_branch</span><span class="p">:</span>
                <span class="n">MAP_stitch_point_new</span><span class="p">,</span><span class="n">change_status</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">move_point_to_nearest_branch_end_point_within_threshold</span><span class="p">(</span>
                                                        <span class="n">skeleton</span><span class="o">=</span><span class="n">curr_skeleton_MAP</span><span class="p">,</span>
                                                        <span class="n">coordinate</span><span class="o">=</span><span class="n">MAP_stitch_point</span><span class="p">,</span>
                                                        <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="n">distance_to_move_point_threshold</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">possible_node_coordinates</span><span class="o">=</span><span class="n">curr_br_endpts_unique</span><span class="p">,</span>
                                                        <span class="n">excluded_node_coordinates</span><span class="o">=</span><span class="n">total_keep_endpoints</span><span class="p">,</span>
                                                        <span class="p">)</span>
                <span class="n">MAP_stitch_point</span><span class="o">=</span><span class="n">MAP_stitch_point_new</span>


            <span class="c1">#4) Find the branches that have that MAP stitch point:</span>

            <span class="n">MAP_branches_with_stitch_point</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span>
                <span class="n">divded_skeleton</span><span class="o">=</span><span class="n">curr_MAP_branch_skeletons</span><span class="p">,</span>
                <span class="n">current_coordinate</span> <span class="o">=</span> <span class="n">MAP_stitch_point</span>
            <span class="p">)</span>



            <span class="n">MAP_stitch_point_on_end_or_branch</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">MAP_stitch_point_on_end_or_branch</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">curr_MAP_branch_skeletons</span><span class="p">[</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                                        <span class="n">MAP_stitch_point</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">MAP_stitch_point_on_end_or_branch</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No matching MAP values&quot;</span><span class="p">)</span>

            <span class="c1">#add the map stitch point to the history</span>
            <span class="n">all_map_stitch_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MAP_stitch_point</span><span class="p">)</span>

            <span class="c1"># ---------------- Doing the MP Part --------------------- #</span>



            <span class="n">ord_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">curr_MP_branch_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ord_keys</span><span class="p">]</span>



<span class="w">            </span><span class="sd">&quot;&quot;&quot; old way of filtering MP pieces just to those touching the MAP, but just want the ones touching the connection group</span>

<span class="sd">            MAP_meshes_with_stitch_point = tu.combine_meshes([limb_correspondence_MAP[MAP_idx][k][&quot;branch_mesh&quot;] for k in MAP_branches_with_stitch_point])</span>

<span class="sd">            conn = tu.mesh_pieces_connectivity(main_mesh=limb_mesh_mparty,</span>
<span class="sd">                                       central_piece=MAP_meshes_with_stitch_point,</span>
<span class="sd">                                       periphery_pieces=curr_MP_branch_meshes)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># 11/9 Addition: New way that filters meshes by their touching of the vertex connection group (this could possibly be an empty group)</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">mesh_list</span><span class="o">=</span><span class="n">curr_MP_branch_meshes</span><span class="p">,</span>
                                           <span class="n">nullifying_points</span><span class="o">=</span><span class="n">v_g</span><span class="p">,</span>
                                            <span class="n">filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                           <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connectivity was 0 for the MP mesh groups touching the vertex group so not restricting by that anymore&quot;</span><span class="p">)</span>
                <span class="n">sk_conn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_MP_branch_meshes</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sk_conn</span> <span class="o">=</span> <span class="n">conn</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_conn = </span><span class="si">{</span><span class="n">sk_conn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn = </span><span class="si">{</span><span class="n">conn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="c1">#1) Get the endpoint vertices of the MP skeleton branches (so every endpoint or high degree node)</span>
            <span class="c1">#(needs to be inside loop because limb correspondence will change)</span>
            <span class="n">curr_MP_branch_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_conn</span><span class="p">]</span>
            <span class="n">endpoint_nodes_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_MP_branch_skeletons</span><span class="p">])</span>
            <span class="n">endpoint_nodes_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">endpoint_nodes_coordinates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; ---------- 1 /5: Take out the possible endpoints --------------------&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">prevent_MP_starter_branch_stitches</span><span class="p">:</span>
                <span class="n">endpoint_nodes_coordinates</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">endpoint_nodes_coordinates</span><span class="p">,</span><span class="n">total_keep_endpoints</span><span class="p">)</span>


            <span class="c1">#2) Find the closest endpoint vertex to the vertex connection group (this is MP stitch point)</span>

            <span class="n">winning_vertex</span> <span class="o">=</span> <span class="n">endpoint_nodes_coordinates</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">endpoint_nodes_coordinates</span><span class="o">-</span><span class="n">av_vert</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_vertex = </span><span class="si">{</span><span class="n">winning_vertex</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="c1">#2b) Find the branch points where the winning vertex is located</span>
            <span class="n">curr_MP_branch_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))]</span>
            <span class="n">MP_branches_with_stitch_point</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span>
                <span class="n">divded_skeleton</span><span class="o">=</span><span class="n">curr_MP_branch_skeletons</span><span class="p">,</span>
                <span class="n">current_coordinate</span> <span class="o">=</span> <span class="n">winning_vertex</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP_branches_with_stitch_point = </span><span class="si">{</span><span class="n">MP_branches_with_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MAP_branches_with_stitch_point = </span><span class="si">{</span><span class="n">MAP_branches_with_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MAP_stitch_point_on_end_or_branch = </span><span class="si">{</span><span class="n">MAP_stitch_point_on_end_or_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="c1"># -------- 11/13 addition: Will see if the MP stitch point was already a MAP stitch point ---- #</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_map_stitch_points</span><span class="p">),</span><span class="n">winning_vertex</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">keep_MP_stitch_static</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keep_MP_stitch_static</span> <span class="o">=</span> <span class="kc">False</span>





            <span class="c1"># ------------------------- This part does the stitching -------------------- #</span>


<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            1) For all MP branches</span>
<span class="sd">                a) Get neighbor coordinates to MP stitch points</span>
<span class="sd">                b) Delete the MP Stitch points on each </span>
<span class="sd">                c) Add skeleton segment from neighbor to MAP stitch point</span>
<span class="sd">            2) Get skeletons and meshes from MP and MAP pieces</span>
<span class="sd">            3) Run mesh correspondence to get new meshes and mesh_idx and widths</span>
<span class="sd">            4a) If MAP_stitch_point_on_end_or_branch is False</span>
<span class="sd">            - Delete the old MAP branch parts and replace with new MAP ones</span>
<span class="sd">            4b) Revise the meshes,  mesh_idx, and widths of the MAP pieces</span>
<span class="sd">            5) Revise the meshes,  mesh_idx, and widths of the MP pieces</span>


<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># -------------- Part 13: Will Adjust the MP branches that have the stitch point so extends to the MAP stitch point -------#</span>
            <span class="n">curr_MP_sk</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b_idx</span> <span class="ow">in</span> <span class="n">MP_branches_with_stitch_point</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_MP_stitch_static</span><span class="p">:</span>
                    <span class="c1">#a) Get neighbor coordinates to MP stitch points</span>
                    <span class="n">MP_stitch_branch_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_MP_branch_skeletons</span><span class="p">[</span><span class="n">b_idx</span><span class="p">])</span>
                    <span class="n">stitch_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">winning_vertex</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">stitch_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="n">stitch_node</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stitch_neighbors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not just one neighbor for stitch point of MP branch&quot;</span><span class="p">)</span>
                    <span class="n">keep_neighbor</span> <span class="o">=</span> <span class="n">stitch_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
                    <span class="n">keep_neighbor_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">keep_neighbor</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1">#b) Delete the MP Stitch points on each </span>
                    <span class="n">MP_stitch_branch_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">stitch_node</span><span class="p">)</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot; Old way that does not do smoothing</span>

<span class="sd">                    #c) Add skeleton segment from neighbor to MAP stitch point</span>
<span class="sd">                    new_node_name = np.max(MP_stitch_branch_graph.nodes())+1</span>

<span class="sd">                    MP_stitch_branch_graph.add_nodes_from([(int(new_node_name),{&quot;coordinates&quot;:MAP_stitch_point})])</span>
<span class="sd">                    MP_stitch_branch_graph.add_weighted_edges_from([(keep_neighbor,new_node_name,np.linalg.norm(MAP_stitch_point - keep_neighbor_coordinates))])</span>

<span class="sd">                    new_MP_skeleton = sk.convert_graph_to_skeleton(MP_stitch_branch_graph)</span>

<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">new_MP_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">add_and_smooth_segment_to_branch</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">),</span>
                                                            <span class="n">skeleton_stitch_point</span><span class="o">=</span><span class="n">keep_neighbor_coordinates</span><span class="p">,</span>
                                                             <span class="n">new_stitch_point</span><span class="o">=</span><span class="n">MAP_stitch_point</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not even attempting smoothing segment because once keep_neighbor_coordinates&quot;</span><span class="p">)</span>
                            <span class="n">new_MP_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">keep_neighbor_coordinates</span><span class="p">,</span><span class="n">MAP_stitch_point</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="s2">&quot;MP_stitch_branch_graph&quot;</span><span class="p">)</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">keep_neighbor_coordinates</span><span class="p">,</span><span class="s2">&quot;keep_neighbor_coordinates&quot;</span><span class="p">)</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">MAP_stitch_point</span><span class="p">,</span><span class="s2">&quot;MAP_stitch_point&quot;</span><span class="p">)</span>


                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong with add_and_smooth_segment_to_branch&quot;</span><span class="p">)</span>





                    <span class="c1">#smooth over the new skeleton</span>
                    <span class="n">new_MP_skeleton_smooth</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">new_MP_skeleton</span><span class="p">,</span>
                                                                      <span class="n">segment_width</span><span class="o">=</span><span class="n">meshparty_segment_size</span><span class="p">)</span>

                    <span class="n">curr_MP_sk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_MP_skeleton_smooth</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adjusting MP skeletons because keep_MP_stitch_static = </span><span class="si">{</span><span class="n">keep_MP_stitch_static</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">curr_MP_sk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_MP_branch_skeletons</span><span class="p">[</span><span class="n">b_idx</span><span class="p">])</span>



            <span class="c1">#2) Get skeletons and meshes from MP and MAP pieces</span>
            <span class="n">curr_MAP_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">MAP_branches_with_stitch_point</span><span class="p">]</span>

            <span class="c1">#2.1) Going to break up the MAP skeleton if need be</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            a) check to see if it needs to be broken up</span>
<span class="sd">            If it does:</span>
<span class="sd">            b) Convert the skeleton into a graph</span>
<span class="sd">            c) Find the node of the MAP stitch point (where need to do the breaking)</span>
<span class="sd">            d) Find the degree one nodes</span>
<span class="sd">            e) For each degree one node:</span>
<span class="sd">            - Find shortest path from stitch node to end node</span>
<span class="sd">            - get a subgraph from that path</span>
<span class="sd">            - convert graph to a skeleton and save as new skeletons</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># -------------- Part 14: Breaks Up MAP skeleton into 2 pieces if Needs (because MAP stitch point not on endpoint or branch point)  -------#</span>

            <span class="c1">#a) check to see if it needs to be broken up</span>
            <span class="n">cut_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">MAP_stitch_point_on_end_or_branch</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_MAP_sk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There was more than one skeleton for MAP skeletons even though MAP_stitch_point_on_end_or_branch = </span><span class="si">{</span><span class="n">MAP_stitch_point_on_end_or_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                <span class="n">skeleton_to_cut</span> <span class="o">=</span> <span class="n">curr_MAP_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">curr_MAP_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">cut_skeleton_at_coordinate</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton_to_cut</span><span class="p">,</span>
                                                            <span class="n">cut_coordinate</span><span class="o">=</span><span class="n">MAP_stitch_point</span><span class="p">)</span>
                <span class="n">cut_flag</span><span class="o">=</span><span class="kc">True</span>


            <span class="c1"># ------ 11/13 Addition: need to adjust the MAP points if have to keep MP static</span>
            <span class="k">if</span> <span class="n">keep_MP_stitch_static</span><span class="p">:</span>
                <span class="n">curr_MAP_sk_final</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">map_skel</span> <span class="ow">in</span> <span class="n">curr_MAP_sk</span><span class="p">:</span>
                    <span class="c1">#a) Get neighbor coordinates to MP stitch points</span>
                    <span class="n">MP_stitch_branch_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">map_skel</span><span class="p">)</span>
                    <span class="n">stitch_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_with_attributes_dict</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">coordinates</span><span class="o">=</span><span class="n">MAP_stitch_point</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">stitch_neighbors</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="n">stitch_node</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stitch_neighbors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Not just one neighbor for stitch point of MP branch&quot;</span><span class="p">)</span>
                    <span class="n">keep_neighbor</span> <span class="o">=</span> <span class="n">stitch_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
                    <span class="n">keep_neighbor_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="n">node_list</span><span class="o">=</span><span class="p">[</span><span class="n">keep_neighbor</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1">#b) Delete the MP Stitch points on each </span>
                    <span class="n">MP_stitch_branch_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">stitch_node</span><span class="p">)</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot; Old way that does not do smoothing</span>

<span class="sd">                    #c) Add skeleton segment from neighbor to MAP stitch point</span>
<span class="sd">                    new_node_name = np.max(MP_stitch_branch_graph.nodes())+1</span>

<span class="sd">                    MP_stitch_branch_graph.add_nodes_from([(int(new_node_name),{&quot;coordinates&quot;:MAP_stitch_point})])</span>
<span class="sd">                    MP_stitch_branch_graph.add_weighted_edges_from([(keep_neighbor,new_node_name,np.linalg.norm(MAP_stitch_point - keep_neighbor_coordinates))])</span>

<span class="sd">                    new_MP_skeleton = sk.convert_graph_to_skeleton(MP_stitch_branch_graph)</span>

<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">new_MP_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">add_and_smooth_segment_to_branch</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">),</span>
                                                            <span class="n">skeleton_stitch_point</span><span class="o">=</span><span class="n">keep_neighbor_coordinates</span><span class="p">,</span>
                                                             <span class="n">new_stitch_point</span><span class="o">=</span><span class="n">winning_vertex</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not even attempting smoothing segment because once keep_neighbor_coordinates&quot;</span><span class="p">)</span>
                            <span class="n">new_MP_skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">keep_neighbor_coordinates</span><span class="p">,</span><span class="n">MAP_stitch_point</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">MP_stitch_branch_graph</span><span class="p">,</span><span class="s2">&quot;MP_stitch_branch_graph&quot;</span><span class="p">)</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">keep_neighbor_coordinates</span><span class="p">,</span><span class="s2">&quot;keep_neighbor_coordinates&quot;</span><span class="p">)</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">winning_vertex</span><span class="p">,</span><span class="s2">&quot;winning_vertex&quot;</span><span class="p">)</span>


                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong with add_and_smooth_segment_to_branch&quot;</span><span class="p">)</span>





                    <span class="c1">#smooth over the new skeleton</span>
                    <span class="n">new_MP_skeleton_smooth</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">new_MP_skeleton</span><span class="p">,</span>
                                                                      <span class="n">segment_width</span><span class="o">=</span><span class="n">meshparty_segment_size</span><span class="p">)</span>

                    <span class="n">curr_MAP_sk_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_MP_skeleton_smooth</span><span class="p">)</span>
                <span class="n">curr_MAP_sk</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_MAP_sk_final</span><span class="p">)</span>



            <span class="c1"># -------------- Part 15: Gets all of the skeletons and Mesh to divide u and does mesh correspondence -------#</span>
            <span class="c1"># ------------- revise IDX so still references the whole limb mesh -----------#</span>

            <span class="c1"># -------------- 11/10 Addition accounting for not all MAP pieces always touching each other --------------------#</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Revising the MAP pieces index:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MAP_pieces_idx_touching_border = </span><span class="si">{</span><span class="n">MAP_pieces_idx_touching_border</span><span class="si">}</span><span class="s2">, MAP_branches_with_stitch_point = </span><span class="si">{</span><span class="n">MAP_branches_with_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">MAP_pieces_for_correspondence</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">MAP_pieces_idx_touching_border</span><span class="p">,</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MAP_pieces_for_correspondence = </span><span class="si">{</span><span class="n">MAP_pieces_for_correspondence</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">curr_MAP_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">MAP_pieces_for_correspondence</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">MAP_pieces_for_correspondence</span> <span class="o">=</span> <span class="n">MAP_branches_with_stitch_point</span>

            <span class="n">curr_MAP_meshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">MAP_pieces_for_correspondence</span><span class="p">]</span>

            <span class="c1"># Have to adjust based on if the skeleton were split</span>

            <span class="k">if</span> <span class="n">cut_flag</span><span class="p">:</span>
                <span class="c1">#Then it was cut and have to do mesh correspondence to find what label to cut</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_MAP_meshes_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;MAP_pieces_for_correspondence was longer than 1 and cut flag was set&quot;</span><span class="p">)</span>
                <span class="n">pre_stitch_mesh_idx</span> <span class="o">=</span> <span class="n">curr_MAP_meshes_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pre_stitch_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">pre_stitch_mesh_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">local_correspondnece_stitch</span> <span class="o">=</span> <span class="n">mesh_correspondence_first_pass</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">pre_stitch_mesh</span><span class="p">,</span>
                                          <span class="n">skeleton_branches</span><span class="o">=</span><span class="n">curr_MAP_sk</span><span class="p">)</span>
                <span class="n">local_correspondence_stitch_revised_MAP</span> <span class="o">=</span> <span class="n">correspondence_1_to_1</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">pre_stitch_mesh</span><span class="p">,</span>
                                                            <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondnece_stitch</span><span class="p">,</span>
                                                            <span class="n">curr_limb_endpoints_must_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                            <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1">#                 curr_MAP_meshes_idx = [pre_stitch_mesh_idx[local_correspondence_stitch_revised_MAP[nn][&quot;branch_face_idx&quot;]] for </span>
<span class="c1">#                                                nn in local_correspondence_stitch_revised_MAP.keys()]</span>
                
                <span class="c1">#Need to readjust the mesh correspondence idx</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">local_correspondence_stitch_revised_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">local_correspondence_stitch_revised_MAP</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_stitch_mesh_idx</span><span class="p">[</span><span class="n">local_correspondence_stitch_revised_MAP</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]]</span>
                    
                <span class="n">curr_MAP_meshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">local_correspondence_stitch_revised_MAP</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_correspondence_stitch_revised_MAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">gg</span><span class="p">,</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">kk</span><span class="p">])</span> <span class="k">for</span> <span class="n">gg</span><span class="p">,</span><span class="n">kk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">MAP_pieces_for_correspondence</span><span class="p">)])</span>
                
                <span class="k">for</span> <span class="n">gg</span><span class="p">,</span><span class="n">kk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">MAP_pieces_for_correspondence</span><span class="p">):</span>
                    <span class="n">local_correspondence_stitch_revised_MAP</span><span class="p">[</span><span class="n">gg</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_MAP_sk</span><span class="p">[</span><span class="n">gg</span><span class="p">]</span>
                    


            <span class="c1">#To make sure that the MAP never gives up ground on the labels</span>
            <span class="n">must_keep_labels_MAP</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">must_keep_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">kk</span><span class="p">,</span><span class="n">b_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_MAP_meshes_idx</span><span class="p">):</span>
                <span class="c1">#must_keep_labels_MAP.update(dict([(ii,kk) for ii in range(must_keep_counter,must_keep_counter+len(b_idx))]))</span>
                <span class="n">must_keep_labels_MAP</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">must_keep_counter</span><span class="p">,</span><span class="n">must_keep_counter</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">))</span>
                <span class="n">must_keep_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">)</span>



            <span class="c1">#this is where should send only the MP that apply</span>
            <span class="n">MP_branches_for_correspondence</span><span class="p">,</span><span class="n">conn_idx</span><span class="p">,</span><span class="n">MP_branches_with_stitch_point_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="n">MP_branches_with_stitch_point</span><span class="p">,</span><span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">curr_MP_meshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">MP_branches_for_correspondence</span><span class="p">]</span>
            <span class="n">curr_MP_sk_for_correspondence</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_MP_sk</span><span class="p">[</span><span class="n">zz</span><span class="p">]</span> <span class="k">for</span> <span class="n">zz</span> <span class="ow">in</span> <span class="n">MP_branches_with_stitch_point_idx</span><span class="p">]</span>

            <span class="n">stitching_mesh_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">curr_MAP_meshes_idx</span> <span class="o">+</span> <span class="n">curr_MP_meshes_idx</span><span class="p">)</span>
            <span class="n">stitching_mesh</span> <span class="o">=</span> <span class="n">limb_mesh_mparty</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">stitching_mesh_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">stitching_skeleton_branches</span> <span class="o">=</span> <span class="n">curr_MAP_sk</span> <span class="o">+</span> <span class="n">curr_MP_sk_for_correspondence</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            ****** NEED TO GET THE RIGHT MESH TO RUN HE IDX ON SO GETS A GOOD MESH (CAN&#39;T BE LIMB_MESH_MPARTY)</span>
<span class="sd">            BUT MUST BE THE ORIGINAL MAP MESH</span>

<span class="sd">            mesh_pieces_for_MAP</span>
<span class="sd">            sublimb_meshes_MP</span>

<span class="sd">            mesh_pieces_for_MAP_face_idx</span>
<span class="sd">            sublimb_meshes_MP_face_idx</span>

<span class="sd">            stitching_mesh = tu.combine_meshes(curr_MAP_meshes + curr_MP_meshes)</span>
<span class="sd">            stitching_skeleton_branches = curr_MAP_sk + curr_MP_sk</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="c1"># ******************************** this is where should do thing about no mesh correspondence ***************** #</span>

            <span class="c1"># -------- 12/22: Trying to do the re-correspondence but if doesn&#39;t work then just resort to old one --------- #</span>

            <span class="k">try</span><span class="p">:</span>
                
                <span class="c1">#3) Run mesh correspondence to get new meshes and mesh_idx and widths</span>
                <span class="n">local_correspondnece_stitch</span> <span class="o">=</span> <span class="n">mesh_correspondence_first_pass</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">stitching_mesh</span><span class="p">,</span>
                                              <span class="n">skeleton_branches</span><span class="o">=</span><span class="n">stitching_skeleton_branches</span><span class="p">)</span>

                <span class="n">local_correspondence_stitch_revised</span> <span class="o">=</span> <span class="n">correspondence_1_to_1</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">stitching_mesh</span><span class="p">,</span>
                                                            <span class="n">local_correspondence</span><span class="o">=</span><span class="n">local_correspondnece_stitch</span><span class="p">,</span>
                                                            <span class="n">curr_limb_endpoints_must_keep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                            <span class="n">curr_soma_to_piece_touching_vertices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                            <span class="n">must_keep_labels</span><span class="o">=</span><span class="n">must_keep_labels_MAP</span><span class="p">)</span>
                
                <span class="c1">#Need to readjust the mesh correspondence idx</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">local_correspondence_stitch_revised</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stitching_mesh_idx</span><span class="p">[</span><span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_face_idx&quot;</span><span class="p">]]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Errored in 1 to 1 correspondence in stitching so just reverting to the original mesh assignments&quot;</span><span class="p">)</span>
                <span class="c1"># Setting the correspondence manually because the adaptive way did not work</span>
                <span class="n">local_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">local_correspondence_stitch_revised</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
                <span class="c1"># setting the MAP parts (the new skeletons have already been adjusted)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">local_correspondence_stitch_revised_MAP</span><span class="p">:</span>
                    <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">local_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_stitch_revised_MAP</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">local_counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># setting the MP parts (the new skeletons have not been adjusted yet so adjusting them here)</span>
                <span class="k">for</span> <span class="n">mp_idx</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">MP_branches_for_correspondence</span><span class="p">):</span>
                    <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">local_counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> 
                    <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">local_counter</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_MP_sk</span><span class="p">[</span><span class="n">mp_idx</span><span class="p">]</span>
                    <span class="n">local_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                
                
<span class="c1">#                 su.compressed_pickle(stitching_skeleton_branches,&quot;stitching_skeleton_branches&quot;)</span>
<span class="c1">#                 su.compressed_pickle(stitching_mesh,&quot;stitching_mesh&quot;)</span>
<span class="c1">#                 su.compressed_pickle(local_correspondnece_stitch,&quot;local_correspondnece_stitch&quot;)</span>
<span class="c1">#                 su.compressed_pickle(must_keep_labels_MAP,&quot;must_keep_labels_MAP&quot;)</span>
                
<span class="c1">#                 raise Exception(&quot;Something went wrong with 1 to 1 correspondence&quot;)</span>


            




            <span class="c1"># -------------- Part 16: Overwrite old branch entries (and add on one new to MAP if required a split) -------#</span>


            <span class="c1">#4a) If MAP_stitch_point_on_end_or_branch is False</span>
            <span class="c1">#- Delete the old MAP branch parts and replace with new MAP ones</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">MAP_stitch_point_on_end_or_branch</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deleting branches from dictionary&quot;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1">#adding the two new branches created from the stitching</span>
                <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1">#have to reorder the keys</span>
                <span class="c1">#limb_correspondence_MAP[MAP_idx] = dict([(k,limb_correspondence_MAP[MAP_idx][k]) for k in np.sort(list(limb_correspondence_MAP[MAP_idx].keys()))])</span>
                <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">order_dict_by_keys</span><span class="p">(</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1">#4b) Revise the meshes,  mesh_idx, and widths of the MAP pieces if weren&#39;t broken up</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_MAP_idx_fixed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">MAP_pieces_for_correspondence</span><span class="p">):</span> 
                    <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">curr_MAP_idx_fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1">#want to update all of the skeletons just in case was altered by keep_MP_stitch_static and not included in correspondence</span>
                <span class="k">if</span> <span class="n">keep_MP_stitch_static</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_MAP_sk_final</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;MAP_branches_with_stitch_point not same size as curr_MAP_sk_final&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">gg</span><span class="p">,</span><span class="n">map_idx_curr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">MAP_branches_with_stitch_point</span><span class="p">):</span>
                        <span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">][</span><span class="n">map_idx_curr</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_MAP_sk_final</span><span class="p">[</span><span class="n">gg</span><span class="p">]</span>


            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">curr_MP_idx_fixed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">MP_branches_for_correspondence</span><span class="p">):</span> <span class="c1">#************** right here just need to make only the ones that applied</span>
                <span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">curr_MP_idx_fixed</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_correspondence_stitch_revised</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_MAP_sk</span><span class="p">)]</span>


            <span class="c1">#5b) Fixing the branch skeletons that were not included in the correspondence</span>
            <span class="n">MP_leftover</span><span class="p">,</span><span class="n">MP_leftover_idx</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">MP_branches_with_stitch_point</span><span class="p">,</span><span class="n">MP_branches_for_correspondence</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP_branches_with_stitch_point= </span><span class="si">{</span><span class="n">MP_branches_with_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP_branches_for_correspondence = </span><span class="si">{</span><span class="n">MP_branches_for_correspondence</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MP_leftover = </span><span class="si">{</span><span class="n">MP_leftover</span><span class="si">}</span><span class="s2">, MP_leftover_idx = </span><span class="si">{</span><span class="n">MP_leftover_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">curr_MP_leftover</span><span class="p">,</span><span class="n">curr_MP_leftover_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">MP_leftover</span><span class="p">,</span><span class="n">MP_leftover_idx</span><span class="p">):</span>
                <span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">][</span><span class="n">curr_MP_leftover</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_MP_sk</span><span class="p">[</span><span class="n">curr_MP_leftover_idx</span><span class="p">]</span>


            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Finished with </span><span class="si">{</span><span class="p">(</span><span class="n">MP_idx</span><span class="p">,</span><span class="n">MAP_idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="se">\n\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">stitch_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1">#         if cut_flag:</span>
    <span class="c1">#             raise Exception(&quot;Cut flag was activated&quot;)</span>

            <span class="k">if</span> <span class="n">check_correspondence_branches</span><span class="p">:</span>
                <span class="n">sk</span><span class="o">.</span><span class="n">check_correspondence_branches_have_2_endpoints</span><span class="p">(</span><span class="n">limb_correspondence_MAP</span><span class="p">[</span><span class="n">MAP_idx</span><span class="p">])</span>
                <span class="n">sk</span><span class="o">.</span><span class="n">check_correspondence_branches_have_2_endpoints</span><span class="p">(</span><span class="n">limb_correspondence_MP</span><span class="p">[</span><span class="n">MP_idx</span><span class="p">])</span>
                
<span class="c1">#             su.compressed_pickle(limb_correspondence_MAP,f&quot;limb_correspondence_MAP_{MAP_idx}_{MP_idx}&quot;)</span>
<span class="c1">#             su.compressed_pickle(limb_correspondence_MP,f&quot;limb_correspondence_MP_{MAP_idx}_{MP_idx}&quot;)</span>


    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There were not both MAP and MP pieces so skipping the stitch resolving phase&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for decomp of Limb = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">curr_limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#     # ------------- Saving the MAP and MP Decompositions ---------------- #</span>
    <span class="c1">#     proper_limb_mesh_correspondence_MAP[curr_limb_idx] = limb_correspondence_MAP</span>
    <span class="c1">#     proper_limb_mesh_correspondence_MP[curr_limb_idx] = limb_correspondence_MP</span>






    <span class="c1"># -------------- Part 17: Grouping the MP and MAP Correspondence into one correspondence dictionary -------#</span>
    <span class="n">limb_correspondence_individual</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">sublimb_idx</span><span class="p">,</span><span class="n">sublimb_branches</span> <span class="ow">in</span> <span class="n">limb_correspondence_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">branch_dict</span> <span class="ow">in</span> <span class="n">sublimb_branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">=</span> <span class="n">branch_dict</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">sublimb_idx</span><span class="p">,</span><span class="n">sublimb_branches</span> <span class="ow">in</span> <span class="n">limb_correspondence_MP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">branch_dict</span> <span class="ow">in</span> <span class="n">sublimb_branches</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">=</span> <span class="n">branch_dict</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="c1">#info that may be used for concept networks</span>
    <span class="n">network_starting_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">touching_verts_list</span> <span class="o">=</span> <span class="n">limb_to_soma_touching_vertices_list</span><span class="p">,</span>
                <span class="n">endpoints_must_keep</span> <span class="o">=</span> <span class="n">limb_to_endpoints_must_keep_list</span>
    <span class="p">)</span>

    
    
    
    
    
    <span class="c1"># -------------- Part 18: 11-17 Addition that filters the network starting info into a more clean presentation ------------ #</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Rearrange the network starting info into a ditionary mapping</span>
<span class="sd">      soma_idx --&gt; branch_broder_group --&gt; list of dict(touching_vertices,endpoint)</span>

<span class="sd">    2) iterate through all the somas and border vertex groups</span>
<span class="sd">    a. filter to only those with an endpoint that is on a branch of the skeleton</span>
<span class="sd">    b1: If 1 --&gt; then keep that one</span>
<span class="sd">    b2: If more --&gt; pick the one with the endpoint closest to the average fo the vertex group</span>
<span class="sd">    b3: If 0 --&gt; find the best available soma extending branch endpoint</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Part 1: Rearrange network info</span>


    <span class="n">t_verts_list_total</span><span class="p">,</span><span class="n">enpts_list_total</span> <span class="o">=</span> <span class="n">network_starting_info</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="n">network_starting_info_revised</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">v_list_dict</span><span class="p">,</span><span class="n">enpts_list_dict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">t_verts_list_total</span><span class="p">,</span><span class="n">enpts_list_total</span><span class="p">)):</span>
        <span class="c1">#print(f&quot;---- Working on {j} -----&quot;)</span>
    <span class="c1">#     print(v_list_dict)</span>
    <span class="c1">#     print(enpts_list_dict)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v_list_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">enpts_list_dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Soma keys not match for touching vertices and endpoints&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sm_idx</span> <span class="ow">in</span> <span class="n">v_list_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">v_list_soma</span> <span class="o">=</span> <span class="n">v_list_dict</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span>
            <span class="n">endpt_soma</span> <span class="o">=</span> <span class="n">enpts_list_dict</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_list_soma</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpt_soma</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;touching vertices list and endpoint list not match size for soma </span><span class="si">{</span><span class="n">sm_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">all_border_vertex_groups</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">v_l</span><span class="p">,</span><span class="n">endpt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">v_list_soma</span><span class="p">,</span><span class="n">endpt_soma</span><span class="p">):</span>

                <span class="n">matching_border_group</span>  <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">curr_border_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_border_vertex_groups</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">test_matching_vertices_in_lists</span><span class="p">(</span><span class="n">curr_border_group</span><span class="p">,</span><span class="n">v_l</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                        <span class="n">matching_border_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_border_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_border_group</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching border groups was not exactly 1: </span><span class="si">{</span><span class="n">matching_border_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">winning_border_group</span> <span class="o">=</span> <span class="n">matching_border_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">sm_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">network_starting_info_revised</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">network_starting_info_revised</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">winning_border_group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">network_starting_info_revised</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">network_starting_info_revised</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">][</span><span class="n">winning_border_group</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">network_starting_info_revised</span><span class="p">[</span><span class="n">sm_idx</span><span class="p">][</span><span class="n">winning_border_group</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">touching_verts</span><span class="o">=</span><span class="n">v_l</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="n">endpt</span><span class="p">))</span>


    <span class="c1"># Part 2 Filter</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2) iterate through all the somas and border vertex groups</span>
<span class="sd">    a. filter to only those with an endpoint that is on a branch of the skeleton</span>
<span class="sd">    b1: If 1 --&gt; then keep that one</span>
<span class="sd">    b2: If more --&gt; pick the one with the endpoint closest to the average fo the vertex group</span>
<span class="sd">    b3: If 0 --&gt; find the best available soma extending branch endpoint</span>

<span class="sd">    Pseudocode for b3:</span>
<span class="sd">    i) get all meshes that touch the vertex group (and keep the vertices that overlap)</span>
<span class="sd">    --&gt; error if none</span>
<span class="sd">    ii) Get all of the endpoints of all matching branches</span>
<span class="sd">    iii) Filter the endpoints to only those that are degree 1 in the overall skeleton</span>
<span class="sd">    --&gt; if none then just keep all endpoints (AND THIS WILL CAUSE AN ERROR)</span>
<span class="sd">    iv) Find the closest viable endpoint to the mean of the boundary group</span>
<span class="sd">    v) save the overlap vertices and the winning endpoint as a dictionary</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">sorted_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">curr_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">]</span>
    <span class="n">curr_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorted_keys</span><span class="p">]</span>

    <span class="n">network_starting_info_revised_cleaned</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">soma_idx</span> <span class="ow">in</span> <span class="n">network_starting_info_revised</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">network_starting_info_revised_cleaned</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bound_g_idx</span><span class="p">,</span><span class="n">endpoint_list</span> <span class="ow">in</span> <span class="n">network_starting_info_revised</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">endpoint_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endpoint_list</span><span class="p">)</span>

            <span class="n">filter_on_skeleton_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">endpt_dict</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endpoint_list</span><span class="p">):</span>
                <span class="c1">#a. filter to only those with an endpoint that is on a branch of the skeleton</span>
                <span class="n">sk_indices</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="o">=</span><span class="n">curr_branches</span><span class="p">,</span>
                                                                            <span class="n">current_coordinate</span><span class="o">=</span><span class="n">endpt_dict</span><span class="p">[</span><span class="s2">&quot;endpoint&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">filter_on_skeleton_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zz</span><span class="p">)</span>

            <span class="n">endpoint_list_filt</span> <span class="o">=</span> <span class="n">endpoint_list</span><span class="p">[</span><span class="n">filter_on_skeleton_list</span><span class="p">]</span>



            <span class="n">curr_border_group_coordinates</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">][</span><span class="n">bound_g_idx</span><span class="p">]</span>
            <span class="n">boundary_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">curr_border_group_coordinates</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoint_list_filt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Only one endpoint after filtering away the endpoints that are not on the skeleton&quot;</span><span class="p">)</span>
                <span class="n">winning_dict</span> <span class="o">=</span> <span class="n">endpoint_list_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#b2: If more --&gt; pick the one with the endpoint closest to the average fo the vertex group</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoint_list_filt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MORE THAN one endpoint after filtering away the endpoints that are not on the skeleton: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">endpoint_list_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">viable_endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpt_dict</span><span class="p">[</span><span class="s2">&quot;endpoint&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">endpt_dict</span> <span class="ow">in</span> <span class="n">endpoint_list_filt</span><span class="p">]</span>


                <span class="n">distanes_from_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">viable_endpoints</span><span class="o">-</span><span class="n">boundary_mean</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">winning_endpoint_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distanes_from_mean</span><span class="p">)</span>
                <span class="n">winning_dict</span> <span class="o">=</span> <span class="n">endpoint_list_filt</span><span class="p">[</span><span class="n">winning_endpoint_idx</span><span class="p">]</span>

            <span class="c1">#if there was no clear winner</span>
            <span class="k">else</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Pseudocode for no viable options:</span>
<span class="sd">                i) get all meshes that touch the vertex group (and keep the vertices that overlap)</span>
<span class="sd">                --&gt; error if none</span>
<span class="sd">                ii) Get all of the endpoints of all matching branches</span>
<span class="sd">                iii) Filter the endpoints to only those that are degree 1 in the overall skeleton</span>
<span class="sd">                --&gt; if none then just keep all endpoints</span>
<span class="sd">                iv) Find the closest viable endpoint to the mean of the boundary group</span>
<span class="sd">                v) save the overlap vertices and the winning endpoint as a dictionary</span>


<span class="sd">                &quot;&quot;&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Having to find a new branch point&quot;</span><span class="p">)</span>
                <span class="c1">#i) get all meshes that touch the vertex group (and keep the vertices that overlap)</span>
                <span class="n">mesh_indices_on_border</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">curr_meshes</span><span class="p">,</span>
                                              <span class="n">nullifying_points</span><span class="o">=</span><span class="n">curr_border_group_coordinates</span><span class="p">,</span>
                                              <span class="n">filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">distance_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                              <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_indices_on_border</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There were no meshes that were touching the boundary group&quot;</span><span class="p">)</span>

                <span class="n">total_skeleton_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">curr_branches</span><span class="p">))</span>
                <span class="n">skeleton_branches_on_border</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_branches</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mesh_indices_on_border</span><span class="p">]</span>
                <span class="n">skeleton_branches_on_border_endpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skeleton_branches_on_border</span><span class="p">])</span>



                <span class="n">viable_endpoints</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">enpt</span> <span class="ow">in</span> <span class="n">skeleton_branches_on_border_endpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">curr_enpt_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">total_skeleton_graph</span><span class="p">,</span><span class="n">enpt</span><span class="p">,</span><span class="n">return_single_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">curr_enpt_degree</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_degree</span><span class="p">(</span><span class="n">total_skeleton_graph</span><span class="p">,</span><span class="n">curr_enpt_node</span><span class="p">)</span>
                    <span class="c1">#print(f&quot;curr_enpt_degree = {curr_enpt_degree}&quot;)</span>
                    <span class="k">if</span> <span class="n">curr_enpt_degree</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">viable_endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enpt</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_endpoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No branch endpoints were degree 1 so just using all endpoints&quot;</span><span class="p">)</span>
                    <span class="n">viable_endpoints</span> <span class="o">=</span> <span class="n">skeleton_branches_on_border_endpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

                <span class="n">distanes_from_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">viable_endpoints</span><span class="o">-</span><span class="n">boundary_mean</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">winning_endpoint</span> <span class="o">=</span> <span class="n">viable_endpoints</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distanes_from_mean</span><span class="p">)]</span>


                <span class="n">sk_indices</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">divded_skeleton</span><span class="o">=</span><span class="n">curr_branches</span><span class="p">,</span>
                                                                                        <span class="n">current_coordinate</span><span class="o">=</span><span class="n">winning_endpoint</span><span class="p">)</span>

                <span class="n">winning_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">mesh_indices_on_border</span><span class="p">,</span><span class="n">sk_indices</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">winning_branch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There was no winning branch for the creation of a new soma extending branch&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">winning_branch_single</span> <span class="o">=</span> <span class="n">winning_branch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


                <span class="n">winning_touching_vertices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_vertices_by_mesh</span><span class="p">(</span><span class="n">curr_meshes</span><span class="p">[</span><span class="n">winning_branch_single</span><span class="p">],</span><span class="n">curr_border_group_coordinates</span><span class="p">)</span>
                <span class="n">winning_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">touching_verts</span><span class="o">=</span><span class="n">winning_touching_vertices</span><span class="p">,</span><span class="n">endpoint</span><span class="o">=</span><span class="n">winning_endpoint</span><span class="p">)</span>








            <span class="n">network_starting_info_revised_cleaned</span><span class="p">[</span><span class="n">soma_idx</span><span class="p">][</span><span class="n">bound_g_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">winning_dict</span>


    <span class="c1"># -------------- Part 18: Filter the limb correspondence for any short stubs ------------ #</span>
    <span class="k">if</span> <span class="n">filter_end_nodes_from_correspondence</span><span class="p">:</span>
        <span class="n">limb_correspondence_individual</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">filter_limb_correspondence_for_end_nodes</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="o">=</span><span class="n">limb_correspondence_individual</span><span class="p">,</span>
                                                     <span class="n">mesh</span><span class="o">=</span><span class="n">limb_mesh_mparty</span><span class="p">,</span>
                                                     <span class="n">starting_info</span><span class="o">=</span><span class="n">network_starting_info_revised_cleaned</span><span class="p">,</span>
                                                    <span class="n">filter_end_node_length</span><span class="o">=</span><span class="n">filter_end_node_length</span><span class="p">,</span>
                                                    <span class="n">error_on_no_starting_coordinates</span><span class="o">=</span><span class="n">error_on_no_starting_coordinates</span><span class="p">,</span>
                                                    <span class="n">error_on_starting_coordinates_not_endnodes</span><span class="o">=</span> <span class="n">prevent_MP_starter_branch_stitches</span>

                                                    <span class="p">)</span>

    
    
    
    
    
    
    
    
    
    
    
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_concept_network</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_concept_network_starting_info</span><span class="p">:</span> <span class="c1">#because may want to calculate the concept networks later</span>
            <span class="k">return</span> <span class="n">limb_correspondence_individual</span><span class="p">,</span><span class="n">network_starting_info_revised_cleaned</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">limb_correspondence_individual</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">,</span>
                                                                        <span class="n">network_starting_info_revised_cleaned</span><span class="p">,</span>
                                                                        <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="n">run_concept_network_checks</span><span class="p">,</span>
                                                                       <span class="p">)</span>




    <span class="k">return</span> <span class="n">limb_correspondence_individual</span><span class="p">,</span><span class="n">limb_to_soma_concept_networks</span></div>


<span class="sd">&#39;&#39;&#39;</span>



<span class="sd">def preprocess_neuron(</span>
<span class="sd">                mesh=None,</span>
<span class="sd">                mesh_file=None,</span>
<span class="sd">                segment_id=None,</span>
<span class="sd">                 description=None,</span>
<span class="sd">                sig_th_initial_split=100, #for significant splitting meshes in the intial mesh split</span>
<span class="sd">                limb_threshold = 2000, #the mesh faces threshold for a mesh to be qualified as a limb (otherwise too small)</span>
<span class="sd">    </span>
<span class="sd">                filter_end_node_length=4000, #used in cleaning the skeleton during skeletonizations</span>
<span class="sd">                return_no_somas = False, #whether to error or to return an empty list for somas</span>
<span class="sd">    </span>
<span class="sd">                decomposition_type=&quot;meshafterparty&quot;,</span>
<span class="sd">                distance_by_mesh_center=True,</span>
<span class="sd">                meshparty_segment_size =100,</span>
<span class="sd">    </span>
<span class="sd">                meshparty_n_surface_downsampling = 2,</span>

<span class="sd">                somas=None, #the precomputed somas</span>
<span class="sd">                combine_close_skeleton_nodes = True,</span>
<span class="sd">                combine_close_skeleton_nodes_threshold=700,</span>

<span class="sd">                use_meshafterparty=True):</span>
<span class="sd">    pre_branch_connectivity = &quot;edges&quot;</span>
<span class="sd">    print(f&quot;use_meshafterparty = {use_meshafterparty}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    whole_processing_tiempo = time.time()</span>


<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To process the mesh into a format that can be loaded into the neuron class</span>
<span class="sd">    and used for higher order processing (how to visualize is included)</span>
<span class="sd">    </span>
<span class="sd">    This method includes the fusion</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if description is None:</span>
<span class="sd">        description = &quot;no_description&quot;</span>
<span class="sd">    if segment_id is None:</span>
<span class="sd">        #pick a random segment id</span>
<span class="sd">        segment_id = np.random.randint(100000000)</span>
<span class="sd">        print(f&quot;picking a random 7 digit segment id: {segment_id}&quot;)</span>
<span class="sd">        description += &quot;_random_id&quot;</span>


<span class="sd">    if mesh is None:</span>
<span class="sd">        if mesh_file is None:</span>
<span class="sd">            raise Exception(&quot;No mesh or mesh_file file were given&quot;)</span>
<span class="sd">        else:</span>
<span class="sd">            current_neuron = tu.load_mesh_no_processing(mesh_file)</span>
<span class="sd">    else:</span>
<span class="sd">        current_neuron = mesh</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    # -------- Phase 1: Doing Soma Detection (if Not already done) ---------- #</span>
<span class="sd">    if somas is None:</span>
<span class="sd">        soma_mesh_list,run_time,total_soma_list_sdf = sm.extract_soma_center(segment_id,</span>
<span class="sd">                                                 current_neuron.vertices,</span>
<span class="sd">                                                 current_neuron.faces)</span>
<span class="sd">    else:</span>
<span class="sd">        soma_mesh_list,run_time,total_soma_list_sdf = somas</span>
<span class="sd">        print(f&quot;Using pre-computed somas: soma_mesh_list = {soma_mesh_list}&quot;)</span>

<span class="sd">    # geting the soma centers</span>
<span class="sd">    if len(soma_mesh_list) &lt;= 0:</span>
<span class="sd">        print(f&quot;**** No Somas Found for Mesh {segment_id} so just one mesh&quot;)</span>
<span class="sd">        soma_mesh_list_centers = []</span>
<span class="sd">        if return_no_somas:</span>
<span class="sd">            return_value= soma_mesh_list_centers</span>
<span class="sd">        raise Exception(&quot;Processing of No Somas is not yet implemented yet&quot;)</span>
<span class="sd">    else:</span>
<span class="sd">        #compute the soma centers</span>
<span class="sd">        print(f&quot;Soma List = {soma_mesh_list}&quot;)</span>

<span class="sd">        soma_mesh_list_centers = sm.find_soma_centroids(soma_mesh_list)</span>
<span class="sd">        print(f&quot;soma_mesh_list_centers = {soma_mesh_list_centers}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    #--- Phase 2: getting the soma submeshes that are connected to each soma and identifiying those that aren&#39;t </span>
<span class="sd">    # ------------------ (and eliminating any mesh pieces inside the soma) ------------------------</span>

<span class="sd">    # -------- 11/13 Addition: Will remove the inside nucleus --------- #</span>
<span class="sd">    interior_time = time.time()</span>
<span class="sd">    main_mesh_total,inside_nucleus_pieces = tu.remove_mesh_interior(current_neuron,return_removed_pieces=True,</span>
<span class="sd">                                                                   try_hole_close=False)</span>
<span class="sd">    print(f&quot;Total time for removing interior = {time.time() - interior_time}&quot;)</span>


<span class="sd">    #finding the mesh pieces that contain the soma</span>
<span class="sd">    #splitting the current neuron into distinct pieces</span>
<span class="sd">    split_time = time.time()</span>
<span class="sd">    split_meshes = tu.split_significant_pieces(</span>
<span class="sd">                                main_mesh_total,</span>
<span class="sd">                                significance_threshold=sig_th_initial_split,</span>
<span class="sd">                                print_flag=False,</span>
<span class="sd">                                connectivity=pre_branch_connectivity)</span>
<span class="sd">    print(f&quot;Total time for splitting mesh = {time.time() - split_time}&quot;)</span>

<span class="sd">    print(f&quot;# total split meshes = {len(split_meshes)}&quot;)</span>

<span class="sd">    #returns the index of the split_meshes index that contains each soma    </span>
<span class="sd">    containing_mesh_indices = sm.find_soma_centroid_containing_meshes(soma_mesh_list,</span>
<span class="sd">                                            split_meshes)</span>

<span class="sd">    # filtering away any of the inside floating pieces: </span>
<span class="sd">    non_soma_touching_meshes = [m for i,m in enumerate(split_meshes)</span>
<span class="sd">                     if i not in list(containing_mesh_indices.values())]</span>

<span class="sd">    #Adding the step that will filter away any pieces that are inside the soma</span>
<span class="sd">    if len(non_soma_touching_meshes) &gt; 0 and len(soma_mesh_list) &gt; 0:</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        *** want to save these pieces that are inside of the soma***</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="sd">        non_soma_touching_meshes,inside_pieces = sm.filter_away_inside_soma_pieces(soma_mesh_list,non_soma_touching_meshes,</span>
<span class="sd">                                        significance_threshold=sig_th_initial_split,</span>
<span class="sd">                                        return_inside_pieces = True)</span>
<span class="sd">    </span>
<span class="sd">    else:</span>
<span class="sd">        non_soma_touching_meshes = []</span>
<span class="sd">        inside_pieces=[]</span>
<span class="sd">    </span>
<span class="sd">    #adding in the nuclei center to the inside pieces</span>
<span class="sd">    inside_pieces += inside_nucleus_pieces</span>


<span class="sd">    split_meshes # the meshes of the original mesh</span>
<span class="sd">    containing_mesh_indices #the mapping of each soma centroid to the correct split mesh</span>
<span class="sd">    soma_containing_meshes = sm.grouping_containing_mesh_indices(containing_mesh_indices)</span>

<span class="sd">    soma_touching_meshes = [split_meshes[k] for k in soma_containing_meshes.keys()]</span>


<span class="sd">    #     print(f&quot;# of non soma touching seperate meshes = {len(non_soma_touching_meshes)}&quot;)</span>
<span class="sd">    #     print(f&quot;# of inside pieces = {len(inside_pieces)}&quot;)</span>
<span class="sd">    print(f&quot;\n-----Before filtering away multiple disconneted soma pieces-----&quot;)</span>
<span class="sd">    print(f&quot;# of soma containing seperate meshes = {len(soma_touching_meshes)}&quot;)</span>
<span class="sd">    print(f&quot;meshes with somas = {soma_containing_meshes}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    # ------ 11/15 Addition: Part 2.b </span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the largest of the meshes with a soma (largest in soma_touching_meshes)</span>
<span class="sd">    2) Save all other meshes not the largest in </span>
<span class="sd">    3) Overwrite the following variables:</span>
<span class="sd">        soma_mesh_list</span>
<span class="sd">        soma_containing_meshes</span>
<span class="sd">        soma_touching_meshes</span>
<span class="sd">        total_soma_list_sdf</span>


<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    #1) Get the largest of the meshes with a soma (largest in soma_touching_meshes)</span>
<span class="sd">    soma_containing_meshes_keys = np.array(list(soma_containing_meshes.keys()))</span>
<span class="sd">    soma_touching_meshes = np.array([split_meshes[k] for k in soma_containing_meshes_keys])</span>
<span class="sd">    largest_soma_touching_mesh_idx = soma_containing_meshes_keys[np.argmax([len(kk.faces) for kk in soma_touching_meshes])]</span>

<span class="sd">    #2) Save all other meshes not the largest in </span>
<span class="sd">    not_processed_soma_containing_meshes_idx = np.setdiff1d(soma_containing_meshes_keys,[largest_soma_touching_mesh_idx])</span>
<span class="sd">    not_processed_soma_containing_meshes = [split_meshes[k] for k in not_processed_soma_containing_meshes_idx]</span>
<span class="sd">    print(f&quot;Number of not_processed_soma_containing_meshes = {len(not_processed_soma_containing_meshes)}&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    3) Overwrite the following variables:</span>
<span class="sd">        soma_mesh_list</span>
<span class="sd">        soma_containing_meshes</span>
<span class="sd">        soma_touching_meshes</span>
<span class="sd">        total_soma_list_sdf</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    somas_idx_to_process = soma_containing_meshes[largest_soma_touching_mesh_idx]</span>
<span class="sd">    soma_mesh_list = [soma_mesh_list[k] for k in somas_idx_to_process]</span>

<span class="sd">    soma_containing_meshes = {largest_soma_touching_mesh_idx:list(np.arange(0,len(soma_mesh_list)))}</span>

<span class="sd">    soma_touching_meshes = [split_meshes[largest_soma_touching_mesh_idx]]</span>

<span class="sd">    total_soma_list_sdf = total_soma_list_sdf[somas_idx_to_process]</span>

<span class="sd">    print(f&quot;\n-----After filtering away multiple disconneted soma pieces-----&quot;)</span>
<span class="sd">    print(f&quot;# of soma containing seperate meshes = {len(soma_touching_meshes)}&quot;)</span>
<span class="sd">    print(f&quot;meshes with somas = {soma_containing_meshes}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    #--- Phase 3:  Soma Extraction was great (but it wasn&#39;t the original soma faces), so now need to get the original soma faces and the original non-soma faces of original pieces</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    for each soma touching mesh get the following:</span>
<span class="sd">    1) original soma meshes</span>
<span class="sd">    2) significant mesh pieces touching these somas</span>
<span class="sd">    3) The soma connectivity to each of the significant mesh pieces</span>
<span class="sd">    -- later will just translate the </span>


<span class="sd">    Process: </span>

<span class="sd">    1) Final all soma faces (through soma extraction and then soma original faces function)</span>
<span class="sd">    2) Subtact all soma faces from original mesh</span>
<span class="sd">    3) Find all significant mesh pieces</span>
<span class="sd">    4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all</span>
<span class="sd">       the available somas</span>
<span class="sd">    Conclusion: Will have connectivity map</span>


<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    soma_touching_mesh_data = dict()</span>

<span class="sd">    for z,(mesh_idx, soma_idxes) in enumerate(soma_containing_meshes.items()):</span>
<span class="sd">        soma_touching_mesh_data[z] = dict()</span>
<span class="sd">        print(f&quot;\n\n----Working on soma-containing mesh piece {z}----&quot;)</span>

<span class="sd">        #1) Final all soma faces (through soma extraction and then soma original faces function)</span>
<span class="sd">        current_mesh = split_meshes[mesh_idx]</span>

<span class="sd">        current_soma_mesh_list = [soma_mesh_list[k] for k in soma_idxes]</span>

<span class="sd">        current_time = time.time()</span>
<span class="sd">        mesh_pieces_without_soma = sm.subtract_soma(current_soma_mesh_list,current_mesh,</span>
<span class="sd">                                                    significance_threshold=250,</span>
<span class="sd">                                                   connectivity=pre_branch_connectivity)</span>
<span class="sd">        print(f&quot;Total time for Subtract Soam = {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>

<span class="sd">        mesh_pieces_without_soma_stacked = tu.combine_meshes(mesh_pieces_without_soma)</span>

<span class="sd">        # find the original soma faces of mesh</span>
<span class="sd">        soma_faces = tu.original_mesh_faces_map(current_mesh,mesh_pieces_without_soma_stacked,matching=False)</span>
<span class="sd">        print(f&quot;Total time for Original_mesh_faces_map for mesh_pieces without soma= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>
<span class="sd">        soma_meshes = current_mesh.submesh([soma_faces],append=True,repair=False)</span>

<span class="sd">        # finding the non-soma original faces</span>
<span class="sd">        non_soma_faces = tu.original_mesh_faces_map(current_mesh,soma_meshes,matching=False)</span>
<span class="sd">        non_soma_stacked_mesh = current_mesh.submesh([non_soma_faces],append=True,repair=False)</span>

<span class="sd">        print(f&quot;Total time for Original_mesh_faces_map for somas= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>

<span class="sd">        #4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all the available somas</span>
<span class="sd">        # get all the seperate mesh faces</span>

<span class="sd">        #How to seperate the mesh faces</span>
<span class="sd">        seperate_soma_meshes,soma_face_components = tu.split(soma_meshes,only_watertight=False,</span>
<span class="sd">                                                            connectivity=pre_branch_connectivity)</span>
<span class="sd">        #take the top largest ones depending how many were originally in the soma list</span>
<span class="sd">        seperate_soma_meshes = seperate_soma_meshes[:len(soma_mesh_list)]</span>
<span class="sd">        soma_face_components = soma_face_components[:len(soma_mesh_list)]</span>

<span class="sd">        soma_touching_mesh_data[z][&quot;soma_meshes&quot;] = seperate_soma_meshes</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        # 3) Find all significant mesh pieces</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        a) Iterate through all of the somas and get the pieces that are connected</span>
<span class="sd">        b) Concatenate all the results into one list and order</span>
<span class="sd">        c) Filter away the mesh pieces that aren&#39;t touching and add to the floating pieces</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        sig_non_soma_pieces,insignificant_limbs = tu.split_significant_pieces(non_soma_stacked_mesh,significance_threshold=limb_threshold,</span>
<span class="sd">                                                         return_insignificant_pieces=True,</span>
<span class="sd">                                                                             connectivity=pre_branch_connectivity)</span>
<span class="sd">        </span>
<span class="sd">        # a) Filter these down to only those touching the somas</span>
<span class="sd">        all_conneted_non_soma_pieces = []</span>
<span class="sd">        for i,curr_soma in enumerate(seperate_soma_meshes):</span>
<span class="sd">            (connected_mesh_pieces,</span>
<span class="sd">             connected_mesh_pieces_vertices,</span>
<span class="sd">             connected_mesh_pieces_vertices_idx) = tu.mesh_pieces_connectivity(</span>
<span class="sd">                            main_mesh=current_mesh,</span>
<span class="sd">                            central_piece=curr_soma,</span>
<span class="sd">                            periphery_pieces = sig_non_soma_pieces,</span>
<span class="sd">                            return_vertices = True,</span>
<span class="sd">                            return_vertices_idx=True)</span>
<span class="sd">            all_conneted_non_soma_pieces.append(connected_mesh_pieces)</span>
<span class="sd">        </span>
<span class="sd">        #b) Iterate through all of the somas and get the pieces that are connected</span>
<span class="sd">        t_non_soma_pieces = np.concatenate(all_conneted_non_soma_pieces)</span>
<span class="sd">        </span>
<span class="sd">        #c) Filter away the mesh pieces that aren&#39;t touching and add to the floating pieces</span>
<span class="sd">        sig_non_soma_pieces = [s_t for hh,s_t in enumerate(sig_non_soma_pieces) if hh in t_non_soma_pieces]</span>
<span class="sd">        new_floating_pieces = [s_t for hh,s_t in enumerate(sig_non_soma_pieces) if hh not in t_non_soma_pieces]</span>
<span class="sd">        </span>
<span class="sd">        print(f&quot;new_floating_pieces = {new_floating_pieces}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        non_soma_touching_meshes += new_floating_pieces</span>
<span class="sd">        </span>
<span class="sd">        </span>

<span class="sd">        print(f&quot;Total time for sig_non_soma_pieces= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>

<span class="sd">        soma_touching_mesh_data[z][&quot;branch_meshes&quot;] = sig_non_soma_pieces</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>

<span class="sd">        print(f&quot;Total time for split= {time.time() - current_time}&quot;)</span>
<span class="sd">        current_time = time.time()</span>



<span class="sd">        soma_to_piece_connectivity = dict()</span>
<span class="sd">        soma_to_piece_touching_vertices = dict()</span>
<span class="sd">        soma_to_piece_touching_vertices_idx = dict()</span>
<span class="sd">        limb_root_nodes = dict()</span>

<span class="sd">        m_vert_graph = tu.mesh_vertex_graph(current_mesh)</span>

<span class="sd">        for i,curr_soma in enumerate(seperate_soma_meshes):</span>
<span class="sd">            (connected_mesh_pieces,</span>
<span class="sd">             connected_mesh_pieces_vertices,</span>
<span class="sd">             connected_mesh_pieces_vertices_idx) = tu.mesh_pieces_connectivity(</span>
<span class="sd">                            main_mesh=current_mesh,</span>
<span class="sd">                            central_piece=curr_soma,</span>
<span class="sd">                            periphery_pieces = sig_non_soma_pieces,</span>
<span class="sd">                            return_vertices = True,</span>
<span class="sd">                            return_vertices_idx=True)</span>
<span class="sd">            #print(f&quot;soma {i}: connected_mesh_pieces = {connected_mesh_pieces}&quot;)</span>
<span class="sd">            soma_to_piece_connectivity[i] = connected_mesh_pieces</span>

<span class="sd">            soma_to_piece_touching_vertices[i] = dict()</span>
<span class="sd">            for piece_index,piece_idx in enumerate(connected_mesh_pieces):</span>
<span class="sd">                limb_root_nodes[piece_idx] = connected_mesh_pieces_vertices[piece_index][0]</span>

<span class="sd">                &quot;&quot;&quot; Old way of finding vertex connected components on a mesh without trimesh function</span>
<span class="sd">                #find the number of touching groups and save those </span>
<span class="sd">                soma_touching_graph = m_vert_graph.subgraph(connected_mesh_pieces_vertices_idx[piece_index])</span>
<span class="sd">                soma_con_comp = [current_mesh.vertices[np.array(list(k)).astype(&quot;int&quot;)] for k in list(nx.connected_components(soma_touching_graph))]</span>
<span class="sd">                soma_to_piece_touching_vertices[i][piece_idx] = soma_con_comp</span>
<span class="sd">                &quot;&quot;&quot;</span>

<span class="sd">                soma_to_piece_touching_vertices[i][piece_idx] = tu.split_vertex_list_into_connected_components(</span>
<span class="sd">                                                    vertex_indices_list=connected_mesh_pieces_vertices_idx[piece_index],</span>
<span class="sd">                                                    mesh=current_mesh, </span>
<span class="sd">                                                    vertex_graph=m_vert_graph, </span>
<span class="sd">                                                    return_coordinates=True</span>
<span class="sd">                                                   )</span>





<span class="sd">    #         border_debug = False</span>
<span class="sd">    #         if border_debug:</span>
<span class="sd">    #             print(f&quot;soma_to_piece_connectivity = {soma_to_piece_connectivity}&quot;)</span>
<span class="sd">    #             print(f&quot;soma_to_piece_touching_vertices = {soma_to_piece_touching_vertices}&quot;)</span>


<span class="sd">        print(f&quot;Total time for mesh_pieces_connectivity= {time.time() - current_time}&quot;)</span>

<span class="sd">        soma_touching_mesh_data[z][&quot;soma_to_piece_connectivity&quot;] = soma_to_piece_connectivity</span>

<span class="sd">    print(f&quot;# of insignificant_limbs = {len(insignificant_limbs)} with trimesh : {insignificant_limbs}&quot;)</span>
<span class="sd">    print(f&quot;# of not_processed_soma_containing_meshes = {len(not_processed_soma_containing_meshes)} with trimesh : {not_processed_soma_containing_meshes}&quot;)</span>
<span class="sd">    </span>



<span class="sd">    # Lets have an alert if there was more than one soma disconnected meshes</span>
<span class="sd">    if len(soma_touching_mesh_data.keys()) &gt; 1:</span>
<span class="sd">        raise Exception(&quot;More than 1 disconnected meshes that contain somas&quot;)</span>

<span class="sd">    current_mesh_data = soma_touching_mesh_data</span>
<span class="sd">    soma_containing_idx = 0</span>

<span class="sd">    #doing inversion of the connectivity and touching vertices</span>
<span class="sd">    piece_to_soma_touching_vertices = gu.flip_key_orders_for_dict(soma_to_piece_touching_vertices)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    # Phase 4: Skeletonization, Mesh Correspondence,  </span>

<span class="sd">    proper_time = time.time()</span>

<span class="sd">    #The containers that will hold the final data for the preprocessed neuron</span>
<span class="sd">    limb_correspondence=dict()</span>
<span class="sd">    limb_network_stating_info = dict()</span>

<span class="sd">    # ---------- Part A: skeletonization and mesh decomposition --------- #</span>
<span class="sd">    skeleton_time = time.time()</span>

<span class="sd">    for curr_limb_idx,limb_mesh_mparty in enumerate(current_mesh_data[0][&quot;branch_meshes&quot;]):</span>

<span class="sd">        #Arguments to pass to the specific function (when working with a limb)</span>
<span class="sd">        soma_touching_vertices_dict = piece_to_soma_touching_vertices[curr_limb_idx]</span>

<span class="sd">    #     if curr_limb_idx != 10:</span>
<span class="sd">    #         continue</span>

<span class="sd">        curr_limb_time = time.time()</span>
<span class="sd">        print(f&quot;\n\n----- Working on Proper Limb # {curr_limb_idx} ---------&quot;)</span>

<span class="sd">        print(f&quot;meshparty_segment_size = {meshparty_segment_size}&quot;)</span>
<span class="sd">        limb_correspondence_individual,network_starting_info = preprocess_limb(mesh=limb_mesh_mparty,</span>
<span class="sd">                       soma_touching_vertices_dict = soma_touching_vertices_dict,</span>
<span class="sd">                       return_concept_network = False, </span>
<span class="sd">                       return_concept_network_starting_info=True,</span>
<span class="sd">                       width_threshold_MAP=500,</span>
<span class="sd">                       size_threshold_MAP=2000,</span>
<span class="sd">                       surface_reconstruction_size=1000,  </span>

<span class="sd">                       #arguments added from the big preprocessing step                                                            </span>
<span class="sd">                       distance_by_mesh_center=distance_by_mesh_center,</span>
<span class="sd">                       meshparty_segment_size=meshparty_segment_size,</span>
<span class="sd">                       meshparty_n_surface_downsampling = meshparty_n_surface_downsampling,</span>
<span class="sd">                                                                               </span>
<span class="sd">                        use_meshafterparty=use_meshafterparty,</span>
<span class="sd">                        error_on_no_starting_coordinates=True</span>

<span class="sd">                       )</span>
<span class="sd">        #Storing all of the data to be sent to </span>

<span class="sd">        limb_correspondence[curr_limb_idx] = limb_correspondence_individual</span>
<span class="sd">        limb_network_stating_info[curr_limb_idx] = network_starting_info</span>
<span class="sd">        </span>
<span class="sd">    print(f&quot;Total time for Skeletonization and Mesh Correspondence = {time.time() - skeleton_time}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    # ---------- Part B: Stitching on floating pieces --------- #</span>
<span class="sd">    print(&quot;\n\n ----- Working on Stitching ----------&quot;)</span>
<span class="sd">    </span>
<span class="sd">#     # --- Get the soma connecting points that don&#39;t want to stitch to ---- #</span>
<span class="sd">#     excluded_node_coordinates = []</span>
<span class="sd">#     for limb_idx,limb_start_v in limb_network_stating_info.items():</span>
<span class="sd">#         for soma_idx,soma_v in limb_start_v.items():</span>
<span class="sd">#             for soma_group_idx,group_v in soma_v.items():</span>
<span class="sd">#                 excluded_node_coordinates.append(group_v[&quot;endpoint&quot;])</span>

<span class="sd">    excluded_node_coordinates = nru.all_soma_connnecting_endpionts_from_starting_info(limb_network_stating_info)</span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    floating_stitching_time = time.time()</span>
<span class="sd">    </span>
<span class="sd">    if len(limb_correspondence) &gt; 0:</span>
<span class="sd">        non_soma_touching_meshes_to_stitch = tu.check_meshes_outside_multiple_mesh_bbox(seperate_soma_meshes,non_soma_touching_meshes,</span>
<span class="sd">                                 return_indices=False)</span>
<span class="sd">        </span>
<span class="sd">        limb_correspondence_with_floating_pieces = attach_floating_pieces_to_limb_correspondence(</span>
<span class="sd">                limb_correspondence,</span>
<span class="sd">                floating_meshes=non_soma_touching_meshes_to_stitch,</span>
<span class="sd">                floating_piece_face_threshold = 600,</span>
<span class="sd">                max_stitch_distance=8000,</span>
<span class="sd">                distance_to_move_point_threshold = 4000,</span>
<span class="sd">                verbose = False,</span>
<span class="sd">                excluded_node_coordinates = excluded_node_coordinates)</span>
<span class="sd">    else:</span>
<span class="sd">        limb_correspondence_with_floating_pieces = limb_correspondence</span>
<span class="sd">        </span>



<span class="sd">    print(f&quot;Total time for stitching floating pieces = {time.time() - floating_stitching_time}&quot;)</span>





<span class="sd">    # ---------- Part C: Computing Concept Networks --------- #</span>
<span class="sd">    concept_network_time = time.time()</span>

<span class="sd">    limb_concept_networks=dict()</span>
<span class="sd">    limb_labels=dict()</span>

<span class="sd">    for curr_limb_idx,limb_mesh_mparty in enumerate(current_mesh_data[0][&quot;branch_meshes&quot;]):</span>
<span class="sd">        limb_to_soma_concept_networks = calculate_limb_concept_networks(limb_correspondence_with_floating_pieces[curr_limb_idx],</span>
<span class="sd">                                                                        limb_network_stating_info[curr_limb_idx],</span>
<span class="sd">                                                                        run_concept_network_checks=True,</span>
<span class="sd">                                                                           )   </span>



<span class="sd">        limb_concept_networks[curr_limb_idx] = limb_to_soma_concept_networks</span>
<span class="sd">        limb_labels[curr_limb_idx]= &quot;Unlabeled&quot;</span>

<span class="sd">    print(f&quot;Total time for Concept Networks = {time.time() - concept_network_time}&quot;)</span>



<span class="sd">    #------ 1/11/ getting the glia faces --------------</span>
<span class="sd">    if glia_meshes is not None and len(glia_meshes)&gt;0:</span>
<span class="sd">            glia_faces = tu.original_mesh_faces_map(current_neuron,tu.combine_meshes(glia_pieces))</span>
<span class="sd">    else:</span>
<span class="sd">        glia_faces = np.array([])</span>

<span class="sd">    preprocessed_data= dict(</span>
<span class="sd">        soma_meshes = current_mesh_data[0][&quot;soma_meshes&quot;],</span>
<span class="sd">        soma_to_piece_connectivity = current_mesh_data[0][&quot;soma_to_piece_connectivity&quot;],</span>
<span class="sd">        soma_sdfs = total_soma_list_sdf,</span>
<span class="sd">        insignificant_limbs=insignificant_limbs,</span>
<span class="sd">        not_processed_soma_containing_meshes=not_processed_soma_containing_meshes,</span>
<span class="sd">        glia_faces = glia_faces,</span>
<span class="sd">        non_soma_touching_meshes=non_soma_touching_meshes,</span>
<span class="sd">        inside_pieces=inside_pieces,</span>
<span class="sd">        limb_correspondence=limb_correspondence_with_floating_pieces,</span>
<span class="sd">        limb_concept_networks=limb_concept_networks,</span>
<span class="sd">        limb_network_stating_info=limb_network_stating_info,</span>
<span class="sd">        limb_labels=limb_labels,</span>
<span class="sd">        limb_meshes=current_mesh_data[0][&quot;branch_meshes&quot;],</span>
<span class="sd">        )</span>



<span class="sd">    print(f&quot;Total time for all mesh and skeletonization decomp = {time.time() - proper_time}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    return preprocessed_data&#39;&#39;&#39;</span>
    
    
    




<div class="viewcode-block" id="preprocess_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.preprocess_neuron">[docs]</a><span class="k">def</span> <span class="nf">preprocess_neuron</span><span class="p">(</span>
    <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
     <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    
    
    <span class="c1"># ---------------- all the parameters that control preprocessing -------------</span>
    <span class="n">sig_th_initial_split</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="c1">#for significant splitting meshes in the intial mesh split</span>
    <span class="n">limb_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="c1">#the mesh faces threshold for a mesh to be qualified as a limb (otherwise too small)</span>
    
    
    <span class="c1"># ------- 12/29 for the limb expansion --------------</span>
    <span class="n">apply_expansion</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">floating_piece_face_threshold_expansion</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="n">max_distance_threshold_expansion</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">min_n_faces_on_path_expansion</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span>

    <span class="n">filter_end_node_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#used in cleaning the skeleton during skeletonizations</span>
    

    <span class="n">decomposition_type</span><span class="o">=</span><span class="s2">&quot;meshafterparty&quot;</span><span class="p">,</span>
    <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">meshparty_segment_size</span> <span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">meshparty_n_surface_downsampling</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>

    
    <span class="n">combine_close_skeleton_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">combine_close_skeleton_nodes_threshold</span><span class="o">=</span><span class="mi">700</span><span class="p">,</span>
    
    <span class="c1">#parameters for prprocess limb</span>
    <span class="n">width_threshold_MAP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">size_threshold_MAP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">surface_reconstruction_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#1000,</span>
    
    <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#600,</span>
    <span class="n">max_stitch_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#8000,</span>
    <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
    
    

    
    <span class="c1"># --------- non-parameter flags -------------------------</span>
    <span class="n">glia_faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">nuclei_faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">somas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#the precomputed somas</span>
    <span class="n">return_no_somas</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#whether to error or to return an empty list for somas</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_adaptive_invalidation_d_floating</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    
    <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_threshold_MAP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_threshold_MAP</span> <span class="o">=</span> <span class="n">width_threshold_MAP_global</span>
    <span class="k">if</span> <span class="n">size_threshold_MAP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size_threshold_MAP</span> <span class="o">=</span> <span class="n">size_threshold_MAP_global</span>
    <span class="k">if</span> <span class="n">apply_expansion</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">apply_expansion</span> <span class="o">=</span> <span class="n">apply_expansion_global</span>
    <span class="k">if</span> <span class="n">max_stitch_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="n">max_stitch_distance_global</span>
    <span class="k">if</span> <span class="n">max_stitch_distance_CGAL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="n">max_stitch_distance_CGAL_global</span>
    <span class="k">if</span> <span class="n">filter_end_node_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="n">filter_end_node_length_global</span>
    <span class="k">if</span> <span class="n">axon_width_preprocess_limb_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="n">axon_width_preprocess_limb_max_global</span>
    <span class="k">if</span> <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="n">limb_remove_mesh_interior_face_threshold_global</span>
    <span class="k">if</span> <span class="n">surface_reconstruction_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">surface_reconstruction_size</span> <span class="o">=</span> <span class="n">surface_reconstruction_size_global</span>
        
    <span class="k">if</span> <span class="n">floating_piece_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_global</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to return preprocess dict of a neuron</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_remove_mesh_interior_face_threshold = </span><span class="si">{</span><span class="n">limb_remove_mesh_interior_face_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">pre_branch_connectivity</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span>
    
    <span class="k">if</span> <span class="s2">&quot;meshafterparty&quot;</span> <span class="ow">in</span> <span class="n">decomposition_type</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="n">use_meshafterparty</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_meshafterparty</span> <span class="o">=</span> <span class="kc">False</span>
    
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;use_meshafterparty = </span><span class="si">{</span><span class="n">use_meshafterparty</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">whole_processing_tiempo</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To process the mesh into a format that can be loaded into the neuron class</span>
<span class="sd">    and used for higher order processing (how to visualize is included)</span>
<span class="sd">    </span>
<span class="sd">    This method includes the fusion</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;no_description&quot;</span>
    <span class="k">if</span> <span class="n">segment_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#pick a random segment id</span>
        <span class="n">segment_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;picking a random 7 digit segment id: </span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">description</span> <span class="o">+=</span> <span class="s2">&quot;_random_id&quot;</span>


    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mesh_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No mesh or mesh_file file were given&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">mesh_file</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">mesh</span>
        
        
        
        
        
        
    <span class="c1"># -------- Phase 1: Doing Soma Detection (if Not already done) ---------- #</span>
    <span class="k">if</span> <span class="n">somas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span> 
         <span class="n">run_time</span><span class="p">,</span> 
         <span class="n">total_soma_list_sdf</span><span class="p">,</span>
         <span class="n">glia_pieces</span><span class="p">,</span>
         <span class="n">nuclei_pieces</span><span class="p">)</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">extract_soma_center</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span>
                                                 <span class="n">current_neuron</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                                 <span class="n">current_neuron</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">glia_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">))</span>
            <span class="n">n_glia_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_faces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glia_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_glia_faces</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_pieces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">nuclei_pieces</span><span class="p">))</span>
            <span class="n">n_nuclei_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_faces</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_nuclei_faces</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">soma_mesh_list</span><span class="p">,</span><span class="n">run_time</span><span class="p">,</span><span class="n">total_soma_list_sdf</span> <span class="o">=</span> <span class="n">somas</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using pre-computed somas: soma_mesh_list = </span><span class="si">{</span><span class="n">soma_mesh_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># geting the soma centers</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;**** No Somas Found for Mesh </span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2"> so just one mesh&quot;</span><span class="p">)</span>
        <span class="n">soma_mesh_list_centers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">return_no_somas</span><span class="p">:</span>
            <span class="n">return_value</span><span class="o">=</span> <span class="n">soma_mesh_list_centers</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Processing of No Somas is not yet implemented yet&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#compute the soma centers</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma List = </span><span class="si">{</span><span class="n">soma_mesh_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">soma_mesh_list_centers</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">find_soma_centroids</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_mesh_list_centers = </span><span class="si">{</span><span class="n">soma_mesh_list_centers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
        
        
    
    <span class="n">print_optimize</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1">#--- Phase 2: getting the soma submeshes that are connected to each soma and identifiying those that aren&#39;t </span>
    <span class="c1"># ------------------ (and eliminating any mesh pieces inside the soma) ------------------------</span>

    <span class="c1"># -------- 11/13 Addition: Will remove the inside nucleus --------- #</span>

    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">glia_faces</span><span class="p">,</span><span class="n">nuclei_faces</span>

    <span class="k">if</span> <span class="n">glia_faces</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nuclei_faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">main_mesh_total</span><span class="p">,</span><span class="n">glia_meshes</span><span class="p">,</span><span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">remove_nuclei_and_glia_meshes</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using pre-computed glia and nuclei pieces&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">glia_meshes</span> <span class="o">+</span> <span class="n">nuclei_meshes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">current_neuron</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">nuclei_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">nuclei_meshes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">total_eliminated_faces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">glia_faces</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">nuclei_faces</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_eliminated_faces</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">total_eliminated_faces</span><span class="p">)</span>
            <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces_to_keep</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">current_neuron</span>


    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting Glia and Nuclei Pieces Subtracted Away </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


    <span class="c1">#finding the mesh pieces that contain the soma</span>
    <span class="c1">#splitting the current neuron into distinct pieces</span>



    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


    <span class="n">split_meshes</span><span class="p">,</span><span class="n">split_meshes_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span>
                                <span class="n">main_mesh_total</span><span class="p">,</span>
                                <span class="n">significance_threshold</span><span class="o">=</span><span class="n">sig_th_initial_split</span><span class="p">,</span>
                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">return_face_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">connectivity</span><span class="o">=</span><span class="n">pre_branch_connectivity</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Splitting mesh after soma cancellation </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of split_meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;  Newer slower way of doing it    </span>

<span class="sd">    tu.two_mesh_list_connectivity(soma_mesh_list,split_meshes_face_idx,main_mesh_total)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#returns the index of the split_meshes index that contains each soma    </span>
    <span class="n">containing_mesh_indices</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">find_soma_centroid_containing_meshes</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span>
                                            <span class="n">split_meshes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Containing Mesh Indices </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;containing_mesh_indices = </span><span class="si">{</span><span class="n">containing_mesh_indices</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    

    <span class="c1"># filtering away any of the inside floating pieces: </span>
    <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="o">.</span><span class="n">values</span><span class="p">()))]</span>

    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; non_soma_touching_meshes </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#Adding the step that will filter away any pieces that are inside the soma</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *** want to save these pieces that are inside of the soma***</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">non_soma_touching_meshes</span><span class="p">,</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">filter_away_inside_soma_pieces</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                        <span class="n">significance_threshold</span><span class="o">=</span><span class="n">sig_th_initial_split</span><span class="p">,</span>
                                        <span class="n">return_inside_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">inside_pieces</span><span class="o">=</span><span class="p">[]</span>

    <span class="k">if</span> <span class="n">print_optimize</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Finding inside pieces and non_soma_touching meshes </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">optimize_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">optimize_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># --------------------- 1/10 Change ---------------- #</span>

    <span class="c1">#adding in the nuclei center to the inside pieces</span>
    <span class="n">inside_pieces</span> <span class="o">+=</span> <span class="n">nuclei_meshes</span>


    <span class="n">split_meshes</span> <span class="c1"># the meshes of the original mesh</span>
    <span class="n">containing_mesh_indices</span> <span class="c1">#the mapping of each soma centroid to the correct split mesh</span>
    <span class="n">soma_containing_meshes</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">grouping_containing_mesh_indices</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_containing_meshes = </span><span class="si">{</span><span class="n">soma_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#     print(f&quot;# of non soma touching seperate meshes = {len(non_soma_touching_meshes)}&quot;)</span>
    <span class="c1">#     print(f&quot;# of inside pieces = {len(inside_pieces)}&quot;)</span>
<span class="w">    </span>

<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;  1/18 Addition that combines all soma meshes</span>
<span class="sd">    </span>
<span class="sd">    # ------ 11/15 Addition: Part 2.b </span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the largest of the meshes with a soma (largest in soma_touching_meshes)</span>
<span class="sd">    2) Save all other meshes not the largest in </span>
<span class="sd">    3) Overwrite the following variables:</span>
<span class="sd">        soma_mesh_list</span>
<span class="sd">        soma_containing_meshes</span>
<span class="sd">        soma_touching_meshes</span>
<span class="sd">        total_soma_list_sdf</span>


<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    #1) Get the largest of the meshes with a soma (largest in soma_touching_meshes)</span>
<span class="sd">    soma_containing_meshes_keys = np.array(list(soma_containing_meshes.keys()))</span>
<span class="sd">    soma_touching_meshes = np.array([split_meshes[k] for k in soma_containing_meshes_keys])</span>
<span class="sd">    largest_soma_touching_mesh_idx = soma_containing_meshes_keys[np.argmax([len(kk.faces) for kk in soma_touching_meshes])]</span>

<span class="sd">    #2) Save all other meshes not the largest in </span>
<span class="sd">    not_processed_soma_containing_meshes_idx = np.setdiff1d(soma_containing_meshes_keys,[largest_soma_touching_mesh_idx])</span>
<span class="sd">    not_processed_soma_containing_meshes = [split_meshes[k] for k in not_processed_soma_containing_meshes_idx]</span>
<span class="sd">    print(f&quot;Number of not_processed_soma_containing_meshes = {len(not_processed_soma_containing_meshes)}&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    3) Overwrite the following variables:</span>
<span class="sd">        soma_mesh_list</span>
<span class="sd">        soma_containing_meshes</span>
<span class="sd">        soma_touching_meshes</span>
<span class="sd">        total_soma_list_sdf</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    somas_idx_to_process = soma_containing_meshes[largest_soma_touching_mesh_idx]</span>
<span class="sd">    soma_mesh_list = [soma_mesh_list[k] for k in somas_idx_to_process]</span>

<span class="sd">    soma_containing_meshes = {largest_soma_touching_mesh_idx:list(np.arange(0,len(soma_mesh_list)))}</span>

<span class="sd">    soma_touching_meshes = [split_meshes[largest_soma_touching_mesh_idx]]</span>

<span class="sd">    total_soma_list_sdf = total_soma_list_sdf[somas_idx_to_process]</span>

<span class="sd">    print(f&quot;\n-----After filtering away multiple disconneted soma pieces-----&quot;)</span>
<span class="sd">    print(f&quot;# of soma containing seperate meshes = {len(soma_touching_meshes)}&quot;)</span>
<span class="sd">    print(f&quot;meshes with somas = {soma_containing_meshes}&quot;)</span>


<span class="sd">    if print_optimize:</span>
<span class="sd">        print(f&quot; Filtering Away Disconnected Soma Pieces {time.time()-optimize_time}&quot;)</span>
<span class="sd">    optimize_time = time.time()</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-----Before combining multiple mesh pieces-----&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_containing_meshes = </span><span class="si">{</span><span class="n">soma_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">soma_containing_meshes_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">combined_soma_containing_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">split_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_containing_meshes_keys</span><span class="p">])</span>
    <span class="n">not_processed_soma_containing_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#rewriting the </span>
    <span class="n">soma_containing_meshes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)))}</span>
    <span class="n">soma_containing_meshes_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-----After combining multiple mesh pieces-----&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_containing_meshes = </span><span class="si">{</span><span class="n">soma_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        <span class="c1">#--- Phase 3:  Soma Extraction was great (but it wasn&#39;t the original soma faces), so now need to get the original soma faces and the original non-soma faces of original pieces</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for each soma touching mesh get the following:</span>
<span class="sd">    1) original soma meshes</span>
<span class="sd">    2) significant mesh pieces touching these somas</span>
<span class="sd">    3) The soma connectivity to each of the significant mesh pieces</span>
<span class="sd">    -- later will just translate the </span>


<span class="sd">    Process: </span>

<span class="sd">    1) Final all soma faces (through soma extraction and then soma original faces function)</span>
<span class="sd">    2) Subtact all soma faces from original mesh</span>
<span class="sd">    3) Find all significant mesh pieces</span>
<span class="sd">    4) Backtrack significant mesh pieces to orignal mesh and find connectivity of each to all</span>
<span class="sd">       the available somas</span>
<span class="sd">    Conclusion: Will have connectivity map</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">soma_touching_mesh_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">z</span><span class="p">,(</span><span class="n">mesh_idx</span><span class="p">,</span> <span class="n">soma_idxes</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">----Working on soma-containing mesh piece </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1">#1) Final all soma faces (through soma extraction and then soma original faces function)</span>
        <span class="n">current_mesh</span> <span class="o">=</span> <span class="n">combined_soma_containing_mesh</span>

        <span class="n">current_soma_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_mesh_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_idxes</span><span class="p">]</span>



        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Old Way</span>
<span class="sd">        seperate_soma_meshes = current_soma_mesh_list</span>
<span class="sd">        non_soma_stacked_mesh_face_idx = tu.original_mesh_faces_map(original_mesh=current_mesh,</span>
<span class="sd">                                      submesh=tu.combine_meshes(current_soma_mesh_list),</span>
<span class="sd">                                      exact_match = True,</span>
<span class="sd">                                    matching=False)</span>

<span class="sd">        non_soma_stacked_mesh = current_mesh.submesh([non_soma_stacked_mesh_face_idx],append=True,repair=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">seperate_soma_meshes_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span>
                                  <span class="n">submesh</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                  <span class="n">exact_match</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">current_soma_mesh_list</span><span class="p">]</span>
        <span class="n">seperate_soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">k</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">seperate_soma_meshes_idx</span><span class="p">]</span>

        <span class="n">non_soma_stacked_mesh</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">seperate_soma_meshes_idx</span><span class="p">))],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seperate_soma_meshes</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Subtract Soma and Original_mesh_faces_map for somas= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>



        <span class="c1"># 3) Find all significant mesh pieces</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        a) Iterate through all of the somas and get the pieces that are connected</span>
<span class="sd">        b) Concatenate all the results into one list and order</span>
<span class="sd">        c) Filter away the mesh pieces that aren&#39;t touching and add to the floating pieces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sig_non_soma_pieces</span><span class="p">,</span><span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">non_soma_stacked_mesh</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="n">limb_threshold</span><span class="p">,</span>
                                                         <span class="n">return_insignificant_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                             <span class="n">connectivity</span><span class="o">=</span><span class="n">pre_branch_connectivity</span><span class="p">)</span>

        <span class="c1"># a) Filter these down to only those touching the somas</span>
        <span class="n">all_conneted_non_soma_pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">curr_soma</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seperate_soma_meshes</span><span class="p">):</span>
            <span class="p">(</span><span class="n">connected_mesh_pieces</span><span class="p">,</span>
             <span class="n">connected_mesh_pieces_vertices</span><span class="p">,</span>
             <span class="n">connected_mesh_pieces_vertices_idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span>
                            <span class="n">main_mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span>
                            <span class="n">central_piece</span><span class="o">=</span><span class="n">curr_soma</span><span class="p">,</span>
                            <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">sig_non_soma_pieces</span><span class="p">,</span>
                            <span class="n">return_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">return_vertices_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">all_conneted_non_soma_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connected_mesh_pieces</span><span class="p">)</span>

        <span class="c1">#b) Iterate through all of the somas and get the pieces that are connected</span>
        <span class="n">t_non_soma_pieces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_conneted_non_soma_pieces</span><span class="p">)</span>

        <span class="c1">#c) Filter away the mesh pieces that aren&#39;t touching and add to the floating pieces</span>
        <span class="n">sig_non_soma_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_t</span> <span class="k">for</span> <span class="n">hh</span><span class="p">,</span><span class="n">s_t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig_non_soma_pieces</span><span class="p">)</span> <span class="k">if</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">t_non_soma_pieces</span><span class="p">]</span>
        <span class="n">new_floating_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">s_t</span> <span class="k">for</span> <span class="n">hh</span><span class="p">,</span><span class="n">s_t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sig_non_soma_pieces</span><span class="p">)</span> <span class="k">if</span> <span class="n">hh</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t_non_soma_pieces</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_floating_pieces = </span><span class="si">{</span><span class="n">new_floating_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">non_soma_touching_meshes</span> <span class="o">+=</span> <span class="n">new_floating_pieces</span>
        
<span class="c1">#         non_soma_touching_meshes_to_stitch = tu.check_meshes_outside_multiple_mesh_bbox(seperate_soma_meshes,non_soma_touching_meshes,</span>
<span class="c1">#                                  return_indices=False)</span>
        
<span class="c1">#         su.compressed_pickle(non_soma_touching_meshes_to_stitch,&quot;non_soma_touching_meshes_to_stitch&quot;)</span>
<span class="c1">#         raise Exception(&quot;&quot;)</span>



        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for sig_non_soma_pieces= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        


        <span class="c1"># -------- 12/29: Part that will expand the limbs that need to be processed ------</span>
        
<span class="c1">#         su.compressed_pickle(non_soma_touching_meshes,&quot;non_soma_touching_meshes&quot;)</span>
<span class="c1">#         su.compressed_pickle(insignificant_limbs,&quot;insignificant_limbs&quot;)</span>
<span class="c1">#         su.compressed_pickle(seperate_soma_meshes,&quot;seperate_soma_meshes&quot;)</span>
<span class="c1">#         print(f&quot;floating_piece_face_threshold_expansion = {floating_piece_face_threshold_expansion}&quot;)</span>
<span class="c1">#         print(f&quot;max_distance_threshold_expansion = {max_distance_threshold_expansion}&quot;)</span>
<span class="c1">#         print(f&quot;min_n_faces_on_path_expansion = {min_n_faces_on_path_expansion}&quot;)</span>
<span class="c1">#         raise Exception(&quot;&quot;)</span>
        
        <span class="k">if</span> <span class="n">apply_expansion</span><span class="p">:</span>
            <span class="n">new_limbs_nst</span><span class="p">,</span><span class="n">new_limbs_il</span><span class="p">,</span><span class="n">nst_still_meshes</span><span class="p">,</span><span class="n">il_still_meshes</span><span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">limb_meshes_expansion</span><span class="p">(</span>
                <span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                <span class="n">insignificant_limbs</span><span class="p">,</span>
                <span class="n">seperate_soma_meshes</span><span class="p">,</span>

                <span class="c1">#Step 1: Filering</span>
                <span class="n">plot_filtered_pieces</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">non_soma_touching_meshes_face_min</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_expansion</span><span class="p">,</span>
                <span class="n">insignificant_limbs_face_min</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_expansion</span><span class="p">,</span>

                <span class="c1">#Step 2: Distance Graph Structure</span>
                <span class="n">plot_distance_G</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">plot_distance_G_thresholded</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">max_distance_threshold</span> <span class="o">=</span> <span class="n">max_distance_threshold_expansion</span><span class="p">,</span>

                <span class="c1">#Step 3: </span>
                <span class="n">min_n_faces_on_path</span> <span class="o">=</span> <span class="n">min_n_faces_on_path_expansion</span><span class="p">,</span>
                <span class="n">plot_final_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">plot_not_added_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                <span class="p">)</span>

            <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nst_still_meshes</span><span class="p">)</span>
            <span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">il_still_meshes</span><span class="p">)</span>
            <span class="n">sig_non_soma_pieces</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_limbs_il</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not applying expansions&quot;</span><span class="p">)</span>
            <span class="n">new_limbs_nst</span> <span class="o">=</span> <span class="p">[]</span>
            
        



        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for split= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>



        <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">soma_to_piece_touching_vertices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">soma_to_piece_touching_vertices_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">limb_root_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1">#m_vert_graph = tu.mesh_vertex_graph(current_mesh)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">curr_soma</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seperate_soma_meshes</span><span class="p">):</span>
            <span class="p">(</span><span class="n">connected_mesh_pieces</span><span class="p">,</span>
             <span class="n">connected_mesh_pieces_vertices</span><span class="p">,</span>
             <span class="n">connected_mesh_pieces_vertices_idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span>
                            <span class="n">main_mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span>
                            <span class="n">central_piece</span><span class="o">=</span><span class="n">curr_soma</span><span class="p">,</span>
                            <span class="n">periphery_pieces</span> <span class="o">=</span> <span class="n">sig_non_soma_pieces</span><span class="p">,</span>
                            <span class="n">return_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">return_vertices_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1">#print(f&quot;soma {i}: connected_mesh_pieces = {connected_mesh_pieces}&quot;)</span>
            <span class="n">soma_to_piece_connectivity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">connected_mesh_pieces</span>
            
            <span class="c1">#add on the connectivity of th non-soma touching pieces</span>
            

            <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">piece_index</span><span class="p">,</span><span class="n">piece_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">connected_mesh_pieces</span><span class="p">):</span>
                <span class="n">limb_root_nodes</span><span class="p">[</span><span class="n">piece_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">connected_mesh_pieces_vertices</span><span class="p">[</span><span class="n">piece_index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot; Old way of finding vertex connected components on a mesh without trimesh function</span>
<span class="sd">                #find the number of touching groups and save those </span>
<span class="sd">                soma_touching_graph = m_vert_graph.subgraph(connected_mesh_pieces_vertices_idx[piece_index])</span>
<span class="sd">                soma_con_comp = [current_mesh.vertices[np.array(list(k)).astype(&quot;int&quot;)] for k in list(nx.connected_components(soma_touching_graph))]</span>
<span class="sd">                soma_to_piece_touching_vertices[i][piece_idx] = soma_con_comp</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">piece_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_vertex_list_into_connected_components</span><span class="p">(</span>
                                                    <span class="n">vertex_indices_list</span><span class="o">=</span><span class="n">connected_mesh_pieces_vertices_idx</span><span class="p">[</span><span class="n">piece_index</span><span class="p">],</span>
                                                    <span class="n">mesh</span><span class="o">=</span><span class="n">current_mesh</span><span class="p">,</span> 
                                                    <span class="c1">#vertex_graph=m_vert_graph, </span>
                                                    <span class="n">return_coordinates</span><span class="o">=</span><span class="kc">True</span>
                                                   <span class="p">)</span>
                
                <span class="c1">#add in the soma to piece touching vertices for non-soma touching pieces</span>

        
        <span class="c1">#-----12/29: Adding the non-soma touching pieces that don&#39;t currently touch ------</span>
        <span class="n">nst_n_vertices</span> <span class="o">=</span> <span class="mi">1</span>
    
        <span class="k">for</span> <span class="n">nst_piece_idx</span><span class="p">,</span><span class="n">piece</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_limbs_nst</span><span class="p">):</span>
            <span class="n">closest_idx</span><span class="p">,</span><span class="n">closest_vertex</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_mesh_to_mesh</span><span class="p">(</span>
                <span class="n">mesh</span><span class="o">=</span><span class="n">piece</span><span class="p">,</span>
                <span class="n">meshes</span><span class="o">=</span><span class="n">seperate_soma_meshes</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">return_closest_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">return_closest_vertex_on_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">nst_n_vertices</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">touching_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">closest_vertex</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unimplemented nst_n_vertices != 1&quot;</span><span class="p">)</span>
                
            <span class="n">curr_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig_non_soma_pieces</span><span class="p">)</span> <span class="o">+</span> <span class="n">nst_piece_idx</span>
            <span class="n">soma_to_piece_connectivity</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_idx</span><span class="p">)</span>
            <span class="n">soma_to_piece_touching_vertices</span><span class="p">[</span><span class="n">closest_idx</span><span class="p">][</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">touching_vertices</span>
            <span class="n">limb_root_nodes</span><span class="p">[</span><span class="n">curr_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">closest_vertex</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
            


    <span class="c1">#         border_debug = False</span>
    <span class="c1">#         if border_debug:</span>
    <span class="c1">#             print(f&quot;soma_to_piece_connectivity = {soma_to_piece_connectivity}&quot;)</span>
    <span class="c1">#             print(f&quot;soma_to_piece_touching_vertices = {soma_to_piece_touching_vertices}&quot;)</span>


        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for mesh_pieces_connectivity= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_to_piece_connectivity</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of insignificant_limbs = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">insignificant_limbs</span><span class="p">)</span><span class="si">}</span><span class="s2"> with trimesh : </span><span class="si">{</span><span class="n">insignificant_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of not_processed_soma_containing_meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">not_processed_soma_containing_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2"> with trimesh : </span><span class="si">{</span><span class="n">not_processed_soma_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    
    <span class="c1">#adds on the meshes</span>

    <span class="n">soma_touching_mesh_data</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_non_soma_pieces</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_limbs_nst</span><span class="p">)</span>

    <span class="c1"># Lets have an alert if there was more than one soma disconnected meshes</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_touching_mesh_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;More than 1 disconnected meshes that contain somas&quot;</span><span class="p">)</span>

    <span class="n">current_mesh_data</span> <span class="o">=</span> <span class="n">soma_touching_mesh_data</span>
    <span class="n">soma_containing_idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#doing inversion of the connectivity and touching vertices</span>
    <span class="n">piece_to_soma_touching_vertices</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">flip_key_orders_for_dict</span><span class="p">(</span><span class="n">soma_to_piece_touching_vertices</span><span class="p">)</span>


    
    
    
    
    
    
    <span class="c1"># Phase 4: Skeletonization, Mesh Correspondence,  </span>

    <span class="n">proper_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#The containers that will hold the final data for the preprocessed neuron</span>
    <span class="n">limb_correspondence</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_network_stating_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># ---------- Part A: skeletonization and mesh decomposition --------- #</span>
    <span class="n">skeleton_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    

    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">limb_mesh_mparty</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]):</span>
        <span class="n">use_meshafterparty_current</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">use_meshafterparty</span><span class="p">)</span>

        <span class="c1">#Arguments to pass to the specific function (when working with a limb)</span>
        <span class="n">soma_touching_vertices_dict</span> <span class="o">=</span> <span class="n">piece_to_soma_touching_vertices</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>

<span class="c1">#         if curr_limb_idx != 1:</span>
<span class="c1">#             continue</span>
        
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>


<span class="c1">#         su.compressed_pickle(limb_mesh_mparty,&quot;limb_mesh_mparty&quot;)</span>
<span class="c1">#         su.compressed_pickle(soma_touching_vertices_dict,&quot;soma_touching_vertices_dict&quot;)</span>
<span class="c1">#         su.compressed_pickle(current_mesh_data[0][&quot;branch_meshes&quot;],&quot;limb_meshes&quot;)</span>
<span class="c1">#         su.compressed_pickle(piece_to_soma_touching_vertices,&quot;piece_to_soma_touching_vertices&quot;)</span>
<span class="c1">#         raise Exception(&quot;&quot;)</span>
        <span class="n">curr_limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">----- Working on Proper Limb # </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2"> ---------&quot;</span><span class="p">)</span>

<span class="c1">#                 su.compressed_pickle(limb_mesh_mparty,f&quot;limb_mesh_mparty_{curr_limb_idx}&quot;)</span>
<span class="c1">#                 su.compressed_pickle(soma_touching_vertices_dict,f&quot;soma_touching_vertices_dict_{curr_limb_idx}&quot;)</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;meshparty_segment_size = </span><span class="si">{</span><span class="n">meshparty_segment_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">limb_correspondence_individual</span><span class="p">,</span><span class="n">network_starting_info</span> <span class="o">=</span> <span class="n">preprocess_limb</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">limb_mesh_mparty</span><span class="p">,</span>
                               <span class="n">soma_touching_vertices_dict</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span><span class="p">,</span>
                               <span class="n">return_concept_network</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                               <span class="n">return_concept_network_starting_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">width_threshold_MAP</span><span class="o">=</span><span class="n">width_threshold_MAP</span><span class="p">,</span>
                               <span class="n">size_threshold_MAP</span><span class="o">=</span><span class="n">size_threshold_MAP</span><span class="p">,</span>
                               <span class="n">surface_reconstruction_size</span><span class="o">=</span><span class="n">surface_reconstruction_size</span><span class="p">,</span>  

                               <span class="c1">#arguments added from the big preprocessing step                                                            </span>
                               <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="n">distance_by_mesh_center</span><span class="p">,</span>
                               <span class="n">meshparty_segment_size</span><span class="o">=</span><span class="n">meshparty_segment_size</span><span class="p">,</span>
                               <span class="n">meshparty_n_surface_downsampling</span> <span class="o">=</span> <span class="n">meshparty_n_surface_downsampling</span><span class="p">,</span>

                                <span class="n">use_meshafterparty</span><span class="o">=</span><span class="n">use_meshafterparty_current</span><span class="p">,</span>
                                <span class="n">error_on_no_starting_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                                       
                                <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="n">use_adaptive_invalidation_d</span><span class="p">,</span>
                                <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="n">axon_width_preprocess_limb_max</span><span class="p">,</span>
                                <span class="n">remove_mesh_interior_face_threshold</span><span class="o">=</span><span class="n">limb_remove_mesh_interior_face_threshold</span><span class="p">,</span>
                                                                                       
                                <span class="n">error_on_bad_cgal_return</span><span class="o">=</span><span class="n">error_on_bad_cgal_return</span><span class="p">,</span>
                                <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="n">max_stitch_distance_CGAL</span>

                               <span class="p">)</span>
                <span class="c1">#Storing all of the data to be sent to </span>

                <span class="n">limb_correspondence</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_correspondence_individual</span>
                <span class="n">limb_network_stating_info</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">network_starting_info</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">jj</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">use_meshafterparty_current</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successful Limb Decomposition&quot;</span><span class="p">)</span>
                <span class="k">break</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Skeletonization and Mesh Correspondence = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">skeleton_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
    <span class="c1"># ---------- Part B: Stitching on floating pieces --------- #</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ----- Working on Stitching ----------&quot;</span><span class="p">)</span>
    
<span class="c1">#     # --- Get the soma connecting points that don&#39;t want to stitch to ---- #</span>
<span class="c1">#     excluded_node_coordinates = []</span>
<span class="c1">#     for limb_idx,limb_start_v in limb_network_stating_info.items():</span>
<span class="c1">#         for soma_idx,soma_v in limb_start_v.items():</span>
<span class="c1">#             for soma_group_idx,group_v in soma_v.items():</span>
<span class="c1">#                 excluded_node_coordinates.append(group_v[&quot;endpoint&quot;])</span>

    <span class="n">excluded_node_coordinates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_soma_connnecting_endpionts_from_starting_info</span><span class="p">(</span><span class="n">limb_network_stating_info</span><span class="p">)</span>
    
    

    <span class="n">floating_stitching_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="c1">#         if verbose:</span>
<span class="c1">#             print(f&quot;BEFORE filtering floating points, {len(non_soma_touching_meshes)} floating pieces: &quot;</span>
<span class="c1">#                   f&quot;{non_soma_touching_meshes[:np.min([10,len(non_soma_touching_meshes)])]}&quot;)</span>
            
        <span class="n">outside_perc_threshold</span> <span class="o">=</span> <span class="mi">80</span>
        <span class="n">non_soma_touching_meshes_to_stitch</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">non_soma_touching_meshes</span> <span class="k">if</span> <span class="n">tu</span><span class="o">.</span><span class="n">n_vertices_outside_mesh_bbox</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span><span class="n">seperate_soma_meshes</span><span class="p">,</span><span class="n">return_percentage</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">outside_perc_threshold</span><span class="p">]</span>    
        
<span class="c1">#         non_soma_touching_meshes_to_stitch = tu.check_meshes_outside_multiple_mesh_bbox(seperate_soma_meshes,non_soma_touching_meshes,</span>
<span class="c1">#                                  return_indices=False)</span>
        
<span class="c1">#         if verbose:</span>
<span class="c1">#             print(f&quot;AFTER filtering floating points, {len(non_soma_touching_meshes_to_stitch)} floating pieces: &quot;</span>
<span class="c1">#                   f&quot;{non_soma_touching_meshes_to_stitch[:np.min([10,len(non_soma_touching_meshes_to_stitch)])]}&quot;)</span>
        
        <span class="c1"># add in a check for distance</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NO NEED TO FILTER FOR STITCH DISTANCE BECAUSE ALREADY DONE IN STEP ABOVE LOOKING FOR EXPANSION</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        
        <span class="n">limb_correspondence_with_floating_pieces</span> <span class="o">=</span> <span class="n">attach_floating_pieces_to_limb_correspondence</span><span class="p">(</span>
                <span class="n">limb_correspondence</span><span class="p">,</span>
                <span class="n">floating_meshes</span><span class="o">=</span><span class="n">non_soma_touching_meshes_to_stitch</span><span class="p">,</span>
                <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold</span><span class="p">,</span><span class="c1">#600,</span>
                <span class="n">max_stitch_distance</span><span class="o">=</span><span class="n">max_stitch_distance</span><span class="p">,</span><span class="c1">#8000,</span>
                <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="n">distance_to_move_point_threshold</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">excluded_node_coordinates</span> <span class="o">=</span> <span class="n">excluded_node_coordinates</span><span class="p">,</span>
                <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="n">use_adaptive_invalidation_d_floating</span><span class="p">,</span>
                <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="n">axon_width_preprocess_limb_max</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limb_correspondence_with_floating_pieces</span> <span class="o">=</span> <span class="n">limb_correspondence</span>
        



    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for stitching floating pieces = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">floating_stitching_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>





    <span class="c1"># ---------- Part C: Computing Concept Networks --------- #</span>
    <span class="n">concept_network_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">limb_concept_networks</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_labels</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">limb_mesh_mparty</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">]):</span>
        <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">limb_correspondence_with_floating_pieces</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">],</span>
                                                                        <span class="n">limb_network_stating_info</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">],</span>
                                                                        <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                           <span class="p">)</span>   



        <span class="n">limb_concept_networks</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_to_soma_concept_networks</span>
        <span class="n">limb_labels</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">=</span> <span class="s2">&quot;Unlabeled&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Concept Networks = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">concept_network_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_meshes&quot;</span><span class="p">]</span>
    <span class="n">preprocessed_data</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">soma_meshes</span><span class="p">,</span>
        <span class="n">soma_volumes</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_meshes</span><span class="p">],</span>
        <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">],</span>
        <span class="n">soma_sdfs</span> <span class="o">=</span> <span class="n">total_soma_list_sdf</span><span class="p">,</span>
        <span class="n">insignificant_limbs</span><span class="o">=</span><span class="n">insignificant_limbs</span><span class="p">,</span>
        <span class="n">not_processed_soma_containing_meshes</span><span class="o">=</span><span class="n">not_processed_soma_containing_meshes</span><span class="p">,</span>
        <span class="n">glia_faces</span> <span class="o">=</span> <span class="n">glia_faces</span><span class="p">,</span>
        <span class="n">non_soma_touching_meshes</span><span class="o">=</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
        <span class="n">inside_pieces</span><span class="o">=</span><span class="n">inside_pieces</span><span class="p">,</span>
        <span class="n">limb_correspondence</span><span class="o">=</span><span class="n">limb_correspondence_with_floating_pieces</span><span class="p">,</span>
        <span class="n">limb_concept_networks</span><span class="o">=</span><span class="n">limb_concept_networks</span><span class="p">,</span>
        <span class="n">limb_network_stating_info</span><span class="o">=</span><span class="n">limb_network_stating_info</span><span class="p">,</span>
        <span class="n">limb_labels</span><span class="o">=</span><span class="n">limb_labels</span><span class="p">,</span>
        <span class="n">limb_meshes</span><span class="o">=</span><span class="n">current_mesh_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;branch_meshes&quot;</span><span class="p">],</span>
        <span class="p">)</span>



    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for all mesh and skeletonization decomp = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">proper_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">preprocessed_data</span>    </div>
<span class="w">    </span>
<span class="w">    </span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def high_fidelity_axon_decomposition_old(neuron_obj,</span>
<span class="sd">                                     plot_new_axon_limb_correspondence=False,</span>
<span class="sd">                                     plot_connecting_skeleton_fix = False,</span>
<span class="sd">                                     plot_final_limb_correspondence=False,</span>
<span class="sd">                                     return_starting_info=True,</span>
<span class="sd">                                verbose = True,</span>
<span class="sd">    ):</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the decomposition of the </span>
<span class="sd">    axon with the a finer skeletonization</span>
<span class="sd">    </span>
<span class="sd">    Returns: a limb correspondence of the revised branches</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the starting information for decomposition</span>
<span class="sd">    2) Split the axon mesh into just one connected mesh (aka filtering away the disconnected parts)</span>
<span class="sd">    3) Run the limb preprocessing</span>
<span class="sd">    4) Retriveing starting info from concept network</span>
<span class="sd">    5) Adjust the axon decomposition to connect to an upstream piece if there was one</span>
<span class="sd">    6) Return limb correspondence and starting information (IF WE REVISED THE STARTING INFO)</span>
<span class="sd">    </span>
<span class="sd">    --- Add back the floating mesh pieces using the stitching process --</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    #---1) Get the starting information for decomposition ---</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    axon_limb_name = neuron_obj.axon_limb_name</span>
<span class="sd">    curr_limb = neuron_obj[axon_limb_name]</span>
<span class="sd">    axon_starting_branch = neuron_obj.axon_starting_branch</span>
<span class="sd">    axon_starting_branch_mesh = curr_limb[axon_starting_branch].mesh</span>
<span class="sd">    axon_starting_coordinate = neuron_obj.axon_starting_coordinate</span>

<span class="sd">    upstream_node_to_axon_starting_branch = None</span>

<span class="sd">    # ---- 2/28: MOVE THE AXON BRANCHES BACK ENOUGH SO THE DENDRITES WONT BE ATTACHED</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    if axon_starting_branch != curr_limb.current_starting_node:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Starting axon branch was not the limb starting node so generating border vertices and computing upstream branch&quot;)</span>
<span class="sd">        border_vertices_for_axon = tu.largest_border_to_coordinate(</span>
<span class="sd">            mesh = axon_starting_branch_mesh,</span>
<span class="sd">            coordinate =axon_starting_coordinate,</span>
<span class="sd">            distance_threshold = 1000,</span>
<span class="sd">            plot_border_vertices = False,</span>
<span class="sd">            error_on_no_border = True,</span>
<span class="sd">            plot_winning_border = False,</span>
<span class="sd">            verbose = False)</span>

<span class="sd">        upstream_node_to_axon_starting_branch = xu.upstream_node(curr_limb.concept_network_directional,</span>
<span class="sd">                                                                 axon_starting_branch</span>
<span class="sd">                                                                   )</span>

<span class="sd">    else:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Starting axon branch was the starting node so using border vertices and NOT computing upstream branch&quot;)</span>
<span class="sd">        border_vertices_for_axon = curr_limb.current_touching_soma_vertices</span>
<span class="sd">        upstream_node_to_axon_starting_branch = None</span>

<span class="sd">    soma_touching_vertices_dict = {0:[border_vertices_for_axon]}</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;upstream_node_to_axon_starting_branch = {upstream_node_to_axon_starting_branch}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    #---2) Split the axon mesh into just one connected mesh (aka filtering away the disconnected parts)---</span>
<span class="sd">        </span>
<span class="sd">    # divide the meshes into the only big continuous one (because if disconnected probably)</span>
<span class="sd">    diff_meshes = tu.split_by_vertices(neuron_obj.axon_mesh)</span>
<span class="sd">    axon_mesh_filtered = tu.filter_meshes_by_containing_coordinates(diff_meshes,</span>
<span class="sd">                                              nullifying_points=border_vertices_for_axon[0],</span>
<span class="sd">                                               method=&quot;distance&quot;,</span>
<span class="sd">                                               distance_threshold = 0,</span>
<span class="sd">                                              filter_away=False)[0]</span>
<span class="sd">    if verbose:</span>
<span class="sd">        if len(diff_meshes) &gt; 1:</span>
<span class="sd">            print(f&quot;More than 1 seperated mesh (taking the top one): {diff_meshes}&quot;)</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">    #---3) Run the limb preprocessing---</span>
<span class="sd">    limb_correspondence_individual,concept_network = pre.preprocess_limb(axon_mesh_filtered,</span>
<span class="sd">                       soma_touching_vertices_dict = soma_touching_vertices_dict,</span>
<span class="sd">                        meshparty_segment_size = 100,</span>
<span class="sd">                        combine_close_skeleton_nodes=True,</span>
<span class="sd">                        #combine_close_skeleton_nodes_threshold=1200,</span>
<span class="sd">                        combine_close_skeleton_nodes_threshold_meshparty = 1300,</span>
<span class="sd">                        filter_end_node_length_meshparty = 1500,</span>
<span class="sd">                        filter_end_node_length = 1500,</span>

<span class="sd">                        use_meshafterparty=False,</span>
<span class="sd">                        perform_cleaning_checks = True,</span>


<span class="sd">                        #concept_network parameters</span>
<span class="sd">                        run_concept_network_checks = True,</span>
<span class="sd">                        return_concept_network = True,</span>
<span class="sd">                        return_concept_network_starting_info=False,</span>

<span class="sd">                        #printing controls</span>
<span class="sd">                        verbose = True,</span>
<span class="sd">                        print_fusion_steps=True,</span>

<span class="sd">                        check_correspondence_branches = True,</span>
<span class="sd">                        filter_end_nodes_from_correspondence=True,</span>
<span class="sd">                        error_on_no_starting_coordinates=True,</span>
<span class="sd">                        invalidation_d=2000,</span>


<span class="sd">                       )</span>
<span class="sd">    </span>
<span class="sd">    #-- 4) Retriveing starting info from concept network --</span>
<span class="sd">    curr_concept_network = concept_network[0][0]</span>

<span class="sd">    starting_node = xu.get_starting_node(curr_concept_network,only_one=False)[0]</span>

<span class="sd">    starting_coordinate = curr_concept_network.nodes[starting_node][&quot;starting_coordinate&quot;]</span>
<span class="sd">    touching_soma_vertices = curr_concept_network.nodes[starting_node][&quot;touching_soma_vertices&quot;]</span>
<span class="sd">    </span>
<span class="sd">    limb_network_stating_info = {0:{0:{&quot;touching_verts&quot;:touching_soma_vertices,</span>
<span class="sd">                                      &quot;endpoint&quot;:starting_coordinate}}}</span>

<span class="sd">    if plot_new_axon_limb_correspondence:</span>
<span class="sd">        nviz.plot_limb_correspondence(limb_correspondence_individual,</span>
<span class="sd">                                     scatters = [starting_coordinate],</span>
<span class="sd">                                     scatter_size=1)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    # -- 5) Adjust the axon decomposition to connect to an upstream piece if there was one --</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the starting axon branch and the upstream node</span>
<span class="sd">    2) Find the common endpoint</span>
<span class="sd">    3) Add a skeletal branch from starting_coordinate (new)</span>
<span class="sd">    and the common endpoint to the starting node of new</span>
<span class="sd">    axon decomposition</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>

<span class="sd">    #1) Get the starting axon branch and the upstream node</span>
<span class="sd">    if upstream_node_to_axon_starting_branch is not None:</span>
<span class="sd">        print(&quot;Readjusting starting axon branch skeleton&quot;)</span>

<span class="sd">        #1) Get the starting axon branch and the upstream node</span>
<span class="sd">        axon_starting_branch,upstream_node_to_axon_starting_branch</span>

<span class="sd">        #2) Find the common endpoint</span>
<span class="sd">    #     shared_endpoint = shared_skeleton_endpoints_for_connected_branches(neuron_obj[axon_limb_name],</span>
<span class="sd">    #                                                 axon_starting_branch,</span>
<span class="sd">    #                                                      upstream_node_to_axon_starting_branch,</span>
<span class="sd">    #                                                 verbose=False)</span>
<span class="sd">        shared_endpoint = neuron_obj.axon_starting_coordinate</span>

<span class="sd">        if shared_endpoint.ndim &gt; 1:</span>
<span class="sd">            shared_endpoint = shared_endpoint[0]</span>

<span class="sd">        #3) Add a skeletal branch from starting_coordinate (new)</span>
<span class="sd">        #and the common endpoint to the starting node of new</span>
<span class="sd">        #axon decomposition</span>

<span class="sd">        curr_endpoints = sk.find_skeleton_endpoint_coordinates(limb_correspondence_individual[starting_node][&quot;branch_skeleton&quot;])</span>
<span class="sd">        if len(nu.matching_rows(curr_endpoints,axon_starting_coordinate)) == 0:</span>
<span class="sd">            print(&quot;Fixing the axon starting branch endpoint to align with upstream branch&quot;)</span>

<span class="sd">            skeleton_pre_fix = limb_correspondence_individual[starting_node][&quot;branch_skeleton&quot;]</span>
<span class="sd">            new_skeleton_segment = np.array([starting_coordinate,shared_endpoint]).reshape(-1,2,3)</span>

<span class="sd">            limb_correspondence_individual[starting_node][&quot;branch_skeleton&quot;] = sk.stack_skeletons([skeleton_pre_fix,</span>
<span class="sd">                                                                                                   new_skeleton_segment</span>
<span class="sd">                                                                                                 ])</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Starting Branch {starting_node} skeleton before fix: {skeleton_pre_fix.shape}&quot;)</span>
<span class="sd">                print(f&quot;Starting Branch {starting_node} skeleton AFTER fix: {limb_correspondence_individual[starting_node][&#39;branch_skeleton&#39;].shape}&quot;)</span>
<span class="sd">        else:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(&quot;Not attempting to fix the limb correspondence because the axon_starting_coordainte was already an endpoint&quot;)</span>

<span class="sd">        </span>
<span class="sd">        if plot_connecting_skeleton_fix:</span>
<span class="sd">            upstream_branch = neuron_obj[axon_limb_name][upstream_node_to_axon_starting_branch]</span>
<span class="sd">            meshes,skeletons = nviz.limb_correspondence_plottable(limb_correspondence_individual)</span>
<span class="sd">            nviz.plot_objects(meshes=meshes + [upstream_branch.mesh],</span>
<span class="sd">                              meshes_colors=&quot;random&quot;,</span>
<span class="sd">                              skeletons=skeletons +  [upstream_branch.skeleton],</span>
<span class="sd">                              skeletons_colors=&quot;random&quot;,</span>
<span class="sd">                                          scatters=[axon_starting_coordinate],</span>
<span class="sd">                                         scatter_size=0.3)</span>
<span class="sd">    else:</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Upstream node was None so don&#39;t have to adjust&quot;)</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">    if plot_final_limb_correspondence:</span>
<span class="sd">        nviz.plot_limb_correspondence(limb_correspondence_individual,</span>
<span class="sd">                             scatters=[limb_network_stating_info[0][0][&quot;endpoint&quot;],</span>
<span class="sd">                                      limb_network_stating_info[0][0][&quot;touching_verts&quot;]],</span>
<span class="sd">                              skeleton_colors=[&quot;red&quot;,&quot;blue&quot;],</span>
<span class="sd">                             scatter_size=[0.2,0.07])</span>
<span class="sd">    </span>
<span class="sd">    if return_starting_info:</span>
<span class="sd">        return limb_correspondence_individual,limb_network_stating_info</span>
<span class="sd">    else:</span>
<span class="sd">        return limb_correspondence_individual&#39;&#39;&#39;</span>


<span class="c1"># --- 3/24 Addition ----</span>
<div class="viewcode-block" id="high_fidelity_axon_decomposition"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.high_fidelity_axon_decomposition">[docs]</a><span class="k">def</span> <span class="nf">high_fidelity_axon_decomposition</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">plot_new_axon_limb_correspondence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">plot_connecting_skeleton_fix</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="n">plot_final_limb_correspondence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">return_starting_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         
                                <span class="c1"># new parameters for stitching</span>
                                <span class="n">stitch_floating_axon_pieces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True,</span>
                                <span class="n">filter_away_floating_pieces_inside_soma_bbox</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">soma_bbox_multiplier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#12,</span>
                                <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#13000,#np.inf,</span>
                                <span class="n">plot_new_axon_limb_correspondence_after_stitch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the decomposition of the </span>
<span class="sd">    axon with the a finer skeletonization (THIS VERSION NOW STITCHES PIECES OF THE AXON)</span>

<span class="sd">    Returns: a limb correspondence of the revised branches</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the starting information for decomposition</span>
<span class="sd">    2) Split the axon mesh into just one connected mesh (aka filtering away the disconnected parts)</span>
<span class="sd">    3) Run the limb preprocessing</span>
<span class="sd">    4) Retriveing starting info from concept network</span>
<span class="sd">    5) Adjust the axon decomposition to connect to an upstream piece if there was one</span>
<span class="sd">    6) Return limb correspondence and starting information (IF WE REVISED THE STARTING INFO)</span>

<span class="sd">    --- Add back the floating mesh pieces using the stitching process --</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">floating_piece_face_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_high_fid_axon_global</span>
    
    <span class="k">if</span> <span class="n">stitch_floating_axon_pieces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stitch_floating_axon_pieces</span> <span class="o">=</span> <span class="n">stitch_floating_axon_pieces_global</span>
        
    <span class="k">if</span> <span class="n">max_stitch_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="n">max_stitch_distance_high_fid_axon_global</span>
    
    <span class="c1">#---1) Get the starting information for decomposition ---</span>


    <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_name</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span>
    <span class="n">axon_starting_branch</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_starting_branch</span>
    <span class="n">axon_starting_branch_mesh</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">axon_starting_branch</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">axon_starting_coordinate</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_starting_coordinate</span>

    <span class="n">upstream_node_to_axon_starting_branch</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ---- 2/28: MOVE THE AXON BRANCHES BACK ENOUGH SO THE DENDRITES WONT BE ATTACHED</span>



    <span class="k">if</span> <span class="n">axon_starting_branch</span> <span class="o">!=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting axon branch was not the limb starting node so generating border vertices and computing upstream branch&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">border_vertices_for_axon</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">largest_border_to_coordinate</span><span class="p">(</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">axon_starting_branch_mesh</span><span class="p">,</span>
                <span class="n">coordinate</span> <span class="o">=</span><span class="n">axon_starting_coordinate</span><span class="p">,</span>
                <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                <span class="n">plot_border_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">error_on_no_border</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">plot_winning_border</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            If no border vertices could be found then just going to assign closest vertices</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">n_closest_vertices</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">border_vertices_for_axon</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">closest_n_attributes_to_coordinate</span><span class="p">(</span>
                <span class="n">axon_starting_branch_mesh</span><span class="p">,</span>
                <span class="n">coordinate</span> <span class="o">=</span> <span class="n">axon_starting_coordinate</span><span class="p">,</span>
                <span class="n">attribute</span> <span class="o">=</span> <span class="s2">&quot;vertices&quot;</span><span class="p">,</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n_closest_vertices</span><span class="p">)</span>
            
            
            

        <span class="n">upstream_node_to_axon_starting_branch</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                                                 <span class="n">axon_starting_branch</span>
                                                                   <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting axon branch was the starting node so using border vertices and NOT computing upstream branch&quot;</span><span class="p">)</span>
        <span class="n">border_vertices_for_axon</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span>
        <span class="n">upstream_node_to_axon_starting_branch</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">soma_touching_vertices_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="n">border_vertices_for_axon</span><span class="p">]}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_node_to_axon_starting_branch = </span><span class="si">{</span><span class="n">upstream_node_to_axon_starting_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="c1">#---2) Split the axon mesh into just one connected mesh (aka filtering away the disconnected parts)---</span>

    <span class="c1"># divide the meshes into the only big continuous one (because if disconnected probably)</span>
    <span class="n">diff_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_by_vertices</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_mesh</span><span class="p">)</span>
    
    <span class="c1">#-------- 5/27 change -------- </span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">axon_mesh_filtered_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">diff_meshes</span><span class="p">,</span>
                                              <span class="n">nullifying_points</span><span class="o">=</span><span class="n">border_vertices_for_axon</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                               <span class="n">method</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
                                               <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                            <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Bad Axon&quot;</span><span class="p">)</span>
        <span class="n">axon_mesh_filtered_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_containing_coordinates</span><span class="p">(</span><span class="n">diff_meshes</span><span class="p">,</span>
                                                  <span class="n">nullifying_points</span><span class="o">=</span><span class="n">border_vertices_for_axon</span><span class="p">,</span>
                                                   <span class="n">method</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
                                                   <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                                  <span class="n">filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="n">axon_mesh_filtered</span> <span class="o">=</span> <span class="n">diff_meshes</span><span class="p">[</span><span class="n">axon_mesh_filtered_idx</span><span class="p">]</span>
    <span class="n">meshes_to_stitch</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff_meshes</span><span class="p">))</span> <span class="k">if</span> <span class="n">k</span><span class="o">!=</span> <span class="n">axon_mesh_filtered_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than 1 seperated mesh (taking the top one): </span><span class="si">{</span><span class="n">diff_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#---3) Run the limb preprocessing---</span>
    <span class="n">limb_correspondence_individual</span><span class="p">,</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">preprocess_limb</span><span class="p">(</span>
        <span class="n">axon_mesh_filtered</span><span class="p">,</span>
        <span class="n">soma_touching_vertices_dict</span> <span class="o">=</span> <span class="n">soma_touching_vertices_dict</span><span class="p">,</span>
        <span class="n">error_on_no_starting_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>            
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">return_concept_network</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">meshparty_segment_size</span><span class="o">=</span> <span class="n">meshparty_segment_size_axon_global</span><span class="p">,</span>
        <span class="n">combine_close_skeleton_nodes_threshold_meshparty</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes_threshold_meshparty_axon_global</span><span class="p">,</span>
        <span class="n">filter_end_node_length_meshparty</span> <span class="o">=</span> <span class="n">filter_end_node_length_meshparty_axon_global</span><span class="p">,</span>
        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="n">filter_end_node_length_axon_global</span><span class="p">,</span>
        <span class="n">invalidation_d</span><span class="o">=</span><span class="n">invalidation_d_axon_global</span><span class="p">,</span>
        <span class="n">smooth_neighborhood</span><span class="o">=</span><span class="n">smooth_neighborhood_axon_global</span><span class="p">,</span>
        <span class="o">**</span><span class="n">preprocessing_args</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1">#-- 4) Retriveing starting info from concept network --</span>
    <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">concept_network</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">starting_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;starting_coordinate&quot;</span><span class="p">]</span>
    <span class="n">touching_soma_vertices</span> <span class="o">=</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span>

    <span class="n">limb_network_stating_info</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:{</span><span class="mi">0</span><span class="p">:{</span><span class="s2">&quot;touching_verts&quot;</span><span class="p">:</span><span class="n">touching_soma_vertices</span><span class="p">,</span>
                                      <span class="s2">&quot;endpoint&quot;</span><span class="p">:</span><span class="n">starting_coordinate</span><span class="p">}}}</span>

    <span class="k">if</span> <span class="n">plot_new_axon_limb_correspondence</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_correspondence</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">,</span>
                                     <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                                     <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>



    <span class="c1"># ---- 3/24 Addition: Stitching the leftover meshes</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb Correspondence before stitching = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
        
    <span class="k">if</span> <span class="n">stitch_floating_axon_pieces</span><span class="p">:</span>
        <span class="c1">#need to specify want high fidelity skeletons</span>
        <span class="n">floating_meshes_non_incorporated</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">non_soma_touching_meshes_not_stitched</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">filter_away_floating_pieces_inside_soma_bbox</span><span class="p">:</span> 
            
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering away non soma floating pieces near the soma&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before filter # of pieces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">floating_meshes_non_incorporated</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">floating_meshes_non_incorporated</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">check_meshes_inside_mesh_bbox</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                <span class="n">floating_meshes_non_incorporated</span><span class="p">,</span>
                                 <span class="n">return_inside</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">bbox_multiply_ratio</span><span class="o">=</span><span class="n">soma_bbox_multiplier</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER filter # of pieces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">floating_meshes_non_incorporated</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            
            

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">floating_meshes_non_incorporated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">meshes_to_stitch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">meshes_to_stitch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">floating_meshes_non_incorporated</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meshes_to_stitch</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

        
<span class="c1">#         su.compressed_pickle(meshes_to_stitch,&quot;meshes_to_stitch&quot;)</span>
<span class="c1">#         su.compressed_pickle(np.array(starting_coordinate).reshape(-1,3),&quot;excluded_node_coordinates&quot;)</span>
<span class="c1">#         print(f&quot;max_stitch_distance = {max_stitch_distance}&quot;)</span>
<span class="c1">#         su.compressed_pickle({0:limb_correspondence_individual},&quot;limb_correspondence_before&quot;)</span>
        
        <span class="n">limb_correspondence_with_floating_pieces</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">attach_floating_pieces_to_limb_correspondence</span><span class="p">(</span>
                        <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="n">limb_correspondence_individual</span><span class="p">},</span>
                        <span class="n">floating_meshes</span><span class="o">=</span> <span class="n">meshes_to_stitch</span><span class="p">,</span>
                        <span class="c1">#stitch_floating_axon_pieces = stitch_floating_axon_pieces,</span>
                        <span class="n">max_stitch_distance</span><span class="o">=</span><span class="n">max_stitch_distance</span><span class="p">,</span>
                        <span class="n">distance_to_move_point_threshold</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">excluded_node_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">starting_coordinate</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                        <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold</span><span class="p">,</span>
                        <span class="n">meshparty_segment_size</span><span class="o">=</span> <span class="n">meshparty_segment_size_axon_global</span><span class="p">,</span>
                        <span class="n">combine_close_skeleton_nodes_threshold_meshparty</span> <span class="o">=</span> <span class="n">combine_close_skeleton_nodes_threshold_meshparty_axon_global</span><span class="p">,</span>
                        <span class="n">filter_end_node_length_meshparty</span> <span class="o">=</span> <span class="n">filter_end_node_length_meshparty_axon_global</span><span class="p">,</span>
                        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="n">filter_end_node_length_axon_global</span><span class="p">,</span>
                        <span class="n">invalidation_d</span><span class="o">=</span><span class="n">invalidation_d_axon_global</span><span class="p">,</span>
                        <span class="n">smooth_neighborhood</span><span class="o">=</span><span class="n">smooth_neighborhood_axon_global</span><span class="p">,</span>
                        <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">preprocessing_args</span>
        <span class="p">)</span>
        
<span class="c1">#         su.compressed_pickle(limb_correspondence_with_floating_pieces,&quot;limb_correspondence_with_floating_pieces&quot;)</span>
<span class="c1">#         raise Exception(&quot;&quot;)</span>
        
        <span class="n">limb_correspondence_individual_stitch</span> <span class="o">=</span> <span class="n">limb_correspondence_with_floating_pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#need to regenerate the concept network</span>
        <span class="n">concept_network_floating_pieces</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">limb_correspondence_individual_stitch</span><span class="p">,</span>
                                                                            <span class="n">limb_network_stating_info</span><span class="p">,</span>
                                                                            <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                               <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">starting_node_floating_pieces</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">concept_network_floating_pieces</span><span class="p">,</span>
                                                             <span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">limb_correspondence_individual</span> <span class="o">=</span> <span class="n">limb_correspondence_individual_stitch</span>
        <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">concept_network_floating_pieces</span>
        <span class="n">starting_node</span> <span class="o">=</span> <span class="n">starting_node_floating_pieces</span>

        
        <span class="k">if</span> <span class="n">plot_new_axon_limb_correspondence_after_stitch</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Limb correspondence after stitching&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_correspondence</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">,</span>
                                         <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        

<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;Limb Correspondence AFTER stitching = {len(limb_correspondence_individual_stitch)}&quot;)</span>
        
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># -- 5) Adjust the axon decomposition to connect to an upstream piece if there was one --</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the starting axon branch and the upstream node</span>
<span class="sd">    2) Find the common endpoint</span>
<span class="sd">    3) Add a skeletal branch from starting_coordinate (new)</span>
<span class="sd">    and the common endpoint to the starting node of new</span>
<span class="sd">    axon decomposition</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) Get the starting axon branch and the upstream node</span>
    <span class="k">if</span> <span class="n">upstream_node_to_axon_starting_branch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Readjusting starting axon branch skeleton&quot;</span><span class="p">)</span>

        <span class="c1">#1) Get the starting axon branch and the upstream node</span>
        <span class="n">axon_starting_branch</span><span class="p">,</span><span class="n">upstream_node_to_axon_starting_branch</span>

        <span class="c1">#2) Find the common endpoint</span>
    <span class="c1">#     shared_endpoint = shared_skeleton_endpoints_for_connected_branches(neuron_obj[axon_limb_name],</span>
    <span class="c1">#                                                 axon_starting_branch,</span>
    <span class="c1">#                                                      upstream_node_to_axon_starting_branch,</span>
    <span class="c1">#                                                 verbose=False)</span>
        <span class="n">shared_endpoint</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_starting_coordinate</span>

        <span class="k">if</span> <span class="n">shared_endpoint</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shared_endpoint</span> <span class="o">=</span> <span class="n">shared_endpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#3) Add a skeletal branch from starting_coordinate (new)</span>
        <span class="c1">#and the common endpoint to the starting node of new</span>
        <span class="c1">#axon decomposition</span>

        <span class="n">curr_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">curr_endpoints</span><span class="p">,</span><span class="n">axon_starting_coordinate</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fixing the axon starting branch endpoint to align with upstream branch&quot;</span><span class="p">)</span>

            <span class="n">skeleton_pre_fix</span> <span class="o">=</span> <span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span>
            <span class="n">new_skeleton_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="n">shared_endpoint</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

            <span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">skeleton_pre_fix</span><span class="p">,</span>
                                                                                                   <span class="n">new_skeleton_segment</span>
                                                                                                 <span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting Branch </span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2"> skeleton before fix: </span><span class="si">{</span><span class="n">skeleton_pre_fix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting Branch </span><span class="si">{</span><span class="n">starting_node</span><span class="si">}</span><span class="s2"> skeleton AFTER fix: </span><span class="si">{</span><span class="n">limb_correspondence_individual</span><span class="p">[</span><span class="n">starting_node</span><span class="p">][</span><span class="s1">&#39;branch_skeleton&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not attempting to fix the limb correspondence because the axon_starting_coordainte was already an endpoint&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">plot_connecting_skeleton_fix</span><span class="p">:</span>
            <span class="n">upstream_branch</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">][</span><span class="n">upstream_node_to_axon_starting_branch</span><span class="p">]</span>
            <span class="n">meshes</span><span class="p">,</span><span class="n">skeletons</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_correspondence_plottable</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span> <span class="o">+</span> <span class="p">[</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">],</span>
                              <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                              <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span> <span class="o">+</span>  <span class="p">[</span><span class="n">upstream_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">],</span>
                              <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                                          <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">axon_starting_coordinate</span><span class="p">],</span>
                                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upstream node was None so don&#39;t have to adjust&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">plot_final_limb_correspondence</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_correspondence</span><span class="p">(</span><span class="n">limb_correspondence_individual</span><span class="p">,</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">limb_network_stating_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;endpoint&quot;</span><span class="p">],</span>
                                      <span class="n">limb_network_stating_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;touching_verts&quot;</span><span class="p">]],</span>
                              <span class="n">skeleton_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span>
                             <span class="n">scatter_size</span><span class="o">=</span><span class="p">[</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.07</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">return_starting_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_correspondence_individual</span><span class="p">,</span><span class="n">limb_network_stating_info</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_correspondence_individual</span></div>
    
    
<span class="c1"># ----- 12/29: Helps with the human data --------------</span>

<span class="n">floating_piece_face_threshold_expansion</span> <span class="o">=</span> <span class="mi">500</span>
<div class="viewcode-block" id="limb_meshes_expansion"><a class="viewcode-back" href="../../neurd.html#neurd.preprocess_neuron.limb_meshes_expansion">[docs]</a><span class="k">def</span> <span class="nf">limb_meshes_expansion</span><span class="p">(</span>
    <span class="n">non_soma_touching_meshes</span><span class="p">,</span>
    <span class="n">insignificant_limbs</span><span class="p">,</span>
    <span class="n">soma_meshes</span><span class="p">,</span>
    
    <span class="c1">#Step 1: Filering</span>
    <span class="n">plot_filtered_pieces</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">non_soma_touching_meshes_face_min</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_expansion</span><span class="p">,</span>
    <span class="n">insignificant_limbs_face_min</span> <span class="o">=</span> <span class="n">floating_piece_face_threshold_expansion</span><span class="p">,</span>
    
    <span class="c1">#Step 2: Distance Graph Structure</span>
    <span class="n">plot_distance_G</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_distance_G_thresholded</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">max_distance_threshold</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    
    <span class="c1">#Step 3: </span>
    <span class="n">min_n_faces_on_path</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span>
    
    <span class="n">plot_final_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_not_added_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_meshes_divided</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the objects that should be made into </span>
<span class="sd">    significant limbs for decomposition </span>
<span class="sd">    (out of the non_soma_touching_meshes and insignificant_limbs )</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Filter the non-soma pieces and insignificant meshes</span>
<span class="sd">    2) Find distances between all of the significant pieces and form a graph structure</span>
<span class="sd">    3) Determine the meshes that should be made significant limbs</span>
<span class="sd">    a) find all paths from NST</span>
<span class="sd">    b) filter for those paths with a certain fae total</span>
<span class="sd">    3) fin all of the nodes right before the soma </span>
<span class="sd">    and the unique set of those will be significant limbs</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    floating_piece_face_threshold_expansion = 500</span>
<span class="sd">    new_limbs_nst,il_still_idx,nst_still_meshes,il_still_meshes = pre.limb_meshes_expansion(</span>
<span class="sd">        neuron_obj_comb.non_soma_touching_meshes,</span>
<span class="sd">        neuron_obj_comb.insignificant_limbs,</span>
<span class="sd">        neuron_obj_comb[&quot;S0&quot;].mesh,</span>

<span class="sd">        #Step 1: Filering</span>
<span class="sd">        plot_filtered_pieces = True,</span>
<span class="sd">    #     non_soma_touching_meshes_face_min = floating_piece_face_threshold_expansion,</span>
<span class="sd">    #     insignificant_limbs_face_min = floating_piece_face_threshold_expansion,</span>

<span class="sd">        #Step 2: Distance Graph Structure</span>
<span class="sd">        plot_distance_G = True,</span>
<span class="sd">        plot_distance_G_thresholded = True,</span>
<span class="sd">        max_distance_threshold = 500,</span>

<span class="sd">        #Step 3: </span>
<span class="sd">        min_n_faces_on_path = 5_000,</span>
<span class="sd">        plot_final_limbs = True,</span>
<span class="sd">        plot_not_added_limbs = True,</span>

<span class="sd">        verbose = True</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">soma_name</span> <span class="o">=</span> <span class="s2">&quot;Soma&quot;</span>
    <span class="c1">#1) Filter the non_soma_touching and insignificant limbs for a size</span>
    <span class="n">non_soma_touching_meshes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">non_soma_touching_meshes</span><span class="p">)</span>
    <span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">insignificant_limbs</span><span class="p">)</span>

    <span class="n">non_soma_touching_meshes_filt_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_size</span><span class="p">(</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                                            <span class="n">non_soma_touching_meshes_face_min</span><span class="p">,</span>
                                                             <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">non_soma_touching_meshes_filt</span> <span class="o">=</span> <span class="n">non_soma_touching_meshes</span><span class="p">[</span><span class="n">non_soma_touching_meshes_filt_idx</span><span class="p">]</span>


    <span class="n">insignificant_limbs_filt_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_size</span><span class="p">(</span><span class="n">insignificant_limbs</span><span class="p">,</span>
                                                        <span class="n">insignificant_limbs_face_min</span><span class="p">,</span>
                                                       <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">insignificant_limbs_filt</span> <span class="o">=</span> <span class="n">insignificant_limbs</span><span class="p">[</span><span class="n">insignificant_limbs_filt_idx</span><span class="p">]</span>

    <span class="n">soma_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(non_soma_touching_meshes_filt) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(insignificant_limbs_filt) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">insignificant_limbs_filt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">plot_filtered_pieces</span><span class="p">:</span>
        <span class="n">soma_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">non_soma_touch_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>
        <span class="n">insignificant_limb_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span>

        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">soma_mesh</span><span class="p">,</span>
            <span class="n">main_mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
            <span class="n">meshes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">non_soma_touching_meshes_filt</span><span class="p">)</span><span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">insignificant_limbs_filt</span><span class="p">),</span>
            <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="n">non_soma_touch_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes_filt</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">insignificant_limb_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">insignificant_limbs_filt</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes_filt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_meshes_divided</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>





    <span class="c1">#2) Find distances between all of the significant pieces and form a graph structure</span>
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_mesh</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_soma_touching_meshes_filt</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">insignificant_limbs_filt</span><span class="p">)</span>
    <span class="n">meshes_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">soma_name</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;nst_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes_filt</span><span class="p">))]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;il_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">insignificant_limbs_filt</span><span class="p">))</span>
    <span class="p">])</span>

    <span class="n">mesh_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">meshes_names</span><span class="p">,</span><span class="n">meshes</span><span class="p">)}</span>

    <span class="n">mesh_edges</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_distance_connectivity</span><span class="p">(</span>
        <span class="n">meshes</span><span class="p">,</span>
        <span class="n">return_G</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">)</span>


    <span class="n">edges_names_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">meshes_names</span><span class="p">[</span><span class="n">mesh_edges</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)],</span><span class="n">mesh_edges</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">edges_names_fixed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_distance_G</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_distance_G&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">G_sub</span> <span class="o">=</span><span class="n">xu</span><span class="o">.</span><span class="n">query_to_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;weight &lt; </span><span class="si">{</span><span class="n">max_distance_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_distance_G_thresholded</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_distance_G_thresholded&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G_sub</span><span class="p">,</span><span class="n">with_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


    <span class="c1">#3) Determine the meshes that should be made significant limbs</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a) find all paths from NST</span>
<span class="sd">    b) filter for those paths with a certain fae total</span>
<span class="sd">    3) fin all of the nodes right before the soma </span>
<span class="sd">    and the unique set of those will be significant limbs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nst_nodes</span><span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G_sub</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;nst&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nst_nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_meshes_divided</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">nst_shortest_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nst_n</span> <span class="ow">in</span> <span class="n">nst_nodes</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">curr_path</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G_sub</span><span class="p">,</span><span class="n">nst_n</span><span class="p">,</span><span class="n">soma_name</span><span class="p">,</span><span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No path from </span><span class="si">{</span><span class="n">nst_n</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">soma_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nst_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nst_shortest_paths = </span><span class="si">{</span><span class="n">nst_shortest_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1">#     if len(nst_shortest_paths) &lt;= 0:</span>
<span class="c1">#         if return_meshes_divided:</span>
<span class="c1">#             return np.array([]),np.array([]),np.array([]),np.array([])</span>
<span class="c1">#         else:</span>
<span class="c1">#             return np.array([])</span>

    <span class="c1">#b) filter for those paths with a certain fae total</span>
    <span class="n">face_totals_for_paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_lookup</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">soma_name</span><span class="p">])</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">nst_shortest_paths</span><span class="p">])</span>


    <span class="n">face_paths_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">face_totals_for_paths</span><span class="o">&gt;</span><span class="n">min_n_faces_on_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


    <span class="n">new_non_sig_limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">nst_shortest_paths</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">face_paths_idx</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;face_totals_for_paths = </span><span class="si">{</span><span class="n">face_totals_for_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;face_paths_idx = </span><span class="si">{</span><span class="n">face_paths_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_non_sig_limbs = </span><span class="si">{</span><span class="n">new_non_sig_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    
    <span class="n">nst_idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_non_sig_limbs</span> <span class="k">if</span> <span class="s2">&quot;nst&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
    <span class="n">il_idx</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_non_sig_limbs</span> <span class="k">if</span> <span class="s2">&quot;il&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>

    <span class="n">new_limbs_nst</span> <span class="o">=</span> <span class="n">non_soma_touching_meshes_filt</span><span class="p">[</span><span class="n">nst_idx</span><span class="p">]</span>
    <span class="n">new_limbs_il</span> <span class="o">=</span> <span class="n">insignificant_limbs_filt</span><span class="p">[</span><span class="n">il_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot_final_limbs</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_limbs_nst</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_limbs_il</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_final_limbs&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                <span class="n">soma_mesh</span><span class="p">,</span>
                <span class="n">main_mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">meshes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">new_limbs_nst</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_limbs_il</span><span class="p">),</span>
                <span class="n">meshes_colors</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_non_sig_limbs</span><span class="p">),</span><span class="n">colors_to_omit</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No new limb meshes to plot&quot;</span><span class="p">)</span>
        
        
    <span class="n">nst_still_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes</span><span class="p">)),</span><span class="n">non_soma_touching_meshes_filt_idx</span><span class="p">[</span><span class="n">nst_idx</span><span class="p">])</span>
    <span class="n">il_still_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">insignificant_limbs</span><span class="p">)),</span><span class="n">insignificant_limbs_filt_idx</span><span class="p">[</span><span class="n">il_idx</span><span class="p">])</span>

    <span class="n">nst_still_meshes</span> <span class="o">=</span> <span class="n">non_soma_touching_meshes</span><span class="p">[</span><span class="n">nst_still_idx</span><span class="p">]</span>
    <span class="n">il_still_meshes</span> <span class="o">=</span> <span class="n">insignificant_limbs</span><span class="p">[</span><span class="n">il_still_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot_not_added_limbs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_not_added_limbs&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
            <span class="n">soma_mesh</span><span class="p">,</span>
            <span class="n">main_mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
            <span class="n">meshes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">nst_still_meshes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">il_still_meshes</span><span class="p">),</span>
            <span class="n">meshes_colors</span><span class="o">=</span><span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nst_still_meshes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">il_still_meshes</span><span class="p">)</span>
                                                                  <span class="p">,</span><span class="n">colors_to_omit</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]),</span>
        <span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_meshes_divided</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(new_limbs_nst) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_limbs_nst</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(new_limbs_il) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">new_limbs_il</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(nst_still_meshes) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nst_still_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(il_still_meshes) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">il_still_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_limbs_nst</span><span class="p">,</span><span class="n">new_limbs_il</span><span class="p">,</span><span class="n">nst_still_meshes</span><span class="p">,</span><span class="n">il_still_meshes</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_non_sig_limbs</span></div>
    
    
<span class="c1"># ------------- parameters for stats ---------------</span>

<span class="n">global_parameters_dict_default_decomp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">width_threshold_MAP</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
        <span class="n">size_threshold_MAP</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
        <span class="n">size_threshold_MAP_stitch</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
        <span class="n">apply_expansion</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
        <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
        <span class="n">filter_end_node_length</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
        <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">use_adaptive_invalidation_d_floating</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">surface_reconstruction_size</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">invalidation_d</span> <span class="o">=</span> <span class="mi">12000</span><span class="p">,</span>
        <span class="n">remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

<span class="n">global_parameters_dict_default_axon_decomp</span> <span class="o">=</span> <span class="n">dsu</span><span class="o">.</span><span class="n">DictType</span><span class="p">(</span>
    <span class="n">combine_close_skeleton_nodes_threshold_meshparty_axon</span> <span class="o">=</span> <span class="mi">1300</span><span class="p">,</span>
    <span class="n">filter_end_node_length_meshparty_axon</span> <span class="o">=</span> <span class="mi">1150</span><span class="p">,</span>
    <span class="n">filter_end_node_length_axon</span> <span class="o">=</span> <span class="mi">1150</span><span class="p">,</span>
    <span class="n">invalidation_d_axon</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span>
    <span class="n">smooth_neighborhood_axon</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;tinyint unisgned&quot;</span><span class="p">),</span>
    <span class="n">meshparty_segment_size_axon</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">stitch_floating_axon_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">max_stitch_distance_high_fid_axon</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span><span class="c1">#2000,</span>
    <span class="n">floating_piece_face_threshold_high_fid_axon</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_default_decomp</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_axon_decomp</span>
<span class="p">])</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="p">)</span>    

<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">global_parameters_dict_microns_axon_decomp</span> <span class="o">=</span> <span class="p">{}</span>


<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01_decomp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">width_threshold_MAP</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">size_threshold_MAP</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">size_threshold_MAP_stitch</span> <span class="o">=</span> <span class="mi">14_000</span><span class="p">,</span>
    <span class="n">apply_expansion</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">max_stitch_distance</span> <span class="o">=</span> <span class="mi">13000</span><span class="p">,</span><span class="c1">#5000,</span>
    <span class="n">max_stitch_distance_CGAL</span> <span class="o">=</span> <span class="mi">13000</span><span class="p">,</span>
    <span class="n">use_adaptive_invalidation_d</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_adaptive_invalidation_d_floating</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">axon_width_preprocess_limb_max</span> <span class="o">=</span> <span class="mi">350</span><span class="p">,</span>
    
    <span class="n">limb_remove_mesh_interior_face_threshold</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
    
    <span class="n">floating_piece_face_threshold</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01_axon_decomp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">invalidation_d_axon</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">,</span>
    <span class="n">stitch_floating_axon_pieces</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">combine_close_skeleton_nodes_threshold_meshparty_axon</span> <span class="o">=</span> <span class="mi">1700</span><span class="p">,</span>
    <span class="n">max_stitch_distance_high_fid_axon</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span><span class="c1">#5000,</span>
    <span class="n">floating_piece_face_threshold_high_fid_axon</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>
    
<span class="p">)</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_h01_decomp</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_axon_decomp</span>
<span class="p">])</span>

<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>

<span class="c1"># modules_to_set = [pre,spu,nst]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="n">preprocessing_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="c1">#                     meshparty_segment_size = meshparty_segment_size_axon_global,</span>
                    <span class="n">combine_close_skeleton_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="c1">#combine_close_skeleton_nodes_threshold=1200,</span>
<span class="c1">#                     combine_close_skeleton_nodes_threshold_meshparty = combine_close_skeleton_nodes_threshold_meshparty_axon_global,</span>
<span class="c1">#                     filter_end_node_length_meshparty = filter_end_node_length_meshparty_axon_global,</span>
<span class="c1">#                     filter_end_node_length = filter_end_node_length_axon_global,</span>

                    <span class="n">use_meshafterparty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">perform_cleaning_checks</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>


                    <span class="c1">#concept_network parameters</span>
                    <span class="n">run_concept_network_checks</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

                    <span class="n">return_concept_network_starting_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

                    <span class="c1">#printing controls</span>
                    <span class="n">print_fusion_steps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>

                    <span class="n">check_correspondence_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">filter_end_nodes_from_correspondence</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>

<span class="c1">#                     invalidation_d=invalidation_d_axon_global,</span>
<span class="c1">#                     smooth_neighborhood=smooth_neighborhood_axon_global,</span>
                         <span class="p">)</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">soma_extraction_utils</span> <span class="k">as</span> <span class="n">sm</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spine_utils</span> <span class="k">as</span> <span class="n">spu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">compartment_utils</span> <span class="k">as</span> <span class="n">cu</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshparty_skeletonize</span> <span class="k">as</span> <span class="n">m_sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">data_struct_utils</span> <span class="k">as</span> <span class="n">dsu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">datasci_tools.tqdm_utils</span> <span class="kn">import</span> <span class="n">tqdm</span>


<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocess_neuron</span> <span class="k">as</span> <span class="n">pre</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
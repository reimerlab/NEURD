<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.proofreading_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.proofreading_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.proofreading_utils</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>

<span class="n">current_proof_version</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1">#has the inhibitory rules and safer overall axon rules</span>
<span class="n">current_proof_version</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1">#has the inhibitory rules and safer overall axon rules</span>

<span class="n">split_version</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">#fixed the problem with split from suggestions</span>
<span class="n">split_version</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># adding all of the non-soma touching pieces to all of the splits</span>
<span class="n">split_version</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># added width thresholding for which edges are allowed in the resolving edges high degree branching</span>
<span class="n">split_version</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># startw with the double back check at beginning</span>

<div class="viewcode-block" id="find_high_degree_coordinates_on_path"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.find_high_degree_coordinates_on_path">[docs]</a><span class="k">def</span> <span class="nf">find_high_degree_coordinates_on_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">curr_path_to_cut</span><span class="p">,</span>
                                   <span class="n">degree_to_check</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find coordinates on a skeleton of the path speciifed (in terms of node ids)</span>
<span class="sd">    that are above the degree_to_check (in reference to the skeleton)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_divergent_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_path_to_cut</span><span class="p">]</span>
    <span class="n">endpoint_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">path_divergent_points</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">limb_sk_gr</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">endpoint_degrees</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_degree</span><span class="p">(</span><span class="n">limb_sk_gr</span><span class="p">,</span><span class="n">endpoint_coordinates</span><span class="p">)</span>
    <span class="n">high_degree_endpoint_coordinates</span> <span class="o">=</span> <span class="n">endpoint_coordinates</span><span class="p">[</span><span class="n">endpoint_degrees</span><span class="o">&gt;=</span><span class="n">degree_to_check</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">high_degree_endpoint_coordinates</span></div>

<span class="n">proofreading_rule_to_clean_name_dict</span> <span class="o">=</span> <span class="p">{</span>
 <span class="s1">&#39;axon_on_dendrite_merges&#39;</span><span class="p">:</span> <span class="s1">&#39;Axon On Dendrite&#39;</span><span class="p">,</span>
 <span class="s1">&#39;high_degree_branching&#39;</span><span class="p">:</span> <span class="s1">&#39;High Degree Axon&#39;</span><span class="p">,</span>
 <span class="s1">&#39;low_degree_branching&#39;</span><span class="p">:</span> <span class="s1">&#39;Low Degree Axon&#39;</span><span class="p">,</span>
 <span class="s1">&#39;high_degree_branching_dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;High Degree Dendrite&#39;</span><span class="p">,</span>
 <span class="s1">&#39;width_jump_up_dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;Width Jump Dendrite&#39;</span><span class="p">,</span>
 <span class="s1">&#39;width_jump_up_axon&#39;</span><span class="p">:</span> <span class="s1">&#39;Width Jump Axon&#39;</span><span class="p">,</span>
 <span class="s1">&#39;double_back_dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;Double Back Dendrite&#39;</span>
<span class="p">}</span>

<span class="n">proofreading_rule_color_dict</span> <span class="o">=</span> <span class="p">{</span>
 <span class="s1">&#39;axon_on_dendrite_merges&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>
 <span class="s1">&#39;high_degree_branching&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>
 <span class="s1">&#39;low_degree_branching&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
 <span class="s1">&#39;high_degree_branching_dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
 <span class="s1">&#39;width_jump_up_dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;brown&#39;</span><span class="p">,</span>
 <span class="s1">&#39;width_jump_up_axon&#39;</span><span class="p">:</span> <span class="s1">&#39;aqua&#39;</span><span class="p">,</span>
 <span class="s1">&#39;double_back_dendrite&#39;</span><span class="p">:</span> <span class="s1">&#39;grey&#39;</span>   
<span class="p">}</span>

<div class="viewcode-block" id="get_best_cut_edge"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_best_cut_edge">[docs]</a><span class="k">def</span> <span class="nf">get_best_cut_edge</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                      <span class="n">cut_path</span><span class="p">,</span>
                      
                      <span class="n">remove_segment_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#the segments along path that should be combined</span>
                      <span class="n">remove_segment_threshold_round_2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">consider_path_neighbors_for_removal</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      
                      <span class="c1">#paraeters for high degree nodes</span>
                      <span class="n">offset_high_degree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2500,#1500,</span>
                      <span class="n">comparison_distance_high_degree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">match_threshold_high_degree</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#65,#35,#45,#35,</span>
                      <span class="n">plot_intermediates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      
                      <span class="c1">#parameter for both width and doubling back</span>
                      <span class="c1"># This will prevent the edges that were added to extend to the soma from causing the doulbing back or width threshold errors</span>
                      <span class="n">skip_small_soma_connectors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">small_soma_connectors_skeletal_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      
                      <span class="c1"># parameters for the doubling back</span>
                      <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#100,# 130,</span>
                      <span class="n">offset_double_back</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">comparison_distance_double_back</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      
                      <span class="c1">#parameters for the width threshold</span>
                      <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      
                      <span class="n">high_degree_endpoint_coordinates_tried</span> <span class="o">=</span> <span class="p">[],</span> <span class="c1">#is a list of high degree end_nodes that have already been tried</span>
                      <span class="n">simple_path_of_2_cut</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      
                      <span class="n">apply_double_back_first</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">double_back_threshold_at_first</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">return_split_reasons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To choose the best path to cut to disconnect</span>
<span class="sd">    a path based on the heuristic hierarchy of </span>
<span class="sd">    </span>
<span class="sd">    Cut in descending priority</span>
<span class="sd">    1) high degree coordinates</span>
<span class="sd">    2) Doubling Back </span>
<span class="sd">    3) Width Jump</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) Combine close nodes if requested</span>
<span class="sd">    1) Get any high degree cordinates on path</span>
<span class="sd">    --&gt; if there are then pick the first one and perform the cuts</span>
<span class="sd">    </span>
<span class="sd">    2) Check the doubling backs (and pick the highest one if above threshold)</span>
<span class="sd">    3) Check for width jumps (and pick the highest one)</span>
<span class="sd">    4) Record the cuts that will be made</span>
<span class="sd">    5) Make the alterations to the graph (can be adding and creating edges)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">remove_segment_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">remove_segment_threshold</span> <span class="o">=</span> <span class="n">remove_segment_threshold_global</span>
        
    <span class="k">if</span> <span class="n">remove_segment_threshold_round_2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">remove_segment_threshold_round_2</span> <span class="o">=</span> <span class="n">remove_segment_threshold_round_2_global</span>
        
    <span class="k">if</span> <span class="n">consider_path_neighbors_for_removal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">consider_path_neighbors_for_removal</span>  <span class="o">=</span> <span class="n">consider_path_neighbors_for_removal_global</span>
        
    <span class="k">if</span> <span class="n">offset_high_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset_high_degree</span> <span class="o">=</span> <span class="n">offset_high_degree_global</span>
        
    <span class="k">if</span> <span class="n">comparison_distance_high_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance_high_degree</span> <span class="o">=</span> <span class="n">comparison_distance_high_degree_global</span>
        
    <span class="k">if</span> <span class="n">match_threshold_high_degree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">match_threshold_high_degree</span> <span class="o">=</span> <span class="n">match_threshold_high_degree_global</span>
        
    <span class="k">if</span> <span class="n">skip_small_soma_connectors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skip_small_soma_connectors</span> <span class="o">=</span> <span class="n">skip_small_soma_connectors_global</span>
        
    <span class="k">if</span> <span class="n">small_soma_connectors_skeletal_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">small_soma_connectors_skeletal_threshold</span> <span class="o">=</span> <span class="n">small_soma_connectors_skeletal_threshold_global</span>
        
    <span class="k">if</span> <span class="n">double_back_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">double_back_threshold</span> <span class="o">=</span><span class="n">double_back_threshold_global</span>
        
    <span class="k">if</span> <span class="n">offset_double_back</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset_double_back</span> <span class="o">=</span> <span class="n">offset_double_back_global</span>
        
    <span class="k">if</span> <span class="n">comparison_distance_double_back</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance_double_back</span> <span class="o">=</span> <span class="n">comparison_distance_double_back_global</span>
    
    <span class="k">if</span> <span class="n">width_jump_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="n">width_jump_threshold_global</span>
        
    <span class="k">if</span> <span class="n">simple_path_of_2_cut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">simple_path_of_2_cut</span> <span class="o">=</span> <span class="n">simple_path_of_2_cut_global</span>
        
    <span class="k">if</span> <span class="n">apply_double_back_first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">apply_double_back_first</span> <span class="o">=</span> <span class="n">apply_double_back_first_global</span>
    
    <span class="k">if</span> <span class="n">double_back_threshold_at_first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">double_back_threshold_at_first</span> <span class="o">=</span><span class="n">double_back_threshold_at_first_global</span>
    
    <span class="c1">#verbose=True</span>
    <span class="n">removed_branches</span><span class="o">=</span><span class="p">[]</span>
    
    <span class="n">cut_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cut_path</span><span class="p">)</span>
    <span class="n">split_reason</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">debug_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">remove_segment_threshold</span><span class="o">=</span><span class="n">remove_segment_threshold</span><span class="p">,</span><span class="c1">#the segments along path that should be combined</span>
        <span class="n">remove_segment_threshold_round_2</span> <span class="o">=</span> <span class="n">remove_segment_threshold_round_2</span><span class="p">,</span>
        <span class="n">consider_path_neighbors_for_removal</span> <span class="o">=</span> <span class="n">consider_path_neighbors_for_removal</span><span class="p">,</span>

        <span class="c1">#paraeters for high degree nodes</span>
        <span class="n">offset_high_degree</span> <span class="o">=</span> <span class="n">offset_high_degree</span><span class="p">,</span><span class="c1">#2500,#1500,</span>
        <span class="n">comparison_distance_high_degree</span> <span class="o">=</span> <span class="n">comparison_distance_high_degree</span><span class="p">,</span>
        <span class="n">match_threshold_high_degree</span> <span class="o">=</span> <span class="n">match_threshold_high_degree</span><span class="p">,</span><span class="c1">#65,#35,#45,#35,</span>
        <span class="n">plot_intermediates</span><span class="o">=</span><span class="n">plot_intermediates</span><span class="p">,</span>

        <span class="c1">#parameter for both width and doubling back</span>
        <span class="c1"># This will prevent the edges that were added to extend to the soma from causing the doulbing back or width threshold errors</span>
        <span class="n">skip_small_soma_connectors</span> <span class="o">=</span> <span class="n">skip_small_soma_connectors</span><span class="p">,</span>
        <span class="n">small_soma_connectors_skeletal_threshold</span> <span class="o">=</span> <span class="n">small_soma_connectors_skeletal_threshold</span><span class="p">,</span>

        <span class="c1"># parameters for the doubling back</span>
        <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold</span><span class="p">,</span><span class="c1">#100,# 130,</span>
        <span class="n">offset_double_back</span> <span class="o">=</span> <span class="n">offset_double_back</span><span class="p">,</span>
        <span class="n">comparison_distance_double_back</span> <span class="o">=</span> <span class="n">comparison_distance_double_back</span><span class="p">,</span>

        <span class="c1">#parameters for the width threshold</span>
        <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="n">width_jump_threshold</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>

        <span class="n">high_degree_endpoint_coordinates_tried</span> <span class="o">=</span> <span class="n">high_degree_endpoint_coordinates_tried</span><span class="p">,</span> <span class="c1">#is a list of high degree end_nodes that have already been tried</span>
        <span class="n">simple_path_of_2_cut</span> <span class="o">=</span> <span class="n">simple_path_of_2_cut</span><span class="p">,</span>

        <span class="n">apply_double_back_first</span> <span class="o">=</span> <span class="n">apply_double_back_first</span><span class="p">,</span>
        <span class="n">double_back_threshold_at_first</span> <span class="o">=</span> <span class="n">double_back_threshold_at_first</span><span class="p">,</span>
        <span class="n">return_split_reasons</span> <span class="o">=</span> <span class="n">return_split_reasons</span><span class="p">,)</span>
        
        <span class="n">debug_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inisde get_best_cut_edge: debug_dict=/n</span><span class="si">{</span><span class="n">debug_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># ---------- 2/2: will just cut the path if current path is 2 ----------------#</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">simple_path_of_2_cut</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path was only 2 segments (</span><span class="si">{</span><span class="n">cut_path</span><span class="si">}</span><span class="s2">) so just cutting them&quot;</span><span class="p">)</span>
        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">curr_high_degree_coord_list</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="n">split_reason</span> <span class="o">=</span> <span class="s2">&quot;2_branch_cut_at_middle&quot;</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">remove_segment_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">remove_segment_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            

            <span class="n">path_without_ends</span> <span class="o">=</span> <span class="n">cut_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">consider_path_neighbors_for_removal</span><span class="p">:</span>
                <span class="n">curr_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cut_path</span><span class="p">]))</span>
                <span class="n">segments_to_consider</span> <span class="o">=</span> <span class="n">curr_neighbors</span><span class="p">[(</span><span class="n">curr_neighbors</span> <span class="o">!=</span> <span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">curr_neighbors</span> <span class="o">!=</span> <span class="n">cut_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

                <span class="c1"># ----------- 1/19: Have to remove the starting nodes from possible collapsing ------</span>
                <span class="n">segments_to_consider</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">segments_to_consider</span><span class="p">,</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_starting_nodes</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;consider_path_neighbors_for_removal is set so segments_to_consider = </span><span class="si">{</span><span class="n">segments_to_consider</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segments_to_consider</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path_without_ends</span><span class="p">)</span>


            <span class="n">sk_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">segments_to_consider</span><span class="p">])</span>

            <span class="n">short_segments</span> <span class="o">=</span> <span class="n">segments_to_consider</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sk_lens</span><span class="o">&lt;</span><span class="n">remove_segment_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">short_segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trying combining short segments with a larger threshold </span><span class="si">{</span><span class="n">remove_segment_threshold_round_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">short_segments</span> <span class="o">=</span> <span class="n">segments_to_consider</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sk_lens</span><span class="o">&lt;</span><span class="n">remove_segment_threshold_round_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Short segments to combine = </span><span class="si">{</span><span class="n">short_segments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">short_segments</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">-------- Removing Segments -------------&quot;</span><span class="p">)</span>
                <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">collapse_branches_on_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                     <span class="n">branch_list</span><span class="o">=</span><span class="n">short_segments</span><span class="p">,</span>
                                                     <span class="n">plot_new_limb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                
                <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_node</span><span class="o">=</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                

                <span class="n">removed_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">short_segments</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">short_segments</span><span class="p">:</span>
                    <span class="n">cut_path</span> <span class="o">=</span> <span class="n">cut_path</span><span class="p">[</span><span class="n">cut_path</span> <span class="o">!=</span> <span class="n">s</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Revised cut path = </span><span class="si">{</span><span class="n">cut_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------- Done Removing Segments -------------</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>







        <span class="n">high_degree_endpoint_coordinates</span> <span class="o">=</span> <span class="n">find_high_degree_coordinates_on_path</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">cut_path</span><span class="p">)</span>
        <span class="n">high_degree_endpoint_coordinates</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">high_degree_endpoint_coordinates</span><span class="p">,</span><span class="n">high_degree_endpoint_coordinates_tried</span><span class="p">)</span>

        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">resolve_crossover_at_end</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">curr_high_degree_coord_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#will store what high degree end-node was tried</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">high_degree_endpoint_coordinates</span><span class="p">)</span><span class="si">}</span><span class="s2"> high degree coordinates to cut&quot;</span><span class="p">)</span>
            
            
            
            
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_node</span> <span class="o">=</span> <span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">apply_double_back_first</span><span class="p">:</span>
            <span class="c1"># ------------- 12 /28 addition that allows us to skip end nodes if too small ------------------</span>
            <span class="n">skip_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">skip_small_soma_connectors</span><span class="p">:</span>
                <span class="n">revised_cut_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cut_path</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">endnode</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cut_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="n">curr_sk_distance</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">endnode</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">curr_sk_distance</span><span class="o">&lt;</span><span class="n">small_soma_connectors_skeletal_threshold</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping endnode </span><span class="si">{</span><span class="n">endnode</span><span class="si">}</span><span class="s2"> because skeletal distance was </span><span class="si">{</span><span class="n">curr_sk_distance</span><span class="si">}</span><span class="s2"> and threshold was </span><span class="si">{</span><span class="n">small_soma_connectors_skeletal_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">revised_cut_path</span> <span class="o">=</span> <span class="n">revised_cut_path</span><span class="p">[</span><span class="n">revised_cut_path</span> <span class="o">!=</span> <span class="n">endnode</span><span class="p">]</span>
                        <span class="n">skip_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endnode</span><span class="p">)</span>


                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">revised_cut_path</span><span class="p">)</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not used the revised endnodes path because empty&quot;</span><span class="p">)</span>
                    <span class="n">skip_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">revised_cut_path</span> <span class="o">=</span> <span class="n">cut_path</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skip_nodes = </span><span class="si">{</span><span class="n">skip_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempting the doubling back check (symmetrical so don&#39;t need to check from both sides)&quot;</span><span class="p">)</span>

                <span class="n">err_edges</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">edges_double_back</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">double_back_edges_path</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                        <span class="n">path_to_check</span><span class="o">=</span><span class="n">revised_cut_path</span><span class="p">,</span>
                                      <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold_at_first</span><span class="p">,</span>
                                      <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_double_back</span><span class="p">,</span>
                                     <span class="n">offset</span><span class="o">=</span><span class="n">offset_double_back</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                    <span class="n">skip_nodes</span><span class="o">=</span><span class="n">skip_nodes</span><span class="p">)</span>


                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="n">largest_double_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">edges_double_back</span><span class="p">)</span>
                    <span class="n">largest_double_back_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edges_double_back</span><span class="p">[</span><span class="n">largest_double_back</span><span class="p">])</span>
                    <span class="n">winning_err_edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">largest_double_back</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">err_edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> edges that passed doubling back threshold of </span><span class="si">{</span><span class="n">double_back_threshold_at_first</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning edge </span><span class="si">{</span><span class="n">winning_err_edge</span><span class="si">}</span><span class="s2"> had a doubling back of </span><span class="si">{</span><span class="n">edges_double_back</span><span class="p">[</span><span class="n">largest_double_back</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_err_edge</span><span class="p">]</span>
                    <span class="n">split_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;double_back_angle_first_pass_</span><span class="si">{</span><span class="n">largest_double_back_value</span><span class="si">}</span><span class="s2">_threshold_</span><span class="si">{</span><span class="n">double_back_threshold_at_first</span><span class="si">}</span><span class="s2">&quot;</span>



        <span class="c1"># -------------- 1/27: Will organize the high degree nodes by the average width of the branches they are touching --- #</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_degree_endpoint_coordinates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">sk_branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">br</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">]</span>

            <span class="n">high_degree_endpoint_coordinates_widths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="n">high_degree_endpoint_coordinates</span><span class="p">:</span>
                <span class="n">coordinate_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">find_branch_skeleton_with_specific_coordinate</span><span class="p">(</span><span class="n">sk_branches</span><span class="p">,</span><span class="n">coordinate</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinate_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mean_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">coordinate_branches</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mean_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="n">high_degree_endpoint_coordinates_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_width</span><span class="p">)</span>

            <span class="n">high_degree_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">high_degree_endpoint_coordinates_widths</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;high_degree_endpoint_coordinates_widths = </span><span class="si">{</span><span class="n">high_degree_endpoint_coordinates_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;high_degree_order = </span><span class="si">{</span><span class="n">high_degree_order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="c1">#for curr_high_degree_coord in high_degree_endpoint_coordinates:</span>
            <span class="k">for</span> <span class="n">curr_high_degree_coord_idx</span> <span class="ow">in</span> <span class="n">high_degree_order</span><span class="p">:</span>
                <span class="n">curr_high_degree_coord</span> <span class="o">=</span> <span class="n">high_degree_endpoint_coordinates</span><span class="p">[</span><span class="n">curr_high_degree_coord_idx</span><span class="p">]</span>

                <span class="n">curr_high_degree_coord_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_high_degree_coord</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Picking </span><span class="si">{</span><span class="n">curr_high_degree_coord</span><span class="si">}</span><span class="s2"> high degree coordinates to cut&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb.deleted_edges 4=</span><span class="si">{</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">deleted_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">edges_to_delete_pre</span><span class="p">,</span><span class="n">edges_to_create_pre</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">resolving_crossovers</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">curr_high_degree_coord</span><span class="p">,</span>
                                                        <span class="n">offset</span><span class="o">=</span><span class="n">offset_high_degree</span><span class="p">,</span>
                                                        <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance_high_degree</span><span class="p">,</span>
                                                                                  <span class="n">match_threshold</span> <span class="o">=</span><span class="n">match_threshold_high_degree</span><span class="p">,</span>
                                                                                  <span class="n">plot_intermediates</span><span class="o">=</span><span class="n">plot_intermediates</span><span class="p">,</span>
                                                        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                         <span class="n">branches_to_disconnect</span> <span class="o">=</span> <span class="n">cut_path</span><span class="p">,</span>
                                                        
                                                        <span class="o">**</span><span class="n">kwargs</span>
                                       <span class="p">)</span>
                
                <span class="c1">#raise Exception(&quot;Done Crossover&quot;)</span>
                <span class="c1">#  --- 1/19: Add in a check that will see if divides up the path, if not then set to empty  --- #</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_to_delete_pre</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>

                    <span class="n">cut_path_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cut_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span><span class="o">.</span><span class="n">T</span>


                    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">cut_path_edges</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nx.number_connected_components(G) before = </span><span class="si">{</span><span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges_to_delete_pre</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;G.edges() = </span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;G.nodes() = </span><span class="si">{</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nx.number_connected_components(G) after = </span><span class="si">{</span><span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_path</span><span class="p">))</span> <span class="ow">or</span> <span class="n">nx</span><span class="o">.</span><span class="n">number_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the resolve crossover delete edges because will help seperate the path&quot;</span><span class="p">)</span>
                        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">edges_to_delete_pre</span>
                        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="n">edges_to_create_pre</span>
                        <span class="n">resolve_crossover_at_end</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">split_reason</span> <span class="o">=</span> <span class="s2">&quot;high_degree_node&quot;</span>
                        <span class="k">break</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NOT USING the resolve crossover delete edges because not help resolve the cut&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>








        <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_node</span> <span class="o">=</span> <span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># ------------- 12 /28 addition that allows us to skip end nodes if too small ------------------</span>
        <span class="n">skip_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">skip_small_soma_connectors</span><span class="p">:</span>
            <span class="n">revised_cut_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cut_path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">endnode</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cut_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">curr_sk_distance</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">endnode</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">curr_sk_distance</span><span class="o">&lt;</span><span class="n">small_soma_connectors_skeletal_threshold</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping endnode </span><span class="si">{</span><span class="n">endnode</span><span class="si">}</span><span class="s2"> because skeletal distance was </span><span class="si">{</span><span class="n">curr_sk_distance</span><span class="si">}</span><span class="s2"> and threshold was </span><span class="si">{</span><span class="n">small_soma_connectors_skeletal_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">revised_cut_path</span> <span class="o">=</span> <span class="n">revised_cut_path</span><span class="p">[</span><span class="n">revised_cut_path</span> <span class="o">!=</span> <span class="n">endnode</span><span class="p">]</span>
                    <span class="n">skip_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endnode</span><span class="p">)</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">revised_cut_path</span><span class="p">)</span> <span class="o">&lt;</span><span class="mi">2</span> <span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not used the revised endnodes path because empty&quot;</span><span class="p">)</span>
                <span class="n">skip_nodes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skip_nodes = </span><span class="si">{</span><span class="n">skip_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempting the doubling back check (symmetrical so don&#39;t need to check from both sides)&quot;</span><span class="p">)</span>

            <span class="n">err_edges</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">edges_double_back</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">double_back_edges_path</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                    <span class="n">path_to_check</span><span class="o">=</span><span class="n">cut_path</span><span class="p">,</span>
                                  <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold</span><span class="p">,</span>
                                  <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_double_back</span><span class="p">,</span>
                                 <span class="n">offset</span><span class="o">=</span><span class="n">offset_double_back</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                <span class="n">skip_nodes</span><span class="o">=</span><span class="n">skip_nodes</span><span class="p">)</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">largest_double_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">edges_double_back</span><span class="p">)</span>
                <span class="n">largest_double_back_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edges_double_back</span><span class="p">[</span><span class="n">largest_double_back</span><span class="p">])</span>
                <span class="n">winning_err_edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">largest_double_back</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">err_edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> edges that passed doubling back threshold of </span><span class="si">{</span><span class="n">double_back_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Winning edge </span><span class="si">{</span><span class="n">winning_err_edge</span><span class="si">}</span><span class="s2"> had a doubling back of </span><span class="si">{</span><span class="n">edges_double_back</span><span class="p">[</span><span class="n">largest_double_back</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_err_edge</span><span class="p">]</span>
                
                <span class="n">split_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;double_back_angle_second_pass_</span><span class="si">{</span><span class="n">largest_double_back_value</span><span class="si">}</span><span class="s2">_threshold_</span><span class="si">{</span><span class="n">double_back_threshold</span><span class="si">}</span><span class="s2">&quot;</span> 

        <span class="k">if</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Attempting the width jump check (ARTIFICIALLY ATTEMPTING FROM BOTH SIDES)&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_jump_threshold = </span><span class="si">{</span><span class="n">width_jump_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">possible_starting_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cut_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>


            <span class="n">first_error_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">first_error_sizes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">first_error_locations</span> <span class="o">=</span> <span class="p">[]</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;  Old way of doing </span>
<span class="sd">            for s_node in possible_starting_nodes:</span>

<span class="sd">                curr_limb.set_concept_network_directional(starting_node = s_node,suppress_disconnected_errors=True)</span>

<span class="sd">                if cut_path[0] != s_node:</span>
<span class="sd">                    cut_path = np.flip(cut_path)</span>
<span class="sd">                    if cut_path[0] != s_node:</span>
<span class="sd">                        raise Exception(&quot;Neither of cut path end nodes are starting node&quot;)</span>

<span class="sd">                err_edges,edges,edges_width_jump = ed.width_jump_edges_path(curr_limb,</span>
<span class="sd">                                                                            path_to_check=cut_path,</span>
<span class="sd">                                                                            width_jump_threshold=width_jump_threshold,</span>
<span class="sd">                                                                            offset=offset,</span>
<span class="sd">                                                                            verbose=verbose,</span>
<span class="sd">                                                                            skip_nodes=skip_nodes</span>
<span class="sd">                                        )</span>

<span class="sd">                if verbose:</span>
<span class="sd">                    print(f&quot;Path starting at {s_node} had err_edges: {err_edges}&quot;)</span>

<span class="sd">                err_edges_mask = edges_width_jump&gt;=width_jump_threshold</span>

<span class="sd">                if np.any(err_edges_mask):</span>
<span class="sd">                    first_error_edges.append(edges[err_edges_mask][0])</span>
<span class="sd">                    first_error_sizes.append(edges_width_jump[err_edges_mask][0])</span>
<span class="sd">                else:</span>
<span class="sd">                    first_error_edges.append(None)</span>
<span class="sd">                    first_error_sizes.append(-np.inf)</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># ----------- 1/19: New Way of Splitting ------------- #</span>
            <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_node</span> <span class="o">=</span> <span class="n">cut_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>



            <span class="n">err_edges</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">edges_width_jump</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">width_jump_edges_path</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                                        <span class="n">path_to_check</span><span class="o">=</span><span class="n">cut_path</span><span class="p">,</span>
                                                                        <span class="n">width_jump_threshold</span><span class="o">=</span><span class="n">width_jump_threshold</span><span class="p">,</span>
                                                                        <span class="n">offset</span><span class="o">=</span><span class="n">offset_double_back</span><span class="p">,</span>
                                                                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                        <span class="n">skip_nodes</span><span class="o">=</span><span class="n">skip_nodes</span>
                                    <span class="p">)</span>

            <span class="c1"># 1) Doing the forwards way</span>

            <span class="n">err_edges_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edges_width_jump</span><span class="o">&gt;=</span><span class="n">width_jump_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">err_edges_mask</span><span class="p">):</span>
                <span class="n">first_error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">err_edges_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">first_error_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges_width_jump</span><span class="p">[</span><span class="n">err_edges_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">first_error_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err_edges_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first_error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">first_error_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="n">first_error_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

            <span class="c1"># 2) Doing the backwards way</span>

            <span class="n">edges_width_jump_flipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">edges_width_jump</span><span class="p">)</span>
            <span class="n">edges_flipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

            <span class="n">err_edges_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edges_width_jump_flipped</span> <span class="o">&lt;=-</span><span class="n">width_jump_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">err_edges_mask</span><span class="p">):</span>
                <span class="n">first_error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges_flipped</span><span class="p">[</span><span class="n">err_edges_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">first_error_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">edges_width_jump_flipped</span><span class="p">[</span><span class="n">err_edges_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
                <span class="n">first_error_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err_edges_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first_error_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">first_error_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="n">first_error_locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) Check if both error edges are not empty</span>
<span class="sd">            2) Get the starting error </span>


<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">first_error_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">first_error_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;  Old way that did it on the biggest size, new way does it on the first jump</span>
<span class="sd">                winning_path = np.argmax(first_error_sizes)</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="n">winning_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">first_error_locations</span><span class="p">)</span>
                <span class="n">winning_err_edge</span> <span class="o">=</span> <span class="n">first_error_edges</span><span class="p">[</span><span class="n">winning_path</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;first_error_sizes = </span><span class="si">{</span><span class="n">first_error_sizes</span><span class="si">}</span><span class="s2">, first_error_locations = </span><span class="si">{</span><span class="n">first_error_locations</span><span class="si">}</span><span class="s2">, winning_path = </span><span class="si">{</span><span class="n">winning_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


                <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="p">[</span><span class="n">winning_err_edge</span><span class="p">]</span>
                <span class="n">split_reason</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;width_jump_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">first_error_sizes</span><span class="p">[</span><span class="n">winning_path</span><span class="p">])</span><span class="si">}</span><span class="s2">_threshold_</span><span class="si">{</span><span class="n">width_jump_threshold</span><span class="si">}</span><span class="s2">&quot;</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not find an error edge in either of the paths&quot;</span><span class="p">)</span>


        <span class="c1"># need to resolve cross over at this point</span>
        <span class="k">if</span> <span class="n">resolve_crossover_at_end</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inside resolve_crossover_at_end at end: </span><span class="se">\n</span><span class="s2">current edges_to_delete = </span><span class="si">{</span><span class="n">edges_to_delete</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="n">cut_e</span> <span class="o">=</span> <span class="n">edges_to_delete</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">suggested_cut_point</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">cut_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                    <span class="n">curr_limb</span><span class="p">[</span><span class="n">cut_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

            <span class="n">edges_to_delete_new</span><span class="p">,</span><span class="n">edges_to_create_new</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">resolving_crossovers</span><span class="p">(</span>
                <span class="n">curr_limb</span><span class="p">,</span>
                <span class="n">coordinate</span><span class="o">=</span><span class="n">suggested_cut_point</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">offset_high_degree</span><span class="p">,</span>
                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance_high_degree</span><span class="p">,</span>
                <span class="n">match_threshold</span> <span class="o">=</span><span class="n">match_threshold_high_degree</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="n">edges_to_avoid</span> <span class="o">=</span> <span class="n">edges_to_delete</span><span class="p">,</span>
                <span class="n">return_subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">branches_to_disconnect</span> <span class="o">=</span> <span class="n">cut_e</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After Resolving crossovers at end: &quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_delete_new = </span><span class="si">{</span><span class="n">edges_to_delete_new</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_create_new = </span><span class="si">{</span><span class="n">edges_to_create_new</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_to_delete_new</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">edges_to_delete</span><span class="p">,</span><span class="n">edges_to_delete_new</span><span class="p">])</span>
                <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>



            <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_to_create</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">edges_to_create</span> <span class="o">+=</span> <span class="n">edges_to_create_new</span>
                <span class="n">edges_to_create</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges_to_create</span> <span class="o">=</span> <span class="n">edges_to_create_new</span>

            <span class="c1"># want to limit the edges to only those with one of the disconnected edges in it</span>
            <span class="n">edges_to_create_final</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e_c1</span> <span class="ow">in</span> <span class="n">edges_to_create</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">e_c1</span><span class="p">,</span><span class="n">cut_e</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">edges_to_create_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_c1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rejecting creating edge </span><span class="si">{</span><span class="n">e_c1</span><span class="si">}</span><span class="s2"> becuase did not involve only 1 node in the deleted edge&quot;</span><span class="p">)</span>
            <span class="n">edges_to_create</span> <span class="o">=</span> <span class="n">edges_to_create_final</span>




    <span class="n">curr_limb</span><span class="p">,</span><span class="n">edges_to_create_final</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">cut_limb_network_by_edges</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                    <span class="n">edges_to_delete</span><span class="p">,</span>
                                                    <span class="n">edges_to_create</span><span class="p">,</span>
                                                    <span class="n">return_accepted_edges_to_create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="n">edges_to_create</span><span class="o">=</span><span class="n">edges_to_create_final</span>
    
        

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of connected components = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Comp </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">):</span>
        <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">):</span>
        <span class="n">edges_to_create</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">edges_to_create</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">):</span>
        <span class="n">removed_branches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_split_reasons</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edges_to_delete</span><span class="p">,</span><span class="n">edges_to_create</span><span class="p">,</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">removed_branches</span><span class="p">,</span><span class="n">curr_high_degree_coord_list</span><span class="p">,</span><span class="n">split_reason</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">edges_to_delete</span><span class="p">,</span><span class="n">edges_to_create</span><span class="p">,</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">removed_branches</span><span class="p">,</span><span class="n">curr_high_degree_coord_list</span></div>

<div class="viewcode-block" id="get_all_coordinate_suggestions"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_all_coordinate_suggestions">[docs]</a><span class="k">def</span> <span class="nf">get_all_coordinate_suggestions</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">voxel_adjustment</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Getting all the coordinates where there should be cuts</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suggestions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">all_coord</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">sugg_v</span> <span class="ow">in</span> <span class="n">suggestions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">get_attribute_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span>
                                 <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;coordinate_suggestions&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">voxel_adjustment</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_coords</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_coords</span> <span class="o">=</span> <span class="n">curr_coords</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">40</span><span class="p">])</span>
                
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_coords</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">voxel_adjustment</span><span class="p">:</span>
        <span class="n">all_coord</span>
    <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_coord</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_coord</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_coord</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_coord</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="get_n_paths_not_cut"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_n_paths_not_cut">[docs]</a><span class="k">def</span> <span class="nf">get_n_paths_not_cut</span><span class="p">(</span><span class="n">limb_results</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all of the coordinates on the paths that will be cut</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">n_paths_not_cut</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span> <span class="n">limb_data</span> <span class="ow">in</span> <span class="n">limb_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">path_cut_info</span> <span class="ow">in</span> <span class="n">limb_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s2">&quot;paths_not_cut&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_paths_not_cut</span> <span class="o">+=</span> <span class="mi">1</span>   
                
    <span class="k">return</span> <span class="n">n_paths_not_cut</span></div>

<div class="viewcode-block" id="split_type_from_title"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_type_from_title">[docs]</a><span class="k">def</span> <span class="nf">split_type_from_title</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="n">somas</span> <span class="o">=</span> <span class="n">title</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; from &quot;</span><span class="p">)</span>
    <span class="n">somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">somas</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">somas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">somas</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="s1">&#39;multi-touch&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;multi-soma&#39;</span></div>
    
<div class="viewcode-block" id="get_n_paths_cut"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_n_paths_cut">[docs]</a><span class="k">def</span> <span class="nf">get_n_paths_cut</span><span class="p">(</span>
    <span class="n">limb_results</span><span class="p">,</span>
    <span class="n">return_multi_touch_multi_soma</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all of the coordinates on the paths that will be cut</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="n">n_paths_cut</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_paths_multi_soma</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_paths_multi_touch</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span> <span class="n">limb_data</span> <span class="ow">in</span> <span class="n">limb_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">path_cut_info</span> <span class="ow">in</span> <span class="n">limb_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s2">&quot;paths_cut&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n_paths_cut</span> <span class="o">+=</span> <span class="mi">1</span>  
                
                <span class="k">if</span> <span class="n">split_type_from_title</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="s1">&#39;multi-touch&#39;</span><span class="p">:</span>
                    <span class="n">n_paths_multi_touch</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n_paths_multi_soma</span> <span class="o">+=</span> <span class="mi">1</span>
                    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_paths_multi_soma = </span><span class="si">{</span><span class="n">n_paths_multi_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_paths_multi_touch = </span><span class="si">{</span><span class="n">n_paths_multi_touch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_paths_cut = </span><span class="si">{</span><span class="n">n_paths_cut</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
    <span class="k">if</span> <span class="n">return_multi_touch_multi_soma</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n_paths_multi_touch</span><span class="p">,</span><span class="n">n_paths_multi_soma</span>
    <span class="k">return</span> <span class="n">n_paths_cut</span></div>

<div class="viewcode-block" id="get_all_cut_and_not_cut_path_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_all_cut_and_not_cut_path_coordinates">[docs]</a><span class="k">def</span> <span class="nf">get_all_cut_and_not_cut_path_coordinates</span><span class="p">(</span><span class="n">limb_results</span><span class="p">,</span><span class="n">voxel_adjustment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all of the coordinates on the paths that will be cut</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],[]</span>
    
    <span class="n">cut_path_coordinates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">not_cut_path_coordinates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span> <span class="n">limb_data</span> <span class="ow">in</span> <span class="n">limb_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">path_cut_info</span> <span class="ow">in</span> <span class="n">limb_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s2">&quot;paths_cut&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cut_path_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s2">&quot;paths_cut&quot;</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s2">&quot;paths_not_cut&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">not_cut_path_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">path_cut_info</span><span class="p">[</span><span class="s2">&quot;paths_not_cut&quot;</span><span class="p">]))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_path_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">total_cut_path_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">cut_path_coordinates</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_cut_path_coordinates</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_cut_path_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">total_not_cut_path_coordinates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">not_cut_path_coordinates</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_not_cut_path_coordinates</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_not_cut_path_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_cut_path_coordinates</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">total_cut_path_coordinates_revised</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">total_cut_path_coordinates</span><span class="p">,</span><span class="n">total_not_cut_path_coordinates</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">total_cut_path_coordinates_revised</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">total_cut_path_coordinates</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">voxel_adjustment</span><span class="p">:</span>
        <span class="n">voxel_divider</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">40</span><span class="p">])</span>
        <span class="n">total_cut_path_coordinates_revised</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">/</span><span class="n">voxel_divider</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_cut_path_coordinates_revised</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">total_not_cut_path_coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">/</span><span class="n">voxel_divider</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_not_cut_path_coordinates</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        
    
        
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">total_cut_path_coordinates_revised</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">total_not_cut_path_coordinates</span><span class="p">)</span></div>

    
    
<div class="viewcode-block" id="get_attribute_from_suggestion"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_attribute_from_suggestion">[docs]</a><span class="k">def</span> <span class="nf">get_attribute_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;edges_to_delete&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">suggestions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">curr_limb_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No specified limb idx when passed all the suggestions&quot;</span><span class="p">)</span>
        <span class="n">suggestions</span> <span class="o">=</span> <span class="n">suggestions</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
        
    <span class="n">total_attribute</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cut_s</span> <span class="ow">in</span> <span class="n">suggestions</span><span class="p">:</span>
        <span class="n">total_attribute</span> <span class="o">+=</span> <span class="n">cut_s</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">total_attribute</span></div>

<div class="viewcode-block" id="get_edges_to_delete_from_suggestion"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_edges_to_delete_from_suggestion">[docs]</a><span class="k">def</span> <span class="nf">get_edges_to_delete_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_attribute_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="p">,</span>
                                 <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;edges_to_delete&quot;</span><span class="p">)</span></div>
<div class="viewcode-block" id="get_edges_to_create_from_suggestion"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_edges_to_create_from_suggestion">[docs]</a><span class="k">def</span> <span class="nf">get_edges_to_create_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_attribute_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="p">,</span>
                                 <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;edges_to_create&quot;</span><span class="p">)</span></div>
<div class="viewcode-block" id="get_removed_branches_from_suggestion"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_removed_branches_from_suggestion">[docs]</a><span class="k">def</span> <span class="nf">get_removed_branches_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_attribute_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="p">,</span>
                                 <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;removed_branches&quot;</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="cut_limb_network_by_suggestions"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.cut_limb_network_by_suggestions">[docs]</a><span class="k">def</span> <span class="nf">cut_limb_network_by_suggestions</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                   <span class="n">suggestions</span><span class="p">,</span>
                                   <span class="n">curr_limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">return_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">suggestions</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">curr_limb_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No specified limb idx when passed all the suggestions&quot;</span><span class="p">)</span>
        <span class="n">suggestions</span> <span class="o">=</span> <span class="n">suggestions</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">cut_limb_network_by_edges</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                    <span class="n">edges_to_delete</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">get_edges_to_delete_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">),</span>
                                    <span class="n">edges_to_create</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">get_edges_to_create_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">),</span>
                                     <span class="n">removed_branches</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">get_removed_branches_from_suggestion</span><span class="p">(</span><span class="n">suggestions</span><span class="p">),</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                     <span class="n">return_copy</span><span class="o">=</span><span class="n">return_copy</span>
                                    <span class="p">)</span></div>
    
<div class="viewcode-block" id="cut_limb_network_by_edges"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.cut_limb_network_by_edges">[docs]</a><span class="k">def</span> <span class="nf">cut_limb_network_by_edges</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                    <span class="n">edges_to_delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">edges_to_create</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">removed_branches</span><span class="o">=</span><span class="p">[],</span>
                                    <span class="n">perform_edge_rejection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">return_accepted_edges_to_create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">return_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">return_limb_network</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">return_copy</span><span class="p">:</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">removed_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">collapse_branches_on_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                 <span class="n">branch_list</span><span class="o">=</span><span class="n">removed_branches</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_to_delete</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_delete (cut_limb_network) = </span><span class="si">{</span><span class="n">edges_to_delete</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">)</span>
        
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">deleted_edges</span> <span class="o">+=</span> <span class="n">edges_to_delete</span>
        
    <span class="c1">#apply the winning cut</span>
    <span class="n">accepted_edges_to_create</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">edges_to_create</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_create = </span><span class="si">{</span><span class="n">edges_to_create</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">perform_edge_rejection</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">edges_to_create</span><span class="p">:</span>
                <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">d1</span><span class="p">,</span><span class="n">d2</span> <span class="ow">in</span> <span class="n">edges_to_delete</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ex_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rejected edge (</span><span class="si">{</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Accepted edge (</span><span class="si">{</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="n">accepted_edges_to_create</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">accepted_edges_to_create</span> <span class="o">=</span> <span class="n">edges_to_create</span>
            <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">accepted_edges_to_create</span><span class="p">)</span>

        <span class="c1">#add them to the properties</span>
        <span class="n">curr_limb</span><span class="o">.</span><span class="n">created_edges</span> <span class="o">+=</span> <span class="n">accepted_edges_to_create</span>
    
    <span class="k">if</span> <span class="n">return_accepted_edges_to_create</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_limb</span><span class="p">,</span><span class="n">accepted_edges_to_create</span>
    
    <span class="k">if</span> <span class="n">return_limb_network</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_limb</span></div>


<div class="viewcode-block" id="soma_connections_from_split_title"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.soma_connections_from_split_title">[docs]</a><span class="k">def</span> <span class="nf">soma_connections_from_split_title</span><span class="p">(</span><span class="n">title</span><span class="p">):</span>
    <span class="n">split_title</span> <span class="o">=</span> <span class="n">title</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split_title</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">split_title</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span></div>
<div class="viewcode-block" id="soma_names_from_split_title"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.soma_names_from_split_title">[docs]</a><span class="k">def</span> <span class="nf">soma_names_from_split_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">split_title</span> <span class="o">=</span> <span class="n">title</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="n">soma_idx_1</span> <span class="o">=</span> <span class="n">split_title</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">soma_idx_2</span> <span class="o">=</span> <span class="n">split_title</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_idx_1</span><span class="p">,</span><span class="n">soma_idx_2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_idx</span><span class="p">:</span>
        <span class="n">return_value</span>  <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_soma_int_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">return_value</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="multi_soma_split_suggestions"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.multi_soma_split_suggestions">[docs]</a><span class="k">def</span> <span class="nf">multi_soma_split_suggestions</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">plot_suggestions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_intermediates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_suggestions_scatter_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
    <span class="n">remove_segment_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_cut_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">only_multi_soma_paths</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1"># to restrict to only different soma-soma paths</span>
    <span class="n">default_cut_edge</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1">#for red blue suggestions</span>
    <span class="n">output_red_blue_suggestions</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">split_red_blue_by_common_upstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">one_hop_downstream_error_branches_max_distance</span><span class="o">=</span><span class="mi">4_000</span><span class="p">,</span>
    <span class="n">offset_distance_for_points</span><span class="o">=</span><span class="mi">3_000</span><span class="p">,</span><span class="c1">#500,</span>
    <span class="n">n_points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="c1">#3,</span>
    <span class="n">plot_final_blue_red_points</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">only_outermost_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_removed_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">min_error_downstream_length_total</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span>
    <span class="n">apply_valid_upstream_branches_restriction</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">debug_red_blue</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To come up with suggestions for splitting a multi-soma</span>

<span class="sd">    Pseudocode: </span>

<span class="sd">    1) Iterate through all of the limbs that need to be processed</span>
<span class="sd">    2) Find the suggested cuts until somas are disconnected or failed</span>
<span class="sd">    3) Optional: Visualize the nodes and their disconnections</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">remove_segment_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">remove_segment_threshold</span> <span class="o">=</span> <span class="n">remove_segment_threshold_global</span>
    
    <span class="c1">#sprint(&quot;inside multi_soma_split_suggestions&quot;)</span>

    <span class="n">multi_soma_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">multi_touch_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">only_multi_soma_paths</span><span class="p">:</span>
        <span class="n">multi_touch_limbs</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;multi_soma_limbs = </span><span class="si">{</span><span class="n">multi_soma_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;multi_touch_limbs = </span><span class="si">{</span><span class="n">multi_touch_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">total_limbs_to_process</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">multi_soma_limbs</span><span class="p">,</span><span class="n">multi_touch_limbs</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">limb_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">red_blue_split_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">red_blue_counter</span> <span class="o">=</span> <span class="mi">0</span>
    

    <span class="k">for</span> <span class="n">curr_limb_idx</span> <span class="ow">in</span> <span class="n">total_limbs_to_process</span><span class="p">:</span>
        <span class="n">curr_limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> -------- Working on limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">------------&quot;</span><span class="p">)</span>
<span class="c1">#         if curr_limb_idx != 2:</span>
<span class="c1">#             continue</span>
        <span class="n">curr_limb_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">output_red_blue_suggestions</span><span class="p">:</span>
            <span class="n">limb_obj_collapsed</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">])</span>
            <span class="n">red_blue_split_dict</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#----- starting the path cutting ------ #</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find path to cut:</span>
<span class="sd">        1) Get the concept network</span>
<span class="sd">        2) Get all of the starting nodes for somas</span>
<span class="sd">        3) Get the shortest path between each combination of starting nodes</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        OLD METHOD OF FINDING THE COMBINATIONS</span>
<span class="sd">        #2) Get all of the starting nodes for somas</span>
<span class="sd">        all_starting_nodes = [k[&quot;starting_node&quot;] for k in curr_limb_copy.all_concept_network_data]</span>

<span class="sd">        starting_node_combinations = list(itertools.combinations(all_starting_nodes,2))</span>
<span class="sd">        starting_node_combinations = nu.unique_non_self_pairings(starting_node_combinations)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">starting_node_combinations</span><span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">starting_node_combinations_of_limb_sorted_by_microns_midpoint</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">curr_limb_idx</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">only_multi_soma_paths</span> <span class="o">=</span> <span class="n">only_multi_soma_paths</span><span class="p">,</span>
            <span class="n">return_soma_names</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting combinations to process = </span><span class="si">{</span><span class="n">starting_node_combinations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        
        
        <span class="k">for</span> <span class="n">st_n_1</span><span class="p">,</span><span class="n">st_n_2</span> <span class="ow">in</span> <span class="n">starting_node_combinations</span><span class="p">:</span>
            <span class="n">local_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">starting_node_1</span><span class="o">=</span><span class="n">st_n_1</span><span class="p">,</span>
                                <span class="n">starting_node_2</span> <span class="o">=</span> <span class="n">st_n_2</span><span class="p">)</span>
            <span class="n">st_n_1_soma</span><span class="p">,</span><span class="n">st_n_1_soma_group_idx</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">get_soma_by_starting_node</span><span class="p">(</span><span class="n">st_n_1</span><span class="p">),</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">get_soma_group_by_starting_node</span><span class="p">(</span><span class="n">st_n_1</span><span class="p">)</span>
            <span class="n">st_n_2_soma</span><span class="p">,</span><span class="n">st_n_2_soma_group_idx</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">get_soma_by_starting_node</span><span class="p">(</span><span class="n">st_n_2</span><span class="p">),</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">get_soma_group_by_starting_node</span><span class="p">(</span><span class="n">st_n_2</span><span class="p">)</span>

            <span class="n">soma_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">st_n_1_soma</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">st_n_1_soma_group_idx</span><span class="si">}</span><span class="s2"> from S</span><span class="si">{</span><span class="n">st_n_2_soma</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">st_n_2_soma_group_idx</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">soma_title</span>
            
            

            <span class="n">total_soma_paths_to_cut</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">total_soma_paths_to_add</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">total_removed_branches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">total_split_reasons</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            
            <span class="c1"># need to keep cutting until no path for them</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---- working on disconnecting </span><span class="si">{</span><span class="n">st_n_1</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">st_n_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---- This disconnects </span><span class="si">{</span><span class="n">soma_title</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Currnet title = </span><span class="si">{</span><span class="n">soma_title</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="n">high_degree_endpoint_coordinates_tried</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">local_paths_cut</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">local_paths_not_cut</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Cut iteration </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of graphs at the end of the split BEFORE DIRECTIONAL = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seperated_graphs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    
                <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_node</span><span class="o">=</span><span class="n">st_n_1</span><span class="p">,</span><span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                
                <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of graphs at the end of the split AFTER DIRECTIONAL = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seperated_graphs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">soma_to_soma_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">st_n_1</span><span class="p">,</span><span class="n">st_n_2</span><span class="p">))</span>
                    
                    
                    
                    
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No valid path so moving onto the next connection&quot;</span><span class="p">)</span>
                    
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                
                <span class="c1">#try and figure out the endpoints along the path</span>
                <span class="n">local_paths_cut</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">skeleton_points_along_path</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">,</span><span class="n">soma_to_soma_path</span><span class="p">))</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shortest path = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">soma_to_soma_path</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># say we found the cut node to make</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;remove_segment_threshold = </span><span class="si">{</span><span class="n">remove_segment_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;high_degree_endpoint_coordinates_tried = </span><span class="si">{</span><span class="n">high_degree_endpoint_coordinates_tried</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="p">(</span><span class="n">cut_edges</span><span class="p">,</span> 
                <span class="n">added_edges</span><span class="p">,</span> 
                <span class="n">curr_limb_copy</span><span class="p">,</span>
                <span class="n">removed_branches</span><span class="p">,</span>
                <span class="n">curr_high_degree_coord</span><span class="p">,</span>
                 <span class="n">curr_split_reason</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">get_best_cut_edge</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">,</span><span class="n">soma_to_soma_path</span><span class="p">,</span>
                                                                <span class="n">remove_segment_threshold</span><span class="o">=</span><span class="n">remove_segment_threshold</span><span class="p">,</span>
                                                                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                      <span class="n">high_degree_endpoint_coordinates_tried</span><span class="o">=</span><span class="n">high_degree_endpoint_coordinates_tried</span><span class="p">,</span>
                                                                <span class="n">plot_intermediates</span><span class="o">=</span><span class="n">plot_intermediates</span><span class="p">,</span>
                                          <span class="n">return_split_reasons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                
                
                <span class="n">high_degree_endpoint_coordinates_tried</span> <span class="o">+=</span> <span class="n">curr_high_degree_coord</span>
                
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb_copy.deleted_edges = </span><span class="si">{</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">deleted_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb_copy.created_edges = </span><span class="si">{</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">created_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After get best cut: cut_edges = </span><span class="si">{</span><span class="n">cut_edges</span><span class="si">}</span><span class="s2">, added_edges = </span><span class="si">{</span><span class="n">added_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
                <span class="k">if</span> <span class="n">cut_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;***** there was no suggested cut for this limb even though it is still connnected***&quot;</span><span class="p">)</span>

                    
                    <span class="k">if</span> <span class="n">default_cut_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--&gt; So Setting the default_cut_edge to </span><span class="si">{</span><span class="n">default_cut_edge</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">default_cut_edge</span> <span class="o">==</span> <span class="s2">&quot;first&quot;</span><span class="p">:</span>
                            <span class="n">cut_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">soma_to_soma_path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">soma_to_soma_path</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                            <span class="n">curr_split_reason</span> <span class="o">=</span> <span class="s2">&quot;default_edge_first&quot;</span>
                        <span class="k">elif</span> <span class="n">default_cut_edge</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
                            <span class="n">cut_edges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">soma_to_soma_path</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">soma_to_soma_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>
                            <span class="n">curr_split_reason</span> <span class="o">=</span> <span class="s2">&quot;default_edge_last&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented default_cut_edge = </span><span class="si">{</span><span class="n">default_cut_edge</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            
                        <span class="n">curr_limb_copy</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">cut_limb_network_by_edges</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">,</span>
                                                    <span class="n">cut_edges</span><span class="p">,</span>
                                                    <span class="p">[],</span>
                                                    <span class="n">return_accepted_edges_to_create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                        <span class="c1">#print(f&quot;cut edges after returned: {cut_edges}&quot;)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
                
                

                <span class="c1">#------ 1/8 Addition: check if any new edges cut and if not then break</span>
                <span class="c1">#print(f&quot;cut_edges = {cut_edges}, total_soma_paths_to_cut = {total_soma_paths_to_cut}&quot;)</span>
                <span class="n">edge_diff</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">cut_edges</span><span class="p">,</span><span class="n">total_soma_paths_to_cut</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge_diff = </span><span class="si">{</span><span class="n">edge_diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">intersect2d</span><span class="p">(</span><span class="n">cut_edges</span><span class="p">,</span><span class="n">total_soma_paths_to_cut</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cut_edges</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**** there were no NEW suggested cuts&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_soma_paths_to_cut = </span><span class="si">{</span><span class="n">total_soma_paths_to_cut</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cut_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">suggested_cut_points</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">cut_e</span> <span class="ow">in</span> <span class="n">cut_edges</span><span class="p">:</span>
                        <span class="n">shared_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">[</span><span class="n">cut_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                        <span class="n">curr_limb_copy</span><span class="p">[</span><span class="n">cut_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                             <span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">shared_endpoints</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">suggested_cut_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shared_endpoints</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">s_e</span> <span class="ow">in</span> <span class="n">shared_endpoints</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">high_degree_endpoint_coordinates_tried</span><span class="p">,</span><span class="n">s_e</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">suggested_cut_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_e</span><span class="p">)</span>

                    <span class="n">suggested_cut_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">suggested_cut_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">curr_split_reason</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">total_split_reasons</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">total_split_reasons</span><span class="p">[</span><span class="n">curr_split_reason</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">suggested_cut_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">total_split_reasons</span><span class="p">[</span><span class="n">curr_split_reason</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">suggested_cut_points</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">plot_cut_coordinates</span><span class="p">:</span>
                        
                        <span class="n">path_skeleton_points</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_points_along_path</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">,</span>
                                                                              <span class="n">skeletal_distance_per_coordinate</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                                                                             <span class="n">branch_path</span><span class="o">=</span><span class="n">soma_to_soma_path</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">suggested_cut_points = </span><span class="si">{</span><span class="n">suggested_cut_points</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                          <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">skeleton</span><span class="p">],</span>
                                          <span class="n">scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">path_skeleton_points</span><span class="p">,</span><span class="n">suggested_cut_points</span><span class="p">],</span>
                                          <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
                                          <span class="n">scatter_size</span> <span class="o">=</span> <span class="mf">0.3</span>
                        
                        <span class="p">)</span>
                        
                    
                    
                    <span class="n">total_soma_paths_to_cut</span> <span class="o">+=</span> <span class="n">cut_edges</span>
                    
                    <span class="c1"># ---------- 11/30: Calculate the coordinates affected by the cut edge</span>
                    
                    
                    
                <span class="k">if</span> <span class="ow">not</span> <span class="n">added_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">total_soma_paths_to_add</span> <span class="o">+=</span> <span class="n">added_edges</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">total_removed_branches</span> <span class="o">+=</span> <span class="n">removed_branches</span>
                    
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-----------counter = </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">------------&quot;</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">counter</span> <span class="o">&gt;</span> <span class="n">max_iterations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Breaking because hit max iterations </span><span class="si">{</span><span class="n">max_iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="n">local_paths_not_cut</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">skeleton_points_along_path</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">,</span><span class="n">soma_to_soma_path</span><span class="p">))</span>
                   
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;edges_to_delete&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_soma_paths_to_cut</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;edges_to_create&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_soma_paths_to_add</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;removed_branches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_removed_branches</span>

            <span class="n">suggested_cut_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cut_e</span> <span class="ow">in</span> <span class="n">total_soma_paths_to_cut</span><span class="p">:</span>
                <span class="n">high_degree_endpoint_coordinates_tried</span>
                <span class="n">shared_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">[</span><span class="n">cut_e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                <span class="n">curr_limb_copy</span><span class="p">[</span><span class="n">cut_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                     <span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">shared_endpoints</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">suggested_cut_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shared_endpoints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">s_e</span> <span class="ow">in</span> <span class="n">shared_endpoints</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows</span><span class="p">(</span><span class="n">high_degree_endpoint_coordinates_tried</span><span class="p">,</span><span class="n">s_e</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">suggested_cut_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_e</span><span class="p">)</span>

            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;coordinate_suggestions&quot;</span><span class="p">]</span> <span class="o">=</span><span class="n">suggested_cut_points</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;successful_disconnection&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">success</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;paths_not_cut&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_paths_not_cut</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;paths_cut&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_paths_cut</span>
            <span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;split_reasons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_split_reasons</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_results</span><span class="p">)</span>
            
            <span class="c1"># ------------ Part where going to output the red/blue points -------------#</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Psuedocode:</span>
<span class="sd">            1) Decide whether to output if need red blue points (if have )</span>
<span class="sd">            2) </span>


<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">output_red_blue_suggestions</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;edges_to_delete&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;edges_to_create&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Not doing red blue splits because no paths to delete or add&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>


                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                     <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">**** Computing red blue splits****&quot;</span><span class="p">)</span>

                <span class="n">soma_starts</span> <span class="o">=</span> <span class="p">[</span><span class="n">st_n_1</span><span class="p">,</span><span class="n">st_n_2</span><span class="p">]</span>
                <span class="n">local_red_blue</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">soma_path</span> <span class="o">=</span> <span class="n">soma_title</span><span class="p">,</span>
                                         <span class="n">node_path</span> <span class="o">=</span> <span class="n">soma_starts</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">debug_red_blue</span><span class="p">:</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">limb_obj_collapsed</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;pre_limb_obj_collapsed_</span><span class="si">{</span><span class="n">red_blue_counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">limb_obj_collapsed</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">collapse_branches_on_limb</span><span class="p">(</span><span class="n">limb_obj_collapsed</span><span class="p">,</span>
                                                     <span class="n">branch_list</span><span class="o">=</span><span class="n">local_results</span><span class="p">[</span><span class="s2">&quot;removed_branches&quot;</span><span class="p">],</span>
                                                     <span class="n">plot_new_limb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                
<span class="c1">#                 if verbose:</span>
<span class="c1">#                     print(f&quot;RIGHT BEFORE RED BLUE SPLIT: curr_limb_copy.created_edges = {curr_limb_copy.created_edges}&quot;)</span>
<span class="c1">#                     print(f&quot;limb_obj_collapsed.created_edges = {limb_obj_collapsed.created_edges}&quot;)</span>
<span class="c1">#                 limb_obj_collapsed.created_edges = curr_limb_copy.created_edges</span>
<span class="c1">#                 if verbose:</span>
<span class="c1">#                     print(f&quot;limb_obj_collapsed.created_edges = {limb_obj_collapsed.created_edges}&quot;)</span>
                
                

                <span class="n">conn_comps</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
                <span class="n">conn_comp_splits</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">connected_component_with_node</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">connected_components</span><span class="o">=</span><span class="n">conn_comps</span><span class="p">,</span><span class="n">return_only_one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_starts</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Conn comp size before expansion = </span><span class="si">{</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">conn_comp_splits</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not expanding to removed branches&quot;</span><span class="p">)</span>

                <span class="n">all_red_blue_splits</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> 
                <span class="n">soma_idxs</span> <span class="o">=</span> <span class="n">soma_names_from_split_title</span><span class="p">(</span><span class="n">soma_title</span><span class="p">,</span><span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">sm_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_connections_from_split_title</span><span class="p">(</span><span class="n">soma_title</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--Doing Red/Blue splits for </span><span class="si">{</span><span class="n">sm_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1">#                     limb_obj_collapsed.set_concept_network_directional(starting_soma = soma_idxs[1 - j],</span>
<span class="c1">#                                                                       suppress_disconnected_errors=True)</span>
                    
                    <span class="n">limb_obj_collapsed</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_node</span><span class="o">=</span><span class="n">soma_starts</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">],</span>
                                                                       <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                       <span class="n">no_cycles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                      <span class="p">)</span>
        
                    <span class="k">if</span> <span class="n">apply_valid_upstream_branches_restriction</span><span class="p">:</span>
                        <span class="n">valid_upstream_branches_restriction</span> <span class="o">=</span> <span class="n">conn_comp_splits</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">valid_upstream_branches_restriction</span> <span class="o">=</span> <span class="kc">None</span>
                        
                    <span class="n">error_branches_for_restriction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">conn_comp_splits</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">edge_diff</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                                                                  <span class="n">conn_comp_splits</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">])</span>
                                                               
                        
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_branches=</span><span class="si">{</span><span class="n">error_branches_for_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_upstream_branches_restriction = </span><span class="si">{</span><span class="n">valid_upstream_branches_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1">#print(f&quot;group_all_conn_comp_together = {group_all_conn_comp_together}&quot;)</span>

                    <span class="n">red_blue_splits</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">limb_errors_to_cancel_to_red_blue_group</span><span class="p">(</span>
                                    <span class="n">limb_obj_collapsed</span><span class="p">,</span>
                                    <span class="c1">#error_branches=conn_comp_splits[j],</span>
                                    <span class="n">error_branches</span> <span class="o">=</span> <span class="n">error_branches_for_restriction</span><span class="p">,</span>
                                    <span class="n">valid_upstream_branches_restriction</span> <span class="o">=</span> <span class="n">valid_upstream_branches_restriction</span><span class="p">,</span>
                                    <span class="n">group_all_conn_comp_together</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">plot_final_blue_red_points</span><span class="o">=</span><span class="n">plot_final_blue_red_points</span><span class="p">,</span>
                                    <span class="n">offset_distance_for_points</span><span class="o">=</span><span class="n">offset_distance_for_points</span><span class="p">,</span>
                                    <span class="n">one_hop_downstream_error_branches_max_distance</span><span class="o">=</span><span class="n">one_hop_downstream_error_branches_max_distance</span><span class="p">,</span>
                                    <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span>
                                    <span class="n">only_outermost_branches</span> <span class="o">=</span> <span class="n">only_outermost_branches</span><span class="p">,</span>
                                    <span class="n">min_error_downstream_length_total</span> <span class="o">=</span> <span class="n">min_error_downstream_length_total</span><span class="p">,</span>
                                    <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">curr_limb_idx</span><span class="p">,</span>
                                    <span class="n">split_red_blue_by_common_upstream</span><span class="o">=</span><span class="n">split_red_blue_by_common_upstream</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of red_blue_splits made = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">red_blue_splits</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">all_red_blue_splits</span><span class="p">[</span><span class="n">sm_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">red_blue_splits</span>
                
                
                <span class="n">red_blue_split_dict</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_red_blue_splits</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">debug_red_blue</span><span class="p">:</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;curr_limb_copy_</span><span class="si">{</span><span class="n">red_blue_counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">limb_obj_collapsed</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;limb_obj_collapsed_</span><span class="si">{</span><span class="n">red_blue_counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">red_blue_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            


            
            
            

        <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total number of graphs at the end of the split = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seperated_graphs</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">))</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">seperated_graphs</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            

        <span class="n">limb_results</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
        
        
        
        
    <span class="k">if</span> <span class="n">plot_suggestions</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_split_suggestions_per_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">limb_results</span><span class="p">,</span>
                                    <span class="n">scatter_size</span> <span class="o">=</span> <span class="n">plot_suggestions_scatter_size</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">output_red_blue_suggestions</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_results</span><span class="p">,</span><span class="n">red_blue_split_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_results</span></div>


<div class="viewcode-block" id="split_suggestions_to_concept_networks"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_suggestions_to_concept_networks">[docs]</a><span class="k">def</span> <span class="nf">split_suggestions_to_concept_networks</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_results</span><span class="p">,</span>
                                         <span class="n">apply_changes_to_limbs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will take the output of the multi_soma_split suggestions and </span>
<span class="sd">    return the concept network with all fo the cuts applied</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">new_concept_networks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">path_cut_info</span> <span class="ow">in</span> <span class="n">limb_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">apply_changes_to_limbs</span><span class="p">:</span>
            <span class="n">limb_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_cp</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
        <span class="c1">#limb_nx = nx.Graph(neuron_obj[curr_limb_idx].concept_network)</span>
        
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">cut_limb_network_by_suggestions</span><span class="p">(</span><span class="n">limb_cp</span><span class="p">,</span>
                                                       <span class="n">path_cut_info</span><span class="p">,</span>
                                                       <span class="n">return_copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">apply_changes_to_limbs</span><span class="p">)</span>
        
        
        <span class="n">new_concept_networks</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span>
        
    
    <span class="k">return</span> <span class="n">new_concept_networks</span></div>


<div class="viewcode-block" id="split_suggestions_to_concept_networks_old"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_suggestions_to_concept_networks_old">[docs]</a><span class="k">def</span> <span class="nf">split_suggestions_to_concept_networks_old</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_results</span><span class="p">,</span>
                                         <span class="n">apply_changes_to_limbs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will take the output of the multi_soma_split suggestions and </span>
<span class="sd">    return the concept network with all fo the cuts applied</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">new_concept_networks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">path_cut_info</span> <span class="ow">in</span> <span class="n">limb_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">apply_changes_to_limbs</span><span class="p">:</span>
            <span class="n">limb_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_cp</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
        <span class="c1">#limb_nx = nx.Graph(neuron_obj[curr_limb_idx].concept_network)</span>
        <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="n">path_cut_info</span><span class="p">:</span>
            <span class="n">limb_cp</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">collapse_branches_on_limb</span><span class="p">(</span><span class="n">limb_cp</span><span class="p">,</span><span class="n">branch_list</span><span class="o">=</span><span class="n">cut</span><span class="p">[</span><span class="s2">&quot;removed_branches&quot;</span><span class="p">])</span>
            <span class="n">limb_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">cut</span><span class="p">[</span><span class="s2">&quot;edges_to_delete&quot;</span><span class="p">])</span>
            <span class="n">limb_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">cut</span><span class="p">[</span><span class="s2">&quot;edges_to_create&quot;</span><span class="p">])</span>
        <span class="n">new_concept_networks</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_cp</span><span class="o">.</span><span class="n">concept_network</span>
        
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Debugging the cuts&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_concept_networks</span></div>


<span class="c1"># --------------- Functions that do the actual limb and Neuron Splitting --------- #</span>


<div class="viewcode-block" id="split_neuron_limb_by_seperated_network"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_neuron_limb_by_seperated_network">[docs]</a><span class="k">def</span> <span class="nf">split_neuron_limb_by_seperated_network</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">curr_limb_idx</span><span class="p">,</span>
                    <span class="n">seperate_networks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">cut_concept_network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#could send a cut concept network that hasn&#39;t been seperated</span>
                    <span class="n">split_current_concept_network</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#if the stored concept network has already been cut then use that</span>
                    <span class="n">error_on_multile_starting_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">delete_limb_if_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Split a neuron limb up into sepearte limb graphs specific</span>

<span class="sd">    Arguments:</span>
<span class="sd">    neuron_obj</span>
<span class="sd">    seperated_graphs</span>
<span class="sd">    limb_idx</span>


<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="c1"># -------- Getting the mesh and correspondence information --------- #</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1) Assemble all the faces of the nodes and concatenate them</span>
<span class="sd">    - copy the data into the new limb correspondence</span>
<span class="sd">    - save the order they were concatenated in the new limb correspondence</span>
<span class="sd">    - copy of </span>
<span class="sd">    2) Use the concatenated faces idx to obtain the new limb mesh</span>
<span class="sd">    3) index the concatenated faces idx into the limb.mesh_face_idx to get the neew limb.mesh_face_idx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seperate_networks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">split_current_concept_network</span><span class="p">:</span>
            <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">cut_concept_network</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">cut_concept_network</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">seperated_graphs</span> <span class="o">=</span> <span class="n">seperate_networks</span>
        
        
    <span class="n">new_limb_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seperated_graphs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sep_graph_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">curr_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;empty&quot;</span><span class="p">]</span>
        <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;Limb_obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">empty_limb_object</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">curr_labels</span><span class="p">)</span>
        <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_labels</span>
        <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()</span>
        <span class="n">new_limb_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep_graph_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">seg_graph_idx</span><span class="p">,</span><span class="n">sep_G</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seperated_graphs</span><span class="p">):</span>

            <span class="n">curr_subgraph</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sep_G</span><span class="p">)</span>

            <span class="c1">#will store all of the relevant info in the </span>
            <span class="n">sep_graph_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_subgraph</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;empty&quot;</span><span class="p">]</span>
                <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;Limb_obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">empty_limb_object</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="n">curr_labels</span><span class="p">)</span>
                <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_labels</span>
                <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
                <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()</span>
                <span class="n">new_limb_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep_graph_data</span><span class="p">)</span>
                <span class="k">continue</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">----Working on seperate_graph </span><span class="si">{</span><span class="n">seg_graph_idx</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>




            <span class="n">fixed_node_objects</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            
            <span class="n">build_from_mesh_face_idx</span> <span class="o">=</span> <span class="kc">False</span>
            
            
            <span class="k">if</span> <span class="n">build_from_mesh_face_idx</span><span class="p">:</span>
                <span class="n">limb_face_idx_concat</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_limb_mesh_list</span> <span class="o">=</span> <span class="p">[]</span>
                
            <span class="n">face_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">old_node_to_new_node_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_subgraph</span><span class="p">):</span>
                <span class="c1">#store the mapping for the new names</span>
                <span class="n">old_node_to_new_node_mapping</span><span class="p">[</span><span class="n">n_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

                <span class="n">fixed_node_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">n_name</span><span class="p">])</span>
                
                <span class="c1">#sometimes these can&#39;t be trusted....</span>
                <span class="k">if</span> <span class="n">build_from_mesh_face_idx</span><span class="p">:</span>
                    <span class="n">curr_mesh_face_idx</span> <span class="o">=</span> <span class="n">fixed_node_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span>
                    <span class="n">limb_face_idx_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_mesh_face_idx</span><span class="p">)</span>
                    <span class="n">fixed_node_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">face_counter</span><span class="p">,</span><span class="n">face_counter</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_mesh_face_idx</span><span class="p">))</span>
                    <span class="n">face_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_mesh_face_idx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_limb_mesh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">fixed_node_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                    <span class="n">curr_new_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">face_counter</span><span class="p">,</span><span class="n">face_counter</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">fixed_node_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">))</span>
                    <span class="n">fixed_node_objects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">curr_new_face_idx</span>
                    <span class="n">face_counter</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_new_face_idx</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">build_from_mesh_face_idx</span><span class="p">:</span>
                <span class="n">total_limb_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">limb_face_idx_concat</span><span class="p">)</span>
                <span class="n">new_limb_mesh</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">total_limb_face_idx</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_limb_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">new_limb_mesh_list</span><span class="p">)</span>
            


            <span class="n">new_limb_mesh_face_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">new_limb_mesh</span><span class="p">,</span>
                                       <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1">#recovered_new_limb_mesh = neuron_obj.mesh.submesh([new_limb_mesh_face_idx],append=True,repair=False)</span>
            <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_limb_mesh</span>

            <span class="c1"># ------- How to get the new concept network starting info --------- #</span>

            <span class="c1">#get all of the starting dictionaries that match a node in the subgraph</span>
            <span class="n">curr_all_concept_network_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">all_concept_network_data</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_subgraph</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_all_concept_network_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warning_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;There were more not exactly one starting dictinoary: </span><span class="si">{</span><span class="n">curr_all_concept_network_data</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="k">if</span> <span class="n">error_on_multile_starting_nodes</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">warning_string</span><span class="p">)</span>


            <span class="n">limb_corresp_for_networks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="n">branch_skeleton</span><span class="o">=</span><span class="n">k</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                     <span class="n">width_from_skeleton</span><span class="o">=</span><span class="n">k</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                                                     <span class="n">branch_mesh</span><span class="o">=</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                     <span class="n">branch_face_idx</span><span class="o">=</span><span class="n">k</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">fixed_node_objects</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

            <span class="n">floating_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_all_concept_network_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#pick a random endpoint to start from the skeleton</span>
                
                <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">total_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">limb_corresp_for_networks</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
                    <span class="n">all_endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">total_skeleton</span><span class="p">)</span>
                    <span class="n">chosen_endpoint</span> <span class="o">=</span> <span class="n">all_endpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">limb_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_corresp_for_networks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="n">chosen_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_branch_endpoints</span><span class="p">(</span><span class="n">limb_corresp_for_networks</span><span class="p">[</span><span class="n">limb_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                    

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There was no starting information so doing to put dummy information and random starting endpoint = </span><span class="si">{</span><span class="n">chosen_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">curr_limb_network_stating_info</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:{</span><span class="o">-</span><span class="mi">1</span><span class="p">:{</span><span class="s2">&quot;touching_verts&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                                                         <span class="s2">&quot;endpoint&quot;</span><span class="p">:</span><span class="n">chosen_endpoint</span><span class="p">}}}</span>
                <span class="n">floating_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#curr_all_concept_network_data[0][&quot;soma_group_idx&quot;] = 0</span>
                <span class="n">curr_all_concept_network_data</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">clean_all_concept_network_data</span><span class="p">(</span><span class="n">curr_all_concept_network_data</span><span class="p">)</span>
                <span class="n">curr_limb_network_stating_info</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_concept_network_data_to_dict</span><span class="p">(</span><span class="n">curr_all_concept_network_data</span><span class="p">)</span>

            <span class="c1">#calculate the concept networks</span>


            <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_correspondence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_corresp_for_networks</span>

            <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_limb_network_stating_info</span>

            <span class="c1">#raise Exception(&quot;Checking on limb starting network info&quot;)</span>

            <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">limb_corresp_for_networks</span><span class="p">,</span>
                                                                                            <span class="n">curr_limb_network_stating_info</span><span class="p">,</span>
                                                                                            <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                                                                           <span class="p">)</span>   

            <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_concept_networks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_to_soma_concept_networks</span>


            <span class="c1"># --------------- Making the new limb object -------------- #</span>
            <span class="n">limb_str_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;split_limb_from_limb_</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">_part_</span><span class="si">{</span><span class="n">seg_graph_idx</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">floating_flag</span><span class="p">:</span>
                <span class="n">limb_str_name</span> <span class="o">+=</span> <span class="s2">&quot;_floating&quot;</span>

            <span class="n">new_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_str_name</span><span class="p">]</span>

            <span class="n">new_limb_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">new_limb_mesh</span><span class="p">,</span>
                         <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="n">limb_corresp_for_networks</span><span class="p">,</span>
                         <span class="n">concept_network_dict</span><span class="o">=</span><span class="n">limb_to_soma_concept_networks</span><span class="p">,</span>
                         <span class="n">mesh_face_idx</span><span class="o">=</span><span class="n">new_limb_mesh_face_idx</span><span class="p">,</span>
                        <span class="n">labels</span><span class="o">=</span><span class="n">new_labels</span><span class="p">,</span>
                         <span class="n">branch_objects</span> <span class="o">=</span> <span class="n">fixed_node_objects</span><span class="p">,</span><span class="c1">#this will have a dictionary mapping to the branch objects if provided</span>
                       <span class="p">)</span>


            <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;limb_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_labels</span>
            <span class="n">sep_graph_data</span><span class="p">[</span><span class="s2">&quot;Limb_obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_limb_obj</span>

            <span class="n">new_limb_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep_graph_data</span><span class="p">)</span>

    
    
    <span class="c1"># Phase 2: ------------- Adjusting the existing neuron object --------------- #</span>
    
    <span class="n">neuron_obj_cp</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="c1">#1) map the new neuron objects to unused limb names</span>
    <span class="n">new_limb_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">new_limb_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj_cp</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_limb_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))]</span>
    <span class="n">new_limb_string_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_limb_idxs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">l_i</span><span class="p">,</span><span class="n">limb_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_limb_idxs</span><span class="p">,</span><span class="n">new_limb_data</span><span class="p">):</span>
        <span class="n">new_limb_dict</span><span class="p">[</span><span class="n">l_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_data</span>


    <span class="c1">#3) Delete the old limb data in the preprocessing dictionary (Adjust the soma_to_piece_connectivity)</span>
    <span class="n">attr_to_update</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;limb_meshes&#39;</span><span class="p">,</span> <span class="s1">&#39;limb_correspondence&#39;</span><span class="p">,</span> <span class="s1">&#39;limb_network_stating_info&#39;</span><span class="p">,</span> <span class="s1">&#39;limb_concept_networks&#39;</span><span class="p">,</span> <span class="s1">&#39;limb_labels&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">attr_upd</span> <span class="ow">in</span> <span class="n">attr_to_update</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">attr_upd</span><span class="p">][</span><span class="n">curr_limb_idx</span><span class="p">]</span>

    <span class="c1"># --- revise the soma_to_piece_connectivity -- #</span>
    <span class="n">somas_to_delete_from</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">neuron_obj_cp</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">sm_d</span> <span class="ow">in</span> <span class="n">somas_to_delete_from</span><span class="p">:</span>
        <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">][</span><span class="n">sm_d</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>

    <span class="c1">#4) Delete the old limb from the neuron concept network   </span>
    <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#5) Add the new limb nodes with edges to the somas they are touching</span>
    <span class="k">for</span> <span class="n">l_i</span><span class="p">,</span><span class="n">limb_data</span> <span class="ow">in</span> <span class="n">new_limb_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">limb_data</span><span class="p">[</span><span class="s2">&quot;Limb_obj&quot;</span><span class="p">]</span>
        <span class="n">curr_limb_touching_somas</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()</span>



        <span class="n">str_node_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">l_i</span><span class="si">}</span><span class="s2">&quot;</span>
        
        <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">str_node_name</span><span class="p">)</span>

        <span class="n">xu</span><span class="o">.</span><span class="n">set_node_data</span><span class="p">(</span><span class="n">curr_network</span><span class="o">=</span><span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                         <span class="n">node_name</span><span class="o">=</span><span class="n">str_node_name</span><span class="p">,</span>
                                         <span class="n">curr_data</span><span class="o">=</span><span class="n">curr_limb_obj</span><span class="p">,</span>
                                         <span class="n">curr_data_label</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sm_d</span> <span class="ow">in</span> <span class="n">curr_limb_touching_somas</span><span class="p">:</span>
            <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">][</span><span class="n">sm_d</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_i</span><span class="p">)</span>
            <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">str_node_name</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">sm_d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">attr_upd</span> <span class="ow">in</span> <span class="n">attr_to_update</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attr_upd</span> <span class="o">==</span> <span class="s2">&quot;limb_meshes&quot;</span><span class="p">:</span>
                <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">attr_upd</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">l_i</span><span class="p">,</span><span class="n">limb_data</span><span class="p">[</span><span class="n">attr_upd</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="n">attr_upd</span><span class="p">][</span><span class="n">l_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_data</span><span class="p">[</span><span class="n">attr_upd</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">sm_d</span> <span class="ow">in</span> <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">]:</span>
        <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">][</span><span class="n">sm_d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">][</span><span class="n">sm_d</span><span class="p">]))</span>
    
    
    <span class="k">return</span> <span class="n">neuron_obj_cp</span></div>






<span class="c1"># ----------------12/27: Whole Neuron Splitting ------------------------ #</span>





<div class="viewcode-block" id="split_neuron_limbs_by_suggestions"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_neuron_limbs_by_suggestions">[docs]</a><span class="k">def</span> <span class="nf">split_neuron_limbs_by_suggestions</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">split_suggestions</span><span class="p">,</span>
                                      <span class="n">plot_soma_limb_network</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    </span>
<span class="sd">    Will take the suggestions of the splits and </span>
<span class="sd">    split the necessary limbs of the neuron object and </span>
<span class="sd">    return the split neuron</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">split_neuron_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">limb_results</span> <span class="o">=</span> <span class="n">split_suggestions</span>
    
    <span class="c1">#this step is where applies the actual changes to the neuron obj</span>
    <span class="n">new_concept_networks</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_suggestions_to_concept_networks</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_results</span><span class="p">,</span>
                                                                    <span class="n">apply_changes_to_limbs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
   
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">curr_limb_nx</span> <span class="ow">in</span> <span class="n">new_concept_networks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>
        
        <span class="c1">#delete the node sthat should be deleted</span>
        <span class="n">removed_branches_list</span>  <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">get_removed_branches_from_suggestion</span><span class="p">(</span><span class="n">limb_results</span><span class="p">,</span><span class="n">curr_limb_idx</span><span class="p">)</span>
        <span class="n">split_neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">collapse_branches_on_limb</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">],</span><span class="n">removed_branches_list</span><span class="p">)</span>
        
        

        <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_limb_nx</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---Working on Splitting Limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span><span class="si">}</span><span class="s2"> components----&quot;</span><span class="p">)</span>

        <span class="n">split_neuron_obj</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_neuron_limb_by_seperated_network</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">,</span>
                                                                      <span class="n">seperate_networks</span><span class="o">=</span><span class="n">conn_comp</span><span class="p">,</span>
                                                                 <span class="n">curr_limb_idx</span> <span class="o">=</span> <span class="n">curr_limb_idx</span><span class="p">,</span>
                                                                <span class="n">error_on_multile_starting_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_soma_limb_network</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_soma_limb_concept_network</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">split_neuron_obj</span></div>

<div class="viewcode-block" id="split_disconnected_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_disconnected_neuron">[docs]</a><span class="k">def</span> <span class="nf">split_disconnected_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">plot_seperated_neurons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">save_original_mesh_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">filter_away_remaining_error_limbs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">return_errored_limbs_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">add_split_to_description</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">copy_all_non_soma_touching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              
                             <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: If a neuron object has already been disconnected</span>
<span class="sd">    at the limbs, this function will then split the neuron object</span>
<span class="sd">    into a list of multiple neuron objects</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) check that there do not exist any error limbs</span>
<span class="sd">    2) Do the splitting process</span>
<span class="sd">    3) Visualize results if requested</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">split_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    
    
    <span class="c1">#--------Part 1: check that all the limbs have beeen split so that there are no more error limbs</span>
    <span class="n">same_soma_error_limbs</span> <span class="o">=</span> <span class="n">split_neuron_obj</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span>
    <span class="n">multi_soma_error_limbs</span> <span class="o">=</span> <span class="n">split_neuron_obj</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span>
    
    <span class="n">curr_error_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">error_limbs</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_error_limbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_away_remaining_error_limbs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were still error limbs before trying the neuron object split: error limbs = </span><span class="si">{</span><span class="n">curr_error_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Still remaining error limbs (</span><span class="si">{</span><span class="n">curr_error_limbs</span><span class="si">}</span><span class="s2">), but will filter them away&quot;</span><span class="p">)</span>
    
    
    
    
    <span class="c1"># ------ Part 2: start the splitting process</span>
    
    <span class="c1"># get all the somas that we will split into</span>
    <span class="n">soma_names</span> <span class="o">=</span> <span class="n">split_neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
    
    
    <span class="n">neuron_obj_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neuron_obj_errored_limbs_area</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neuron_obj_errored_limbs_skeletal_length</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neuron_obj_n_multi_soma_errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neuron_obj_n_same_soma_errors</span> <span class="o">=</span> <span class="p">[]</span>
    

    <span class="k">for</span> <span class="n">curr_soma_idx</span><span class="p">,</span><span class="n">curr_soma_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">------ Working on Soma </span><span class="si">{</span><span class="n">curr_soma_idx</span><span class="si">}</span><span class="s2"> -------&quot;</span><span class="p">)</span>

        <span class="n">neuron_cp</span> <span class="o">=</span> <span class="n">split_neuron_obj</span>

        <span class="c1">#getting all the soma information we will need for preprocessing</span>
        <span class="n">soma_obj</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="p">[</span><span class="n">curr_soma_name</span><span class="p">]</span>
        <span class="n">curr_soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
        <span class="n">curr_soma_sdfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_obj</span><span class="o">.</span><span class="n">sdf</span><span class="p">]</span>
        <span class="n">curr_soma_synapses</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">]</span>
        <span class="n">curr_soma_volume</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_obj</span><span class="o">.</span><span class="n">volume</span><span class="p">]</span>
        <span class="n">curr_soma_volume_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_obj</span><span class="o">.</span><span class="n">volume_ratio</span><span class="p">]</span>





        <span class="c1"># getting the limb information and new soma connectivity</span>
        <span class="n">limb_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">neuron_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">curr_soma_name</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="n">limb_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_neighbors</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_neighbors = </span><span class="si">{</span><span class="n">limb_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;soma_to_piece_connectivity&quot;</span><span class="p">][</span><span class="n">curr_soma_idx</span><span class="p">]</span>
        
        

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">,</span><span class="n">soma_to_piece_connectivity</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_to_piece_connectivity</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;piece connectivity (</span><span class="si">{</span><span class="n">soma_to_piece_connectivity</span><span class="si">}</span><span class="s2">) not match limb neighbors (</span><span class="si">{</span><span class="n">limb_neighbors</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">filter_away_remaining_error_limbs</span><span class="p">:</span><span class="c1"># and len(curr_error_limbs)&gt;0:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_neighbors BEFORE error limbs removed = </span><span class="si">{</span><span class="n">limb_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">original_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">)</span>
            
            
            <span class="c1"># ---------- 1/28: More error limb information ----------------- #</span>
            <span class="n">curr_neuron_same_soma_error_limbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">,</span><span class="n">same_soma_error_limbs</span><span class="p">))</span>
            <span class="n">curr_neuron_multi_soma_error_limbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">,</span><span class="n">multi_soma_error_limbs</span><span class="p">))</span>
            
            <span class="c1">#print(f&quot;curr_neuron_multi_soma_error_limbs = {curr_neuron_multi_soma_error_limbs}&quot;)</span>
            
            <span class="n">curr_n_multi_soma_limbs_cancelled</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_neuron_multi_soma_error_limbs</span><span class="p">)</span>
            <span class="n">curr_n_same_soma_limbs_cancelled</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_neuron_same_soma_error_limbs</span><span class="p">)</span>
            
            <span class="n">unique_error_limbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_neuron_same_soma_error_limbs</span> <span class="o">+</span> <span class="n">curr_neuron_multi_soma_error_limbs</span><span class="p">)</span>
            
            <span class="n">curr_error_limbs_cancelled_area</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()))</span>
                                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_error_limbs</span><span class="p">]</span>
            
            <span class="n">curr_error_limbs_cancelled_skeletal_length</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()))</span>
                                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unique_error_limbs</span><span class="p">]</span>
            
            
            <span class="n">limb_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">,</span><span class="n">curr_error_limbs</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_neighbors AFTER error limbs removed = </span><span class="si">{</span><span class="n">limb_neighbors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_n_multi_soma_limbs_cancelled</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">curr_n_same_soma_limbs_cancelled</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">curr_error_limbs_cancelled_area</span> <span class="o">=</span> <span class="p">[]</span>
            
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_n_multi_soma_limbs_cancelled = </span><span class="si">{</span><span class="n">curr_n_multi_soma_limbs_cancelled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_n_same_soma_limbs_cancelled = </span><span class="si">{</span><span class="n">curr_n_same_soma_limbs_cancelled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_errored_lims = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_error_limbs_cancelled_area</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_error_limbs_cancelled_area = </span><span class="si">{</span><span class="n">curr_error_limbs_cancelled_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">neuron_obj_errored_limbs_area</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_error_limbs_cancelled_area</span><span class="p">)</span>
        <span class="n">neuron_obj_errored_limbs_skeletal_length</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_error_limbs_cancelled_skeletal_length</span><span class="p">)</span>
        <span class="n">neuron_obj_n_multi_soma_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_n_multi_soma_limbs_cancelled</span><span class="p">)</span>
        <span class="n">neuron_obj_n_same_soma_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_n_same_soma_limbs_cancelled</span><span class="p">)</span>

        <span class="n">curr_soma_to_piece_connectivity</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">)))}</span>






        <span class="c1">#getting the whole mesh and limb face correspondence</span>
        <span class="n">mesh_list_for_whole</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>

        <span class="c1">#for the limb meshes</span>
        <span class="n">limb_meshes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#for the limb mesh faces idx</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_soma_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="n">face_idx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">counter</span><span class="p">)]</span>

        <span class="n">old_node_to_new_node_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span>  <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">):</span>

            <span class="c1">#getting the name mapping</span>
            <span class="n">old_node_to_new_node_mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1">#getting the meshes of the limbs</span>
            <span class="n">limb_mesh</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="n">limb_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_mesh</span><span class="p">)</span>


            <span class="n">mesh_list_for_whole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_mesh</span><span class="p">)</span>
            <span class="n">face_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="n">face_idx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span><span class="n">counter</span> <span class="o">+</span> <span class="n">face_length</span><span class="p">))</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="n">face_length</span>

        <span class="n">whole_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">mesh_list_for_whole</span><span class="p">)</span>






        <span class="c1"># generating the new limb correspondence:</span>
        <span class="c1">#curr_limb_correspondence = dict([(i,neuron_cp.preprocessed_data[&quot;limb_correspondence&quot;][k]) for i,k in enumerate(limb_neighbors)])</span>
        <span class="n">curr_limb_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span><span class="n">neuron_cp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">limb_correspondence</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_neighbors</span><span class="p">)])</span>




        <span class="c1"># concept network generation</span>
        <span class="n">curr_limb_network_stating_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_neighbors</span><span class="p">:</span>

            <span class="n">local_starting_info</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_network_stating_info&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>

            <span class="c1">#making sure the soma has the right name</span>
            <span class="n">soma_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">local_starting_info</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;More than one soma connection&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">soma_key</span> <span class="o">=</span> <span class="n">soma_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">soma_key</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">local_starting_info</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="n">local_starting_info</span><span class="p">[</span><span class="n">soma_key</span><span class="p">]}</span>


            <span class="c1">#making sure the soma group has the right name</span>
            <span class="n">starting_group_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">local_starting_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">starting_group_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">starting_group_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Touching group was not equal to 0&quot;</span><span class="p">)</span>

            <span class="c1">#save the new starting info</span>
            <span class="n">curr_limb_network_stating_info</span><span class="p">[</span><span class="n">old_node_to_new_node_mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">local_starting_info</span>

        <span class="c1"># creating the new concept networks from the starting info</span>
        <span class="n">curr_limb_concept_networks</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>

        
        <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">new_limb_correspondence_indiv</span> <span class="ow">in</span> <span class="n">curr_limb_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">new_limb_correspondence_indiv</span><span class="p">,</span>
                                                                                <span class="n">curr_limb_network_stating_info</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">],</span>
                                                                                <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                               <span class="p">)</span>   

            <span class="n">curr_limb_concept_networks</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_to_soma_concept_networks</span>








        <span class="c1">#limb labels:</span>
        <span class="n">curr_limb_labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_neighbors</span><span class="p">:</span>
            <span class="n">local_limb_labels</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="o">.</span><span class="n">preprocessed_data</span><span class="p">[</span><span class="s2">&quot;limb_labels&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">local_limb_labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">local_limb_labels</span> <span class="o">==</span> <span class="s2">&quot;Unlabeled&quot;</span><span class="p">:</span>
                <span class="n">local_limb_labels</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">local_limb_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma_</span><span class="si">{</span><span class="n">curr_soma_idx</span><span class="si">}</span><span class="s2">_originally&quot;</span><span class="p">)</span>
            <span class="n">curr_limb_labels</span><span class="p">[</span><span class="n">old_node_to_new_node_mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">local_limb_labels</span>



        <span class="n">meshes_to_concat</span> <span class="o">=</span> <span class="p">[[</span><span class="n">kv</span><span class="p">[</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">kv</span> <span class="ow">in</span> <span class="n">jv</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">jv</span> <span class="ow">in</span> <span class="n">curr_limb_correspondence</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meshes_to_concat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">whole_branch_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">meshes_to_concat</span><span class="p">))</span>
            
            <span class="n">floating_indexes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_pieces_connectivity</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">whole_branch_mesh</span><span class="p">,</span>
                        <span class="n">periphery_pieces</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
            <span class="n">local_floating_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span><span class="p">)[</span><span class="n">floating_indexes</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;local_floating_meshes = </span><span class="si">{</span><span class="n">local_floating_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            5/9: Attemps to copy all floating pieces to each of the splits</span>
<span class="sd">            so if want to add them back  later then can (DecompositionAxon)</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">copy_all_non_soma_touching</span><span class="p">:</span>
                <span class="n">local_floating_meshes</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">non_soma_touching_meshes</span>
                
            <span class="n">whole_mesh</span>  <span class="o">=</span> <span class="n">whole_mesh</span> <span class="o">+</span> <span class="n">local_floating_meshes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">local_floating_meshes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">whole_mesh</span>  <span class="o">=</span> <span class="n">whole_mesh</span> <span class="o">+</span> <span class="n">local_floating_meshes</span>
            

        
        

        <span class="c1">#using all of the data to create new preprocessing info</span>
        <span class="n">new_preprocessed_data</span> <span class="o">=</span> <span class="n">preprocessed_data</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="c1">#soma data</span>
                <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">curr_soma_meshes</span><span class="p">,</span>
                <span class="n">soma_sdfs</span> <span class="o">=</span> <span class="n">curr_soma_sdfs</span><span class="p">,</span>
                <span class="n">soma_synapses</span> <span class="o">=</span> <span class="n">curr_soma_synapses</span><span class="p">,</span>
                <span class="n">soma_volumes</span> <span class="o">=</span> <span class="n">curr_soma_volume</span><span class="p">,</span>
                <span class="n">soma_volume_ratios</span><span class="o">=</span><span class="n">curr_soma_volume_ratios</span><span class="p">,</span>
                

                <span class="c1">#soma connectivity</span>
                <span class="n">soma_to_piece_connectivity</span> <span class="o">=</span> <span class="n">curr_soma_to_piece_connectivity</span><span class="p">,</span>

                <span class="c1"># limb info</span>
                <span class="n">limb_correspondence</span><span class="o">=</span><span class="n">curr_limb_correspondence</span><span class="p">,</span>
                <span class="n">limb_meshes</span><span class="o">=</span><span class="n">limb_meshes</span><span class="p">,</span>
                <span class="n">limb_mehses_face_idx</span> <span class="o">=</span> <span class="n">face_idx_list</span><span class="p">,</span>
                <span class="n">limb_labels</span><span class="o">=</span><span class="n">curr_limb_labels</span><span class="p">,</span>

                <span class="c1">#concept network info</span>
                <span class="n">limb_concept_networks</span><span class="o">=</span><span class="n">curr_limb_concept_networks</span><span class="p">,</span>
                <span class="n">limb_network_stating_info</span><span class="o">=</span><span class="n">curr_limb_network_stating_info</span><span class="p">,</span>


                <span class="c1"># the other mesh pieces that will not be included</span>
                <span class="n">insignificant_limbs</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">not_processed_soma_containing_meshes</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">glia_faces</span> <span class="o">=</span> <span class="p">[],</span>
                <span class="n">non_soma_touching_meshes</span><span class="o">=</span><span class="n">local_floating_meshes</span><span class="p">,</span>
                <span class="n">inside_pieces</span><span class="o">=</span><span class="p">[],</span>


                <span class="p">)</span>

        <span class="n">limb_to_branch_objects</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_neighbors</span><span class="p">:</span>
            <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
            <span class="n">branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">b</span><span class="p">,</span><span class="n">limb_obj</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)])</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()])</span>
            <span class="n">limb_to_branch_objects</span><span class="p">[</span><span class="n">old_node_to_new_node_mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">branch_dict</span>

        <span class="n">segment_id</span> <span class="o">=</span> <span class="n">neuron_cp</span><span class="o">.</span><span class="n">segment_id</span>
        <span class="k">if</span> <span class="n">add_split_to_description</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neuron_cp</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">_soma_</span><span class="si">{</span><span class="n">curr_soma_idx</span><span class="si">}</span><span class="s2">_split&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neuron_cp</span><span class="o">.</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1">#---------- 1/24: Will save off the original mesh idx so can use the old mesh file to load -------- #</span>
        <span class="k">if</span> <span class="n">save_original_mesh_idx</span><span class="p">:</span>
            <span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">whole_mesh</span><span class="p">,</span>
                          <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">original_mesh_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">original_mesh_idx</span><span class="p">[</span><span class="n">original_mesh_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">original_mesh_idx</span> <span class="o">=</span> <span class="kc">None</span>


        <span class="c1"># new neuron object:</span>

        <span class="n">single_split_neuron_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">whole_mesh</span><span class="p">,</span>
                 <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                 <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
                 <span class="n">preprocessed_data</span><span class="o">=</span><span class="n">new_preprocessed_data</span><span class="p">,</span>
                 <span class="n">limb_to_branch_objects</span><span class="o">=</span><span class="n">limb_to_branch_objects</span><span class="p">,</span>
                 <span class="n">widths_to_calculate</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">original_mesh_idx</span><span class="o">=</span><span class="n">original_mesh_idx</span><span class="p">,</span>
                <span class="n">suppress_output</span><span class="o">=</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">,</span>
                <span class="n">suppress_all_output</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">)</span>


        <span class="n">neuron_obj_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">single_split_neuron_obj</span><span class="p">)</span>
        
        
        
    <span class="c1"># ------ Part 3: Visualize the Results</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Number of seperate neuron objects = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_seperated_neurons</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n_obj</span> <span class="ow">in</span> <span class="n">neuron_obj_list</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">n_obj</span><span class="p">,</span>
                                 <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                                 <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

            
    
    <span class="k">if</span> <span class="n">return_errored_limbs_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">neuron_obj_list</span><span class="p">,</span>
                <span class="n">neuron_obj_errored_limbs_area</span><span class="p">,</span>
                <span class="n">neuron_obj_errored_limbs_skeletal_length</span><span class="p">,</span>
                <span class="n">neuron_obj_n_multi_soma_errors</span><span class="p">,</span>
                <span class="n">neuron_obj_n_same_soma_errors</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_obj_list</span></div>



<div class="viewcode-block" id="split_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_neuron">[docs]</a><span class="k">def</span> <span class="nf">split_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">plot_crossover_intermediates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">plot_neuron_split_results</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 
                 <span class="n">plot_soma_limb_network</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">plot_seperated_neurons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">filter_away_remaining_error_limbs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">return_error_info</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 
                 <span class="n">min_skeletal_length_limb</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 
                 
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take in a whole neuron that could have any number of somas</span>
<span class="sd">    and then to split it into multiple neuron objects</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the split suggestions</span>
<span class="sd">    2) Split all of the limbs that need splitting</span>
<span class="sd">    3) Once have split the limbs, split the neuron object into mutliple objects</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">min_skeletal_length_limb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_skeletal_length_limb</span> <span class="o">=</span> <span class="n">min_skeletal_length_limb_global</span>
    
    <span class="k">if</span> <span class="n">plot_crossover_intermediates</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;plot_intermediates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_error_limbs</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_somas</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No error limbs to processs so just returning the original neuron&quot;</span><span class="p">)</span>
        
        <span class="n">neuron_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_obj</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">neuron_list</span><span class="p">,[[]],[[]],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">neuron_list</span>
        
    
    <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="c1"># ---------- 1/22 Addition that cleans the concept network info ------------ #</span>
    <span class="n">nru</span><span class="o">.</span><span class="n">clean_neuron_all_concept_network_data</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="c1">#1) Get all of the split suggestions</span>
    <span class="k">if</span> <span class="n">limb_results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_results</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">multi_soma_split_suggestions</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                   <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;using precomputed split suggestions&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">plot_neuron_split_results</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_split_suggestions_per_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">limb_results</span><span class="p">)</span>
    
    <span class="c1">#2) Split all of the limbs that need splitting</span>
    <span class="n">split_neuron_obj</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_neuron_limbs_by_suggestions</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">split_suggestions</span><span class="o">=</span><span class="n">limb_results</span><span class="p">,</span>
                                <span class="n">plot_soma_limb_network</span><span class="o">=</span><span class="n">plot_soma_limb_network</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    
    <span class="n">nru</span><span class="o">.</span><span class="n">clean_neuron_all_concept_network_data</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">filter_away_remaining_error_limbs</span><span class="p">:</span>
        <span class="n">curr_error_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">error_limbs</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_error_limbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were still error limbs before the splitting: </span><span class="si">{</span><span class="n">curr_error_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    
    <span class="c1">#3) Once have split the limbs, split the neuron object into mutliple objects</span>
    <span class="p">(</span><span class="n">neuron_list</span><span class="p">,</span>
     <span class="n">neuron_list_errored_limbs_area</span><span class="p">,</span>
     <span class="n">neuron_list_errored_limbs_skeletal_length</span><span class="p">,</span>
    <span class="n">neuron_list_n_multi_soma_errors</span><span class="p">,</span>
    <span class="n">neuron_list_n_same_soma_errors</span><span class="p">)</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_disconnected_neuron</span><span class="p">(</span><span class="n">split_neuron_obj</span><span class="p">,</span>
                         <span class="n">plot_seperated_neurons</span><span class="o">=</span><span class="n">plot_seperated_neurons</span><span class="p">,</span>
                        <span class="n">filter_away_remaining_error_limbs</span><span class="o">=</span><span class="n">filter_away_remaining_error_limbs</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    
    <span class="c1">#2b) Check that all the splits occured</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_list</span><span class="p">):</span>
        <span class="n">curr_error_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">error_limbs</span><span class="p">(</span><span class="n">n_obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_error_limbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were still error limbs after splitting for neuron obj </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
    <span class="c1">#3) Filter the limbs by length if necessary</span>
    <span class="k">if</span> <span class="n">min_skeletal_length_limb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filter limb lengths for limb size of </span><span class="si">{</span><span class="n">min_skeletal_length_limb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">neuron_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">filter_away_neuron_limbs_by_min_skeletal_length</span><span class="p">(</span>
                <span class="n">n_obj</span><span class="p">,</span><span class="n">min_skeletal_length_limb</span> <span class="o">=</span> <span class="n">min_skeletal_length_limb</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n_obj</span> <span class="ow">in</span> <span class="n">neuron_list</span><span class="p">]</span>
        

    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">neuron_list</span><span class="p">,</span><span class="n">neuron_list_errored_limbs_area</span><span class="p">,</span>
                <span class="n">neuron_list_errored_limbs_skeletal_length</span><span class="p">,</span>
                                        <span class="n">neuron_list_n_multi_soma_errors</span><span class="p">,</span>
                                        <span class="n">neuron_list_n_same_soma_errors</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_list</span></div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def collapse_branches_on_limb_old(limb_obj,branch_list,</span>
<span class="sd">                             plot_new_limb=False,</span>
<span class="sd">                              reassign_mesh=True,</span>
<span class="sd">                              store_placeholder_for_removed_nodes=True,</span>
<span class="sd">                              debug_time = True,</span>
<span class="sd">                             verbose=False):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove 1 or more branches from the concept network</span>
<span class="sd">    of a limb and to adjust the underlying skeleton</span>
<span class="sd">    </span>
<span class="sd">    Application: To be used in when trying to split </span>
<span class="sd">    a neuron and want to combine nodes that are really close</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    *** currently does not does not reallocate the mesh part of the nodes that were deleted</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    </span>
<span class="sd">    For each branch to remove</span>
<span class="sd">    0) Find the branches that were touching the soon to be deleted branch</span>
<span class="sd">    1) Alter the skeletons of those that were touching that branch</span>
<span class="sd">    </span>
<span class="sd">    After revised all nodes</span>
<span class="sd">    2) Remove the current node</span>
<span class="sd">    3) Generate the limb correspondence, network starting info to generate soma concept networks</span>
<span class="sd">    4) Create a new limb object and return it</span>


<span class="sd">    Ex: new_limb_obj = nru.collapse_branches_on_limb(curr_limb,[30,31],plot_new_limb=True,verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    limb_time = time.time()</span>
<span class="sd">    </span>
<span class="sd">    curr_limb_cp = copy.deepcopy(limb_obj)</span>
<span class="sd">    </span>
<span class="sd">    if debug_time:</span>
<span class="sd">        print(f&quot;deepcopy limb time = {time.time() - limb_time}&quot;)</span>
<span class="sd">        limb_time = time.time()</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    if not nu.is_array_like(branch_list ):</span>
<span class="sd">        branch_list = [branch_list]</span>
<span class="sd">        </span>
<span class="sd">    seg_id_lookup = np.arange(0,len(curr_limb_cp))</span>
<span class="sd">    </span>
<span class="sd">    for curr_short_seg in branch_list:</span>
<span class="sd">        #need to look up the new seg id if there is one now based on previous deletions</span>
<span class="sd">        </span>
<span class="sd">        curr_short_seg_revised = seg_id_lookup[curr_short_seg]</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;curr_short_seg_revised = {curr_short_seg_revised}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        branch_obj = curr_limb_cp[curr_short_seg_revised]</span>
<span class="sd">        </span>
<span class="sd">        touching_branches,touching_endpoints = nru.skeleton_touching_branches(curr_limb_cp,branch_idx=curr_short_seg_revised)</span>
<span class="sd">        </span>
<span class="sd">        if debug_time:</span>
<span class="sd">            print(f&quot;skeleton branch touchings = {time.time() - limb_time}&quot;)</span>
<span class="sd">            limb_time = time.time()</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        #deciding whether to take the average or just an endpoint as the new stitch point depending on if nodes on both ends</span>
<span class="sd">        touch_len = np.array([len(k) for k in touching_branches])</span>
<span class="sd">        </span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;np.sum(touch_len&gt;0) = {np.sum(touch_len&gt;0)}&quot;)</span>
<span class="sd">            </span>
<span class="sd">        if np.sum(touch_len&gt;0)==2:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(&quot;Using average stitch point&quot;)</span>
<span class="sd">            new_stitch_point = np.mean(touching_endpoints,axis=0)</span>
<span class="sd">            middle_node = True</span>
<span class="sd">        else:</span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(&quot;Using ONE stitch point&quot;)</span>
<span class="sd">            new_stitch_point = touching_endpoints[np.argmax(touch_len)]</span>
<span class="sd">            middle_node = False</span>
<span class="sd">        </span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;touching_endpoints = {touching_endpoints}&quot;)</span>
<span class="sd">            print(f&quot;new_stitch_point = {new_stitch_point}&quot;)</span>
<span class="sd">            </span>
<span class="sd">        if debug_time:</span>
<span class="sd">            print(f&quot;Getting new stitch point time = {time.time() - limb_time}&quot;)</span>
<span class="sd">            limb_time = time.time()</span>
<span class="sd">        </span>
<span class="sd">        #1a) Decide which branch to give the mesh to</span>
<span class="sd">        if middle_node and reassign_mesh:</span>
<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            1) Get the skeletal angles between all the touching branches and the branch to be deleted</span>
<span class="sd">            2) Find the branch with the smallest skeletal angle</span>
<span class="sd">            3) Things that need to be updated for the winning branch:</span>
<span class="sd">            - mesh</span>
<span class="sd">            -mesh_face_idx</span>
<span class="sd">            - n_spines</span>
<span class="sd">            - spines</span>
<span class="sd">            - spines_volume</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
<span class="sd">            all_touching_branches = np.concatenate(touching_branches)</span>
<span class="sd">            all_touching_branches_angles = [sk.offset_skeletons_aligned_parent_child_skeletal_angle(</span>
<span class="sd">                            curr_limb_cp[br].skeleton,</span>
<span class="sd">                            curr_limb_cp[curr_short_seg_revised].skeleton) for br in all_touching_branches]</span>
<span class="sd">            winning_branch =all_touching_branches[np.argmin(all_touching_branches_angles)]</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            if verbose:</span>
<span class="sd">                print(f&quot;Angles for {all_touching_branches} are {all_touching_branches_angles}&quot;)</span>
<span class="sd">                print(f&quot;Branch that will absorb mesh of {curr_short_seg} is {winning_branch} &quot;)</span>
<span class="sd">                </span>
<span class="sd">            if debug_time:</span>
<span class="sd">                print(f&quot;branch angles = {time.time() - limb_time}&quot;)</span>
<span class="sd">                limb_time = time.time()</span>
<span class="sd">            </span>
<span class="sd">            curr_limb_cp[winning_branch].mesh_face_idx = np.concatenate([curr_limb_cp[winning_branch].mesh_face_idx,</span>
<span class="sd">                                                                    curr_limb_cp[curr_short_seg_revised].mesh_face_idx])</span>
<span class="sd">            curr_limb_cp[winning_branch].mesh = tu.combine_meshes([curr_limb_cp[winning_branch].mesh,</span>
<span class="sd">                                                                    curr_limb_cp[curr_short_seg_revised].mesh])</span>
<span class="sd">            if not curr_limb_cp[curr_short_seg_revised].spines is None:</span>
<span class="sd">                if curr_limb_cp[winning_branch].spines is not None:</span>
<span class="sd">                    curr_limb_cp[winning_branch].spines += curr_limb_cp[curr_short_seg_revised].spines</span>
<span class="sd">                    curr_limb_cp[winning_branch].spines_volume += curr_limb_cp[curr_short_seg_revised].spines_volume</span>
<span class="sd">                else:</span>
<span class="sd">                    curr_limb_cp[winning_branch].spines = curr_limb_cp[curr_short_seg_revised].spines</span>
<span class="sd">                    curr_limb_cp[winning_branch].spines_volume = curr_limb_cp[curr_short_seg_revised].spines_volume</span>
<span class="sd">                    </span>
<span class="sd">            </span>
<span class="sd">            if debug_time:</span>
<span class="sd">                print(f&quot;Resolving spines time = {time.time() - limb_time}&quot;)</span>
<span class="sd">                limb_time = time.time()</span>
<span class="sd">            </span>

<span class="sd">        #1b) Alter the skeletons of those that were touching</span>
<span class="sd">        for t_branches,t_endpoints in zip(touching_branches,touching_endpoints):</span>
<span class="sd">            for br in t_branches:</span>
<span class="sd">                curr_limb_cp[br].skeleton = sk.add_and_smooth_segment_to_branch(curr_limb_cp[br].skeleton,</span>
<span class="sd">                                                                                new_stitch_point=new_stitch_point,</span>
<span class="sd">                                                                            skeleton_stitch_point=t_endpoints)</span>
<span class="sd">                curr_limb_cp[br].calculate_endpoints()</span>
<span class="sd">                </span>
<span class="sd">        if debug_time:</span>
<span class="sd">            print(f&quot;smoothing the segments and calculating endpoints = {time.time() - limb_time}&quot;)</span>
<span class="sd">            limb_time = time.time()</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        #2) Remove the current node</span>
<span class="sd">        if not store_placeholder_for_removed_nodes:</span>
<span class="sd">            curr_limb_cp.concept_network.remove_node(curr_short_seg_revised)</span>
<span class="sd">            #update the seg_id_lookup</span>
<span class="sd">            seg_id_lookup = np.insert(seg_id_lookup,curr_short_seg,-1)[:-1]</span>
<span class="sd">            run_concept_network_checks=True</span>
<span class="sd">        else:</span>
<span class="sd">            curr_mesh_center = curr_limb_cp[curr_short_seg_revised].mesh_center</span>
<span class="sd">            center_deviation = 5.2345</span>
<span class="sd">            curr_limb_cp[curr_short_seg_revised].skeleton = np.array([curr_mesh_center,curr_mesh_center+center_deviation]).reshape(-1,2,3)</span>
<span class="sd">            curr_limb_cp[curr_short_seg_revised].calculate_endpoints()</span>
<span class="sd">            run_concept_network_checks = False</span>
<span class="sd">            </span>
<span class="sd">        if debug_time:</span>
<span class="sd">            print(f&quot; Adding placeholder branch time = {time.time() - limb_time}&quot;)</span>
<span class="sd">            limb_time = time.time()</span>

<span class="sd">        limb_to_soma_concept_networks = pre.calculate_limb_concept_networks(curr_limb_cp.limb_correspondence,</span>
<span class="sd">                                                                                    curr_limb_cp.network_starting_info,</span>
<span class="sd">                                                                                    run_concept_network_checks=False,</span>
<span class="sd">                                                                              )  </span>
<span class="sd">        if debug_time:</span>
<span class="sd">            print(f&quot;Calculating limb concept networks time = {time.time() - limb_time}&quot;)</span>
<span class="sd">            limb_time = time.time()</span>
<span class="sd">        </span>
<span class="sd">        #print(f&quot;curr_limb.deleted_edges 6={curr_limb_cp.deleted_edges}&quot;)</span>
<span class="sd">        curr_limb_cp = neuron.Limb(curr_limb_cp.mesh,</span>
<span class="sd">                                 curr_limb_cp.limb_correspondence,</span>
<span class="sd">                                 concept_network_dict=limb_to_soma_concept_networks,</span>
<span class="sd">                                 mesh_face_idx = curr_limb_cp.mesh_face_idx,</span>
<span class="sd">                                 labels=curr_limb_cp.labels,</span>
<span class="sd">                                 branch_objects=curr_limb_cp.branch_objects,</span>
<span class="sd">                                  deleted_edges=curr_limb_cp.deleted_edges,</span>
<span class="sd">                                  created_edges=curr_limb_cp.created_edges)</span>
<span class="sd">        </span>
<span class="sd">        if debug_time:</span>
<span class="sd">                print(f&quot;Creating new limb object time = {time.time() - limb_time}&quot;)</span>
<span class="sd">                limb_time = time.time()</span>
<span class="sd">        </span>
<span class="sd">        #print(f&quot;curr_limb.deleted_edges 7={curr_limb_cp.deleted_edges}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    if plot_new_limb:</span>
<span class="sd">        nviz.plot_limb_correspondence(curr_limb_cp.limb_correspondence)</span>
<span class="sd">    </span>
<span class="sd">    return curr_limb_cp</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="collapse_branches_on_limb"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.collapse_branches_on_limb">[docs]</a><span class="k">def</span> <span class="nf">collapse_branches_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">,</span>
                             <span class="n">plot_new_limb</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">reassign_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">store_placeholder_for_removed_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To remove 1 or more branches from the concept network</span>
<span class="sd">    of a limb and to adjust the underlying skeleton</span>
<span class="sd">    </span>
<span class="sd">    ** this is more if want to remove the presence of a branch but not</span>
<span class="sd">    remove the mesh associated with it (so just collapsing the node)</span>
<span class="sd">    </span>
<span class="sd">    Application: To be used in when trying to split </span>
<span class="sd">    a neuron and want to combine nodes that are really close</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    *** currently does not does not reallocate the mesh part of the nodes that were deleted</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    </span>
<span class="sd">    For each branch to remove</span>
<span class="sd">    0) Find the branches that were touching the soon to be deleted branch</span>
<span class="sd">    1) Alter the skeletons of those that were touching that branch</span>
<span class="sd">    </span>
<span class="sd">    After revised all nodes</span>
<span class="sd">    2) Remove the current node</span>
<span class="sd">    3) Generate the limb correspondence, network starting info to generate soma concept networks</span>
<span class="sd">    4) Create a new limb object and return it</span>


<span class="sd">    Ex: new_limb_obj = nru.collapse_branches_on_limb(curr_limb,[30,31],plot_new_limb=True,verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">curr_limb_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;deepcopy limb time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branch_list</span> <span class="p">):</span>
        <span class="n">branch_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_list</span><span class="p">]</span>
        
    <span class="n">seg_id_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_cp</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">curr_short_seg</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
        <span class="c1">#need to look up the new seg id if there is one now based on previous deletions</span>
        
        <span class="n">curr_short_seg_revised</span> <span class="o">=</span> <span class="n">seg_id_lookup</span><span class="p">[</span><span class="n">curr_short_seg</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_short_seg_revised = </span><span class="si">{</span><span class="n">curr_short_seg_revised</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span>
        
        <span class="n">touching_branches</span><span class="p">,</span><span class="n">touching_endpoints</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_touching_branches</span><span class="p">(</span><span class="n">curr_limb_cp</span><span class="p">,</span><span class="n">branch_idx</span><span class="o">=</span><span class="n">curr_short_seg_revised</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton branch touchings = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        
        <span class="c1">#deciding whether to take the average or just an endpoint as the new stitch point depending on if nodes on both ends</span>
        <span class="n">touch_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">touching_branches</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.sum(touch_len&gt;0) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">touch_len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">touch_len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using average stitch point&quot;</span><span class="p">)</span>
            <span class="n">new_stitch_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">touching_endpoints</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">middle_node</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using ONE stitch point&quot;</span><span class="p">)</span>
            <span class="n">new_stitch_point</span> <span class="o">=</span> <span class="n">touching_endpoints</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">touch_len</span><span class="p">)]</span>
            <span class="n">middle_node</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;touching_endpoints = </span><span class="si">{</span><span class="n">touching_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_stitch_point = </span><span class="si">{</span><span class="n">new_stitch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting new stitch point time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="c1">#1a) Decide which branch to give the mesh to</span>
        <span class="k">if</span> <span class="n">middle_node</span> <span class="ow">and</span> <span class="n">reassign_mesh</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            1) Get the skeletal angles between all the touching branches and the branch to be deleted</span>
<span class="sd">            2) Find the branch with the smallest skeletal angle</span>
<span class="sd">            3) Things that need to be updated for the winning branch:</span>
<span class="sd">            - mesh</span>
<span class="sd">            -mesh_face_idx</span>
<span class="sd">            - n_spines</span>
<span class="sd">            - spines</span>
<span class="sd">            - spines_volume</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">all_touching_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">touching_branches</span><span class="p">)</span>
            <span class="n">all_touching_branches_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">offset_skeletons_aligned_parent_child_skeletal_angle</span><span class="p">(</span>
                            <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">br</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                            <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">all_touching_branches</span><span class="p">]</span>
            <span class="n">winning_branch</span> <span class="o">=</span><span class="n">all_touching_branches</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_touching_branches_angles</span><span class="p">)]</span>
            
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Angles for </span><span class="si">{</span><span class="n">all_touching_branches</span><span class="si">}</span><span class="s2"> are </span><span class="si">{</span><span class="n">all_touching_branches_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch that will absorb mesh of </span><span class="si">{</span><span class="n">curr_short_seg</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="n">winning_branch</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch angles = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span>
                                                                    <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">])</span>
            <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                                    <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span> <span class="o">+=</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span>
                    <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">+=</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">spines_volume</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span>
                    <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">winning_branch</span><span class="p">]</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">spines_volume</span>
                    
            
            <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resolving spines time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            

        <span class="c1">#1b) Alter the skeletons of those that were touching</span>
        <span class="k">for</span> <span class="n">t_branches</span><span class="p">,</span><span class="n">t_endpoints</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">touching_branches</span><span class="p">,</span><span class="n">touching_endpoints</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">br</span> <span class="ow">in</span> <span class="n">t_branches</span><span class="p">:</span>
                <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">br</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">add_and_smooth_segment_to_branch</span><span class="p">(</span><span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">br</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                                <span class="n">new_stitch_point</span><span class="o">=</span><span class="n">new_stitch_point</span><span class="p">,</span>
                                                                            <span class="n">skeleton_stitch_point</span><span class="o">=</span><span class="n">t_endpoints</span><span class="p">)</span>
                <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">br</span><span class="p">]</span><span class="o">.</span><span class="n">calculate_endpoints</span><span class="p">()</span>
                
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;smoothing the segments and calculating endpoints = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
            
        <span class="c1">#2) Remove the current node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">store_placeholder_for_removed_nodes</span><span class="p">:</span>
            <span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">curr_short_seg_revised</span><span class="p">)</span>
            <span class="c1">#update the seg_id_lookup</span>
            <span class="n">seg_id_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">seg_id_lookup</span><span class="p">,</span><span class="n">curr_short_seg</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_mesh_center</span> <span class="o">=</span> <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
            <span class="n">center_deviation</span> <span class="o">=</span> <span class="mf">5.2345</span>
            <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">curr_mesh_center</span><span class="p">,</span><span class="n">curr_mesh_center</span><span class="o">+</span><span class="n">center_deviation</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">curr_limb_cp</span><span class="p">[</span><span class="n">curr_short_seg_revised</span><span class="p">]</span><span class="o">.</span><span class="n">calculate_endpoints</span><span class="p">()</span>
            <span class="n">run_concept_network_checks</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Adding placeholder branch time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            

    <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">limb_correspondence</span><span class="p">,</span>
                                                                                <span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">network_starting_info</span><span class="p">,</span>
                                                                                <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                          <span class="p">)</span>  
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating limb concept networks time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#print(f&quot;curr_limb.deleted_edges 6={curr_limb_cp.deleted_edges}&quot;)</span>
    <span class="n">curr_limb_cp</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">(</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">limb_correspondence</span><span class="p">,</span>
                             <span class="n">concept_network_dict</span><span class="o">=</span><span class="n">limb_to_soma_concept_networks</span><span class="p">,</span>
                             <span class="n">mesh_face_idx</span> <span class="o">=</span> <span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">mesh_face_idx</span><span class="p">,</span>
                             <span class="n">labels</span><span class="o">=</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
                             <span class="n">branch_objects</span><span class="o">=</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">branch_objects</span><span class="p">,</span>
                              <span class="n">deleted_edges</span><span class="o">=</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">deleted_edges</span><span class="p">,</span>
                              <span class="n">created_edges</span><span class="o">=</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">created_edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating new limb object time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limb_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">limb_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>


    <span class="k">if</span> <span class="n">plot_new_limb</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_correspondence</span><span class="p">(</span><span class="n">curr_limb_cp</span><span class="o">.</span><span class="n">limb_correspondence</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">curr_limb_cp</span></div>



<span class="c1"># ----------------- 1/26: Final Proofreading Rules splitting ------------#</span>



<div class="viewcode-block" id="delete_branches_from_limb"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.delete_branches_from_limb">[docs]</a><span class="k">def</span> <span class="nf">delete_branches_from_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">branches_to_delete</span><span class="p">,</span>
                              <span class="n">limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will delete branches from a certain limb</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---- Working on Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2"> ----&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;length of concept network BEFORE elimination = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="c1">#1) Remove the nodes in the limb branch dict</span>
    <span class="n">concept_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
    <span class="n">concept_graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">branches_to_delete</span><span class="p">)</span>
    <span class="n">seperate_networks</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">concept_graph</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;length of concept network AFTER elimination = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">concept_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="n">split_neuron</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_neuron_limb_by_seperated_network</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                             <span class="n">curr_limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span>
                                                              <span class="c1">#seperate_networks = [list(concept_graph.nodes())]</span>
                                                              <span class="n">seperate_networks</span> <span class="o">=</span> <span class="n">seperate_networks</span>
                                                             <span class="p">)</span>
    <span class="k">return</span> <span class="n">split_neuron</span></div>

<div class="viewcode-block" id="delete_branches_from_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.delete_branches_from_neuron">[docs]</a><span class="k">def</span> <span class="nf">delete_branches_from_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">limb_branch_dict</span><span class="p">,</span>
                                <span class="n">plot_neuron_after_cancellation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">add_split_to_description</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargss</span>
                               <span class="p">):</span>
<span class="w">    </span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To eliminate the error cells and downstream targets</span>
<span class="sd">    given limb branch dict of nodes to eliminate</span>

<span class="sd">    Pseudocode: </span>

<span class="sd">    For each limb in branch dict</span>
<span class="sd">    1) Remove the nodes in the limb branch dict</span>

<span class="sd">    2) Send the neuron to </span>
<span class="sd">       i) split_neuron_limbs_by_suggestions</span>
<span class="sd">       ii) split_disconnected_neuron</span>


<span class="sd">    If a limb is empty or has no more connetion to the</span>
<span class="sd">    starting soma then it will be deleted in the end</span>

<span class="sd">    &quot;&quot;&quot;</span>



    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches at beginning = </span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="c1">#For each limb in branch dict</span>
    <span class="n">n_branches_at_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches</span><span class="p">)</span>

    <span class="n">split_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branches_to_delete</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        
        <span class="n">split_neuron</span> <span class="o">=</span> <span class="n">delete_branches_from_limb</span><span class="p">(</span><span class="n">split_neuron</span><span class="p">,</span>
                              <span class="n">branches_to_delete</span><span class="o">=</span><span class="n">branches_to_delete</span><span class="p">,</span>
                              <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                <span class="p">)</span>
        

    <span class="k">if</span> <span class="n">plot_neuron_after_cancellation</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">split_neuron</span><span class="p">,</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches after split_neuron_limb_by_seperated_network = </span><span class="si">{</span><span class="n">split_neuron</span><span class="o">.</span><span class="n">n_branches</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="n">disconnected_neuron</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_disconnected_neuron</span><span class="p">(</span><span class="n">split_neuron</span><span class="p">,</span>
                                                        <span class="n">return_errored_limbs_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                       <span class="n">add_split_to_description</span><span class="o">=</span><span class="n">add_split_to_description</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">disconnected_neuron</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The disconnected neurons were not 1: </span><span class="si">{</span><span class="n">disconnected_neuron</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">return_neuron</span> <span class="o">=</span> <span class="n">disconnected_neuron</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of branches after split_disconnectd neuron = </span><span class="si">{</span><span class="n">return_neuron</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_neuron</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">return_neuron</span><span class="p">,</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_neuron</span></div>
    
    
<span class="c1"># ----------- 1/28 Proofreading Rules that will help filter a neuron object --------------- #</span>

<div class="viewcode-block" id="filter_away_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">filter_away_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                 <span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">limb_edge_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span>
                                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away a limb branch dict from a single neuron</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict was empty so returning original neuron&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">neuron_obj</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">neuron_obj</span>
    
    <span class="k">if</span> <span class="n">plot_limb_branch_filter_away</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Branches Requested to Remove (without disconnect effect)&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">limb_branch_dict</span><span class="p">)</span>


    <span class="c1">#2) Find the total branches that will be removed using the axon-error limb branch dict</span>

    <span class="n">removed_limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">,</span>
                                 <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After disconnecte effect, removed_limb_branch_dict = </span><span class="si">{</span><span class="n">removed_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Branches Requested to Remove (WITH disconnect effect)&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">removed_limb_branch_dict</span><span class="p">)</span>
    
    <span class="c1">#3) Calculate the total skeleton length and error faces area for what will be removed</span>
    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="n">total_area</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">removed_limb_branch_dict</span><span class="p">,</span>
                                           <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>

        <span class="n">total_sk_distance</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                               <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">removed_limb_branch_dict</span><span class="p">,</span>
                                               <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_sk_distance = </span><span class="si">{</span><span class="n">total_sk_distance</span><span class="si">}</span><span class="s2">, total_area = </span><span class="si">{</span><span class="n">total_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#4) Delete the brnaches from the neuron</span>
    <span class="n">new_neuron</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">delete_branches_from_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">removed_limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">plot_neuron_after_cancellation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">add_split_to_description</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_neuron</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">new_neuron</span><span class="p">,</span>
                             <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                             <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_neuron</span><span class="p">,</span><span class="n">total_area</span><span class="p">,</span><span class="n">total_sk_distance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_neuron</span></div>
    
    

<div class="viewcode-block" id="filter_away_axon_on_dendrite_merges_old"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_axon_on_dendrite_merges_old">[docs]</a><span class="k">def</span> <span class="nf">filter_away_axon_on_dendrite_merges_old</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">perform_deepcopy</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">axon_merge_error_limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">perform_axon_classification</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_pre_existing_axon_labels</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>

    <span class="n">plot_limb_branch_filter_away</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">prevent_errors_on_branches_with_all_postsyn</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_limb_branch_before_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>

<span class="sd">    If error labels not given</span>
<span class="sd">    1a) Apply axon classification if requested</span>
<span class="sd">    1b) Use the pre-existing error labels if requested</span>

<span class="sd">    2) Find the total branches that will be removed using the axon-error limb branch dict</span>
<span class="sd">    3) Calculate the total skeleton length and error faces area for what will be removed</span>
<span class="sd">    4) Delete the brnaches from the neuron</span>
<span class="sd">    5) Return the neuron</span>

<span class="sd">    Example: </span>
<span class="sd">    </span>
<span class="sd">    filter_away_axon_on_dendrite_merges(</span>
<span class="sd">    neuron_obj = neuron_obj_1,</span>
<span class="sd">    perform_axon_classification = True,</span>
<span class="sd">    return_error_info=True,</span>
<span class="sd">    verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">perform_deepcopy</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axon_merge_error_limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">perform_axon_classification</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">use_pre_existing_axon_labels</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to set either perform_axon_classification or use_pre_existing_axon_labels because&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; axon_merge_error_limb_branch_dict is None&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_pre_existing_axon_labels</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;using pre-existing labels for axon-error detection&quot;</span><span class="p">)</span>

            <span class="n">axon_merge_error_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-error&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;performing axon classification for axon-error detection&quot;</span><span class="p">)</span>


            <span class="n">axon_limb_branch_dict</span><span class="p">,</span><span class="n">axon_merge_error_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">return_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">return_error_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">plot_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">plot_axon_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="p">)</span>


    <span class="k">if</span> <span class="n">prevent_errors_on_branches_with_all_postsyn</span><span class="p">:</span>
        <span class="k">pass</span>
        
    <span class="n">new_neuron</span><span class="p">,</span><span class="n">total_area</span><span class="p">,</span><span class="n">total_sk_distance</span> <span class="o">=</span> <span class="n">filter_away_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_merge_error_limb_branch_dict</span><span class="p">,</span>
                                    <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                                     <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                    <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                           <span class="o">**</span><span class="n">kwargs</span>
                                                                           
                                    <span class="p">)</span>
    
    <span class="n">axon_merge_error_limb_branch_dict_after</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">axon_merge_error_limb_branch_dict</span><span class="p">,</span>
                                 <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_limb_branch_before_filter_away</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_neuron</span><span class="p">,</span><span class="n">total_area</span><span class="p">,</span><span class="n">total_sk_distance</span><span class="p">,</span><span class="n">axon_merge_error_limb_branch_dict_after</span><span class="p">,</span><span class="n">axon_merge_error_limb_branch_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">new_neuron</span><span class="p">,</span><span class="n">total_area</span><span class="p">,</span><span class="n">total_sk_distance</span><span class="p">,</span><span class="n">axon_merge_error_limb_branch_dict_after</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_neuron</span><span class="p">,</span><span class="n">total_area</span><span class="p">,</span><span class="n">total_sk_distance</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_neuron</span></div>

<span class="c1">#---------- Rule 2: Removing Dendritic Merges on Axon ------------- #</span>

<div class="viewcode-block" id="filter_away_dendrite_on_axon_merges_old"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_dendrite_on_axon_merges_old">[docs]</a><span class="k">def</span> <span class="nf">filter_away_dendrite_on_axon_merges_old</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">perform_deepcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    
    <span class="n">limb_branch_dict_for_search</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">perform_axon_classification</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    
    <span class="n">dendritic_merge_on_axon_query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dendrite_merge_skeletal_length_min</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span>
    <span class="n">dendrite_merge_width_min</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">dendritie_spine_density_min</span> <span class="o">=</span> <span class="mf">0.00015</span><span class="p">,</span>
    
    <span class="n">plot_limb_branch_filter_away</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_error_info</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away the dendrite parts that are </span>
<span class="sd">    merged onto axon pieces</span>
<span class="sd">    </span>
<span class="sd">    if limb_branch_dict_for_search is None then </span>
<span class="sd">    just going to try and classify the axon and then </span>
<span class="sd">    going to search from there</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">perform_deepcopy</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">limb_branch_dict_for_search</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">use_pre_existing_axon_labels</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">perform_axon_classification</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Need to set either perform_axon_classification or use_pre_existing_axon_labels because&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; limb_branch_dict_for_search is None&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_pre_existing_axon_labels</span><span class="p">:</span>
            <span class="n">axon_limb_branch_dict</span><span class="p">,</span><span class="n">axon_error_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">return_error_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">plot_candidates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">plot_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">plot_axon_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using pre-existing axon and axon-like labels&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">dendritic_merge_on_axon_query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dendritic_merge_on_axon_query</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;labels_restriction == True and &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(median_mesh_center &gt; </span><span class="si">{</span><span class="n">dendrite_merge_width_min</span><span class="si">}</span><span class="s2">) and  &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(skeletal_length &gt; </span><span class="si">{</span><span class="n">dendrite_merge_skeletal_length_min</span><span class="si">}</span><span class="s2">) and &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(spine_density) &gt; </span><span class="si">{</span><span class="n">dendritie_spine_density_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">function_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">],</span>
                          <span class="n">not_matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">])</span>

    <span class="n">dendritic_branches_merged_on_axon</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;labels_restriction&quot;</span><span class="p">,</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span><span class="s2">&quot;spine_density&quot;</span><span class="p">],</span>
                    <span class="n">query</span><span class="o">=</span><span class="n">dendritic_merge_on_axon_query</span><span class="p">,</span>
                    <span class="n">function_kwargs</span><span class="o">=</span><span class="n">function_kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dendritic_branches_merged_on_axon = </span><span class="si">{</span><span class="n">dendritic_branches_merged_on_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    

    <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
        <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
         <span class="n">total_sk_distance_stripped</span><span class="p">)</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">dendritic_branches_merged_on_axon</span><span class="p">,</span>
                                        <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                                         <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                    <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                     <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                   <span class="n">dendritic_branches_merged_on_axon</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                    <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                     <span class="n">total_sk_distance_stripped</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dendrite_stripped_neuron</span></div>
    
    
<span class="c1"># ------------ Rule 3: Filtering away axon mess ----------- #</span>

<div class="viewcode-block" id="filter_away_limb_branch_dict_with_function"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_limb_branch_dict_with_function">[docs]</a><span class="k">def</span> <span class="nf">filter_away_limb_branch_dict_with_function</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict_function</span><span class="p">,</span>
    <span class="n">perform_deepcopy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    
    
    <span class="n">plot_limb_branch_filter_away</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_error_info</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_limb_branch_before_filter_away</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_created_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">apply_after_removal_to_limb_branch_before</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span> <span class="c1">#These argument will be for running the function that will come up with limb branch dict</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter away a limb branch dict from</span>
<span class="sd">    a neuron using a function that generates a limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">perform_deepcopy</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

        
    <span class="n">ret_val</span> <span class="o">=</span> <span class="n">limb_branch_dict_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_created_edges</span><span class="p">:</span>
        <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span><span class="n">created_edges</span> <span class="o">=</span> <span class="n">ret_val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="n">ret_val</span>
        
    <span class="c1"># doing the cancelling beforehand</span>
    <span class="n">limb_branch_dict_to_cancel_pre</span> <span class="o">=</span> <span class="n">limb_branch_dict_to_cancel</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">apply_after_removal_to_limb_branch_before</span><span class="p">:</span>
        <span class="n">limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                              <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                                     <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="p">)</span>

    
    
    <span class="k">if</span> <span class="n">print_limb_branch_dict_to_cancel</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict_to_cancel = </span><span class="si">{</span><span class="n">limb_branch_dict_to_cancel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
    <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
     <span class="n">total_sk_distance_stripped</span><span class="p">)</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                                        <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                                         <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_created_edges</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                        <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                         <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                       <span class="n">created_edges</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                        <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                         <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                       <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_limb_branch_before_filter_away</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_created_edges</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                            <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                             <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                           <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                            <span class="n">limb_branch_dict_to_cancel_pre</span><span class="p">,</span>
                           <span class="n">created_edges</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                            <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                             <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                           <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                            <span class="n">limb_branch_dict_to_cancel_pre</span><span class="p">,</span>
                        
                           <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_created_edges</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                            <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                             <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                           <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                           <span class="n">created_edges</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">dendrite_stripped_neuron</span><span class="p">,</span>
                            <span class="n">total_area_dendrite_stripped</span><span class="p">,</span>
                             <span class="n">total_sk_distance_stripped</span><span class="p">,</span>
                           <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                        
                           <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dendrite_stripped_neuron</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_limb_branch_before_filter_away</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_created_edges</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dendrite_stripped_neuron</span><span class="p">,</span> <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span><span class="n">limb_branch_dict_to_cancel_pre</span><span class="p">,</span><span class="n">created_edges</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dendrite_stripped_neuron</span><span class="p">,</span> <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span><span class="n">limb_branch_dict_to_cancel_pre</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">return_created_edges</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dendrite_stripped_neuron</span><span class="p">,</span> <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span><span class="n">created_edges</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dendrite_stripped_neuron</span><span class="p">,</span> <span class="n">limb_branch_dict_to_cancel</span></div>


<div class="viewcode-block" id="filter_away_low_branch_length_clusters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_low_branch_length_clusters">[docs]</a><span class="k">def</span> <span class="nf">filter_away_low_branch_length_clusters</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">max_skeletal_length</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                                           <span class="n">min_n_nodes_in_cluster</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">nru</span><span class="o">.</span><span class="n">low_branch_length_clusters</span><span class="p">,</span>
                 <span class="n">max_skeletal_length</span><span class="o">=</span><span class="n">max_skeletal_length</span><span class="p">,</span>
                 <span class="n">min_n_nodes_in_cluster</span><span class="o">=</span><span class="n">min_n_nodes_in_cluster</span><span class="p">,</span>
                 <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
<span class="c1"># ---------- Rule 4: Width and doubling back rules ---------------- #</span>


<div class="viewcode-block" id="edges_to_cut_by_doubling_back_and_width_change"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.edges_to_cut_by_doubling_back_and_width_change">[docs]</a><span class="k">def</span> <span class="nf">edges_to_cut_by_doubling_back_and_width_change</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    
    <span class="c1">#--- Parameter for the width_jump_double_back_edges_path function</span>
    <span class="n">skeletal_length_to_skip</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>

    <span class="c1"># parameters for the boundary transition</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>


    <span class="c1">#the thresholds for determining if there are errors</span>
    <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
    <span class="n">width_jump_axon_like_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
    <span class="n">running_width_jump_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
    
                                     
    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
    <span class="n">double_back_axon_like_threshold</span> <span class="o">=</span> <span class="mi">145</span><span class="p">,</span>

    <span class="n">perform_double_back_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">perform_width_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">skip_double_back_errors_for_axon</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Getting the edges of the concept</span>
<span class="sd">    network to cut for a limb object based on </span>
<span class="sd">    the width and doubling back rules</span>
<span class="sd">    </span>
<span class="sd">    Application: Will then feed these edges in to cut the limb</span>
<span class="sd">    when automatic proofreading</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#verbose = True</span>


    <span class="n">curr_limb</span> <span class="o">=</span><span class="n">limb_obj</span>
    <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">()</span>
    <span class="n">dir_nx</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
    <span class="n">paths_to_end_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_path_from_start_to_end_nodes</span><span class="p">(</span><span class="n">dir_nx</span><span class="p">,</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">)</span>


    <span class="n">edges_to_cut_from_double_back</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges_to_cut_from_width</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span>

    <span class="n">checked_edges</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">ex_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths_to_end_nodes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on path </span><span class="si">{</span><span class="n">jj</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ex_path</span><span class="si">}</span><span class="s2"> -- #&quot;</span><span class="p">)</span>
    

        <span class="n">all_cuts</span><span class="p">,</span><span class="n">double_back_cuts</span><span class="p">,</span><span class="n">width_cuts</span><span class="p">,</span><span class="n">all_sk_angles</span><span class="p">,</span><span class="n">all_widths</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">width_jump_double_back_edges_path</span><span class="p">(</span>
                        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">,</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">ex_path</span><span class="p">,</span>
                        <span class="n">starting_coordinate</span><span class="o">=</span><span class="n">starting_coordinate</span><span class="p">,</span>
                        
                        <span class="n">skeletal_length_to_skip</span><span class="o">=</span><span class="n">skeletal_length_to_skip</span><span class="p">,</span>

                        <span class="c1"># parameters for the boundary transition</span>
                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>


                        <span class="c1">#the thresholds for determining if there are errors</span>
                        <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="n">width_jump_threshold</span><span class="p">,</span>
                        <span class="n">width_jump_axon_like_threshold</span> <span class="o">=</span> <span class="n">width_jump_axon_like_threshold</span><span class="p">,</span>
                        <span class="n">running_width_jump_method</span><span class="o">=</span><span class="n">running_width_jump_method</span><span class="p">,</span>
            
            
                        <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold</span><span class="p">,</span>
                        <span class="n">double_back_axon_like_threshold</span> <span class="o">=</span> <span class="n">double_back_axon_like_threshold</span><span class="p">,</span>
        
    

                        <span class="n">perform_double_back_errors</span> <span class="o">=</span> <span class="n">perform_double_back_errors</span><span class="p">,</span>
                        <span class="n">perform_width_errors</span> <span class="o">=</span> <span class="n">perform_width_errors</span><span class="p">,</span>
                        <span class="n">skip_double_back_errors_for_axon</span> <span class="o">=</span> <span class="n">skip_double_back_errors_for_axon</span><span class="p">,</span>
            
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all cuts = </span><span class="si">{</span><span class="n">all_cuts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_back_cuts = </span><span class="si">{</span><span class="n">double_back_cuts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_cuts = </span><span class="si">{</span><span class="n">width_cuts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_sk_angles = </span><span class="si">{</span><span class="n">all_sk_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_widths = </span><span class="si">{</span><span class="n">all_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">double_back_cuts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges_to_cut_from_double_back</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">double_back_cuts</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">width_cuts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges_to_cut_from_width</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">width_cuts</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_to_cut_from_double_back</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">edges_to_cut_from_double_back</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">edges_to_cut_from_double_back</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edges_to_cut_from_double_back</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_to_cut_from_width</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">edges_to_cut_from_width</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">edges_to_cut_from_width</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edges_to_cut_from_width</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">edges_to_cut_from_double_back</span><span class="p">,</span><span class="n">edges_to_cut_from_width</span></div>

<div class="viewcode-block" id="edges_to_create_and_delete_by_doubling_back_and_width"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.edges_to_create_and_delete_by_doubling_back_and_width">[docs]</a><span class="k">def</span> <span class="nf">edges_to_create_and_delete_by_doubling_back_and_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for the doubling back and width cuts that will generate edges to delete</span>
<span class="sd">    and create so can fit the edge pipeline</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">double_back_cuts_total</span><span class="p">,</span> <span class="n">width_cuts_total</span> <span class="o">=</span> <span class="n">edges_to_cut_by_doubling_back_and_width_change</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">double_back_cuts_total</span> <span class="o">+</span> <span class="n">width_cuts_total</span>
    <span class="n">edges_to_create</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">return</span> <span class="n">edges_to_create</span><span class="p">,</span><span class="n">edges_to_delete</span></div>



<div class="viewcode-block" id="doubling_back_and_width_elimination_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.doubling_back_and_width_elimination_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">doubling_back_and_width_elimination_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
    
                                            <span class="c1">#--- Parameter for the width_jump_double_back_edges_path function</span>
                                            <span class="n">skeletal_length_to_skip</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>

                                            <span class="c1"># parameters for the boundary transition</span>
                                            <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
                                            <span class="n">offset</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="c1">#have to make the offset larger because the spines are cancelled out 2000 from the endpoints</span>


                                            <span class="c1">#the thresholds for determining if there are errors</span>
                                            <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span><span class="c1">#200,</span>
                                            <span class="n">width_jump_axon_like_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
                                            <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>

                                            <span class="n">perform_double_back_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="n">perform_width_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="n">skip_double_back_errors_for_axon</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    
    
    <span class="n">double_back_width_limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_edge_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">edge_function</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">edges_to_create_and_delete_by_doubling_back_and_width</span><span class="p">,</span>
                                                                            
                                    <span class="n">skeletal_length_to_skip</span><span class="o">=</span><span class="n">skeletal_length_to_skip</span><span class="p">,</span>

                                    <span class="c1"># parameters for the boundary transition</span>
                                    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>


                                    <span class="c1">#the thresholds for determining if there are errors</span>
                                    <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="n">width_jump_threshold</span><span class="p">,</span>
                                    <span class="n">width_jump_axon_like_threshold</span> <span class="o">=</span> <span class="n">width_jump_axon_like_threshold</span><span class="p">,</span>
                                    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold</span><span class="p">,</span>

                                    <span class="n">perform_double_back_errors</span> <span class="o">=</span> <span class="n">perform_double_back_errors</span><span class="p">,</span>
                                    <span class="n">perform_width_errors</span> <span class="o">=</span> <span class="n">perform_width_errors</span><span class="p">,</span>
                                    <span class="n">skip_double_back_errors_for_axon</span> <span class="o">=</span> <span class="n">skip_double_back_errors_for_axon</span><span class="p">,</span>

                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                                            <span class="o">**</span><span class="n">kwargs</span>
                                    
                                  <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">double_back_width_limb_branch_dict</span></div>



<div class="viewcode-block" id="filter_away_large_double_back_or_width_changes"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_large_double_back_or_width_changes">[docs]</a><span class="k">def</span> <span class="nf">filter_away_large_double_back_or_width_changes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">doubling_back_and_width_elimination_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
<span class="c1"># ------------- Rule 5: Resolving Crossing Traintracks --------------------- #</span>


<div class="viewcode-block" id="edges_to_create_and_delete_crossover"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.edges_to_create_and_delete_crossover">[docs]</a><span class="k">def</span> <span class="nf">edges_to_create_and_delete_crossover</span><span class="p">(</span>
                                        <span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">match_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">require_two_pairs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        
                                        <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To seperate train track crossovers if there are perfect matches</span>
<span class="sd">    and ignore them if there are not</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all 4 degree skeleton coordinates</span>
<span class="sd">    2) For each coordinate:</span>
<span class="sd">    a) if axon dependnet --&gt; check that all of them are axon (if not then continue)</span>
<span class="sd">    b) do resolve the crossover with the best pairs</span>
<span class="sd">    c) if 2 perfect pairs --&gt; then add the delete and remove edges to the big list</span>
<span class="sd">        not 2 pairs --&gt; skip</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">comparison_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_high_degree_global</span>
        
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_high_degree_global</span>
        
    <span class="k">if</span> <span class="n">match_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_threshold_high_degree_global</span>
        
    
    <span class="k">if</span> <span class="n">require_two_pairs</span><span class="p">:</span>
        <span class="n">exactly_equal</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exactly_equal</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">crossover_coordinates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">high_degree_branching_coordinates_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                                                                         <span class="n">exactly_equal</span><span class="o">=</span><span class="n">exactly_equal</span><span class="p">,</span>
                                                                         <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;crossover_coordinates = </span><span class="si">{</span><span class="n">crossover_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">edges_to_create</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#2) For each oe resolve the crossover with the best pairs</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c_coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">crossover_coordinates</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">axon_dependent</span><span class="p">:</span>
            <span class="n">continue_flag</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">branches_at_coord</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">c_coord</span><span class="p">))</span>
            
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_only_group</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                   <span class="n">branches_at_coord</span><span class="p">,</span>
                                   <span class="n">use_axon_like</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">):</span>
                <span class="k">continue</span>
                
<span class="c1">#             for b in branches_at_coord:</span>
<span class="c1">#                 if &quot;axon-like&quot; not in limb_obj[b].labels and &quot;axon&quot; not in limb_obj[b].labels:</span>
<span class="c1">#                     if verbose:</span>
<span class="c1">#                         print(f&quot;Skipping coordinate {i} ({c_coord}) because branch {b} was not an axon-like or axon piece &quot;)</span>
<span class="c1">#                     continue_flag=True</span>
<span class="c1">#                     break</span>

<span class="c1">#             if continue_flag:</span>
<span class="c1">#                 continue</span>

        <span class="n">curr_edges_to_delete</span><span class="p">,</span><span class="n">curr_edges_to_create</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">resolving_crossovers</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">coordinate</span> <span class="o">=</span><span class="n">c_coord</span><span class="p">,</span>
                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                             <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                            <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_threshold</span><span class="p">,</span>
                            <span class="n">require_two_pairs</span><span class="o">=</span><span class="n">require_two_pairs</span><span class="p">,</span>
                            <span class="c1">#verbose = False,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                             <span class="n">return_new_edges</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="c1">#plot_intermediates=False,</span>
                            <span class="n">plot_intermediates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_edges_to_create</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">require_two_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found matching train tracks for coordinate </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">c_coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">edges_to_create</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_edges_to_create</span><span class="p">)</span>
            <span class="n">edges_to_delete</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_edges_to_delete</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_edges_to_create</span><span class="p">)</span><span class="si">}</span><span class="s2"> successful matches so skipping&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">edges_to_create</span><span class="p">,</span><span class="n">edges_to_delete</span></div>

<div class="viewcode-block" id="crossover_elimination_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.crossover_elimination_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">crossover_elimination_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">offset</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">,</span>
                                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
                                           <span class="n">require_two_pairs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">comparison_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_high_degree_global</span>
    
    <span class="n">high_degree_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_edge_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">edge_function</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">edges_to_create_and_delete_crossover</span><span class="p">,</span>
                                                                  <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                                                    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                                                    <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_threshold</span><span class="p">,</span>
                                                                    <span class="n">axon_dependent</span> <span class="o">=</span> <span class="n">axon_dependent</span><span class="p">,</span>
                                                                 <span class="n">require_two_pairs</span><span class="o">=</span><span class="n">require_two_pairs</span><span class="p">,</span>
                                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                                                  
    <span class="k">return</span> <span class="n">high_degree_limb_branch</span>    </div>

<div class="viewcode-block" id="filter_away_crossovers"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_crossovers">[docs]</a><span class="k">def</span> <span class="nf">filter_away_crossovers</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">crossover_elimination_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="c1"># ------------- Rule 6: Filtering Away High Degree Edges --------------------- #</span>

<div class="viewcode-block" id="edges_to_create_and_delete_high_degree_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.edges_to_create_and_delete_high_degree_coordinates">[docs]</a><span class="k">def</span> <span class="nf">edges_to_create_and_delete_high_degree_coordinates</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                     <span class="n">min_degree_to_find</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                                                       <span class="n">axon_dependent</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Cut all edges at branches</span>
<span class="sd">    grouped around a high degree skeleton node</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Find Branches Grouped around a high degree skeleton node</span>
<span class="sd">    2) Get all combinations of the branches</span>
<span class="sd">    3) Make those combinations the edges to delete, and make edges to create empty</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    limb_obj =  neuron_obj[0]</span>
<span class="sd">    min_degree_to_find = 5</span>

<span class="sd">    edges_to_create_and_delete_high_degree_coordinate(limb_obj,</span>
<span class="sd">                                                         min_degree_to_find = min_degree_to_find,</span>
<span class="sd">                                                         verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#1) Find Branches Grouped around a high degree skeleton node</span>
    <span class="n">high_degree_branch_groups</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_at_high_degree_coordinates</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                       <span class="n">min_degree_to_find</span><span class="o">=</span><span class="n">min_degree_to_find</span><span class="p">,</span>
                                                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;high_degree_branch_groups = </span><span class="si">{</span><span class="n">high_degree_branch_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#2) Get all combinations of the branches</span>
    <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edges_to_create</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">b_group</span> <span class="ow">in</span> <span class="n">high_degree_branch_groups</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axon_dependent</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nru</span><span class="o">.</span><span class="n">axon_only_group</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                   <span class="n">b_group</span><span class="p">,</span>
                                   <span class="n">use_axon_like</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">):</span>
                <span class="k">continue</span>
            
        
        <span class="n">all_pairings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">all_unique_choose_2_combinations</span><span class="p">(</span><span class="n">b_group</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For branch group (</span><span class="si">{</span><span class="n">b_group</span><span class="si">}</span><span class="s2">), the edges to cut were: </span><span class="si">{</span><span class="n">all_pairings</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">edges_to_delete</span> <span class="o">+=</span> <span class="n">all_pairings</span>
    
    <span class="k">return</span> <span class="n">edges_to_create</span><span class="p">,</span><span class="n">edges_to_delete</span></div>

<div class="viewcode-block" id="high_degree_coordinates_elimination_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.high_degree_coordinates_elimination_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">high_degree_coordinates_elimination_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                       <span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                                         <span class="n">axon_dependent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">high_degree_limb_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_edge_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">edge_function</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">edges_to_create_and_delete_high_degree_coordinates</span><span class="p">,</span>
                                                                  <span class="n">min_degree_to_find</span><span class="o">=</span><span class="n">min_degree_to_find</span><span class="p">,</span>
                                                                 <span class="n">axon_dependent</span><span class="o">=</span><span class="n">axon_dependent</span><span class="p">,</span>
                                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                                                  
    <span class="k">return</span> <span class="n">high_degree_limb_branch</span>    </div>


<div class="viewcode-block" id="filter_away_high_degree_coordinates"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_high_degree_coordinates">[docs]</a><span class="k">def</span> <span class="nf">filter_away_high_degree_coordinates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">high_degree_coordinates_elimination_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
                                                                  
<span class="c1">#  ---- 2/2: Pipeline for Applying Filters ------:</span>
<div class="viewcode-block" id="make_filter_dict"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.make_filter_dict">[docs]</a><span class="k">def</span> <span class="nf">make_filter_dict</span><span class="p">(</span><span class="n">filter_name</span><span class="p">,</span>
                    <span class="n">filter_function</span><span class="p">,</span>
                    <span class="n">filter_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">filter_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">filter_name</span><span class="o">=</span><span class="n">filter_name</span><span class="p">,</span>
               <span class="n">filter_function</span><span class="o">=</span><span class="n">filter_function</span><span class="p">,</span>
               <span class="n">filter_kwargs</span><span class="o">=</span><span class="n">filter_kwargs</span><span class="p">,</span>
               <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">)</span></div>


<div class="viewcode-block" id="apply_proofreading_filters_to_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.apply_proofreading_filters_to_neuron">[docs]</a><span class="k">def</span> <span class="nf">apply_proofreading_filters_to_neuron</span><span class="p">(</span>
    <span class="n">input_neuron</span><span class="p">,</span>
    <span class="n">filter_list</span><span class="p">,</span>
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_outline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_red_blue_splits</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_split_locations</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">save_intermediate_neuron_objs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">combine_path_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To apply a list of filters to a neuron</span>
<span class="sd">    and collect all of the information on what was filtered </span>
<span class="sd">    away and the remaining neuron after</span>

<span class="sd">    - Be able to set certain run arguments that could</span>
<span class="sd">    help with plotting along the way </span>


<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Recieve the input neuron</span>

<span class="sd">    For each filter:</span>
<span class="sd">    a) print the name of the function, and the arguments to go along</span>
<span class="sd">    b) Run the function with the function argument and run arguments</span>
<span class="sd">    c) print the time it takes</span>
<span class="sd">    d) Print the erro information</span>
<span class="sd">    e) Store the following information</span>
<span class="sd">    - neuron</span>
<span class="sd">    - error skeleton</span>
<span class="sd">    - error area</span>
<span class="sd">    time</span>

<span class="sd">    f) Make the output neuron as the new input neuron</span>

<span class="sd">    # -- Adding Optional parameter that allows a filter to recover from an error gracefully -- #</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#print(f&quot;filter_list = \n{filter_list}&quot;)</span>

    <span class="n">output_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">total_apply_filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    

    <span class="k">for</span> <span class="n">z</span><span class="p">,</span><span class="n">current_filter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filter_list</span><span class="p">):</span>
        <span class="c1">#print(f&quot;input_neuron.description = {input_neuron.description}&quot;)</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">current_filter</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">filter_name</span> <span class="o">=</span> <span class="n">current_filter</span><span class="p">[</span><span class="s2">&quot;filter_name&quot;</span><span class="p">]</span>
            <span class="n">filter_function</span> <span class="o">=</span> <span class="n">current_filter</span><span class="p">[</span><span class="s2">&quot;filter_function&quot;</span><span class="p">]</span>
            <span class="n">filter_kwargs</span> <span class="o">=</span> <span class="n">current_filter</span><span class="p">[</span><span class="s2">&quot;filter_kwargs&quot;</span><span class="p">]</span>
            <span class="n">filter_catch_error</span> <span class="o">=</span> <span class="n">current_filter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;catch_error&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">gu</span><span class="o">.</span><span class="n">is_function</span><span class="p">(</span><span class="n">current_filter</span><span class="p">):</span>
            <span class="n">filter_function</span> <span class="o">=</span> <span class="n">current_filter</span>
            <span class="n">filter_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">current_filter</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="n">filter_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">filter_catch_error</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown type for filter: </span><span class="si">{</span><span class="n">current_filter</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">current_filter</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on filter </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;function = </span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;function __name__ = </span><span class="si">{</span><span class="n">filter_function</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;function arguments = </span><span class="si">{</span><span class="n">filter_kwargs</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------------- Running Filter ------------------&quot;</span><span class="p">)</span>
            
        <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
<span class="c1">#         try:</span>
        <span class="n">output_res</span><span class="o">=</span> <span class="n">filter_function</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">,</span>
            <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
            <span class="n">plot_limb_branch_filter_away</span> <span class="o">=</span> <span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
            <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                                            <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                            <span class="n">return_limb_branch_before_filter_away</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">filter_kwargs</span>
                                           <span class="p">)</span>
    
    
    
        <span class="n">limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">red_blue_suggestions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">created_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">split_locations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">split_locations_before</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="p">(</span><span class="n">output_neuron</span><span class="p">,</span>
                 <span class="n">total_area_current</span><span class="p">,</span>
                 <span class="n">total_sk_distance_current</span><span class="p">,</span>
                <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                <span class="n">limb_branch_dict_to_cancel_before_filt</span><span class="p">)</span>  <span class="o">=</span> <span class="n">output_res</span>

                <span class="n">created_edges</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">output_neuron</span><span class="p">,</span>
                 <span class="n">total_area_current</span><span class="p">,</span>
                 <span class="n">total_sk_distance_current</span><span class="p">,</span>
                <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_to_cancel_before_filt</span><span class="o">.</span>
                <span class="n">created_edges</span><span class="p">)</span>  <span class="o">=</span> <span class="n">output_res</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            -- 5/10 Want to generate the red and blue points as well</span>


<span class="sd">            &quot;&quot;&quot;</span>
<span class="c1">#             red_blue_suggestions = pru.extract_blue_red_points_from_limb_branch_dict_to_cancel(</span>
<span class="c1">#                 input_neuron,</span>
<span class="c1">#                 limb_branch_dict_to_cancel)</span>

            <span class="k">if</span> <span class="n">return_red_blue_splits</span><span class="p">:</span>
                <span class="n">red_blue_suggestions</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">limb_branch_dict_to_cancel_to_red_blue_groups</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">input_neuron</span><span class="p">,</span>
                                                <span class="n">limb_branch_dict_to_cancel</span><span class="o">=</span><span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                                                            <span class="n">created_edges</span> <span class="o">=</span> <span class="n">created_edges</span><span class="p">,</span>
                                                            <span class="n">plot_all_blue_red_groups</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                             <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_split_locations</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">limb_utils</span> <span class="k">as</span> <span class="n">lu</span>
                <span class="n">split_locations_before_filter</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">most_upstream_endpoints_of_limb_branch</span><span class="p">(</span>
                    <span class="n">input_neuron</span><span class="p">,</span>
                    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict_to_cancel_before_filt</span><span class="p">,</span>
                    <span class="n">group_by_conn_comp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="c1"># &quot;axon_on_dendrite&quot; in filter_name,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="p">)</span>
                <span class="n">split_locations</span><span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">most_upstream_endpoints_of_limb_branch</span><span class="p">(</span>
                    <span class="n">input_neuron</span><span class="p">,</span>
                    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                    <span class="n">group_by_conn_comp</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="p">)</span>
            
                
            

        <span class="k">else</span><span class="p">:</span>

            <span class="p">(</span><span class="n">output_neuron</span><span class="p">,</span>
             <span class="n">total_area_current</span><span class="p">,</span>
             <span class="n">total_sk_distance_current</span><span class="p">)</span> <span class="o">=</span> <span class="n">output_res</span>

            
                
<span class="c1">#         except Exception as e:</span>
<span class="c1">#             if not filter_catch_error:</span>
<span class="c1">#                 raise Exception(str(e))</span>
<span class="c1">#             else:</span>
<span class="c1">#                 print(f&quot;Becasue catch_error = {filter_catch_error}, Gracefullly recovering from error {str(e)}&quot;)</span>
                
<span class="c1">#                 output_neuron = input_neuron</span>
<span class="c1">#                 total_area_current = 0</span>
<span class="c1">#                 total_sk_distance_current = 0</span>
<span class="c1">#                 limb_branch_dict_to_cancel = {}</span>
<span class="c1">#                 red_blue_suggestions = {}</span>
            
        
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------------- FINISHED Running Filter ------------------</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">filter_time</span>

        <span class="c1">#c) print the time it takes</span>
        <span class="c1">#d) Print the erro information</span>
        <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> --Filter </span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2"> Results --&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time = </span><span class="si">{</span><span class="n">elapsed_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_area=</span><span class="si">{</span><span class="n">total_area_current</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_length=</span><span class="si">{</span><span class="n">total_sk_distance_current</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict_to_cancel = </span><span class="si">{</span><span class="n">limb_branch_dict_to_cancel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        e) Store the following information</span>
<span class="sd">        - neuron</span>
<span class="sd">        - error skeleton</span>
<span class="sd">        - error area</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">local_results</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_time&quot;</span><span class="p">:</span><span class="n">elapsed_time</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_error_area&quot;</span><span class="p">:</span><span class="n">total_area_current</span><span class="p">,</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_error_length&quot;</span><span class="p">:</span><span class="n">total_sk_distance_current</span><span class="p">}</span>
        
        <span class="k">if</span> <span class="n">combine_path_branches</span><span class="p">:</span>
            <span class="c1">#print(f&quot;\n\n\n***combining path branches****\n\n&quot;)</span>
            <span class="n">output_neuron</span> <span class="o">=</span> <span class="n">nsimp</span><span class="o">.</span><span class="n">combine_path_branches</span><span class="p">(</span>
                <span class="n">output_neuron</span><span class="p">,</span>
                <span class="n">plot_downstream_path_limb_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
        
        
        
        <span class="k">if</span> <span class="n">save_intermediate_neuron_objs</span><span class="p">:</span>
            <span class="n">local_results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_neuron&quot;</span><span class="p">:</span><span class="n">output_neuron</span><span class="p">,})</span>
            
        <span class="k">if</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">:</span>
            <span class="n">local_results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_limb_branch_dict_to_cancel&quot;</span><span class="p">:</span><span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_created_edges&quot;</span><span class="p">:</span><span class="n">created_edges</span><span class="p">,</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_red_blue_suggestions&quot;</span><span class="p">:</span><span class="n">red_blue_suggestions</span><span class="p">,</span>
                                 <span class="p">})</span>
        <span class="k">if</span> <span class="n">return_split_locations</span><span class="p">:</span>
            <span class="n">local_results</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_split_locations&quot;</span><span class="p">:</span><span class="n">split_locations</span><span class="p">,</span>
                                  <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2">_split_locations_before_filter&quot;</span><span class="p">:</span><span class="n">split_locations_before_filter</span>
                                 <span class="p">})</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> --Filter </span><span class="si">{</span><span class="n">filter_name</span><span class="si">}</span><span class="s2"> Results --&quot;</span><span class="p">)</span>
            <span class="c1">#print(f&quot;local_results = {local_results}&quot;)</span>

        <span class="n">output_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_results</span><span class="p">)</span>

        <span class="c1">#f) Make the output neuron as the new input neuron</span>
        <span class="n">input_neuron</span> <span class="o">=</span> <span class="n">output_neuron</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2"> ---- Total time for applying filter: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">total_apply_filter_time</span><span class="si">}</span><span class="s2"> -----&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_error_info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_neuron</span><span class="p">,</span><span class="n">output_info</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_neuron</span></div>
    
<div class="viewcode-block" id="get_exc_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_exc_filters">[docs]</a><span class="k">def</span> <span class="nf">get_exc_filters</span><span class="p">():</span>
    <span class="n">exc_axon_on_dendrite_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;axon_on_dendrite_merges&quot;</span><span class="p">,</span>
                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_axon_on_dendrite_merges_old</span><span class="p">,</span>
                                         <span class="nb">dict</span><span class="p">(</span><span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                              
                                        <span class="p">)</span>

    <span class="n">exc_low_branch_clusters_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_branch_clusters&quot;</span><span class="p">,</span>
                                            <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_branch_length_clusters</span><span class="p">,</span>
                                            <span class="nb">dict</span><span class="p">())</span>

    <span class="n">exc_dendrite_on_axon_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;dendrite_on_axon_merges&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_dendrite_on_axon_merges_old</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                                         <span class="p">)</span>
    <span class="n">exc_double_back_and_width_change_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_and_width_change&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_large_double_back_or_width_changes</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">perform_double_back_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">skip_double_back_errors_for_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                              <span class="c1">#double_back_threshold = 140,</span>
                                                               
                                                               <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
                                                               <span class="n">running_width_jump_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                               
                                                               
                                                               <span class="n">double_back_axon_like_threshold</span><span class="o">=</span><span class="mi">145</span><span class="p">,</span>
                                                               <span class="c1">#double_back_threshold = 115,</span>
                                                               <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
                                                              <span class="p">),</span>
                                                                   <span class="n">catch_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="p">)</span>
    <span class="n">exc_crossovers_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;crossovers&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_crossovers</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span>
                                                         <span class="p">)</span>
    
    <span class="n">exc_high_degree_coordinates_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_coordinates&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_coordinates</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                                                         <span class="p">)</span>

    
    <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">,</span>
                  <span class="n">exc_low_branch_clusters_filter</span><span class="p">,</span>
                  <span class="n">exc_dendrite_on_axon_merges_filter</span><span class="p">,</span>
                  <span class="n">exc_double_back_and_width_change_filter</span><span class="p">,</span>
                  <span class="n">exc_crossovers_filter</span><span class="p">,</span>
                  <span class="n">exc_high_degree_coordinates_filter</span><span class="p">,]</span>
    
    <span class="k">return</span> <span class="n">exc_filters</span></div>


<div class="viewcode-block" id="get_inh_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_inh_filters">[docs]</a><span class="k">def</span> <span class="nf">get_inh_filters</span><span class="p">():</span>
    <span class="n">inh_low_branch_clusters_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_branch_clusters&quot;</span><span class="p">,</span>
                                            <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_branch_length_clusters</span><span class="p">,</span>
                                            <span class="nb">dict</span><span class="p">())</span>
    <span class="c1"># --------- 2/16: No longer making the cross overs axon dependent ----------- #</span>
    <span class="n">inh_crossovers_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;crossovers&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_crossovers</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                              <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span>
                                                         <span class="p">)</span>

    <span class="n">inh_double_back_and_width_change_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_and_width_change&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_large_double_back_or_width_changes</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">perform_double_back_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">skip_double_back_errors_for_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                               
                                                               <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
                                                              <span class="n">running_width_jump_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                               
                                                               
                                                               <span class="n">double_back_axon_like_threshold</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
                                                               <span class="c1">#double_back_threshold = 115,</span>
                                                               <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">115</span><span class="p">,</span>
                                                              
                                                              <span class="p">),</span>
                                                                   <span class="n">catch_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="p">)</span>
    
    <span class="n">inh_high_degree_coordinates_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_coordinates&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_coordinates</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                                                         <span class="p">)</span>



    <span class="n">inh_filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">inh_low_branch_clusters_filter</span><span class="p">,</span>
                   <span class="n">inh_crossovers_filter</span><span class="p">,</span>
                   <span class="n">inh_double_back_and_width_change_filter</span><span class="p">,</span>
                   <span class="n">inh_high_degree_coordinates_filter</span><span class="p">,</span>
                  <span class="p">]</span>

    <span class="k">return</span> <span class="n">inh_filters</span></div>


<div class="viewcode-block" id="get_exc_filters_high_fidelity_axon_preprocessing_old"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_exc_filters_high_fidelity_axon_preprocessing_old">[docs]</a><span class="k">def</span> <span class="nf">get_exc_filters_high_fidelity_axon_preprocessing_old</span><span class="p">():</span>
    <span class="n">exc_dendrite_on_axon_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;dendrite_on_axon_merges&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_dendrite_on_axon_merges_old</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                                         <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">exc_dendrite_on_axon_merges_filter</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_exc_filters_high_fidelity_axon_postprocessing_old"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_exc_filters_high_fidelity_axon_postprocessing_old">[docs]</a><span class="k">def</span> <span class="nf">get_exc_filters_high_fidelity_axon_postprocessing_old</span><span class="p">():</span>
    <span class="n">exc_axon_on_dendrite_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;axon_on_dendrite_merges&quot;</span><span class="p">,</span>
                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_axon_on_dendrite_merges_old</span><span class="p">,</span>
                                         <span class="nb">dict</span><span class="p">(</span><span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                              
                                        <span class="p">)</span>

    <span class="n">exc_low_branch_clusters_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_branch_clusters&quot;</span><span class="p">,</span>
                                            <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_branch_length_clusters</span><span class="p">,</span>
                                            <span class="nb">dict</span><span class="p">())</span>

    <span class="n">exc_double_back_and_width_change_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_and_width_change&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_large_double_back_or_width_changes</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">perform_double_back_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">skip_double_back_errors_for_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                              <span class="c1">#double_back_threshold = 140,</span>
                                                               
                                                               <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
                                                               <span class="n">running_width_jump_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                                               
                                                               
                                                               <span class="n">double_back_axon_like_threshold</span><span class="o">=</span><span class="mi">145</span><span class="p">,</span>
                                                               <span class="c1">#double_back_threshold = 115,</span>
                                                               <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
                                                              <span class="p">),</span><span class="n">catch_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="p">)</span>
    <span class="n">exc_crossovers_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;crossovers&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_crossovers</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                              <span class="n">match_threshold</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                                                              <span class="n">require_two_pairs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                                                         <span class="p">)</span>
    
    <span class="n">exc_high_degree_coordinates_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_coordinates&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_coordinates</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                                                         <span class="p">)</span>
    
    
    <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">,</span>
                   <span class="n">exc_crossovers_filter</span><span class="p">,</span>
                  <span class="c1">#exc_low_branch_clusters_filter,</span>
                  <span class="n">exc_double_back_and_width_change_filter</span><span class="p">,</span>
                  <span class="n">exc_high_degree_coordinates_filter</span><span class="p">,]</span>
    
    <span class="k">return</span> <span class="n">exc_filters</span></div>


<div class="viewcode-block" id="proofread_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.proofread_neuron">[docs]</a><span class="k">def</span> <span class="nf">proofread_neuron</span><span class="p">(</span>
    
    <span class="n">input_neuron</span><span class="p">,</span>

    <span class="n">attempt_to_split_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_neuron_split_results</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">plot_neuron_before_filtering</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">plot_axon</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_axon_like</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># -- for the filtering loop</span>
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_final_filtered_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1"># -- for the output --</span>
    <span class="n">return_process_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose_outline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    
    <span class="c1">#will apply the high fidelity axon process on excitatory cells</span>
    <span class="n">high_fidelity_axon_on_excitatory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    
    <span class="c1"># --------- Arguments to make it a streamlined process  ----------- #</span>
    <span class="n">inh_exc_class</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">perform_axon_classification</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To apply all of the </span>
<span class="sd">    proofreading rules to a neuron (or a pre-split neuron)</span>
<span class="sd">    and to return the proofread neuron and all of the </span>
<span class="sd">    error information</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) If requested try and split the neuron</span>
<span class="sd">    2) Put the neuron(s) into a list</span>

<span class="sd">    For each neuron</span>
<span class="sd">    a) Check that there are not any error limbs or</span>
<span class="sd">       multiple somas </span>
<span class="sd">    b) Run the axon classification</span>
<span class="sd">    c) Run the excitatory and inhibitory classification (save results in dict)</span>
<span class="sd">    d) Based on cell type--&gt; get the filters going to use</span>
<span class="sd">    e) Apply the filters to the neuron --&gt; save the error information</span>

<span class="sd">    3) If not requested to split neuron, then just return the </span>
<span class="sd">    just the single neuron</span>



<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    pru.proofread_neuron(</span>
<span class="sd">    </span>
<span class="sd">    input_neuron = neuron_obj_original,</span>

<span class="sd">    attempt_to_split_neuron = True,</span>
<span class="sd">    plot_neuron_split_results = False,</span>

<span class="sd">    plot_neuron_before_filtering = False,</span>

<span class="sd">    plot_axon = False,</span>
<span class="sd">    plot_axon_like = False,</span>

<span class="sd">    # -- for the filtering loop</span>
<span class="sd">    plot_limb_branch_filter_with_disconnect_effect = True,</span>
<span class="sd">    plot_final_filtered_neuron = True,</span>

<span class="sd">    # -- for the output --</span>
<span class="sd">    return_process_info = True,</span>

<span class="sd">    debug_time = True,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    verbose_outline=True</span>

<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="n">neuron_obj_original</span> <span class="o">=</span> <span class="n">input_neuron</span>
    <span class="n">proof_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># -------------------</span>

    <span class="c1">#1) If requested try and split the neuron</span>
    <span class="k">if</span> <span class="n">attempt_to_split_neuron</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---- Part A: Attempting to split neuron --------&quot;</span><span class="p">)</span>


        <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="n">split_results</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">multi_soma_split_suggestions</span><span class="p">(</span><span class="n">neuron_obj_original</span><span class="p">,</span>
                                                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_neuron_split_results</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_split_suggestions_per_limb</span><span class="p">(</span><span class="n">neuron_obj_original</span><span class="p">,</span>
                                            <span class="n">split_results</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="p">(</span><span class="n">neuron_list</span><span class="p">,</span>
        <span class="n">neuron_list_errored_limbs_area</span><span class="p">,</span>
         <span class="n">neuron_list_errored_limbs_skeletal_length</span><span class="p">,</span>
        <span class="n">neuron_list_n_multi_soma_errors</span><span class="p">,</span>
        <span class="n">neuron_list_n_same_soma_errors</span><span class="p">)</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_neuron</span><span class="p">(</span><span class="n">neuron_obj_original</span><span class="p">,</span>
                        <span class="n">limb_results</span><span class="o">=</span><span class="n">split_results</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span>
                                            <span class="p">)</span> 

        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for Split Neuron = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">filter_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">split_error_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">errored_limbs_area</span><span class="o">=</span><span class="n">neuron_list_errored_limbs_area</span><span class="p">,</span>
                               <span class="n">errored_limbs_skeletal_length</span><span class="o">=</span><span class="n">neuron_list_errored_limbs_skeletal_length</span><span class="p">,</span>
                                <span class="n">n_multi_soma_errors</span><span class="o">=</span><span class="n">neuron_list_n_multi_soma_errors</span><span class="p">,</span>
                                <span class="n">n_same_soma_errors</span> <span class="o">=</span> <span class="n">neuron_list_n_same_soma_errors</span>

                               <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; # of neurons = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_list_errored_limbs_area = </span><span class="si">{</span><span class="n">neuron_list_errored_limbs_area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_list_errored_limbs_skeletal_length = </span><span class="si">{</span><span class="n">neuron_list_errored_limbs_skeletal_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_list_n_multi_soma_errors = </span><span class="si">{</span><span class="n">neuron_list_n_multi_soma_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_list_n_same_soma_errors = </span><span class="si">{</span><span class="n">neuron_list_n_same_soma_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">verbose_outline</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; # of neurons found after split= </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---- Part A: NOT Attempting to split neuron --------&quot;</span><span class="p">)</span>

        <span class="n">split_error_info</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;errored_limbs_area&#39;</span><span class="p">:</span> <span class="p">[[]],</span>
         <span class="s1">&#39;errored_limbs_skeletal_length&#39;</span><span class="p">:</span> <span class="p">[[]],</span>
         <span class="s1">&#39;n_multi_soma_errors&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="mi">0</span><span class="p">],</span>
         <span class="s1">&#39;n_same_soma_errors&#39;</span><span class="p">:</span> <span class="p">[</span> <span class="mi">0</span><span class="p">]}</span>

        <span class="n">neuron_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_neuron</span><span class="p">]</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each neuron</span>
<span class="sd">    a) Check that there are not any error limbs or</span>
<span class="sd">       multiple somas </span>
<span class="sd">    b) Run the axon classification</span>
<span class="sd">    c) Run the excitatory and inhibitory classification (save results in dict)</span>
<span class="sd">    d) Based on cell type--&gt; get the filters going to use</span>
<span class="sd">    e) Apply the filters to the neuron --&gt; save the error information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neuron_list_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n_idx</span><span class="p">,</span><span class="n">neuron_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_list</span><span class="p">):</span>

        <span class="n">local_split_error_info</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span><span class="p">[</span><span class="n">n_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">split_error_info</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Working on Neuron </span><span class="si">{</span><span class="n">n_idx</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>

        <span class="c1">#a) Check that there are not any error limbs or multiple somas </span>
        <span class="k">if</span> <span class="n">plot_neuron_before_filtering</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_lite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

        <span class="c1">#b) Run the axon classification</span>

        <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_somas</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of Somas was greater than 1: </span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_somas</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_error_limbs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of Error Limbs was greater than 1: </span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_error_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>




        <span class="c1">#b) Run the axon classification</span>
        <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ------ Part B: Axon Classification ---- </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">perform_axon_classification</span><span class="p">:</span>
            <span class="n">axon_limb_branch_dict</span><span class="p">,</span><span class="n">axon_angles</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                    <span class="n">return_error_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                    <span class="n">plot_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                        <span class="n">best_axon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                    <span class="n">label_axon_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                    <span class="n">return_axon_angles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axon Classification = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">filter_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping Axon Classification&quot;</span><span class="p">)</span>
            <span class="n">axon_limb_branch_dict</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
            <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
            <span class="n">axon_angles</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_angles</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>



        <span class="k">if</span> <span class="n">plot_axon</span><span class="p">:</span>
            <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                             <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">axon_limb_branch_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_axon_like</span><span class="p">:</span>
            <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                             <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">])</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">axon_limb_branch_dict</span><span class="p">)</span>





        <span class="c1">#c) Run the excitatory and inhibitory classification (save results in dict)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ------ Part C: Inhibitory Excitatory Classification ---- </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inh_exc_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">inh_exc_class</span><span class="p">,</span>
                         <span class="n">spine_category</span><span class="p">,</span>
                         <span class="n">axon_angles</span><span class="p">,</span>
                         <span class="n">n_axons</span><span class="p">,</span>
                         <span class="n">n_apicals</span><span class="p">,</span>
                         <span class="n">neuron_spine_density</span><span class="p">,</span>
                         <span class="n">n_branches_processed</span><span class="p">,</span>
                         <span class="n">skeletal_length_processed</span><span class="p">,</span>
                         <span class="n">n_branches_in_search_radius</span><span class="p">,</span>
                         <span class="n">skeletal_length_in_search_radius</span>
                         <span class="p">)</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">inhibitory_excitatory_classifier</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                            <span class="n">return_spine_classification</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                            <span class="n">return_axon_angles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                             <span class="n">return_n_axons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                             <span class="n">return_n_apicals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                             <span class="n">return_spine_statistics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">axon_limb_branch_dict_precomputed</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                                            <span class="n">axon_angles_precomputed</span><span class="o">=</span><span class="n">axon_angles</span><span class="p">,</span>
                                                                 <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="c1">#4) Get the maximum of the axon angles:</span>
            <span class="n">all_axon_angles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">limb_data</span> <span class="ow">in</span> <span class="n">axon_angles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">candidate_idx</span><span class="p">,</span><span class="n">cand_angle</span> <span class="ow">in</span> <span class="n">limb_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">all_axon_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand_angle</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_angles</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">axon_angle_maximum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_axon_angles</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axon_angle_maximum</span> <span class="o">=</span> <span class="mi">0</span>



            <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inhibitory Excitatory Classification = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">filter_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">filter_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> -- Cell Type Classification Results --&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inh_exc_class=</span><span class="si">{</span><span class="n">inh_exc_class</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_category=</span><span class="si">{</span><span class="n">spine_category</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_angles=</span><span class="si">{</span><span class="n">axon_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_axons=</span><span class="si">{</span><span class="n">n_axons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_apicals=</span><span class="si">{</span><span class="n">n_apicals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_spine_density=</span><span class="si">{</span><span class="n">neuron_spine_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_branches_processed=</span><span class="si">{</span><span class="n">n_branches_processed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal_length_processed=</span><span class="si">{</span><span class="n">skeletal_length_processed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_branches_in_search_radius=</span><span class="si">{</span><span class="n">n_branches_in_search_radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal_length_in_search_radius=</span><span class="si">{</span><span class="n">skeletal_length_in_search_radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose_outline</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">verbose</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cell type = </span><span class="si">{</span><span class="n">inh_exc_class</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">cell_type_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                        <span class="n">inh_exc_class</span><span class="o">=</span><span class="n">inh_exc_class</span><span class="p">,</span>
                         <span class="n">spine_category</span><span class="o">=</span><span class="n">spine_category</span><span class="p">,</span>
                         <span class="n">axon_angles</span><span class="o">=</span><span class="n">axon_angles</span><span class="p">,</span>
                        <span class="n">axon_angle_maximum</span> <span class="o">=</span> <span class="n">axon_angle_maximum</span><span class="p">,</span>
                         <span class="n">n_axons</span><span class="o">=</span><span class="n">n_axons</span><span class="p">,</span>
                         <span class="n">n_apicals</span><span class="o">=</span><span class="n">n_apicals</span><span class="p">,</span>
                         <span class="n">neuron_spine_density</span><span class="o">=</span><span class="n">neuron_spine_density</span><span class="p">,</span>
                         <span class="n">n_branches_processed</span><span class="o">=</span><span class="n">neuron_spine_density</span><span class="p">,</span>
                         <span class="n">skeletal_length_processed</span><span class="o">=</span><span class="n">skeletal_length_processed</span><span class="p">,</span>
                         <span class="n">n_branches_in_search_radius</span><span class="o">=</span><span class="n">n_branches_in_search_radius</span><span class="p">,</span>
                         <span class="n">skeletal_length_in_search_radius</span><span class="o">=</span><span class="n">skeletal_length_in_search_radius</span><span class="p">,</span>

            <span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping the Cell Type classification because predetermined as </span><span class="si">{</span><span class="n">inh_exc_class</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">cell_type_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


        <span class="c1">#d) Based on cell type--&gt; get the filters going to use</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ------ Part D: Neuron Filtering ---- </span><span class="se">\n\n</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="n">o_neuron</span><span class="p">,</span><span class="n">filtering_info</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">proofread_neuron_class_predetermined</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">inh_exc_class</span> <span class="o">=</span> <span class="n">inh_exc_class</span><span class="p">,</span>
            <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="n">verbose_outline</span> <span class="o">=</span> <span class="n">verbose_outline</span><span class="p">,</span>
            <span class="n">high_fidelity_axon_on_excitatory</span> <span class="o">=</span> <span class="n">high_fidelity_axon_on_excitatory</span><span class="p">,</span>
            <span class="n">plot_final_filtered_neuron</span> <span class="o">=</span> <span class="n">plot_final_filtered_neuron</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ------ Part E: Save Neuron  ---- </span><span class="se">\n\n</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="n">neuron_list_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="o">=</span><span class="n">o_neuron</span><span class="p">,</span>
                                    <span class="n">split_info</span><span class="o">=</span><span class="n">local_split_error_info</span><span class="p">,</span>
                                    <span class="n">cell_type_info</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">,</span>
                                    <span class="n">filtering_info</span> <span class="o">=</span> <span class="n">filtering_info</span><span class="p">))</span>
        
        


        
    <span class="k">if</span> <span class="n">verbose_outline</span> <span class="ow">or</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Total time for Neuron Proofreading: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">proof_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">attempt_to_split_neuron</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_process_info</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">neuron_list_results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span>  <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;filtered_neuron&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neuron_list_results</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_process_info</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">neuron_list_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;filtered_neuron&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">return_value</span></div>


<span class="c1"># --------------- Proofreading The Synapses ------------------------- #</span>

<div class="viewcode-block" id="synapse_filtering"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.synapse_filtering">[docs]</a><span class="k">def</span> <span class="nf">synapse_filtering</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">split_index</span><span class="p">,</span>
                <span class="n">nucleus_id</span><span class="p">,</span>
                <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">return_synapse_filter_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">return_synapse_center_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">return_error_synapse_ids</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">return_valid_synapse_centers</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">return_errored_synapses_ids_non_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">return_error_table_entries</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                
                <span class="n">mapping_threshold</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                <span class="n">plot_synapses</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">original_mesh_method</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">original_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">valid_faces_on_original_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">axon_faces_on_original_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">apply_non_axon_presyn_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      
                <span class="c1"># if already have the synapse data (for instance we use when validating)</span>
                <span class="c1"># NEEDS TO BE DICTIONARY</span>
                <span class="n">precomputed_synapse_dict</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Psuedocode:</span>
<span class="sd">    1) Get the synapses that are presyn or postsyn to segment id (but not both)</span>
<span class="sd">    2) Build a KDTree of the mesh final</span>

<span class="sd">    ------ For presyn and postsyn (as type): -------------------</span>
<span class="sd">    2) Restrict the table to when segment id is that type</span>
<span class="sd">    3) Fetch the synapses and scale the centers</span>
<span class="sd">    4) Find the distance of synapses to mesh</span>
<span class="sd">    5) If within distance threshold then consider valid</span>
<span class="sd">    6) For synapses to keep create a list of dictionaries saving off:</span>
<span class="sd">    synaps_id</span>
<span class="sd">    type (presyn or postsyn)</span>
<span class="sd">    segment_id</span>
<span class="sd">    split_id</span>
<span class="sd">    nucleus_id</span>
<span class="sd">    7) Save of the stats on how many synapses of that type you started with and how many you finished with</span>
<span class="sd">    8) Save of synapse centers into valid and error groups</span>


<span class="sd">    ------ End Loop -------------------</span>
<span class="sd">    9) Compiles all stats on erroring</span>
<span class="sd">    10) Compile all synapse centers</span>

<span class="sd">    Return the dictionaries to write and also:</span>
<span class="sd">    - stats</span>
<span class="sd">    - synapse centers</span>

<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">if</span> <span class="n">segment_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segment_id</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span>
        
        
    <span class="c1"># --------- Check Axon Classification if requested ---------- #</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">axon_faces_on_original_mesh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">apply_non_axon_presyn_errors</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;axon_faces_on_original_mesh was None&quot;</span><span class="p">)</span>
    
        
    <span class="k">if</span> <span class="n">axon_faces_on_original_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_faces_on_original_mesh</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">axon_faces_on_original_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axon_faces_on_original_mesh</span><span class="p">)</span>
    
    <span class="c1"># ----------------------- </span>
    <span class="c1">#1) Get the synapses that are presyn or postsyn to segment id (but not both)</span>

    <span class="k">if</span> <span class="n">precomputed_synapse_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">beginning_direct_connections</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">segment_id_to_synapse_table</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span>
                                                                         <span class="n">validation</span><span class="o">=</span><span class="n">validation</span><span class="p">)</span>
    <span class="c1">#2) Build a KDTree of the mesh final</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">original_mesh_method</span><span class="p">:</span>
        <span class="n">neuron_kd</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>


    <span class="n">data_to_write</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data_to_write_errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">synapse_stats</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">synapse_center_coordinates</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">total_error_synapse_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;presyn&quot;</span><span class="p">,</span><span class="s2">&quot;postsyn&quot;</span><span class="p">]:</span>
        
        
        <span class="c1">#3) Fetch the synapses and scale the centers</span>
        <span class="k">if</span> <span class="n">precomputed_synapse_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">table_for_type</span> <span class="o">=</span> <span class="n">beginning_direct_connections</span> <span class="o">&amp;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">synapse_ids</span><span class="p">,</span> <span class="n">centroid_xs</span><span class="p">,</span> <span class="n">centroid_ys</span><span class="p">,</span> <span class="n">centroid_zs</span> <span class="o">=</span> <span class="n">table_for_type</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s2">&quot;synapse_id&quot;</span><span class="p">,</span><span class="s2">&quot;synapse_x&quot;</span><span class="p">,</span><span class="s2">&quot;synapse_y&quot;</span><span class="p">,</span><span class="s2">&quot;synapse_z&quot;</span><span class="p">)</span>
            <span class="n">synapse_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">centroid_xs</span><span class="p">,</span><span class="n">centroid_ys</span><span class="p">,</span><span class="n">centroid_zs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">synapse_centers_scaled</span> <span class="o">=</span> <span class="n">synapse_centers</span><span class="o">*</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">synapse_ids</span> <span class="o">=</span> <span class="n">precomputed_synapse_dict</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">][</span><span class="s2">&quot;synapse_ids&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;synapse_ceneters_scaled&quot;</span> <span class="ow">in</span> <span class="n">precomputed_synapse_dict</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">synapse_ceneters_scaled</span> <span class="o">=</span> <span class="n">precomputed_synapse_dict</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">][</span><span class="s2">&quot;synapse_ceneters_scaled&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">synapse_centers</span> <span class="o">=</span> <span class="n">precomputed_synapse_dict</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">][</span><span class="s2">&quot;synapse_centers&quot;</span><span class="p">]</span>
                <span class="n">synapse_centers_scaled</span> <span class="o">=</span> <span class="n">synapse_centers</span><span class="o">*</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span>


        <span class="c1">#4) Find the distance of synapses to mesh</span>
        
        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">original_mesh_method</span><span class="p">:</span>
            <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">neuron_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">synapse_centers_scaled</span><span class="p">)</span>
            
            
            <span class="n">errored_synapses_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dist</span><span class="o">&gt;</span><span class="n">mapping_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">valid_synapses_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_centers_scaled</span><span class="p">)),</span><span class="n">errored_synapses_idx</span><span class="p">)</span>
            <span class="n">error_presyn_dendrites_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode:</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">neuron_mesh_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">))</span>
            <span class="n">neuron_mesh_labels_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">neuron_mesh_labels</span><span class="p">)</span>
            <span class="n">neuron_mesh_labels</span><span class="p">[</span><span class="n">valid_faces_on_original_mesh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            
            
            <span class="n">dist</span><span class="p">,</span><span class="n">closest_face</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">synapse_centers_scaled</span><span class="p">)</span>
            
            <span class="n">closest_face_labels</span> <span class="o">=</span> <span class="n">neuron_mesh_labels</span><span class="p">[</span><span class="n">closest_face</span><span class="p">]</span>
            
            <span class="n">errored_synapses_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">dist</span><span class="o">&gt;</span><span class="n">mapping_threshold</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">closest_face_labels</span><span class="o">==</span><span class="mi">0</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">            </span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;  2/15: Adding the parts that will error out synapses that are presyn</span>
<span class="sd">            but are not the axon</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
        
            <span class="k">if</span> <span class="n">apply_non_axon_presyn_errors</span> <span class="ow">and</span> <span class="n">synapse_type</span> <span class="o">==</span> <span class="s2">&quot;presyn&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Apply the presyn non_error&quot;</span><span class="p">)</span>
                <span class="n">axon_faces_on_original_mesh</span> <span class="o">=</span> <span class="n">axon_faces_on_original_mesh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
                <span class="n">neuron_mesh_labels_original</span><span class="p">[</span><span class="n">axon_faces_on_original_mesh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">closest_face_labels_axon</span> <span class="o">=</span> <span class="n">neuron_mesh_labels_original</span><span class="p">[</span><span class="n">closest_face</span><span class="p">]</span>
                <span class="n">error_presyn_dendrites_idx_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">closest_face_labels_axon</span><span class="o">!=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">error_presyn_dendrites_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">error_presyn_dendrites_idx_pre</span><span class="p">,</span><span class="n">errored_synapses_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
                
                <span class="n">errored_synapses_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">errored_synapses_idx</span><span class="p">,</span><span class="n">error_presyn_dendrites_idx</span><span class="p">])</span>
                <span class="n">valid_synapses_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_centers_scaled</span><span class="p">)),</span><span class="n">errored_synapses_idx</span><span class="p">)</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_synapses_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_centers_scaled</span><span class="p">)),</span><span class="n">errored_synapses_idx</span><span class="p">)</span>
                <span class="n">error_presyn_dendrites_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
                
                
            

        <span class="n">n_errored_synapses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">errored_synapses_idx</span><span class="p">)</span>
        <span class="n">n_valid_synapses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_synapses_idx</span><span class="p">)</span>
        <span class="n">n_error_presyn_non_axon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_presyn_dendrites_idx</span><span class="p">)</span>
        <span class="n">total_synapses</span> <span class="o">=</span> <span class="n">n_errored_synapses</span> <span class="o">+</span> <span class="n">n_valid_synapses</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">: # valid synapses = </span><span class="si">{</span><span class="n">n_valid_synapses</span><span class="si">}</span><span class="s2">, # error synapses  = </span><span class="si">{</span><span class="n">n_errored_synapses</span><span class="si">}</span><span class="s2">, # error presyns = </span><span class="si">{</span><span class="n">n_error_presyn_non_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        6) For synapses to keep create a list of dictionaries saving off:</span>
<span class="sd">        synaps_id</span>
<span class="sd">        type (presyn or postsyn)</span>
<span class="sd">        segment_id</span>
<span class="sd">        split_id</span>
<span class="sd">        nucleus_id</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">errored_synapses</span> <span class="o">=</span> <span class="n">synapse_ids</span><span class="p">[</span><span class="n">errored_synapses_idx</span><span class="p">]</span>
        <span class="n">errored_synapses_non_axons</span> <span class="o">=</span> <span class="n">synapse_ids</span><span class="p">[</span><span class="n">error_presyn_dendrites_idx</span><span class="p">]</span>
        <span class="n">non_errored_synapses</span> <span class="o">=</span> <span class="n">synapse_ids</span><span class="p">[</span><span class="n">valid_synapses_idx</span><span class="p">]</span>
        <span class="n">val_syn_centers</span> <span class="o">=</span> <span class="n">synapse_centers_scaled</span><span class="p">[</span><span class="n">valid_synapses_idx</span><span class="p">]</span>
        
        <span class="c1">#print(f&quot;errored_synapses_non_axons = {errored_synapses_non_axons}&quot;)</span>

        
        <span class="n">total_error_synapse_ids</span><span class="p">[</span><span class="n">synapse_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">errored_synapses</span>
        
        
        <span class="k">if</span> <span class="n">return_valid_synapse_centers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing the distance to soma for the synapses&quot;</span><span class="p">)</span>
                
            <span class="n">syn_dist</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">synapse_skeletal_distances_to_soma</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                               <span class="n">synapse_coordinates</span><span class="o">=</span><span class="n">val_syn_centers</span><span class="p">,</span>
                                               <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="p">,</span>
                                               <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">original_mesh_kdtree</span><span class="p">,</span>
                                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

                                              <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syn_dist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">non_errored_synapses</span><span class="p">)</span>
            <span class="n">syn_dist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">non_errored_synapses</span><span class="p">)</span>

        <span class="n">local_data_to_write</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">synapse_id</span><span class="o">=</span><span class="n">syn</span><span class="p">,</span>
                              <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                              <span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">nucleus_id</span><span class="p">,</span>
                              <span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span><span class="p">,</span>
                              <span class="n">split_index</span> <span class="o">=</span> <span class="n">split_index</span><span class="p">,</span>
                            <span class="n">skeletal_distance_to_soma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">syn_dist</span><span class="p">[</span><span class="n">syn_i</span><span class="p">],</span><span class="mi">2</span><span class="p">),)</span>
                               
                               <span class="k">for</span> <span class="n">syn_i</span><span class="p">,</span><span class="n">syn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">non_errored_synapses</span><span class="p">)]</span>
        
        
        
        <span class="n">data_to_write</span> <span class="o">+=</span> <span class="n">local_data_to_write</span>
        
        <span class="k">if</span> <span class="n">return_error_table_entries</span><span class="p">:</span> 
            <span class="n">total_err_for_table</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">errored_synapses</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">errored_synapses_non_axons</span><span class="p">)</span>
            <span class="c1">#print(f&quot;total_err_for_table = {total_err_for_table}&quot;)</span>
            <span class="n">local_data_to_write_errors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">synapse_id</span><span class="o">=</span><span class="n">syn</span><span class="p">,</span>
                              <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                              <span class="n">nucleus_id</span> <span class="o">=</span> <span class="n">nucleus_id</span><span class="p">,</span>
                              <span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span><span class="p">,</span>
                              <span class="n">split_index</span> <span class="o">=</span> <span class="n">split_index</span><span class="p">,</span>
                            <span class="n">skeletal_distance_to_soma</span><span class="o">=-</span><span class="mi">1</span><span class="p">,)</span>
                            <span class="k">for</span> <span class="n">syn_i</span><span class="p">,</span><span class="n">syn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">errored_synapses</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">errored_synapses_non_axons</span><span class="p">))]</span>
            <span class="c1">#print(f&quot;local_data_to_write_errors = {local_data_to_write_errors}&quot;)</span>
        
            <span class="n">data_to_write_errors</span> <span class="o">+=</span> <span class="n">local_data_to_write_errors</span>
            


        <span class="c1">#7) Save of the stats on how many synapses of that type you started with and how many you finished with</span>
        <span class="n">local_synapse_stats</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;n_valid_syn_</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">n_valid_synapses</span><span class="p">,</span>
                               <span class="sa">f</span><span class="s2">&quot;n_errored_syn_</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">n_errored_synapses</span><span class="p">,</span>
                              <span class="p">}</span>
        <span class="k">if</span> <span class="n">synapse_type</span> <span class="o">==</span> <span class="s2">&quot;presyn&quot;</span><span class="p">:</span>
            <span class="n">local_synapse_stats</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;n_errored_syn_presyn_non_axon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_error_presyn_non_axon</span>
            <span class="k">if</span> <span class="n">return_errored_synapses_ids_non_axons</span><span class="p">:</span>
                <span class="n">synapse_stats</span><span class="p">[</span><span class="s2">&quot;presyn_error_syn_non_axon_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">errored_synapses_non_axons</span>
        
        <span class="n">synapse_stats</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_synapse_stats</span><span class="p">)</span>

        <span class="c1">#8) Save of synapse centers into valid and error groups</span>
        <span class="n">local_synapse_centers</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;valid_syn_centers_</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">synapse_centers_scaled</span><span class="p">[</span><span class="n">valid_synapses_idx</span><span class="p">],</span>
                               <span class="sa">f</span><span class="s2">&quot;errored_syn_centers_</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">synapse_centers_scaled</span><span class="p">[</span><span class="n">errored_synapses_idx</span><span class="p">],</span>
                              <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">synapse_type</span> <span class="o">==</span> <span class="s2">&quot;presyn&quot;</span><span class="p">:</span>
            <span class="n">local_synapse_centers</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;errored_syn_centers_presyn_non_axon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synapse_centers_scaled</span><span class="p">[</span><span class="n">error_presyn_dendrites_idx</span><span class="p">]</span>
        
        <span class="n">synapse_center_coordinates</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_synapse_centers</span><span class="p">)</span>
        
    

    <span class="k">if</span> <span class="n">plot_synapses</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Displaying the Synapse Classifications&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_valid_error_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">synapse_center_coordinates</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">return_synapse_filter_info</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_synapse_center_data</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_error_synapse_ids</span><span class="p">)</span>
        <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_error_table_entries</span><span class="p">)</span>
       <span class="p">):</span>
        <span class="k">return</span> <span class="n">data_to_write</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_to_write</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">return_synapse_filter_info</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapse_stats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_synapse_center_data</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapse_center_coordinates</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_error_synapse_ids</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_error_synapse_ids</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_error_table_entries</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_to_write_errors</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_value</span></div>



<div class="viewcode-block" id="calculate_error_rate"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.calculate_error_rate">[docs]</a><span class="k">def</span> <span class="nf">calculate_error_rate</span><span class="p">(</span><span class="n">total_error_synapse_ids_list</span><span class="p">,</span>
                        <span class="n">synapse_stats_list</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates all of the synapse erroring stats</span>
<span class="sd">    for the neuron after all the runs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">all_presyn_errors</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersect1d_multi_list</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;presyn&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_error_synapse_ids_list</span><span class="p">])</span>
    <span class="n">all_postsyn_errors</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">intersect1d_multi_list</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;postsyn&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_error_synapse_ids_list</span><span class="p">])</span>

    <span class="n">n_presyn_error_syn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_presyn_errors</span><span class="p">)</span>
    <span class="n">n_postsyn_error_syn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_postsyn_errors</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_presyn_error_syn = </span><span class="si">{</span><span class="n">n_presyn_error_syn</span><span class="si">}</span><span class="s2">, n_postsyn_error_syn = </span><span class="si">{</span><span class="n">n_postsyn_error_syn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="n">curr_split_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total_presyns</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_stats_list</span><span class="p">[</span><span class="n">curr_split_idx</span><span class="p">][</span><span class="s2">&quot;n_valid_syn_presyn&quot;</span><span class="p">]</span> <span class="o">+</span>
                     <span class="n">synapse_stats_list</span><span class="p">[</span><span class="n">curr_split_idx</span><span class="p">][</span><span class="s2">&quot;n_errored_syn_presyn&quot;</span><span class="p">])</span>

    <span class="n">total_postsyns</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_stats_list</span><span class="p">[</span><span class="n">curr_split_idx</span><span class="p">][</span><span class="s2">&quot;n_valid_syn_postsyn&quot;</span><span class="p">]</span> <span class="o">+</span>
                     <span class="n">synapse_stats_list</span><span class="p">[</span><span class="n">curr_split_idx</span><span class="p">][</span><span class="s2">&quot;n_errored_syn_postsyn&quot;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_presyns = </span><span class="si">{</span><span class="n">total_presyns</span><span class="si">}</span><span class="s2">, total_postsyns = </span><span class="si">{</span><span class="n">total_postsyns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>





    <span class="c1"># finding the total number of presyns and postsyns</span>
    <span class="k">if</span> <span class="n">total_presyns</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">perc_error_presyn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n_presyn_error_syn</span><span class="o">/</span><span class="n">total_presyns</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perc_error_presyn</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">total_postsyns</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">perc_error_postsyn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">n_postsyn_error_syn</span><span class="o">/</span><span class="n">total_postsyns</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perc_error_postsyn</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_error_presyn = </span><span class="si">{</span><span class="n">perc_error_presyn</span><span class="si">}</span><span class="s2">, perc_error_postsyn = </span><span class="si">{</span><span class="n">perc_error_postsyn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>




    <span class="n">total_synapses</span> <span class="o">=</span> <span class="n">total_presyns</span> <span class="o">+</span> <span class="n">total_postsyns</span>
    <span class="n">total_error_synapses</span> <span class="o">=</span> <span class="n">n_presyn_error_syn</span> <span class="o">+</span> <span class="n">n_postsyn_error_syn</span>


    <span class="k">if</span> <span class="n">total_synapses</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">overall_percent_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">total_error_synapses</span><span class="o">/</span><span class="n">total_synapses</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overall_percent_error</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_error_synapses = </span><span class="si">{</span><span class="n">total_error_synapses</span><span class="si">}</span><span class="s2">, total_synapses = </span><span class="si">{</span><span class="n">total_synapses</span><span class="si">}</span><span class="s2">&quot;</span>
         <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">overall_percent_error= </span><span class="si">{</span><span class="n">overall_percent_error</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>




    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">n_presyn_error_syn</span><span class="o">=</span><span class="n">n_presyn_error_syn</span><span class="p">,</span>
                       <span class="n">n_postsyn_error_syn</span><span class="o">=</span><span class="n">n_postsyn_error_syn</span><span class="p">,</span>
                       <span class="n">total_error_synapses</span><span class="o">=</span><span class="n">total_error_synapses</span><span class="p">,</span>

                       <span class="n">total_presyns</span><span class="o">=</span><span class="n">total_presyns</span><span class="p">,</span>
                       <span class="n">total_postsyns</span><span class="o">=</span><span class="n">total_postsyns</span><span class="p">,</span>
                       <span class="n">total_synapses</span><span class="o">=</span><span class="n">total_synapses</span><span class="p">,</span>

                       <span class="n">perc_error_presyn</span><span class="o">=</span><span class="n">perc_error_presyn</span><span class="p">,</span>
                       <span class="n">perc_error_postsyn</span><span class="o">=</span><span class="n">perc_error_postsyn</span><span class="p">,</span>

                       <span class="n">overall_percent_error</span><span class="o">=</span><span class="n">overall_percent_error</span><span class="p">,</span>


                    <span class="p">)</span>
    <span class="k">return</span> <span class="n">return_dict</span></div>




<div class="viewcode-block" id="proofreading_table_processing"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.proofreading_table_processing">[docs]</a><span class="k">def</span> <span class="nf">proofreading_table_processing</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                  <span class="n">proof_version</span><span class="p">,</span>
                                  <span class="n">axon_version</span><span class="p">,</span>
                                 <span class="n">ver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                  <span class="n">compute_synapse_to_soma_skeletal_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">return_errored_synapses_ids_non_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">validation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">soma_center_in_nm</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="n">perform_axon_classification</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">high_fidelity_axon_on_excitatory</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">perform_nucleus_pairing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">add_synapses_before_filtering</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To do the proofreading and synapse filtering </span>
<span class="sd">    for the datajoint tables</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ver</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="s2">&quot;ver&quot;</span><span class="p">]</span>
    
    <span class="c1"># 1) Pull Down All of the Neurons</span>
    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="s2">&quot;segment_id&quot;</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">------- AutoProofreadNeuron </span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">  ----------&quot;</span><span class="p">)</span>

    <span class="n">neuron_objs</span><span class="p">,</span><span class="n">neuron_split_idxs</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">decomposition_with_spine_recalculation</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of Neurons found =</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_objs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1"># 2)  ----- Pre-work ------</span>

    <span class="n">nucleus_ids</span><span class="p">,</span><span class="n">nucleus_centers</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">segment_to_nuclei</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span>
                                                       <span class="n">nuclei_version</span><span class="o">=</span><span class="n">ver</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of Corresponding Nuclei = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nucleus_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nucleus_ids = </span><span class="si">{</span><span class="n">nucleus_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nucleus_centers = </span><span class="si">{</span><span class="n">nucleus_centers</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">fetch_segment_id_mesh</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>
    <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">triangles_center</span><span class="p">)</span>



    <span class="c1"># 3) ----- Iterate through all of the Neurons and Proofread --------</span>

    <span class="c1"># lists to help save stats until write to ProofreadStats Table</span>
    <span class="n">filtering_info_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">synapse_stats_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_error_synapse_ids_list</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="n">AutoProofreadSynapse_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">AutoProofreadSynapseErrors_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">AutoProofreadNeurons_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neuron_mesh_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">axon_mesh_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">axon_skeleton_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dendrite_skeleton_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">neuron_skeleton_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="k">for</span> <span class="n">split_index</span><span class="p">,</span><span class="n">neuron_obj_pre_split</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">neuron_split_idxs</span><span class="p">,</span><span class="n">neuron_objs</span><span class="p">):</span>

        <span class="n">whole_pass_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-----Working on Neuron Split </span><span class="si">{</span><span class="n">split_index</span><span class="si">}</span><span class="s2">-----&quot;</span><span class="p">)</span>



        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj_pre_split</span>
    <span class="c1">#             if neuron_obj_pre_split.n_error_limbs &gt; 0:</span>
    <span class="c1">#                 if verbose:</span>
    <span class="c1">#                     print(f&quot;   ---&gt; Pre-work: Splitting Neuron Limbs Because still error limbs exist--- &quot;)</span>
    <span class="c1">#                 neuron_objs_split = pru.split_neuron(neuron_obj_pre_split,</span>
    <span class="c1">#                                              verbose=False)</span>
    <span class="c1">#                 if len(neuron_objs_split) &gt; 1:</span>
    <span class="c1">#                     raise Exception(f&quot;After splitting the neuron there were more than 1: {neuron_objs_split}&quot;)</span>

    <span class="c1">#                 neuron_obj= neuron_objs_split[0]</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 neuron_obj = neuron_obj_pre_split</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> ----&gt; Pre =-work: Adding the Synapses to Neuron object)---&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">add_synapses_before_filtering</span><span class="p">:</span>
            <span class="n">syu</span><span class="o">.</span><span class="n">add_synapses_to_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">validation</span> <span class="o">=</span> <span class="n">validation</span><span class="p">,</span>
                                <span class="n">verbose</span>  <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="p">,</span>
                                <span class="n">plot_valid_error_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">calculate_synapse_soma_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">add_valid_synapses</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">add_error_synapses</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Part A: Proofreading the Neuron</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   --&gt; Part A: Proofreading the Neuron ----&quot;</span><span class="p">)</span>


    <span class="c1">#     nviz.visualize_neuron(neuron_obj,</span>
    <span class="c1">#                       limb_branch_dict=&quot;all&quot;)</span>



        <span class="n">output_dict</span><span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">proofread_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">plot_final_filtered_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">perform_axon_classification</span> <span class="o">=</span> <span class="n">perform_axon_classification</span><span class="p">,</span>
                            <span class="n">high_fidelity_axon_on_excitatory</span> <span class="o">=</span> <span class="n">high_fidelity_axon_on_excitatory</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">filtered_neuron</span> <span class="o">=</span> <span class="n">output_dict</span><span class="p">[</span><span class="s2">&quot;filtered_neuron&quot;</span><span class="p">]</span>
        <span class="n">cell_type_info</span> <span class="o">=</span> <span class="n">output_dict</span><span class="p">[</span><span class="s2">&quot;cell_type_info&quot;</span><span class="p">]</span>
        <span class="n">filtering_info</span> <span class="o">=</span> <span class="n">output_dict</span><span class="p">[</span><span class="s2">&quot;filtering_info&quot;</span><span class="p">]</span>





        <span class="c1"># Part B: Getting Soma Centers and Matching To Nuclei</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">    --&gt; Part B: Getting Soma Centers and Matching To Nuclei ----&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">perform_nucleus_pairing</span><span class="p">:</span>
            <span class="n">winning_nucleus_id</span><span class="p">,</span> <span class="n">nucleus_info</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">pair_neuron_obj_to_nuclei</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                     <span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                      <span class="n">nucleus_ids</span><span class="p">,</span>
                                      <span class="n">nucleus_centers</span><span class="p">,</span>
                                     <span class="n">nuclei_distance_threshold</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">,</span>
                                      <span class="n">return_matching_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">winning_nucleus_id</span> <span class="o">=</span> <span class="mi">12345</span>
            <span class="n">nucleus_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">winning_nucleus_id</span>
            <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;nuclei_distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;n_nuclei_in_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;n_nuclei_in_bbox&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nucleus_info = </span><span class="si">{</span><span class="n">nucleus_info</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;winning_nucleus_id = </span><span class="si">{</span><span class="n">winning_nucleus_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        






        <span class="c1"># Part C: Getting the Faces of the Original Mesh</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">    --&gt; Part C: Getting the Faces of the Original Mesh ----&quot;</span><span class="p">)</span>

        <span class="n">original_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                    <span class="n">filtered_neuron</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                                                    <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>

        <span class="n">original_mesh_faces_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_faces</span><span class="p">(</span><span class="n">original_mesh_faces</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                    <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;proofv</span><span class="si">{</span><span class="n">proof_version</span><span class="si">}</span><span class="s2">_neuron&quot;</span><span class="p">)</span>




    <span class="c1">#     nviz.plot_objects(recovered_mesh)</span>


        <span class="c1"># Part C.2: Getting the axon information to use for the synapse erroring</span>
        <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">)</span>

        <span class="n">axon_skeletal_length</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                         <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>

        <span class="n">axon_mesh_area</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                             <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>

        <span class="n">axon_face_labels</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_faces_from_labels_on_original_mesh</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                               <span class="n">original_mesh</span><span class="o">=</span><span class="n">original_mesh</span><span class="p">,</span>
                                               <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">,</span>
                                                <span class="n">plot_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,)</span>

        <span class="n">original_mesh_faces_file_axon</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_faces</span><span class="p">(</span><span class="n">axon_face_labels</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                                    <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;proofv</span><span class="si">{</span><span class="n">proof_version</span><span class="si">}</span><span class="s2">_axon&quot;</span><span class="p">)</span>

        
        <span class="c1"># Part D: Getting the Synapse Information</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">    --&gt; Part D: Getting the Synapse Information ----&quot;</span><span class="p">)</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # -------- old version that did not use the synapse objects ----------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        (keys_to_write_without_version,</span>
<span class="sd">         synapse_stats,</span>
<span class="sd">         total_error_synapse_ids,</span>
<span class="sd">         keys_to_write_without_version_errors,</span>
<span class="sd">         </span>
<span class="sd">        ) = pru.synapse_filtering(filtered_neuron,</span>
<span class="sd">                        split_index,</span>
<span class="sd">                        nucleus_id=winning_nucleus_id,</span>
<span class="sd">                        segment_id=None,</span>
<span class="sd">                        return_synapse_filter_info = True,</span>
<span class="sd">                        return_synapse_center_data = False,</span>
<span class="sd">                        return_error_synapse_ids = True,</span>
<span class="sd">                       return_valid_synapse_centers=compute_synapse_to_soma_skeletal_distance,</span>
<span class="sd">                        return_errored_synapses_ids_non_axons=return_errored_synapses_ids_non_axons,</span>
<span class="sd">                        return_error_table_entries = True,</span>
<span class="sd">                        mapping_threshold = 500,</span>
<span class="sd">                          plot_synapses=False,</span>
<span class="sd">                        verbose = True,</span>
<span class="sd">                        original_mesh_method = True,</span>
<span class="sd">                        original_mesh = original_mesh,</span>
<span class="sd">                        original_mesh_kdtree = original_mesh_kdtree,</span>
<span class="sd">                        valid_faces_on_original_mesh=original_mesh_faces, </span>
<span class="sd">                        axon_faces_on_original_mesh=axon_face_labels,</span>
<span class="sd">                                  </span>
<span class="sd">                        #will only apply the filter if it is excitatory</span>
<span class="sd">                        apply_non_axon_presyn_errors=cell_type_info[&quot;inh_exc_class&quot;] == &quot;excitatory&quot;,</span>
<span class="sd">                        validation=validation,</span>

<span class="sd">                        )</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">keys_to_write_without_version</span><span class="p">,</span>
         <span class="n">synapse_stats</span><span class="p">,</span>
         <span class="n">total_error_synapse_ids</span><span class="p">,</span>
         <span class="n">keys_to_write_without_version_errors</span><span class="p">,</span>

        <span class="p">)</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_filtering_vp2</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                <span class="n">split_index</span><span class="p">,</span>
                                <span class="n">nucleus_id</span><span class="o">=</span><span class="n">winning_nucleus_id</span><span class="p">,</span>
                                <span class="n">return_synapse_filter_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">return_synapse_center_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">return_error_synapse_ids</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">compute_synapse_to_soma_skeletal_distance</span><span class="o">=</span><span class="n">compute_synapse_to_soma_skeletal_distance</span><span class="p">,</span>
                                <span class="n">return_errored_synapses_ids_non_axons</span><span class="o">=</span><span class="n">return_errored_synapses_ids_non_axons</span><span class="p">,</span>
                                <span class="n">return_error_table_entries</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">plot_synapses</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="p">,</span>
                                <span class="c1">#will only apply the filter if it is excitatory</span>
                                <span class="n">apply_non_axon_presyn_errors</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;inh_exc_class&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">,</span>
                                <span class="n">validation</span><span class="o">=</span><span class="n">validation</span><span class="p">)</span>

        <span class="c1"># -- 2/15: Will calculate the synapse distances ---- #</span>

        <span class="n">keys_to_write</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">ver</span><span class="o">=</span><span class="n">key</span><span class="p">[</span><span class="s2">&quot;ver&quot;</span><span class="p">])</span>
                                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_to_write_without_version</span><span class="p">]</span>
        
        <span class="c1">#print(f&quot;keys_to_write_without_version_errors = {keys_to_write_without_version_errors}&quot;)</span>
        <span class="n">keys_to_write_errors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">ver</span><span class="o">=</span><span class="n">key</span><span class="p">[</span><span class="s2">&quot;ver&quot;</span><span class="p">])</span>
                                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_to_write_without_version_errors</span><span class="p">]</span>



        <span class="n">soma_x</span><span class="p">,</span><span class="n">soma_y</span><span class="p">,</span><span class="n">soma_z</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">soma_centers</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="p">,</span>
                                           <span class="n">soma_name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                           <span class="n">voxel_adjustment</span><span class="o">=</span><span class="ow">not</span> <span class="n">soma_center_in_nm</span><span class="p">)</span>





        <span class="c1">#7) Creating the dictionary to insert into the AutoProofreadNeuron</span>
        <span class="n">new_key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                       <span class="n">split_index</span> <span class="o">=</span> <span class="n">split_index</span><span class="p">,</span>
                       <span class="n">proof_version</span> <span class="o">=</span> <span class="n">proof_version</span><span class="p">,</span>
                       <span class="n">axon_version</span><span class="o">=</span> <span class="n">axon_version</span><span class="p">,</span>

                       <span class="n">multiplicity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_objs</span><span class="p">),</span>

                       <span class="c1"># -------- Important Excitatory Inhibitory Classfication ------- #</span>
                    <span class="n">cell_type_predicted</span> <span class="o">=</span> <span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;inh_exc_class&quot;</span><span class="p">],</span>
                    <span class="n">spine_category</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;spine_category&quot;</span><span class="p">],</span>

                    <span class="n">n_axons</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;n_axons&quot;</span><span class="p">],</span>
                    <span class="n">n_apicals</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;n_axons&quot;</span><span class="p">],</span>




                    <span class="c1"># ----- Soma Information ----#</span>
                    <span class="n">nucleus_id</span>         <span class="o">=</span> <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;nucleus_id&quot;</span><span class="p">],</span>
                    <span class="n">nuclei_distance</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;nuclei_distance&quot;</span><span class="p">],</span><span class="mi">2</span><span class="p">),</span>
                    <span class="n">n_nuclei_in_radius</span>   <span class="o">=</span> <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;n_nuclei_in_radius&quot;</span><span class="p">],</span>
                    <span class="n">n_nuclei_in_bbox</span>     <span class="o">=</span> <span class="n">nucleus_info</span><span class="p">[</span><span class="s2">&quot;n_nuclei_in_bbox&quot;</span><span class="p">],</span>

                    <span class="n">soma_x</span>           <span class="o">=</span> <span class="n">soma_x</span><span class="p">,</span>
                    <span class="n">soma_y</span>           <span class="o">=</span><span class="n">soma_y</span><span class="p">,</span>
                    <span class="n">soma_z</span>           <span class="o">=</span><span class="n">soma_z</span><span class="p">,</span>

                    <span class="c1"># ---------- Mesh Faces ------ #</span>


                    <span class="c1"># ------------- The Regular Neuron Information (will be computed in the stats dict) ----------------- #</span>



                       <span class="c1"># ------ Information Used For Excitatory Inhibitory Classification -------- </span>
                    <span class="n">axon_angle_maximum</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;axon_angle_maximum&quot;</span><span class="p">],</span>
                    <span class="n">spine_density_classifier</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;neuron_spine_density&quot;</span><span class="p">],</span>
                    <span class="n">n_branches_processed</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;n_branches_processed&quot;</span><span class="p">],</span>
                    <span class="n">skeletal_length_processed</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;skeletal_length_processed&quot;</span><span class="p">],</span>
                    <span class="n">n_branches_in_search_radius</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;n_branches_in_search_radius&quot;</span><span class="p">],</span>
                    <span class="n">skeletal_length_in_search_radius</span><span class="o">=</span><span class="n">cell_type_info</span><span class="p">[</span><span class="s2">&quot;skeletal_length_in_search_radius&quot;</span><span class="p">],</span>




                       <span class="n">run_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">whole_pass_time</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
                      <span class="p">)</span>




        


        <span class="n">stats_dict</span> <span class="o">=</span> <span class="n">filtered_neuron</span><span class="o">.</span><span class="n">neuron_stats</span><span class="p">()</span>
        <span class="n">new_key</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">stats_dict</span><span class="p">)</span>
        
        <span class="n">AutoProofreadSynapse_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys_to_write</span><span class="p">)</span>
        <span class="n">AutoProofreadSynapseErrors_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys_to_write_errors</span><span class="p">)</span>
        <span class="n">AutoProofreadNeurons_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_key</span><span class="p">)</span>
        
        <span class="c1">#     #saving following information for later processing:</span>
        <span class="n">filtering_info_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtering_info</span><span class="p">)</span>
        <span class="n">synapse_stats_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synapse_stats</span><span class="p">)</span>
        <span class="n">total_error_synapse_ids_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_error_synapse_ids</span><span class="p">)</span>
        
        <span class="n">neuron_mesh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_mesh_faces_file</span><span class="p">)</span>
        <span class="n">axon_mesh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_mesh_faces_file_axon</span><span class="p">)</span>
        
        <span class="c1"># ---- 2/27: saving off the skeletons ------------</span>
        <span class="n">axon_skeleton_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_skeleton</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="o">.</span><span class="n">axon_skeleton</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                    <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;proofv</span><span class="si">{</span><span class="n">proof_version</span><span class="si">}</span><span class="s2">_axon_skeleton&quot;</span><span class="p">)</span>
        
        <span class="n">dendrite_skeleton_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_skeleton</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="o">.</span><span class="n">dendrite_skeleton</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                    <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;proofv</span><span class="si">{</span><span class="n">proof_version</span><span class="si">}</span><span class="s2">_dendrite_skeleton&quot;</span><span class="p">)</span>
        
        <span class="n">neuron_skeleton_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_skeleton</span><span class="p">(</span><span class="n">filtered_neuron</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                    <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;proofv</span><span class="si">{</span><span class="n">proof_version</span><span class="si">}</span><span class="s2">_neuron_skeleton&quot;</span><span class="p">)</span>
        
        
        
        <span class="n">axon_skeleton_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axon_skeleton_file</span><span class="p">)</span>
        <span class="n">dendrite_skeleton_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dendrite_skeleton_file</span><span class="p">)</span>
        <span class="n">neuron_skeleton_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neuron_skeleton_file</span><span class="p">)</span>
    
    <span class="n">dict_to_return</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">AutoProofreadSynapse_keys</span><span class="o">=</span><span class="n">AutoProofreadSynapse_keys</span><span class="p">,</span>
                          <span class="n">AutoProofreadSynapseErrors_keys</span> <span class="o">=</span> <span class="n">AutoProofreadSynapseErrors_keys</span><span class="p">,</span>
                          <span class="n">AutoProofreadNeurons_keys</span><span class="o">=</span><span class="n">AutoProofreadNeurons_keys</span><span class="p">,</span>
                        <span class="n">filtering_info_list</span><span class="o">=</span><span class="n">filtering_info_list</span><span class="p">,</span>
                        <span class="n">synapse_stats_list</span><span class="o">=</span><span class="n">synapse_stats_list</span><span class="p">,</span>
                        <span class="n">total_error_synapse_ids_list</span><span class="o">=</span><span class="n">total_error_synapse_ids_list</span><span class="p">,</span>

                        <span class="n">neuron_mesh_list</span><span class="o">=</span><span class="n">neuron_mesh_list</span><span class="p">,</span>
                        <span class="n">axon_mesh_list</span> <span class="o">=</span> <span class="n">axon_mesh_list</span><span class="p">,</span>
                          <span class="n">neuron_split_idxs</span><span class="o">=</span><span class="n">neuron_split_idxs</span><span class="p">,</span>
                          
                        <span class="n">axon_skeleton_list</span> <span class="o">=</span> <span class="n">axon_skeleton_list</span><span class="p">,</span>
                        <span class="n">dendrite_skeleton_list</span> <span class="o">=</span> <span class="n">dendrite_skeleton_list</span><span class="p">,</span>
                          <span class="n">neuron_skeleton_list</span> <span class="o">=</span> <span class="n">neuron_skeleton_list</span><span class="p">,</span>
       
    
    
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">dict_to_return</span></div>
    
    
    

<div class="viewcode-block" id="refine_axon_for_high_fidelity_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.refine_axon_for_high_fidelity_skeleton">[docs]</a><span class="k">def</span> <span class="nf">refine_axon_for_high_fidelity_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">plot_new_axon_limb_correspondence</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_new_limb_object</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_revised_axon_branch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>



<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To replace the axon branches with a higher</span>
<span class="sd">    fidelity representation within the neuron object</span>
<span class="sd">    (aka replacing all of the branch objects)</span>

<span class="sd">    ** Note: The Neuron should already have axon classification up to this point **</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    0) Get the limb branch dict for the axon (if empty then return)</span>
<span class="sd">    #1) Generate the new limb correspondence for the axon (will pass back the starting info as well)</span>
<span class="sd">    2) Combine the data with any left over branches that still exist </span>
<span class="sd">    in the limb object</span>

<span class="sd">    a. Figure out which starting info to use (previous one or axon one)</span>

<span class="sd">    b. Delete all replaced branches</span>

<span class="sd">    c. Rename the existing branches so not incorporate any of the new names</span>
<span class="sd">    from the correspondence</span>

<span class="sd">    d. Save the computed dict of all existing branches</span>

<span class="sd">    e. export a limb correspondence for those existing branches</span>

<span class="sd">    3) Send all the limb correspondence info to create a limb object</span>

<span class="sd">    4) Part 4: Computing of all the feautres:</span>
<span class="sd">    a) Add back the computed dict</span>
<span class="sd">    b) Re-compute the median mesh width  and add no spines for all the new ones</span>
<span class="sd">        (have option where can set spines to 0)</span>
<span class="sd">    6) Recompoute median mesh no spine</span>

<span class="sd">    5) Adding new limb</span>
<span class="sd">    a)  replace old limb with new one</span>
<span class="sd">    b) Run the function that will go through and fix the limbs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#0) Get the limb branch dict for the axon (if empty then return)</span>
    <span class="n">axon_limb_branch_dict</span><span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_obj</span>

    <span class="c1">#1) Generate the new limb correspondence for the axon (will pass back the starting info as well)</span>
    <span class="n">new_limb_corr</span><span class="p">,</span> <span class="n">st_info</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">high_fidelity_axon_decomposition</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">plot_new_axon_limb_correspondence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">plot_connecting_skeleton_fix</span> <span class="o">=</span> <span class="n">plot_new_axon_limb_correspondence</span><span class="p">,</span>
                                         <span class="n">return_starting_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,)</span>
    
    
    
    <span class="c1"># ---- Part 2: Combine Axon Data</span>
    <span class="n">neuron_obj_cp</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">axon_limb_name</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj_cp</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">])</span> 
    <span class="n">axon_branches</span> <span class="o">=</span> <span class="n">axon_limb_branch_dict</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span>
    <span class="n">axon_starting_branch</span> <span class="o">=</span> <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">axon_starting_branch</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_limb_name= </span><span class="si">{</span><span class="n">axon_limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb starting node = </span><span class="si">{</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axon starting node = </span><span class="si">{</span><span class="n">axon_starting_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_branches = </span><span class="si">{</span><span class="n">axon_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="c1">#a. Figure out starting network info</span>
    <span class="k">if</span> <span class="n">axon_starting_branch</span> <span class="o">==</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using Axon Starting Info&quot;</span><span class="p">)</span>
        <span class="n">network_starting_info</span> <span class="o">=</span> <span class="n">st_info</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using Original Starting Info&quot;</span><span class="p">)</span>
        <span class="n">network_starting_info</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">network_starting_info</span>
        
        
    <span class="c1">#b. Delete all replaced branches</span>
    <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">)</span>
    
    <span class="n">high_fid_node_name</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_limb_corr</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">curr_node_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>

    <span class="n">new_node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_node_names</span><span class="p">))</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">high_fid_node_name</span><span class="p">)</span>

    <span class="n">node_name_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">curr_node_names</span><span class="p">,</span><span class="n">new_node_names</span><span class="p">)])</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Leftover Nodes After Axon Deletion = </span><span class="si">{</span><span class="n">curr_node_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New Node names = </span><span class="si">{</span><span class="n">new_node_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Leftover Nodes Mapping = </span><span class="si">{</span><span class="n">node_name_mapping</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="c1">#c. Rename the existing branches so not incorporate any of the new names</span>
    <span class="c1">#from the correspondence</span>

    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
    <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                     <span class="n">mapping</span><span class="o">=</span><span class="n">node_name_mapping</span><span class="p">,</span>
                     <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">#d. Save the computed dict of all existing branches</span>
    <span class="n">computed_data_non_axon</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_computed_attribute_data</span><span class="p">()</span>
    
    <span class="c1">#e. export a limb correspondence for those existing branches</span>
    <span class="n">kept_limb_correspondence</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">limb_correspondence</span>
    <span class="n">kept_limb_correspondence</span>
    
    
    
    
    
    <span class="c1"># --Part 3: Creating the Limb Object ---</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3) Send all the limb correspondence info to create a limb object</span>

<span class="sd">    Purpose: Create new limb object from all our information</span>
<span class="sd">    of limb correspondences</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Create the joint limb correspondence</span>
<span class="sd">    2) Calculate the new concept network</span>
<span class="sd">    3) Send all the information </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">combined_limb_correspondence</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">new_limb_corr</span><span class="p">)</span>
    <span class="n">combined_limb_correspondence</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kept_limb_correspondence</span><span class="p">)</span>

    <span class="n">limb_to_soma_concept_networks</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">calculate_limb_concept_networks</span><span class="p">(</span><span class="n">combined_limb_correspondence</span><span class="p">,</span>
                                                                            <span class="n">network_starting_info</span><span class="p">,</span>
                                                                            <span class="n">run_concept_network_checks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                           <span class="p">)</span>
    <span class="n">limb_mesh</span> <span class="o">=</span> <span class="n">neuron_obj_cp</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">limb_mesh_face_idx</span> <span class="o">=</span> <span class="n">neuron_obj_cp</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_face_idx</span>

    <span class="n">new_limb_object</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">(</span> <span class="n">mesh</span><span class="o">=</span><span class="n">limb_mesh</span><span class="p">,</span>
                                 <span class="n">curr_limb_correspondence</span><span class="o">=</span><span class="n">combined_limb_correspondence</span><span class="p">,</span>
                                 <span class="n">concept_network_dict</span><span class="o">=</span><span class="n">limb_to_soma_concept_networks</span><span class="p">,</span>
                                 <span class="n">mesh_face_idx</span><span class="o">=</span><span class="n">limb_mesh_face_idx</span><span class="p">,</span>
                                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">plot_new_limb_object</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New Limb Object&quot;</span><span class="p">)</span>   
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_limb_obj</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">new_limb_object</span><span class="p">)</span>
        
        
        
    <span class="c1"># -- Part 4: Assigning New Limb and Computing All the Features</span>
    
    <span class="c1">#a) Add back the computed dict</span>
    <span class="n">new_limb_object</span><span class="o">.</span><span class="n">set_computed_attribute_data</span><span class="p">(</span><span class="n">computed_data_non_axon</span><span class="p">)</span>
    
    <span class="c1">#b) Make none of the axon have spines or spine volume</span>
    <span class="k">for</span> <span class="n">b_idx</span> <span class="ow">in</span> <span class="n">high_fid_node_name</span><span class="p">:</span>
        <span class="n">new_limb_object</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_limb_object</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]</span><span class="o">.</span><span class="n">spines_volume</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_limb_object</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">,</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span>
        
    <span class="c1">#c) setting the new limb object before calulating new widths</span>
    <span class="n">nru</span><span class="o">.</span><span class="n">neuron_limb_overwrite</span><span class="p">(</span><span class="n">neuron_obj_cp</span><span class="p">,</span>
                         <span class="n">limb_name</span> <span class="o">=</span> <span class="n">axon_limb_name</span><span class="p">,</span>
                         <span class="n">limb_obj</span><span class="o">=</span><span class="n">new_limb_object</span><span class="p">)</span>
    
    <span class="c1">#d) Recalculate the widths</span>

    <span class="n">new_axon_limb_branch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">axon_limb_name</span><span class="p">:</span><span class="n">high_fid_node_name</span><span class="p">}</span>

    <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">calculate_new_width</span><span class="p">(</span><span class="n">no_spines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">summary_measure</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
                            <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">new_axon_limb_branch_dict</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="n">neuron_obj_cp</span><span class="o">.</span><span class="n">calculate_new_width</span><span class="p">(</span><span class="n">no_spines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">distance_by_mesh_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="n">summary_measure</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
                            <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">new_axon_limb_branch_dict</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>


    
    
    <span class="c1"># ---- Part 5: Re-processing the Limb to Make sure everything is good</span>
    <span class="n">neuron_obj_revised</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_neuron_limb_by_seperated_network</span><span class="p">(</span><span class="n">neuron_obj_cp</span><span class="p">,</span>
                                                               <span class="n">curr_limb_idx</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">axon_limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                                                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_final_revised_axon_branch</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj_revised</span><span class="p">,</span>
                              <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="n">axon_limb_name</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">})</span>
    
    <span class="k">return</span> <span class="n">neuron_obj_revised</span></div>

<div class="viewcode-block" id="proofread_neuron_class_predetermined"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.proofread_neuron_class_predetermined">[docs]</a><span class="k">def</span> <span class="nf">proofread_neuron_class_predetermined</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">inh_exc_class</span><span class="p">,</span>
    <span class="n">perform_axon_classification</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">high_fidelity_axon_on_excitatory</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_final_filtered_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1">#arguments for the axon high fidelity:</span>
    <span class="n">plot_new_axon_limb_correspondence</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_new_limb_object</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_revised_axon_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_outline</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         
    <span class="n">return_red_blue_splits</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_split_locations</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">neuron_simplification</span> <span class="o">=</span> <span class="kc">True</span>
                                        
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To apply filtering rules to a neuron that</span>
<span class="sd">    has already been classified</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">perform_axon_classification</span><span class="p">:</span>
        <span class="n">clu</span><span class="o">.</span><span class="n">axon_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inh_exc_class</span> <span class="o">==</span> <span class="s2">&quot;inhibitory&quot;</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">filter_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_filters</span> <span class="o">=</span> <span class="n">inh_filters_auto_proof</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_filters</span> <span class="o">=</span> <span class="n">filter_list</span>

        <span class="n">o_neuron</span><span class="p">,</span> <span class="n">filtering_info</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">apply_proofreading_filters_to_neuron</span><span class="p">(</span><span class="n">input_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">filter_list</span> <span class="o">=</span> <span class="n">curr_filters</span><span class="p">,</span>
                    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                        <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                        <span class="n">verbose_outline</span><span class="o">=</span><span class="n">verbose_outline</span><span class="p">,</span>
                                        <span class="n">return_limb_branch_dict_to_cancel</span> <span class="o">=</span> <span class="n">return_limb_branch_dict_to_cancel</span><span class="p">,</span>
                                        <span class="n">return_red_blue_splits</span><span class="o">=</span><span class="n">return_red_blue_splits</span><span class="p">,</span>
                                        <span class="n">return_split_locations</span> <span class="o">=</span> <span class="n">return_split_locations</span> <span class="p">)</span>


    <span class="k">elif</span> <span class="n">inh_exc_class</span> <span class="o">==</span> <span class="s2">&quot;excitatory&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">filter_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#curr_filters = pru.get_exc_filters()</span>
            <span class="c1">#curr_filters = pru.v4_exc_filters()</span>
            <span class="c1">#curr_filters = pru.v5_exc_filters()</span>
            <span class="n">curr_filters</span> <span class="o">=</span> <span class="n">exc_filters_auto_proof</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_filters</span> <span class="o">=</span> <span class="n">filter_list</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">high_fidelity_axon_on_excitatory</span><span class="p">:</span>
            <span class="n">o_neuron</span><span class="p">,</span> <span class="n">filtering_info</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">apply_proofreading_filters_to_neuron</span><span class="p">(</span><span class="n">input_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">filter_list</span> <span class="o">=</span> <span class="n">curr_filters</span><span class="p">,</span>
                    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                        <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                        <span class="n">verbose_outline</span><span class="o">=</span><span class="n">verbose_outline</span><span class="p">,</span>
                                        <span class="n">return_limb_branch_dict_to_cancel</span><span class="o">=</span><span class="n">return_limb_branch_dict_to_cancel</span><span class="p">,</span>
                                        <span class="n">return_red_blue_splits</span><span class="o">=</span><span class="n">return_red_blue_splits</span><span class="p">,</span>
                                        <span class="n">return_split_locations</span> <span class="o">=</span> <span class="n">return_split_locations</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            2/25 Addition:</span>

<span class="sd">            Pseudocode:</span>
<span class="sd">            1) Run the Dendrite on Axon Proofreading</span>
<span class="sd">            2) Run the High Fidelity Axon replacement</span>
<span class="sd">            3) Run the Post processing Filters</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> Using high_fidelity_axon_on_excitatory&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---Step 1: Applying Dendrite on Axon Filtering&quot;</span><span class="p">)</span>

            <span class="n">pre_filters</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">get_exc_filters_high_fidelity_axon_preprocessing</span><span class="p">()</span>
            <span class="n">post_filters</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">get_exc_filters_high_fidelity_axon_postprocessing</span><span class="p">()</span>

            <span class="c1">#1) Run the Dendrite on Axon Proofreading</span>
            <span class="n">o_neuron_pre</span><span class="p">,</span> <span class="n">filtering_info_pre</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">apply_proofreading_filters_to_neuron</span><span class="p">(</span><span class="n">input_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">,</span>
                                        <span class="n">filter_list</span> <span class="o">=</span> <span class="n">pre_filters</span><span class="p">,</span>
                    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                        <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                        <span class="n">verbose_outline</span><span class="o">=</span><span class="n">verbose_outline</span><span class="p">,</span>
                                        <span class="n">return_limb_branch_dict_to_cancel</span><span class="o">=</span><span class="n">return_limb_branch_dict_to_cancel</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---- Step 2: Applying High Fidelity Axon -----&quot;</span><span class="p">)</span>

            <span class="c1">#2) Run the High Fidelity Axon replacement</span>
            <span class="n">neuron_obj_high_fidelity_axon</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">refine_axon_for_high_fidelity_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">o_neuron_pre</span><span class="p">,</span>
                            <span class="n">plot_new_axon_limb_correspondence</span> <span class="o">=</span> <span class="n">plot_new_axon_limb_correspondence</span><span class="p">,</span>
                            <span class="n">plot_new_limb_object</span> <span class="o">=</span> <span class="n">plot_new_limb_object</span><span class="p">,</span>
                            <span class="n">plot_final_revised_axon_branch</span><span class="o">=</span><span class="n">plot_final_revised_axon_branch</span><span class="p">,</span>
                             <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="n">verbose_outline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---- Step 3: Applying Excitatory Filters Post-processing -----&quot;</span><span class="p">)</span>

            <span class="n">o_neuron</span><span class="p">,</span> <span class="n">filtering_info</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">apply_proofreading_filters_to_neuron</span><span class="p">(</span><span class="n">input_neuron</span> <span class="o">=</span> <span class="n">neuron_obj_high_fidelity_axon</span><span class="p">,</span>
                                        <span class="n">filter_list</span> <span class="o">=</span> <span class="n">post_filters</span><span class="p">,</span>
                    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                                        <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

                                        <span class="n">return_error_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                        <span class="n">verbose_outline</span><span class="o">=</span><span class="n">verbose_outline</span><span class="p">,</span>
                                    <span class="n">return_limb_branch_dict_to_cancel</span><span class="o">=</span><span class="n">return_limb_branch_dict_to_cancel</span><span class="p">,</span>
                                                <span class="n">return_red_blue_splits</span><span class="o">=</span><span class="n">return_red_blue_splits</span><span class="p">,</span>
                                                <span class="n">return_split_locations</span> <span class="o">=</span> <span class="n">return_split_locations</span> 
                                                                               <span class="p">)</span>
            <span class="n">filtering_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">filtering_info_pre</span><span class="p">)</span>



    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid cell type: </span><span class="si">{</span><span class="n">inh_exc_class</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">neuron_simplification</span><span class="p">:</span>
        <span class="n">o_neuron</span> <span class="o">=</span> <span class="n">nsimp</span><span class="o">.</span><span class="n">branching_simplification</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_final_filtered_neuron</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">               ******* Plotting Final Neuron ***************&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_lite</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">)</span>
        
    
        
    <span class="k">return</span> <span class="n">o_neuron</span><span class="p">,</span><span class="n">filtering_info</span></div>

    
<span class="c1"># ---------- For Allen Requested Proofreading ---- #</span>
<div class="viewcode-block" id="plot_limb_to_red_blue_groups"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.plot_limb_to_red_blue_groups">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_to_red_blue_groups</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">limb_to_red_blue_groups</span><span class="p">,</span>
                                <span class="n">error_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                <span class="n">valid_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                                <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot a picture of all the limb to red blue groups</span>
<span class="sd">    information</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">limb_branch_dict_plot</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_branch_dict_plot_color</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">total_valid_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_error_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">error_comp_dict</span> <span class="ow">in</span> <span class="n">limb_to_red_blue_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict_plot</span><span class="p">:</span>
            <span class="n">limb_branch_dict_plot</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">limb_branch_dict_plot_color</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">comp_idx</span><span class="p">,</span><span class="n">points_info</span> <span class="ow">in</span> <span class="n">error_comp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">limb_branch_dict_plot</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">points_info</span><span class="p">[</span><span class="s2">&quot;error_branches&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">points_info</span><span class="p">[</span><span class="s2">&quot;valid_branches&quot;</span><span class="p">])</span>
            <span class="n">total_valid_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points_info</span><span class="p">[</span><span class="s2">&quot;valid_points&quot;</span><span class="p">])</span>
            <span class="n">total_error_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points_info</span><span class="p">[</span><span class="s2">&quot;error_points&quot;</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">points_info</span><span class="p">[</span><span class="s2">&quot;error_branches&quot;</span><span class="p">]:</span>
                <span class="n">limb_branch_dict_plot_color</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_color</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">points_info</span><span class="p">[</span><span class="s2">&quot;valid_branches&quot;</span><span class="p">]:</span>
                <span class="n">limb_branch_dict_plot_color</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_color</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">total_valid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">total_valid_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">total_valid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">total_error_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">total_error_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">total_error_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict_plot</span><span class="p">,</span>
                          <span class="n">mesh_color</span><span class="o">=</span><span class="n">limb_branch_dict_plot_color</span><span class="p">,</span>
                          <span class="n">skeleton_color</span><span class="o">=</span><span class="n">limb_branch_dict_plot_color</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">total_valid_points</span><span class="p">,</span><span class="n">total_error_points</span><span class="p">],</span>
                          <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="n">valid_color</span><span class="p">,</span><span class="n">error_color</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,)</span></div>
    

<div class="viewcode-block" id="limb_errors_to_cancel_to_red_blue_group"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.limb_errors_to_cancel_to_red_blue_group">[docs]</a><span class="k">def</span> <span class="nf">limb_errors_to_cancel_to_red_blue_group</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">error_branches</span><span class="p">,</span>
    <span class="n">neuron_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="n">plot_error_graph_before_create_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_error_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">created_edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_error_graph_after_create_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">plot_error_connected_components</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_one_hop_downstream_error_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True,</span>
    <span class="n">one_hop_downstream_error_branches_max_distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#4_000,#10_000,</span>

    <span class="n">offset_distance_for_points_valid</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3_000,#500,#1000,</span>
    <span class="n">offset_distance_for_points_error</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#3_000</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1,#3,</span>
    <span class="n">n_red_points</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_blue_points</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">red_blue_points_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#&quot;closest_mesh_face&quot;, #other options: &quot;skeleton&quot;,</span>
    <span class="n">plot_final_blue_red_points</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">pair_conn_comp_by_common_upstream</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#False</span>
    <span class="n">pair_conn_comp_errors</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1"># True,</span>
    <span class="n">group_all_conn_comp_together</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">only_outermost_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True,</span>
    
    <span class="n">min_error_downstream_length_total</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#5_000,# None,#5_000,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">valid_upstream_branches_restriction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="n">split_red_blue_by_common_upstream</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True,#False,</span>
    <span class="n">use_undirected_graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">avoid_one_red_or_blue</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#True,</span>
    
    <span class="n">min_cancel_distance_absolute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#2000,</span>
    
    <span class="n">min_cancel_distance_absolute_all_points</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">add_additional_point_to_no_children_branches</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">return_error_skeleton_points</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_synapse_points</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To lay down red and blue points on a limb</span>
<span class="sd">    given error branches</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">include_one_hop_downstream_error_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">include_one_hop_downstream_error_branches</span> <span class="o">=</span> <span class="n">include_one_hop_downstream_error_branches_red_blue_global</span>
    <span class="k">if</span> <span class="n">one_hop_downstream_error_branches_max_distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">one_hop_downstream_error_branches_max_distance</span> <span class="o">=</span> <span class="n">one_hop_downstream_error_branches_max_distance_red_blue_global</span>
    <span class="k">if</span> <span class="n">offset_distance_for_points_valid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset_distance_for_points_valid</span> <span class="o">=</span> <span class="n">offset_distance_for_points_valid_red_blue_global</span>
    <span class="k">if</span> <span class="n">offset_distance_for_points_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset_distance_for_points_error</span> <span class="o">=</span> <span class="n">offset_distance_for_points_error_red_blue_global</span>
    <span class="k">if</span> <span class="n">n_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">n_points_red_blue_global</span>
    <span class="k">if</span> <span class="n">n_red_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_red_points</span> <span class="o">=</span> <span class="n">n_red_points_red_blue_global</span>
    <span class="k">if</span> <span class="n">n_blue_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_blue_points</span> <span class="o">=</span> <span class="n">n_blue_points_red_blue_global</span>
    <span class="k">if</span> <span class="n">red_blue_points_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">red_blue_points_method</span> <span class="o">=</span> <span class="n">red_blue_points_method_red_blue_global</span>
    <span class="k">if</span> <span class="n">pair_conn_comp_by_common_upstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pair_conn_comp_by_common_upstream</span> <span class="o">=</span> <span class="n">pair_conn_comp_by_common_upstream_red_blue_global</span>
    <span class="k">if</span> <span class="n">pair_conn_comp_errors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pair_conn_comp_errors</span> <span class="o">=</span> <span class="n">pair_conn_comp_errors_red_blue_global</span>
        
    <span class="k">if</span> <span class="n">group_all_conn_comp_together</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">group_all_conn_comp_together</span> <span class="o">=</span> <span class="n">group_all_conn_comp_together_red_blue_global</span>
    <span class="k">if</span> <span class="n">only_outermost_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">only_outermost_branches</span> <span class="o">=</span> <span class="n">only_outermost_branches_red_blue_global</span>
    <span class="k">if</span> <span class="n">min_error_downstream_length_total</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_error_downstream_length_total</span> <span class="o">=</span> <span class="n">min_error_downstream_length_total_red_blue_global</span>
    <span class="k">if</span> <span class="n">split_red_blue_by_common_upstream</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">split_red_blue_by_common_upstream</span> <span class="o">=</span> <span class="n">split_red_blue_by_common_upstream_red_blue_global</span>
    <span class="k">if</span> <span class="n">use_undirected_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">use_undirected_graph</span> <span class="o">=</span> <span class="n">use_undirected_graph_red_blue_global</span>
    <span class="k">if</span> <span class="n">avoid_one_red_or_blue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">avoid_one_red_or_blue</span> <span class="o">=</span> <span class="n">avoid_one_red_or_blue_red_blue_global</span>
    <span class="k">if</span> <span class="n">min_cancel_distance_absolute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_cancel_distance_absolute</span> <span class="o">=</span> <span class="n">min_cancel_distance_absolute_red_blue_global</span>
    
    <span class="k">if</span> <span class="n">n_red_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_red_points</span> <span class="o">=</span> <span class="n">n_points</span>
    <span class="k">if</span> <span class="n">n_blue_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_blue_points</span> <span class="o">=</span> <span class="n">n_points</span>
        

    <span class="n">red_blue_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">n_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    <span class="k">if</span> <span class="n">created_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">created_edges</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error branches list empty in error_limb_branch_dict for limb&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error Branches = </span><span class="si">{</span><span class="n">error_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">limb_obj</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_undirected_graph</span><span class="p">:</span>
        <span class="n">error_subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">error_branches</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">error_subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">error_branches</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot_error_graph_before_create_edges</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_error_graph_before_create_edges&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">error_subgraph</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">plot_error_branches</span> <span class="ow">and</span> <span class="n">n_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_path</span><span class="p">(</span><span class="n">n_obj</span><span class="p">,</span>
                                  <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">limb_idx</span><span class="p">,</span>
                                  <span class="n">path</span><span class="o">=</span><span class="n">error_branches</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">created_edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">error_branches</span> <span class="ow">and</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">error_branches</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding error edge: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">error_subgraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_error_graph_after_create_edges</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_error_graph_after_create_edges&quot;</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">error_subgraph</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>




    <span class="c1">#1) Find the connected components of error branches</span>
    <span class="n">conn_comp_errors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">error_subgraph</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">**conn_comp_errors = </span><span class="si">{</span><span class="n">conn_comp_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        
    <span class="k">if</span> <span class="n">group_all_conn_comp_together</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grouping all conn comp together&quot;</span><span class="p">)</span>
            
        <span class="n">conn_comp_errors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">conn_comp_errors</span><span class="p">))]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">**conn_comp_errors AFTER PAIRING = </span><span class="si">{</span><span class="n">conn_comp_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">pair_conn_comp_by_common_upstream</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempting to pair_conn_comp_by_common_upstream&quot;</span><span class="p">)</span>
        <span class="n">conn_comp_errors</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">pair_branch_connected_components_by_common_upstream</span><span class="p">(</span>
            <span class="n">curr_limb</span><span class="p">,</span>
            <span class="n">conn_comp</span> <span class="o">=</span> <span class="n">conn_comp_errors</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">**conn_comp_errors AFTER PAIRING = </span><span class="si">{</span><span class="n">conn_comp_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">elif</span> <span class="n">pair_conn_comp_errors</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attempting to pair_conn_comp_errors&quot;</span><span class="p">)</span>
        <span class="n">conn_comp_errors</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">pair_branch_connected_components</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                                <span class="n">conn_comp</span> <span class="o">=</span> <span class="n">conn_comp_errors</span><span class="p">,</span>
                                <span class="n">plot_conn_comp_before_combining</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">**conn_comp_errors AFTER PAIRING = </span><span class="si">{</span><span class="n">conn_comp_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>



<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    2) For each connected component we will build a red and a blue team</span>

<span class="sd">    a) find all upstream nodes of error branches THAT AREN&#39;T ERRORS:</span>
<span class="sd">    -&gt; include the error branches hat these upstream valid branches came from and the </span>
<span class="sd">    skeleton point that connectes them</span>

<span class="sd">    b) Find all valid downstream nodes from te upstream valid ones</span>
<span class="sd">    --. include te skeleton points that connect them</span>

<span class="sd">    c) Optional: Choose the downstream error branches of current boundary error branches</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">conn_comp_idx</span><span class="p">,</span><span class="n">curr_conn_comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conn_comp_errors</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on connected component: </span><span class="si">{</span><span class="n">curr_conn_comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">valid_upstream_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">error_border_branches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">error_border_coordinates</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_conn_comp</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_undirected_graph</span><span class="p">:</span>
                <span class="n">curr_upstream_nodes</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">convert_to_array_like</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">return_single</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_upstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
                
<span class="c1">#             if verbose:</span>
<span class="c1">#                 print(f&quot;curr_upstream_nodes= {curr_upstream_nodes}&quot;)</span>
            
            <span class="k">for</span> <span class="n">curr_upstream_node</span> <span class="ow">in</span> <span class="n">curr_upstream_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">valid_upstream_branches_restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">curr_upstream_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_upstream_branches_restriction</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping upstream node </span><span class="si">{</span><span class="n">curr_upstream_node</span><span class="si">}</span><span class="s2"> because was not in valid_upstream_branches_restriction&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>

                <span class="k">if</span> <span class="n">curr_upstream_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">curr_conn_comp</span><span class="p">:</span>

                    <span class="n">error_border_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    - 5/10 Addition: Accounts for if the error node is the starting node</span>

<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">curr_upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">valid_upstream_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">error_border_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#if curr_upstream_node not in error_branches:</span>
                        <span class="n">valid_upstream_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_upstream_node</span><span class="p">)</span>
                        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                  <span class="n">curr_limb</span><span class="p">[</span><span class="n">curr_upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                  <span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

                        <span class="n">error_border_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2"> had a valid upstream node </span><span class="si">{</span><span class="n">curr_upstream_node</span><span class="si">}</span><span class="s2"> with common endpoint </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
        
        

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_upstream_branches = </span><span class="si">{</span><span class="n">valid_upstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_border_branches = </span><span class="si">{</span><span class="n">error_border_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_border_coordinates = </span><span class="si">{</span><span class="n">error_border_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1">#b) Find all valid downstream nodes from te upstream valid ones</span>
        <span class="c1">#--&gt; include te skeleton points that connect them</span>
        
        
        <span class="c1"># ---------------- COULD FORM GROUPS OF error_border_branches ---------------- #</span>
        <span class="k">if</span> <span class="n">split_red_blue_by_common_upstream</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grouping Red Blue into Common Upstream Groups&quot;</span><span class="p">)</span>
            
            <span class="n">valid_upstream_branches_total</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">error_border_branches_total</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">error_border_coordinates_total</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="n">named_upstream_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">upstream</span><span class="p">,</span><span class="n">error_branch</span><span class="p">,</span><span class="n">error_coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">valid_upstream_branches</span><span class="p">,</span>
                                                        <span class="n">error_border_branches</span><span class="p">,</span>
                                                        <span class="n">error_border_coordinates</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">upstream</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">valid_upstream_branches_total</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">upstream</span><span class="p">])</span>
                    <span class="n">error_border_branches_total</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">error_branch</span><span class="p">])</span>
                    <span class="n">error_border_coordinates_total</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">error_coord</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">upstream</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">named_upstream_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">named_upstream_dict</span><span class="p">[</span><span class="n">upstream</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">up</span><span class="o">=</span><span class="p">[],</span><span class="n">err</span><span class="o">=</span><span class="p">[],</span><span class="n">err_c</span> <span class="o">=</span> <span class="p">[])</span>
                    
                    <span class="n">named_upstream_dict</span><span class="p">[</span><span class="n">upstream</span><span class="p">][</span><span class="s2">&quot;up&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upstream</span><span class="p">)</span>
                    <span class="n">named_upstream_dict</span><span class="p">[</span><span class="n">upstream</span><span class="p">][</span><span class="s2">&quot;err&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error_branch</span><span class="p">)</span>
                    <span class="n">named_upstream_dict</span><span class="p">[</span><span class="n">upstream</span><span class="p">][</span><span class="s2">&quot;err_c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error_coord</span><span class="p">)</span>
                
            <span class="k">for</span> <span class="n">up_key</span><span class="p">,</span><span class="n">data_dict</span> <span class="ow">in</span> <span class="n">named_upstream_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">valid_upstream_branches_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">])</span>
                <span class="n">error_border_branches_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;err&quot;</span><span class="p">])</span>
                <span class="n">error_border_coordinates_total</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;err_c&quot;</span><span class="p">])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valid_upstream_branches_total</span> <span class="o">=</span> <span class="p">[</span><span class="n">valid_upstream_branches</span><span class="p">]</span>
            <span class="n">error_border_branches_total</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_border_branches</span><span class="p">]</span>
            <span class="n">error_border_coordinates_total</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_border_coordinates</span><span class="p">]</span>
            
            
        <span class="n">local_red_blue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">upstream_idx</span><span class="p">,(</span><span class="n">valid_upstream_branches</span><span class="p">,</span>
             <span class="n">error_border_branches</span><span class="p">,</span>
             <span class="n">error_border_coordinates</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">valid_upstream_branches_total</span><span class="p">,</span>
                                                       <span class="n">error_border_branches_total</span><span class="p">,</span>
                                                       <span class="n">error_border_coordinates_total</span><span class="p">)):</span>
            
            <span class="n">valid_upstream_branches_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_upstream_branches</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">valid_upstream_branches_unique</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                    
                <span class="k">if</span> <span class="ow">not</span> <span class="n">use_undirected_graph</span><span class="p">:</span>
                    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                                   <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">error_border_branches</span><span class="p">,</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                    
                    
                    
                    
                <span class="c1">#non_error_downstream = np.setdiff1d(downstream_nodes,curr_conn_comp)</span>
                <span class="n">non_error_downstream</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">,</span><span class="n">error_branches</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_error_downstream</span><span class="p">:</span>
                    <span class="n">valid_upstream_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="n">error_border_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                  <span class="n">curr_limb</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                  <span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

                    <span class="n">error_border_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid Branch </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> had a valid downstream node </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> with common endpoint </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After Adding Downstream Valid Nodes&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_border_branches = </span><span class="si">{</span><span class="n">error_border_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_upstream_branches = </span><span class="si">{</span><span class="n">valid_upstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_border_coordinates = </span><span class="si">{</span><span class="n">error_border_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>


            <span class="n">error_border_branches_copy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">error_border_branches</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">include_one_hop_downstream_error_branches</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">error_border_branches_copy</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="o">&gt;</span> <span class="n">one_hop_downstream_error_branches_max_distance</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping Branch </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> one hop downstream because skeletal distance&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span><span class="si">}</span><span class="s2">) larger than threshold one_hop_downstream_error_branches_max_distance&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                        
                    
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_undirected_graph</span><span class="p">:</span>
                        <span class="n">downstream_error_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">downstream_error_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">v</span><span class="p">),</span><span class="n">error_branches</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_error_nodes</span><span class="p">:</span>
                        <span class="n">error_border_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                        <span class="n">valid_upstream_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">common_endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">shared_endpoint</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                      <span class="n">curr_limb</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                                      <span class="n">return_possibly_two</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

                        <span class="n">error_border_coordinates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">common_endpoint</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error Branch </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> had an error downstream node </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> with common endpoint </span><span class="si">{</span><span class="n">common_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After Adding Downstream Error Nodes&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_border_branches = </span><span class="si">{</span><span class="n">error_border_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid_upstream_branches = </span><span class="si">{</span><span class="n">valid_upstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_border_coordinates = </span><span class="si">{</span><span class="n">error_border_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>




<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            d) for each node in the group</span>
<span class="sd">                For each endpoint that is included in a boundary</span>
<span class="sd">                    i) Attempt to restrict the skeleton by X distance from that endoint </span>
<span class="sd">                    (if two small then pick other endpoint)</span>
<span class="sd">                    ii) Find the closest traingle face to that point on that branch mesh and use that</span>
<span class="sd">            &quot;&quot;&quot;</span>


    <span class="c1">#             blue_points = []</span>
    <span class="c1">#             red_points = []</span>

            <span class="n">processed_valid</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">curr_node_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;red&quot;</span><span class="p">]</span>
            <span class="n">blue_red_points</span> <span class="o">=</span> <span class="p">[[],[]]</span>
            

            <span class="k">if</span> <span class="n">only_outermost_branches</span><span class="p">:</span>
                <span class="n">error_branches_to_skip</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">upstream_branches_in_branches_list</span><span class="p">(</span>
                                            <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">,</span>
                                            <span class="n">branches</span> <span class="o">=</span> <span class="n">error_border_branches</span><span class="p">,</span>
                                            <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error_branches_to_skip = </span><span class="si">{</span><span class="n">error_branches_to_skip</span><span class="si">}</span><span class="s2"> after upsream branches in branches list&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">error_branches_to_skip</span> <span class="o">=</span> <span class="p">[]</span>


<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            10/5 Edit: making the min error downstream just part of the skip branches</span>
<span class="sd">            </span>
<span class="sd">            Old way ---------- </span>
<span class="sd">            if min_error_downstream_length_total is not None:</span>
<span class="sd">                error_border_branches_down_len = np.array([nst.skeletal_length_downstream_total(curr_limb,n)</span>
<span class="sd">                                                 for n in error_border_branches if n &gt;= 0])</span>
<span class="sd">                if len(error_border_branches_down_len) == 0 or np.sum(error_border_branches_down_len&gt;=min_error_downstream_length_total) == 0:</span>
<span class="sd">                    #print(f&quot;changing min_error_downstream_length_total to None because otherwise no red points&quot;)</span>
<span class="sd">                    min_error_downstream_length_total = None</span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="n">e_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">error_border_branches</span><span class="p">)</span>
            <span class="n">e_nodes</span> <span class="o">=</span> <span class="n">e_nodes</span><span class="p">[</span><span class="n">e_nodes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">min_error_downstream_length_total</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">possible_skip_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error_border_branches</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">error_border_branches</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
                
                <span class="n">error_border_branches_down_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_downstream_total</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
                                                 <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">possible_skip_nodes</span><span class="p">])</span>
                
                
                <span class="n">filtered_skip_nodes</span> <span class="o">=</span> <span class="n">possible_skip_nodes</span><span class="p">[</span><span class="n">error_border_branches_down_len</span><span class="o">&lt;=</span><span class="n">min_error_downstream_length_total</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtered_skip_nodes according to min_error_downstream_length_total (</span><span class="si">{</span><span class="n">min_error_downstream_length_total</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">filtered_skip_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="c1"># --- 10/7 Addition: Making sure not going to skip any starting nodes or those with downstream nodes ----</span>
                <span class="c1"># ---- don&#39;t need the number of downstream ones because downstream skeleton already acccounts for it ---------</span>
<span class="c1">#                 filtered_skip_nodes_n_downstream = np.array([nru.n_downstream_nodes(curr_limb,k) for k in filtered_skip_nodes])</span>
<span class="c1">#                 filtered_skip_nodes_with_downstream = filtered_skip_nodes[filtered_skip_nodes_n_downstream &gt; 0]</span>
<span class="c1">#                 nodes_not_to_skip = np.concatenate([curr_limb.all_starting_nodes,filtered_skip_nodes_with_downstream])</span>

                <span class="c1">## nodes skipping: starting nodes</span>

                <span class="n">nodes_not_to_skip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_starting_nodes</span><span class="p">,</span>
                            <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">filtered_skip_nodes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">all_starting_nodes</span><span class="p">,</span>
                            <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">k</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_not_to_skip= </span><span class="si">{</span><span class="n">nodes_not_to_skip</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">filtered_skip_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">filtered_skip_nodes</span><span class="p">,</span><span class="n">nodes_not_to_skip</span><span class="p">)</span>
                
                <span class="c1"># need to filter for </span>
                
                <span class="c1">#if len(possible_skip_nodes) &gt; len(filtered_skip_nodes): </span>
                <span class="n">new_total_error_branches_to_skip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">error_branches_to_skip</span><span class="p">,</span><span class="n">filtered_skip_nodes</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_skip_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">e_nodes</span><span class="p">,</span><span class="n">new_total_error_branches_to_skip</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                    <span class="n">error_branches_to_skip</span> <span class="o">=</span> <span class="n">new_total_error_branches_to_skip</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Because of min_error_downstream_length_total = </span><span class="si">{</span><span class="n">min_error_downstream_length_total</span><span class="si">}</span><span class="s2">&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> --&gt; Expanding to skip nodes to </span><span class="si">{</span><span class="n">error_branches_to_skip</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">                    </span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            10/5 Addition: Will compute the number of branches to be processed</span>
<span class="sd">            and whether a double point needs to be layed down</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">v_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">valid_upstream_branches</span><span class="p">)</span>
            <span class="n">v_nodes</span> <span class="o">=</span> <span class="n">v_nodes</span><span class="p">[</span><span class="n">v_nodes</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">e_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">e_nodes</span><span class="p">,</span><span class="n">error_branches_to_skip</span><span class="p">)</span>
            
            <span class="n">double_point_flags</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
                                <span class="k">for</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v_nodes</span><span class="p">,</span><span class="n">e_nodes</span><span class="p">]]</span>
            
<span class="c1">#             su.compressed_pickle(curr_limb,&quot;curr_limb&quot;)</span>
<span class="c1">#             raise Exception(&quot;&quot;)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before laying down points&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;valid nodes to process: </span><span class="si">{</span><span class="n">v_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error nodes to process: </span><span class="si">{</span><span class="n">e_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;double_point_flags = </span><span class="si">{</span><span class="n">double_point_flags</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="k">for</span> <span class="n">y</span><span class="p">,(</span><span class="n">v</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">coord</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">valid_upstream_branches</span><span class="p">,</span>
                                 <span class="n">error_border_branches</span><span class="p">,</span>
                                <span class="n">error_border_coordinates</span><span class="p">)):</span>
                <span class="n">curr_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="n">e</span><span class="p">]</span>
                
                <span class="n">downstream_flag</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">add_additional_point_to_no_children_branches</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">downstream_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">e_nodes</span><span class="p">,</span>
                                                       <span class="n">nru</span><span class="o">.</span><span class="n">all_downstream_branches</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_errors = </span><span class="si">{</span><span class="n">downstream_errors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">downstream_flag</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For Pair </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">: coordinate </span><span class="si">{</span><span class="n">coord</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">n</span><span class="p">,</span><span class="n">lab</span><span class="p">,</span><span class="n">off_dist</span><span class="p">,</span><span class="n">n_pts</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">curr_nodes</span><span class="p">,[</span><span class="s2">&quot;valid&quot;</span><span class="p">,</span><span class="s2">&quot;error&quot;</span><span class="p">],</span>
                                                        <span class="p">[</span><span class="n">offset_distance_for_points_valid</span><span class="p">,</span><span class="n">offset_distance_for_points_error</span><span class="p">],</span>
                                                       <span class="p">[</span><span class="n">n_blue_points</span><span class="p">,</span><span class="n">n_red_points</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">processed_valid</span><span class="p">:</span>
                        <span class="k">continue</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    - 5/10 Addition: Accounts for if the error node is the starting node</span>

<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                        <span class="n">blue_red_points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">error_branches_to_skip</span><span class="p">:</span>
                        <span class="k">continue</span>
                        
                    <span class="c1"># 10 /5 </span>
                    <span class="n">dp_flag</span> <span class="o">=</span> <span class="n">double_point_flags</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    
                    
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">dp_flag</span> <span class="ow">or</span> <span class="p">(</span><span class="n">downstream_flag</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">and</span> <span class="n">n_pts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incrementing the number of points&quot;</span><span class="p">)</span>
                        <span class="n">local_n_points</span> <span class="o">=</span> <span class="n">n_pts</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">local_n_points</span> <span class="o">=</span> <span class="n">n_pts</span>

<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    if min_error_downstream_length_total is not None and lab == &quot;error&quot;:</span>
<span class="sd">                        total_downstream_length = nst.skeletal_length_downstream_total(curr_limb,n)</span>
<span class="sd">                        #print(f&quot;total_downstream_length = {total_downstream_length}&quot;)</span>
<span class="sd">                        if total_downstream_length &lt; min_error_downstream_length_total:</span>
<span class="sd">                            if verbose:</span>
<span class="sd">                                print(f&quot;Skipping node {n} because total_downstream_length ({total_downstream_length}) less than min_error_downstream_length_total ({min_error_downstream_length_total})&quot;)</span>
<span class="sd">                            continue</span>
<span class="sd">                            </span>
<span class="sd">                    &quot;&quot;&quot;</span>

                    <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    ---5/12: Where can lay down multiple points</span>

<span class="sd">                    &quot;&quot;&quot;</span>
<span class="w">                    </span>
<span class="w">                    </span><span class="sd">&#39;&#39;&#39;  OLD WAY OF LAYING DOWN POINTS</span>
<span class="sd">                    tried_offsets = [0]</span>
<span class="sd">                    n_fails = 3</span>
<span class="sd">                    for point_idx in range(1,local_n_points+1):</span>
<span class="sd">                        if tried_offsets[-1] == np.max(tried_offsets):</span>
<span class="sd">                            curr_offset = tried_offsets[-1] + offset_distance_for_points</span>
<span class="sd">                        else:</span>
<span class="sd">                            curr_offset = (tried_offsets[-1] + tried_offsets[-2])/2</span>


<span class="sd">                        sk_point,success = sk.skeleton_coordinate_offset_from_endpoint(branch_obj.skeleton,</span>
<span class="sd">                                                        coord,</span>
<span class="sd">                                                        offset_distance=curr_offset,</span>
<span class="sd">                                                        return_success = True)</span>

<span class="sd">                        for jj in range(n_fails):</span>
<span class="sd">                            if success:</span>
<span class="sd">                                break</span>
<span class="sd">                            curr_offset = (curr_offset + tried_offsets[-1])/2</span>
<span class="sd">                            sk_point,success = sk.skeleton_coordinate_offset_from_endpoint(branch_obj.skeleton,</span>
<span class="sd">                                                        coord,</span>
<span class="sd">                                                        offset_distance=curr_offset,</span>
<span class="sd">                                                        return_success = True)</span>
<span class="sd">                        #print(f&quot;For point {point_idx}: curr_offset = {curr_offset}&quot;)</span>
<span class="sd">                        tried_offsets.append(curr_offset)</span>
<span class="sd">                        </span>

<span class="sd">                        if red_blue_points_method == &quot;skeleton&quot;:</span>
<span class="sd">                            curr_points = np.array(sk_point).reshape(-1,3)</span>

<span class="sd">                        elif red_blue_points_method == &quot;closest_mesh_face&quot;:</span>
<span class="sd">                            curr_points = np.array(tu.closest_face_to_coordinate(branch_obj.mesh,sk_point,</span>
<span class="sd">                                             return_face_coordinate=True)).reshape(-1,3)</span>
<span class="sd">                        else:</span>
<span class="sd">                            raise Exception(f&quot;Unimplemented red_blue_points_method {red_blue_points_method}&quot;)</span>

<span class="sd">                        if verbose:</span>
<span class="sd">                            print(f&quot;{curr_node_names[j]} {n} node offset skeleton coordinate is {sk_point}&quot;)</span>
<span class="sd">                            print(f&quot; --&gt; using {red_blue_points_method} method curr_points = {curr_points}&quot;)</span>


<span class="sd">                        blue_red_points[j].append(curr_points)</span>
<span class="sd">                        </span>
<span class="sd">                        &#39;&#39;&#39;</span>
                    
                    
                    
                    <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span>
                    
                    
                    <span class="k">if</span> <span class="n">min_cancel_distance_absolute_all_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_cancel_distance_absolute_all_points</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">blue_red_combined</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blue_red_points</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">faces_farther_than_distance_of_coordinates</span><span class="p">(</span>
                                            <span class="n">mesh_to_map</span><span class="p">,</span>
                                            <span class="n">coordinate</span> <span class="o">=</span> <span class="n">blue_red_combined</span><span class="p">,</span>
                                            <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">min_cancel_distance_absolute_all_points</span><span class="p">,</span>
                                            <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span>
                                        <span class="p">)</span>
                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_to_map</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_neighbors_mesh</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                    <span class="n">n</span><span class="p">,</span>
                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                   <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">break</span>
                            
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">break</span>

                    
                    <span class="n">point_array</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">coordinates_along_skeleton_offset_from_start</span><span class="p">(</span>
                        <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                        <span class="n">coord</span><span class="p">,</span>
                            <span class="n">offset</span> <span class="o">=</span> <span class="n">off_dist</span><span class="p">,</span>
                            <span class="n">n_points</span> <span class="o">=</span> <span class="n">local_n_points</span><span class="p">,</span>
                            <span class="n">plot_points</span><span class="o">=</span><span class="kc">False</span>
                        <span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;point_array= </span><span class="si">{</span><span class="n">point_array</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
                        
                    
                    <span class="k">if</span> <span class="n">local_n_points</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">min_cancel_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">all_pairwise_distances_between_coordinates</span><span class="p">(</span><span class="n">point_array</span><span class="p">))</span>
                        
                        <span class="k">if</span> <span class="n">min_cancel_distance_absolute</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deciding between min_cancel_distance = </span><span class="si">{</span><span class="n">min_cancel_distance</span><span class="si">}</span><span class="s2">, and min_cancel_distance_absolute = </span><span class="si">{</span><span class="n">min_cancel_distance_absolute</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">min_cancel_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">min_cancel_distance_absolute</span><span class="p">,</span><span class="n">min_cancel_distance</span><span class="p">])</span>
                            
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After min: min_cancel_distance = </span><span class="si">{</span><span class="n">min_cancel_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">sk_point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point_array</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">tu</span><span class="o">.</span><span class="n">n_faces</span><span class="p">(</span><span class="n">mesh_to_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1">#raise Exception(&quot;mesh_to_map empty&quot;)</span>
                            <span class="n">use_mesh_map</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">use_mesh_map</span> <span class="o">=</span> <span class="kc">True</span>
                        
                        <span class="k">if</span> <span class="n">red_blue_points_method</span> <span class="o">==</span> <span class="s2">&quot;skeleton&quot;</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_mesh_map</span><span class="p">:</span>
                            <span class="n">curr_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk_point</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

                        <span class="k">elif</span> <span class="n">red_blue_points_method</span> <span class="o">==</span> <span class="s2">&quot;closest_mesh_face&quot;</span><span class="p">:</span>
                            <span class="n">curr_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tu</span><span class="o">.</span><span class="n">closest_face_to_coordinate</span><span class="p">(</span><span class="n">mesh_to_map</span><span class="p">,</span><span class="n">sk_point</span><span class="p">,</span>
                                             <span class="n">return_face_coordinate</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented red_blue_points_method </span><span class="si">{</span><span class="n">red_blue_points_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">curr_node_names</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> node offset skeleton coordinate is </span><span class="si">{</span><span class="n">sk_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; --&gt; using </span><span class="si">{</span><span class="n">red_blue_points_method</span><span class="si">}</span><span class="s2"> method curr_points = </span><span class="si">{</span><span class="n">curr_points</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
                        <span class="c1"># check to see if the point already exists</span>
                        <span class="n">blue_red_points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_points</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">local_n_points</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">use_mesh_map</span><span class="p">:</span>
                            <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">faces_farther_than_distance_of_coordinates</span><span class="p">(</span>
                                <span class="n">mesh_to_map</span><span class="p">,</span>
                                <span class="n">coordinate</span> <span class="o">=</span> <span class="n">blue_red_points</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">min_cancel_distance</span><span class="p">,</span>
                                <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="p">)</span>
                            
                            <span class="k">if</span> <span class="n">tu</span><span class="o">.</span><span class="n">n_faces</span><span class="p">(</span><span class="n">mesh_to_map</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Having to use surrounding neighbors mesh &quot;</span><span class="p">)</span>
                                <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_neighbors_mesh</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                <span class="n">n</span><span class="p">,</span>
                                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                               <span class="p">)</span>
                                
                                <span class="k">if</span> <span class="n">min_cancel_distance_absolute_all_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_cancel_distance_absolute_all_points</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">blue_red_combined</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">blue_red_points</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

                                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                            <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">faces_farther_than_distance_of_coordinates</span><span class="p">(</span>
                                                    <span class="n">mesh_to_map</span><span class="p">,</span>
                                                    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">blue_red_combined</span><span class="p">,</span>
                                                    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">min_cancel_distance_absolute_all_points</span><span class="p">,</span>
                                                    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span>
                                                <span class="p">)</span>
<span class="w">                                    </span>
<span class="w">                                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                                Old way: </span>
<span class="sd">                                for jj_old in range(0,j+1):</span>
<span class="sd">                                    mesh_to_map = tu.faces_farther_than_distance_of_coordinates(</span>
<span class="sd">                                        mesh_to_map,</span>
<span class="sd">                                        coordinate = sk_point,</span>
<span class="sd">                                        distance_threshold = min_cancel_distance,</span>
<span class="sd">                                        return_mesh = True</span>
<span class="sd">                                    )</span>
<span class="sd">                                &quot;&quot;&quot;</span>
                                
                                
                                <span class="n">mesh_to_map</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">faces_farther_than_distance_of_coordinates</span><span class="p">(</span>
                                    <span class="n">mesh_to_map</span><span class="p">,</span>
                                    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">blue_red_points</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                                    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">min_cancel_distance</span><span class="p">,</span>
                                    <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="p">)</span>
                        
                        
                        

                    <span class="c1">#print(f&quot;blue_red_points = {blue_red_points}&quot;)</span>

                <span class="n">processed_valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">final_blue_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">final_blue_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                
            <span class="n">final_red_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">blue_red_points</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_blue_points = </span><span class="si">{</span><span class="n">final_blue_points</span><span class="si">}</span><span class="s2">, voxels = </span><span class="si">{</span><span class="n">final_blue_points</span><span class="o">/</span><span class="n">vdi</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_red_points = </span><span class="si">{</span><span class="n">final_red_points</span><span class="si">}</span><span class="s2">, voxels = </span><span class="si">{</span><span class="n">final_blue_points</span><span class="o">/</span><span class="n">vdi</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            
            
            <span class="n">curr_conn_comp_div</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_downstream_branches_from_multiple_branhes</span><span class="p">(</span>
                                    <span class="n">curr_limb</span><span class="p">,</span>
                                    <span class="n">branches_idx</span><span class="o">=</span><span class="n">error_border_branches</span><span class="p">,</span>
                                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_final_blue_red_points</span> <span class="ow">and</span> <span class="n">n_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">limb_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_path</span><span class="p">(</span><span class="n">n_obj</span><span class="p">,</span>
                                      <span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span>
                                      <span class="n">path</span><span class="o">=</span><span class="n">curr_conn_comp_div</span><span class="p">,</span>
                                      <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">final_blue_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                                               <span class="n">final_red_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                                      <span class="n">scatter_color_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
                                      <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">)</span>


            <span class="n">error_branches_skeleton_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> 
                                                     <span class="k">for</span>  <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_conn_comp_div</span><span class="p">])</span>
            
            

            <span class="k">try</span><span class="p">:</span>
                <span class="n">parent_branch</span> <span class="o">=</span> <span class="n">valid_upstream_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">parent_branch_width</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">parent_branch</span><span class="p">])</span>
                <span class="n">parent_branch_axon</span> <span class="o">=</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">parent_branch</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">parent_branch</span> <span class="o">=</span> <span class="n">error_border_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">parent_branch_width</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">parent_branch</span><span class="p">])</span>
                <span class="n">parent_branch_axon</span> <span class="o">=</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">parent_branch</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span>
                
            <span class="n">e_branches_for_syns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_conn_comp_div</span><span class="p">)</span>
            <span class="n">e_branches_for_syns</span> <span class="o">=</span> <span class="n">e_branches_for_syns</span><span class="p">[</span><span class="n">e_branches_for_syns</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e_branches_for_syns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">e_branches_for_syns</span><span class="p">)</span>

            <span class="n">v_branches_for_syns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_nodes</span><span class="p">)</span>
            <span class="n">v_branches_for_syns</span> <span class="o">=</span> <span class="n">v_branches_for_syns</span><span class="p">[</span><span class="n">v_branches_for_syns</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v_branches_for_syns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">v_branches_for_syns</span><span class="p">)</span>

            <span class="n">curr_local_red_blue</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">error_branches</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">e_branches_for_syns</span><span class="p">),</span>
                                                                     <span class="n">error_branches_skeleton_length</span> <span class="o">=</span> <span class="n">error_branches_skeleton_length</span><span class="p">,</span>
                                                                     <span class="n">valid_branches</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_branches_for_syns</span><span class="p">),</span>
                                                                     <span class="n">parent_branch</span> <span class="o">=</span> <span class="n">parent_branch</span><span class="p">,</span>
                                                                     <span class="n">parent_branch_width</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">parent_branch</span><span class="p">]),</span>
                                                                     <span class="n">parent_branch_axon</span> <span class="o">=</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">parent_branch</span><span class="p">]</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span>
                                                                     <span class="n">n_error_branches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">e_branches_for_syns</span><span class="p">),</span>
                                                                   <span class="n">valid_points</span> <span class="o">=</span> <span class="n">final_blue_points</span><span class="p">,</span>
                                                                   <span class="n">error_points</span> <span class="o">=</span> <span class="n">final_red_points</span><span class="p">,</span>
                                       <span class="n">coordinate</span> <span class="o">=</span> <span class="n">coord</span><span class="p">,</span>
                                      <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_error_skeleton_points</span><span class="p">:</span>
                <span class="n">curr_local_red_blue</span><span class="p">[</span><span class="s2">&quot;error_branches_skeleton_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_nodes_from_branches_on_limb</span><span class="p">(</span>
                                                    <span class="n">curr_limb</span><span class="p">,</span>
                                                    <span class="n">curr_conn_comp_div</span><span class="p">,</span>
                                                    <span class="n">plot_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="p">)</span>
                
            <span class="k">if</span> <span class="n">return_synapse_points</span><span class="p">:</span>
                
                <span class="k">for</span> <span class="n">b_type</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;error&quot;</span><span class="p">,</span><span class="s2">&quot;valid&quot;</span><span class="p">],[</span><span class="n">e_branches_for_syns</span><span class="p">,</span><span class="n">v_branches_for_syns</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">syn_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pre&quot;</span><span class="p">,</span><span class="s2">&quot;post&quot;</span><span class="p">]:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b_type</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">syn_type</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">curr_syns</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">curr_syns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">bidx</span><span class="p">],</span><span class="sa">f</span><span class="s2">&quot;synapses_</span><span class="si">{</span><span class="n">syn_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">bidx</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
                        
                        <span class="n">curr_local_red_blue</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_ids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">syn_id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">curr_syns</span><span class="p">])</span>
                        <span class="n">curr_local_red_blue</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coordinate</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">curr_syns</span><span class="p">])</span>
                
                
            <span class="n">local_red_blue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_local_red_blue</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">split_red_blue_by_common_upstream</span><span class="p">:</span>
            <span class="n">red_blue_dict</span><span class="p">[</span><span class="n">conn_comp_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_red_blue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">red_blue_dict</span><span class="p">[</span><span class="n">conn_comp_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_red_blue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">red_blue_dict</span></div>

<div class="viewcode-block" id="limb_branch_dict_to_cancel_to_red_blue_groups"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.limb_branch_dict_to_cancel_to_red_blue_groups">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dict_to_cancel_to_red_blue_groups</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                  <span class="n">limb_branch_dict_to_cancel</span><span class="p">,</span>
                                                <span class="n">plot_error_graph_before_create_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">plot_error_branches</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">created_edges</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="n">plot_error_graph_after_create_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

                                                <span class="n">plot_error_connected_components</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="c1">#                                                 include_one_hop_downstream_error_branches = True,</span>
<span class="c1">#                                                 one_hop_downstream_error_branches_max_distance = 4_000,#10_000,</span>

<span class="c1">#                                                 offset_distance_for_points = 3_000,#500,#1000,</span>
<span class="c1">#                                                 n_points = 1,#3,</span>
<span class="c1">#                                                 red_blue_points_method = &quot;closest_mesh_face&quot;, #other options: &quot;skeleton&quot;,</span>
                                                
                                                  <span class="n">plot_final_blue_red_points</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                                                <span class="n">plot_all_blue_red_groups</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">pair_conn_comp_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  
                                                  <span class="n">return_error_skeleton_points</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create groups that should be split using blue and red team</span>
<span class="sd">    and then find the split points</span>


<span class="sd">    Psuedocode: </span>

<span class="sd">    For each limb: </span>
<span class="sd">    0a) Get subgraph of error branches</span>
<span class="sd">    0b) Add any edges that were created that are</span>
<span class="sd">    between these error branches</span>
<span class="sd">    1) Find the connected components of error branches</span>
<span class="sd">    2) For each connected component we will build a red and a blue team</span>

<span class="sd">    a) find all upstream nodes of error branches THAT AREN&#39;T ERRORS:</span>
<span class="sd">    -&gt; include the error branches hat these upstream valid branches came from and the </span>
<span class="sd">    skeleton point that connectes them</span>

<span class="sd">    b) Find all valid downstream nodes from te upstream valid ones</span>
<span class="sd">    --. include te skeleton points that connect them</span>

<span class="sd">    c) Optional: Choose the downstream error branches of current boundary error branches</span>

<span class="sd">    At this point: Have the red and blue branches and the connecting points</span>


<span class="sd">    d) for each node in the group</span>
<span class="sd">        For each endpoint that is included in a boundary</span>
<span class="sd">            i) Attempt to restrict the skeleton by X distance from that endoint </span>
<span class="sd">            (if two small then pick other endpoint)</span>
<span class="sd">            ii) Find the closest traingle face to that point on that branch mesh and use that</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>




    <span class="n">error_limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict_to_cancel</span><span class="c1"># axon_merge_error_limb_branch_dict</span>
    <span class="n">error_limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_after_limb_branch_removal</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">error_limb_branch_dict</span><span class="p">,</span>
                                 <span class="n">return_removed_limb_branch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>
    
    <span class="n">n_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span> <span class="c1">#neuron_obj_high_fidelity_axon</span>

    <span class="k">if</span> <span class="n">created_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">created_edges</span> <span class="o">=</span> <span class="p">[]</span>




    <span class="n">limb_to_red_blue_groups</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1">#For each limb:</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">error_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

        <span class="n">limb_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">limb_to_red_blue_groups</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- Working on </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> --&quot;</span><span class="p">)</span>
            
        <span class="c1">#getting the error branches</span>
        <span class="n">error_branches</span> <span class="o">=</span> <span class="n">error_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">n_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>

        <span class="n">limb_to_red_blue_groups</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">limb_errors_to_cancel_to_red_blue_group</span><span class="p">(</span>
                                                    <span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">error_branches</span><span class="p">,</span>
                                                    <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">n_obj</span><span class="p">,</span>

                                                    <span class="n">plot_error_graph_before_create_edges</span> <span class="o">=</span> <span class="n">plot_error_graph_before_create_edges</span><span class="p">,</span>
                                                    <span class="n">plot_error_branches</span> <span class="o">=</span> <span class="n">plot_error_branches</span><span class="p">,</span>
                                                    <span class="n">created_edges</span> <span class="o">=</span> <span class="n">created_edges</span><span class="p">,</span>
                                                    <span class="n">plot_error_graph_after_create_edges</span> <span class="o">=</span> <span class="n">plot_error_graph_after_create_edges</span><span class="p">,</span>

                                                    <span class="n">plot_error_connected_components</span> <span class="o">=</span> <span class="n">plot_error_connected_components</span><span class="p">,</span>
                                                    
<span class="c1">#                                                     include_one_hop_downstream_error_branches = include_one_hop_downstream_error_branches,</span>
<span class="c1">#                                                     one_hop_downstream_error_branches_max_distance = one_hop_downstream_error_branches_max_distance,</span>

<span class="c1">#                                                     offset_distance_for_points = offset_distance_for_points,#1000,</span>
<span class="c1">#                                                     n_points = n_points,</span>
<span class="c1">#                                                     red_blue_points_method = red_blue_points_method, #other options: &quot;skeleton&quot;,</span>
                                                    <span class="n">plot_final_blue_red_points</span> <span class="o">=</span> <span class="n">plot_final_blue_red_points</span><span class="p">,</span>
                                                    <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                                                    <span class="n">pair_conn_comp_errors</span> <span class="o">=</span> <span class="n">pair_conn_comp_errors</span><span class="p">,</span>
                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                    <span class="n">return_error_skeleton_points</span> <span class="o">=</span> <span class="n">return_error_skeleton_points</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span>
                                                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_all_blue_red_groups</span><span class="p">:</span>
        <span class="n">pru</span><span class="o">.</span><span class="n">plot_limb_to_red_blue_groups</span><span class="p">(</span><span class="n">n_obj</span><span class="p">,</span>
                                    <span class="n">limb_to_red_blue_groups</span><span class="p">,</span>
                                    <span class="n">error_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                    <span class="n">valid_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                                    <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">)</span>   
        
    <span class="k">return</span> <span class="n">limb_to_red_blue_groups</span></div>

<div class="viewcode-block" id="valid_synapse_records_to_unique_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.valid_synapse_records_to_unique_synapse_df">[docs]</a><span class="k">def</span> <span class="nf">valid_synapse_records_to_unique_synapse_df</span><span class="p">(</span><span class="n">synapse_records</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To turn the records of the synapses into a dataframe of the unique synapses</span>
<span class="sd">    </span>
<span class="sd">    Application: For turning the synapse filtering output into a valid dataframe</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    pru.valid_synapse_records_to_unique_synapse_df(keys_to_write_without_version)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">synapse_records</span><span class="p">)</span>
    <span class="n">v_synapse_ids</span><span class="p">,</span> <span class="n">v_synapse_id_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">curr_df</span><span class="p">[</span><span class="s2">&quot;synapse_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v_synapse_ids_unique</span> <span class="o">=</span> <span class="n">v_synapse_ids</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">v_synapse_id_counts</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">curr_df_unique</span> <span class="o">=</span> <span class="n">curr_df</span><span class="p">[</span><span class="n">curr_df</span><span class="p">[</span><span class="s2">&quot;synapse_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">v_synapse_ids_unique</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">curr_df_unique</span></div>


<span class="c1"># ------------- Version 4 Rules ----------------- </span>
<div class="viewcode-block" id="filter_away_small_axon_fork_divergence"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_small_axon_fork_divergence">[docs]</a><span class="k">def</span> <span class="nf">filter_away_small_axon_fork_divergence</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">axon_fork_divergence_errors_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_webbing_t_merges"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_webbing_t_merges">[docs]</a><span class="k">def</span> <span class="nf">filter_away_webbing_t_merges</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">webbing_t_errors_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_high_degree_branching"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_high_degree_branching">[docs]</a><span class="k">def</span> <span class="nf">filter_away_high_degree_branching</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">high_degree_branch_errors_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_high_degree_branching_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_high_degree_branching_dendrite">[docs]</a><span class="k">def</span> <span class="nf">filter_away_high_degree_branching_dendrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">high_degree_branch_errors_dendrite_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_thick_t_merge"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_thick_t_merge">[docs]</a><span class="k">def</span> <span class="nf">filter_away_thick_t_merge</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">thick_t_errors_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>




<span class="n">exc_axon_on_dendrite_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;axon_on_dendrite_merges&quot;</span><span class="p">,</span>
                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_axon_on_dendrite_merges_old</span><span class="p">,</span>
                                         <span class="nb">dict</span><span class="p">(</span><span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                              
                                        <span class="p">)</span>
    
<span class="n">exc_double_back_and_width_change_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_and_width_change&quot;</span><span class="p">,</span>
                                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_large_double_back_or_width_changes</span><span class="p">,</span>
                                                      <span class="nb">dict</span><span class="p">(</span><span class="n">perform_double_back_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                          <span class="n">skip_double_back_errors_for_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                          <span class="c1">#double_back_threshold = 140,</span>

                                                           <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">250</span><span class="p">,</span>
                                                           <span class="n">running_width_jump_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 


                                                           <span class="n">double_back_axon_like_threshold</span><span class="o">=</span><span class="mi">145</span><span class="p">,</span>
                                                           <span class="c1">#double_back_axon_like_threshold=130,</span>
                                                           <span class="c1">#axon_comparison_distance = 1500,</span>
                                                           <span class="c1">#double_back_threshold = 115,</span>
                                                           <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>

                                                           <span class="c1">#allow_axon_double_back_angle_with_top = 39,</span>
                                                           <span class="n">allow_axon_double_back_angle_with_top</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                           <span class="c1">#allow_axon_double_back_angle_with_top_width_min = 140,</span>
                                                           <span class="n">allow_axon_double_back_angle_with_top_width_min</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
                                                           <span class="n">skeletal_length_to_skip</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
                                                           <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>


                                                            <span class="n">perform_width_errors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">perform_axon_width_errors</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                           

                                                          <span class="p">),</span>
                                                               <span class="n">catch_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="p">)</span>

<span class="n">exc_axon_fork_divergence_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;axon_fork_divergence&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_small_axon_fork_divergence</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">(</span><span class="n">divergence_threshold_mean</span><span class="o">=</span><span class="mi">165</span><span class="p">)</span>

                                    <span class="p">)</span>
<span class="n">exc_axon_webbing_t_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;axon_webbing_t_merges&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_webbing_t_merges</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">(</span><span class="n">child_width_maximum</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                        <span class="n">parent_width_maximum</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span>
                                         <span class="n">axon_only</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="n">error_if_web_is_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">web_size_threshold</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span>
                                        <span class="n">web_size_type</span><span class="o">=</span><span class="s2">&quot;ray_trace_median&quot;</span><span class="p">,</span>
                                        <span class="n">web_above_threshold</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,)</span>

                                    <span class="p">)</span>

<span class="c1">#     exc_crossovers_filter = pru.make_filter_dict(&quot;crossovers&quot;,</span>
<span class="c1">#                                                          pru.filter_away_crossovers,</span>
<span class="c1">#                                                           dict(axon_dependent=True,</span>
<span class="c1">#                                                               match_threshold = 30,</span>
<span class="c1">#                                                               comparison_distance = 2500,</span>
<span class="c1">#                                                               offset=2000,)</span>
<span class="c1">#                                                          )</span>

<span class="n">exc_high_degree_branching_filter_old</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_branching&quot;</span><span class="p">,</span>
                                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching</span><span class="p">,</span>
                                                      <span class="nb">dict</span><span class="p">(</span>
                                                          <span class="c1">#arguments for the angle checking</span>
                                                        <span class="n">offset</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
                                                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                                                        <span class="n">worst_case_sk_angle_match_threshold</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>

                                                        <span class="c1">#args for width matching</span>
                                                        <span class="n">width_diff_max</span> <span class="o">=</span> <span class="mi">75</span><span class="p">,</span><span class="c1">#np.inf,#100,</span>
                                                        <span class="n">width_diff_perc</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>

                                                        <span class="c1">#args for definite pairs</span>
                                                        <span class="n">sk_angle_match_threshold</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
                                                        <span class="n">sk_angle_buffer</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>

                                                        <span class="n">max_degree_to_resolve</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
                                                        <span class="n">max_degree_to_resolve_wide</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>

                                                        <span class="c1">#args for picking the final winner</span>
                                                        <span class="n">match_method</span> <span class="o">=</span> <span class="s2">&quot;best_match&quot;</span><span class="p">,</span> <span class="c1">#other option is &quot;best_match&quot;</span>
                                                          
                                                        <span class="n">kiss_check</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">kiss_check_bbox_longest_side_threshold</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span>

                                                      <span class="p">),</span>
                                                         <span class="n">catch_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                     <span class="p">)</span>

<span class="n">exc_thick_t_merge_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;thick_t_merge&quot;</span><span class="p">,</span>
                            <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_thick_t_merge</span><span class="p">,</span>
                            <span class="nb">dict</span><span class="p">(</span>
                            
                            <span class="p">))</span>

<span class="n">exc_high_degree_coordinates_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_coordinates&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_coordinates</span><span class="p">,</span>
                                                          <span class="nb">dict</span><span class="p">(</span><span class="n">axon_dependent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">min_degree_to_find</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                                                         <span class="p">)</span>
    
<div class="viewcode-block" id="v4_exc_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v4_exc_filters">[docs]</a><span class="k">def</span> <span class="nf">v4_exc_filters</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v4 Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
        <span class="n">exc_high_degree_branching_filter_old</span><span class="p">,</span>
        <span class="n">exc_axon_webbing_t_merges_filter</span><span class="p">,</span>
        <span class="n">exc_thick_t_merge_filter</span><span class="p">,</span>
        <span class="n">exc_double_back_and_width_change_filter</span><span class="p">,</span>
        <span class="n">exc_axon_fork_divergence_filter</span><span class="p">,</span>
        <span class="c1">#exc_high_degree_coordinates_filter,</span>
    <span class="p">]</span>
    

    <span class="k">return</span> <span class="n">exc_filters</span></div>


<div class="viewcode-block" id="extract_from_filter_info"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.extract_from_filter_info">[docs]</a><span class="k">def</span> <span class="nf">extract_from_filter_info</span><span class="p">(</span><span class="n">filter_info</span><span class="p">,</span>
                            <span class="c1">#name_to_extract=&quot;limb_branch_dict_to_cancel&quot;</span>
                            <span class="n">name_to_extract</span> <span class="o">=</span> <span class="s2">&quot;red_blue_suggestions&quot;</span><span class="p">,</span>
                            <span class="n">name_must_be_ending</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    <span class="k">if</span> <span class="n">name_must_be_ending</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">filter_info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">name_to_extract</span><span class="p">):]</span> <span class="o">==</span> <span class="n">name_to_extract</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">filter_info</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name_to_extract</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span></div>

<div class="viewcode-block" id="extract_blue_red_points_from_limb_branch_dict_to_cancel"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.extract_blue_red_points_from_limb_branch_dict_to_cancel">[docs]</a><span class="k">def</span> <span class="nf">extract_blue_red_points_from_limb_branch_dict_to_cancel</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                           <span class="n">limb_branch_dict_to_cancel</span><span class="p">,):</span>
    <span class="n">total_limb_to_red_blue_groups</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_cancel_key</span><span class="p">,</span><span class="n">curr_limb_branch_dict</span> <span class="ow">in</span> <span class="n">limb_branch_dict_to_cancel</span><span class="o">.</span><span class="n">items</span><span class="p">():</span><span class="c1">#[&quot;axon_on_dendrite_merges_limb_branch_dict_to_cancel&quot;]</span>
        <span class="n">limb_to_red_blue_groups</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">limb_branch_dict_to_cancel_to_red_blue_groups</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                            <span class="n">limb_branch_dict_to_cancel</span><span class="o">=</span><span class="n">curr_limb_branch_dict</span><span class="p">,</span>
                                                        <span class="n">plot_all_blue_red_groups</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">limb_branch_st_idx</span> <span class="o">=</span> <span class="n">curr_cancel_key</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict_to_cancel&quot;</span><span class="p">)</span>

        <span class="n">total_limb_to_red_blue_groups</span><span class="p">[</span><span class="n">curr_cancel_key</span><span class="p">[:</span><span class="n">limb_branch_st_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">limb_to_red_blue_groups</span>

    <span class="k">return</span> <span class="n">total_limb_to_red_blue_groups</span></div>



<span class="c1"># ----------- 5/27: version 5 Additions with better width jump/ doubling back that is axon/dendrite specific ----</span>

<div class="viewcode-block" id="filter_away_width_jump_up_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_width_jump_up_dendrite">[docs]</a><span class="k">def</span> <span class="nf">filter_away_width_jump_up_dendrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">width_jump_up_dendrite</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">exc_width_jump_up_dendrite_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;width_jump_up_dendrite&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_width_jump_up_dendrite</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>

<div class="viewcode-block" id="filter_away_width_jump_up_axon"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_width_jump_up_axon">[docs]</a><span class="k">def</span> <span class="nf">filter_away_width_jump_up_axon</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">width_jump_up_axon</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">exc_width_jump_up_axon_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;width_jump_up_axon&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_width_jump_up_axon</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>


<div class="viewcode-block" id="filter_away_double_back_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_double_back_dendrite">[docs]</a><span class="k">def</span> <span class="nf">filter_away_double_back_dendrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">double_back_dendrite</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">exc_double_back_dendrite_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_dendrite&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_double_back_dendrite</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>

<div class="viewcode-block" id="filter_away_double_back_axon_thin"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_double_back_axon_thin">[docs]</a><span class="k">def</span> <span class="nf">filter_away_double_back_axon_thin</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">double_back_axon_thin</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">exc_double_back_axon_thin_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_axon_thin&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_double_back_axon_thin</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>

<div class="viewcode-block" id="filter_away_double_back_axon_thick"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_double_back_axon_thick">[docs]</a><span class="k">def</span> <span class="nf">filter_away_double_back_axon_thick</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">double_back_axon_thick</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">exc_double_back_axon_thick_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_axon_thick&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_double_back_axon_thick</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>


<div class="viewcode-block" id="v5_exc_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v5_exc_filters">[docs]</a><span class="k">def</span> <span class="nf">v5_exc_filters</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v5 Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
        <span class="n">exc_high_degree_branching_filter_old</span><span class="p">,</span>
        <span class="n">exc_axon_webbing_t_merges_filter</span><span class="p">,</span>
        <span class="n">exc_thick_t_merge_filter</span><span class="p">,</span>
        
        <span class="c1"># exc_double_back_and_width_change_filter,</span>
        
        <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
        <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
        <span class="n">exc_double_back_dendrite_filter</span><span class="p">(),</span>
        <span class="n">exc_double_back_axon_thin_filter</span><span class="p">,</span>
        <span class="n">exc_double_back_axon_thick_filter</span><span class="p">,</span>
        
        <span class="n">exc_axon_fork_divergence_filter</span><span class="p">,</span>
        <span class="c1">#exc_high_degree_coordinates_filter,</span>
    <span class="p">]</span>
    
    <span class="k">return</span> <span class="n">exc_filters</span></div>


<span class="c1"># --------------v6 excitatory filters ------------------ #</span>
<span class="n">exc_high_degree_branching_filter_v6</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_branching&quot;</span><span class="p">,</span>
                                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching</span><span class="p">,</span>
                                                      <span class="nb">dict</span><span class="p">(</span>
                                                          <span class="c1">#perform_synapse_filter = False</span>
                                                      <span class="p">),</span>
                                                         <span class="n">catch_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                     <span class="p">)</span>


<div class="viewcode-block" id="filter_away_low_degree_branching"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_low_degree_branching">[docs]</a><span class="k">def</span> <span class="nf">filter_away_low_degree_branching</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">ed</span><span class="o">.</span><span class="n">low_degree_branch_errors_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="n">exc_low_degree_branching_filter_v6</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_degree_branching&quot;</span><span class="p">,</span>
                                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_degree_branching</span><span class="p">,</span>
                                                      <span class="nb">dict</span><span class="p">(</span>
                                                          <span class="c1">#perform_synapse_filter = False</span>
                                                      <span class="p">),</span>
                                                         <span class="n">catch_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                     <span class="p">)</span>
<div class="viewcode-block" id="v6_exc_filters_old"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v6_exc_filters_old">[docs]</a><span class="k">def</span> <span class="nf">v6_exc_filters_old</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v6 Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
        <span class="n">exc_high_degree_branching_filter</span><span class="p">(),</span>
        <span class="n">exc_axon_webbing_t_merges_filter</span><span class="p">,</span>
        <span class="n">exc_thick_t_merge_filter</span><span class="p">,</span>
        
        <span class="c1"># exc_double_back_and_width_change_filter,</span>
        
        <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
        <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
        <span class="n">exc_double_back_dendrite_filter</span><span class="p">(),</span>
        <span class="n">exc_double_back_axon_thin_filter</span><span class="p">,</span>
        <span class="n">exc_double_back_axon_thick_filter</span><span class="p">,</span>
        
        <span class="n">exc_axon_fork_divergence_filter</span><span class="p">,</span>
        <span class="c1">#exc_high_degree_coordinates_filter,</span>
    <span class="p">]</span>
    
    <span class="k">return</span> <span class="n">exc_filters</span></div>


<div class="viewcode-block" id="v6_exc_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v6_exc_filters">[docs]</a><span class="k">def</span> <span class="nf">v6_exc_filters</span><span class="p">():</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v6 Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
        <span class="n">exc_high_degree_branching_filter</span><span class="p">(),</span>
        <span class="n">exc_low_degree_branching_filter</span><span class="p">(),</span>
        <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
        <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
        <span class="n">exc_double_back_dendrite_filter</span><span class="p">(),</span>
    <span class="p">]</span>
    
    <span class="k">return</span> <span class="n">exc_filters</span></div>
    

<span class="c1"># ----------------- 7/22 New Axon Preprocessing Filters ----------- #</span>
<div class="viewcode-block" id="filter_away_axon_on_dendrite_merges"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_axon_on_dendrite_merges">[docs]</a><span class="k">def</span> <span class="nf">filter_away_axon_on_dendrite_merges</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">au</span><span class="o">.</span><span class="n">axon_on_dendrite_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_dendrite_on_axon_merges"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_dendrite_on_axon_merges">[docs]</a><span class="k">def</span> <span class="nf">filter_away_dendrite_on_axon_merges</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">au</span><span class="o">.</span><span class="n">dendrite_on_axon_limb_branch_dict</span><span class="p">,</span>
                <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_exc_filters_high_fidelity_axon_preprocessing"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.get_exc_filters_high_fidelity_axon_preprocessing">[docs]</a><span class="k">def</span> <span class="nf">get_exc_filters_high_fidelity_axon_preprocessing</span><span class="p">():</span>
    <span class="n">exc_dendrite_on_axon_merges_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;dendrite_on_axon_merges&quot;</span><span class="p">,</span>
                                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_dendrite_on_axon_merges</span><span class="p">,</span>
                                                         <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">exc_dendrite_on_axon_merges_filter</span><span class="p">]</span></div>


<span class="c1"># ----------- Inhibitory Filters ------------------------</span>
<span class="c1"># corresponding to the function ed.high_degree_branch_errors_limb_branch_dict</span>
<span class="c1"># which calls on function: ed.high_degree_upstream_match</span>
<span class="n">inh_high_degree_branching_filter_v6</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_branching&quot;</span><span class="p">,</span>
                                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching</span><span class="p">,</span>
                                                      <span class="nb">dict</span><span class="p">(</span>
                                                          <span class="n">width_max</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span> <span class="c1">#setting the width max for crossovers a little smaller</span>
                                                          <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="mi">180</span><span class="p">,</span>
                                                      <span class="p">),</span>
                                                         <span class="n">catch_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                     <span class="p">)</span>




<span class="c1"># corresponding to the function ed.low_degree_branch_errors_limb_branch_dict</span>
<span class="c1"># which calls on function ed.low_degree_upstream_match</span>
<span class="c1"># inh_low_degree_branching_filter_v6 = pru.make_filter_dict(&quot;low_degree_branching&quot;,</span>
<span class="c1">#                                                      pru.filter_away_low_degree_branching,</span>
<span class="c1">#                                                       dict(</span>
<span class="c1">#                                                           #perform_synapse_filter = False</span>
<span class="c1">#                                                           width_max = 140,</span>
<span class="c1">#                                                           upstream_width_max = 180,</span>
<span class="c1">#                                                           max_degree_to_resolve_absolute = 5,</span>
<span class="c1">#                                                           filters_to_run = [</span>
<span class="c1">#                                                              gf.axon_webbing_filter,</span>
<span class="c1">#                                                              gf.thick_t_filter,</span>
<span class="c1">#                                                              #gf.axon_double_back_filter,</span>
<span class="c1">#                                                               gf.axon_double_back_inh_filter,</span>
<span class="c1">#                                                              gf.fork_divergence_filter,</span>
<span class="c1">#                                                              gf.fork_min_skeletal_distance_filter,</span>
                                                              
<span class="c1">#                                                           ]</span>
<span class="c1">#                                                       ),</span>
<span class="c1">#                                                          catch_error=False,</span>
<span class="c1">#                                                      )</span>

<div class="viewcode-block" id="v6_inh_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v6_inh_filters">[docs]</a><span class="k">def</span> <span class="nf">v6_inh_filters</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v6 INHIBITORY Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">inh_filters</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
        <span class="n">inh_high_degree_branching_filter</span><span class="p">(),</span>
        <span class="n">inh_low_degree_branching_filter</span><span class="p">(),</span>
        <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
        <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
        <span class="n">exc_double_back_dendrite_filter</span><span class="p">(),</span>
    <span class="p">]</span>
    
    <span class="k">return</span> <span class="n">inh_filters</span></div>


<div class="viewcode-block" id="proofread_neuron_full"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.proofread_neuron_full">[docs]</a><span class="k">def</span> <span class="nf">proofread_neuron_full</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    
    <span class="c1"># arguments for processing down in DecompositionCellType</span>
    <span class="n">cell_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">add_valid_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">validation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">add_spines</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">add_back_soma_synapses</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">perform_axon_processing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">return_after_axon_processing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1">#arguments for processing after DecompositionCellType to Proofread Neuron</span>
    <span class="n">plot_head_neck_shaft_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">plot_soma_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">proofread_verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose_outline</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_final_filtered_neuron</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_synapses_after_proofread</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">plot_compartments</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">plot_valid_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_error_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">return_filtering_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">debug_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_red_blue_splits</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_split_locations</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">filter_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    
    <span class="n">add_spine_distances</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">original_mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To proofread the neuron after it has already been:</span>
<span class="sd">    </span>
<span class="sd">    1) cell typed</span>
<span class="sd">    2) Found the axon (can be optionally performed)</span>
<span class="sd">    3) Synapses have been added (can be optionally performed)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">add_valid_synapses</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--Adding valid synapses&quot;</span><span class="p">)</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">add_synapses_to_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">validation</span> <span class="o">=</span> <span class="n">validation</span><span class="p">,</span>
                            <span class="n">verbose</span>  <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="p">,</span>
                            <span class="n">plot_valid_error_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">calculate_synapse_soma_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">add_valid_synapses</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                              <span class="n">add_error_synapses</span><span class="o">=</span><span class="kc">False</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done adding synapses: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">add_spines</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--Adding Spines:&quot;</span><span class="p">)</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">add_head_neck_shaft_spine_objs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                               <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                                                              <span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done adding spines: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--Calculating the cell type because was none &quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">baylor_e_i</span><span class="p">,</span><span class="n">baylor_cell_type_info</span> <span class="o">=</span> <span class="n">ctu</span><span class="o">.</span><span class="n">e_i_classification_from_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                                                     <span class="n">return_cell_type_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;baylor_e_i = </span><span class="si">{</span><span class="n">baylor_e_i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="n">baylor_e_i</span>
        
    
    <span class="k">if</span> <span class="n">perform_axon_processing</span><span class="p">:</span> 
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--Performing axon processing&quot;</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">neuron_obj</span><span class="p">,</span><span class="n">filtering_info_axon</span><span class="p">,</span><span class="n">axon_angles_dict</span><span class="o">=</span><span class="n">au</span><span class="o">.</span><span class="n">complete_axon_processing</span><span class="p">(</span>
                    <span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">cell_type</span> <span class="o">=</span> <span class="n">cell_type</span><span class="p">,</span>
                     <span class="n">add_synapses_and_head_neck_shaft_spines</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">validation</span> <span class="o">=</span> <span class="n">validation</span><span class="p">,</span>
                    <span class="n">plot_initial_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">plot_axon_on_dendrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">return_filtering_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">return_axon_angle_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Doen Axon Processing: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">return_after_axon_processing</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_obj</span>
            
    <span class="c1"># --- a) adding head neck shaft bouton labels (and setting the labels to synapses) ===</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- a) adding head neck shaft bouton labels (and setting the labels to synapses)&quot;</span><span class="p">)</span>

    <span class="n">spu</span><span class="o">.</span><span class="n">set_neuron_head_neck_shaft_idx</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">spu</span><span class="o">.</span><span class="n">set_neuron_synapses_head_neck_shaft</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">a) Time for head/neck/shaft/bouton labels and syn label: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_head_neck_shaft_synapses</span><span class="p">:</span>
        <span class="n">syu</span><span class="o">.</span><span class="n">plot_head_neck_shaft_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        
    
    <span class="c1"># ---- b) Adding Back the Soma Synapses -----</span>
    <span class="k">if</span> <span class="n">add_back_soma_synapses</span><span class="p">:</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---- b) Adding Back the Soma Synapses &quot;</span><span class="p">)</span>
        <span class="n">syu</span><span class="o">.</span><span class="n">add_valid_soma_synapses_to_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">b) Time for adding back soma synapses: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_soma_synapses</span><span class="p">:</span>
            <span class="n">syu</span><span class="o">.</span><span class="n">plot_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">total_synapses</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
    
    <span class="c1"># --- c) Proofreading the Neuron</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- c) Proofreading the Neuron&quot;</span><span class="p">)</span>

    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">high_fidelity_axon_on_excitatory</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">o_neuron</span><span class="p">,</span><span class="n">filtering_info</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">proofread_neuron_class_predetermined</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">inh_exc_class</span> <span class="o">=</span> <span class="n">cell_type</span><span class="p">,</span>
            <span class="n">plot_limb_branch_filter_with_disconnect_effect</span> <span class="o">=</span> <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">proofread_verbose</span><span class="p">,</span>
            <span class="n">verbose_outline</span> <span class="o">=</span> <span class="n">verbose_outline</span><span class="p">,</span>
            <span class="n">high_fidelity_axon_on_excitatory</span> <span class="o">=</span> <span class="n">high_fidelity_axon_on_excitatory</span><span class="p">,</span>
            <span class="n">plot_final_filtered_neuron</span> <span class="o">=</span> <span class="n">plot_final_filtered_neuron</span><span class="p">,</span>
            <span class="n">filter_list</span><span class="o">=</span><span class="n">filter_list</span><span class="p">,</span>
            <span class="n">return_red_blue_splits</span><span class="o">=</span><span class="n">return_red_blue_splits</span><span class="p">,</span>
            <span class="n">return_split_locations</span> <span class="o">=</span> <span class="n">return_split_locations</span> 
                                                                      <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Time for proofreading rules: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_synapses_after_proofread</span><span class="p">:</span>
        <span class="n">syu</span><span class="o">.</span><span class="n">plot_synapses</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">,</span><span class="n">total_synapses</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="c1"># ---- d) Compartment Classification</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---- d) Compartment Classification&quot;</span><span class="p">)</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">o_neuron</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartment_classification_by_cell_type</span><span class="p">(</span>
        <span class="n">o_neuron</span><span class="p">,</span>
        <span class="n">cell_type</span><span class="o">=</span><span class="n">cell_type</span><span class="p">,</span>
        <span class="n">plot_compartments</span><span class="o">=</span><span class="n">plot_compartments</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Time for cell compartments: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># --- e) Add the error synapses back to the neuorn (because done proofreading)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- e) Add the error synapses back to the neuorn (because done proofreading)&quot;</span><span class="p">)</span>
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">syu</span><span class="o">.</span><span class="n">add_synapses_to_neuron_obj</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">,</span>
                               <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">validation</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span>  <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">original_mesh</span><span class="p">,</span>
                            <span class="n">plot_valid_error_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">calculate_synapse_soma_distance</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">add_valid_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">add_error_synapses</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">limb_branch_dict_to_add_synapses</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="c1">#set_head_neck_shaft=True</span>
                              <span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">b) Time for adding back error synapses: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="c1"># ---f) setting the limb/branch idx and soma distances for synapses</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---f) setting the limb/branch idx and soma distances for synapses&quot;</span><span class="p">)</span>
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">syu</span><span class="o">.</span><span class="n">set_limb_branch_idx_to_synapses</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">)</span>
    <span class="n">syu</span><span class="o">.</span><span class="n">calculate_neuron_soma_distance</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">,</span>
                                  <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="n">spu</span><span class="o">.</span><span class="n">set_soma_synapses_spine_label</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">debug_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">b) Time for setting limb/branch idx and soma distances for synapses: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">plot_valid_synapses</span><span class="p">:</span>
        <span class="n">syu</span><span class="o">.</span><span class="n">plot_synapses_valid_from_neuron_obj</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_error_synapses</span><span class="p">:</span>
        <span class="n">syu</span><span class="o">.</span><span class="n">plot_synapses_error_from_neuron_obj</span><span class="p">(</span><span class="n">o_neuron</span><span class="p">)</span>    
        
    <span class="k">if</span> <span class="n">add_spine_distances</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding spine distances&quot;</span><span class="p">)</span>
        <span class="n">o_neuron</span><span class="o">=</span> <span class="n">spu</span><span class="o">.</span><span class="n">calculate_spine_obj_attr_for_neuron</span><span class="p">(</span>
            <span class="n">o_neuron</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_filtering_info</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">o_neuron</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">o_neuron</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">return_filtering_info</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtering_info</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>



<div class="viewcode-block" id="save_off_meshes_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.save_off_meshes_skeletons">[docs]</a><span class="k">def</span> <span class="nf">save_off_meshes_skeletons</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">save_off_compartments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">save_off_entire_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">file_name_ending</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">return_file_paths</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">split_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To save off the skeletons and mesh of a neuron</span>
<span class="sd">    and the compartments</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_path_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span>
    
    <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">fetch_segment_id_mesh</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>
    <span class="n">original_mesh_kdtree</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_to_kdtree</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">split_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">split_index</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">split_index</span>
        
    <span class="k">if</span> <span class="n">split_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Split index is None&quot;</span><span class="p">)</span>
    
    <span class="c1">#saving off the meshes</span>
    
    <span class="k">if</span> <span class="n">save_off_compartments</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---Working on Compartments&quot;</span><span class="p">)</span>
        <span class="n">comp_meshes</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartments_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---Working on Meshes&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span><span class="n">c_mesh</span> <span class="ow">in</span> <span class="n">comp_meshes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Working on </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">original_c_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                        <span class="n">c_mesh</span><span class="p">,</span>
                                                        <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>

            <span class="n">c_mesh_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_faces</span><span class="p">(</span><span class="n">original_c_faces</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                                <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name_ending</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_mesh_faces&quot;</span><span class="p">)</span>
            <span class="n">file_path_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_mesh_faces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_mesh_file</span>


        <span class="c1">#saving off the skeleton</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---Working on Skeleton&quot;</span><span class="p">)</span>
        <span class="n">comp_sks</span> <span class="o">=</span> <span class="n">apu</span><span class="o">.</span><span class="n">compartments_skeleton</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">comp</span><span class="p">,</span><span class="n">c_sk</span> <span class="ow">in</span> <span class="n">comp_sks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Working on </span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">c_skeleton_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_skeleton</span><span class="p">(</span><span class="n">c_sk</span><span class="p">,</span>
                                                          <span class="n">segment_id</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="p">,</span>
                                                          <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                                <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name_ending</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeleton&quot;</span><span class="p">)</span>
            <span class="n">file_path_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_skeleton_file</span>
    
    
    <span class="k">if</span> <span class="n">save_off_entire_neuron</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---Saving off entire neuron&quot;</span><span class="p">)</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="s2">&quot;neuron&quot;</span>
        <span class="n">original_c_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                            <span class="n">nru</span><span class="o">.</span><span class="n">neuron_mesh_from_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">),</span>
                                                            <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                            <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>

        <span class="n">c_mesh_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_faces</span><span class="p">(</span><span class="n">original_c_faces</span><span class="p">,</span>
                                                      <span class="n">segment_id</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="p">,</span>
                                                      <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                            <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name_ending</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_mesh_faces&quot;</span><span class="p">)</span>
        <span class="n">file_path_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_mesh_faces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_mesh_file</span>
        
        <span class="n">c_sk</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeleton</span>
        
        <span class="n">c_skeleton_file</span> <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">save_proofread_skeleton</span><span class="p">(</span><span class="n">c_sk</span><span class="p">,</span>
                                                      <span class="n">segment_id</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="p">,</span>
                                                      <span class="n">split_index</span><span class="o">=</span><span class="n">split_index</span><span class="p">,</span>
                                            <span class="n">file_name_ending</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">file_name_ending</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeleton&quot;</span><span class="p">)</span>
        <span class="n">file_path_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp</span><span class="si">}</span><span class="s2">_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_skeleton_file</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;file_path_dict = </span><span class="se">\n</span><span class="si">{</span><span class="n">file_path_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_file_paths</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">file_path_dict</span></div>

    
<div class="viewcode-block" id="split_success"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.split_success">[docs]</a><span class="k">def</span> <span class="nf">split_success</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_error_limbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">split_success</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">split_successs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">split_success</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">split_success</span> <span class="o">=</span> <span class="mi">3</span>
        
    <span class="k">return</span> <span class="n">split_success</span></div>


<span class="c1"># ---------------------- Version 7 Filters -------------------------</span>
<div class="viewcode-block" id="low_branch_length_large_clusters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.low_branch_length_large_clusters">[docs]</a><span class="k">def</span> <span class="nf">low_branch_length_large_clusters</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#8_000,</span>
    <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#16,</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeletal_distance_from_soma_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#15_000</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    To identify large clusters of small length</span>
<span class="sd">    branches that usually signifify dendrite that</span>
<span class="sd">    was converted to axon or glia pieces</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import proofreading_utils as pru</span>
<span class="sd">    _ = pru.low_branch_length_large_clusters_dendrite(neuron_obj,plot = True,</span>
<span class="sd">                                                      max_skeletal_length = 9000,</span>
<span class="sd">                                                 min_n_nodes_in_cluster = 20)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_skeletal_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="n">max_skeletal_length_low_branch_clusters_axon_global</span>
    <span class="k">if</span> <span class="n">min_n_nodes_in_cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="n">min_n_nodes_in_cluster_low_branch_clusters_axon_global</span>
    <span class="k">if</span> <span class="n">skeletal_distance_from_soma_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeletal_distance_from_soma_min</span> <span class="o">=</span> <span class="n">skeletal_distance_from_soma_min_axon_global</span>
    
        
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">low_branch_length_clusters</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="n">max_skeletal_length</span><span class="p">,</span>
        <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="n">min_n_nodes_in_cluster</span><span class="p">,</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
        <span class="n">skeletal_distance_from_soma_min</span> <span class="o">=</span> <span class="n">skeletal_distance_from_soma_min</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                                                <span class="p">)</span></div>

<div class="viewcode-block" id="low_branch_length_large_clusters_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.low_branch_length_large_clusters_dendrite">[docs]</a><span class="k">def</span> <span class="nf">low_branch_length_large_clusters_dendrite</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#8_000,</span>
    <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#16,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">max_skeletal_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="n">max_skeletal_length_low_branch_clusters_dendrite_global</span>
    <span class="k">if</span> <span class="n">min_n_nodes_in_cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="n">min_n_nodes_in_cluster_low_branch_clusters_dendrite_global</span>

    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">low_branch_length_large_clusters</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">max_skeletal_length</span><span class="o">=</span><span class="n">max_skeletal_length</span><span class="p">,</span>
        <span class="n">min_n_nodes_in_cluster</span><span class="o">=</span><span class="n">min_n_nodes_in_cluster</span><span class="p">,</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        
    <span class="p">)</span></div>

<div class="viewcode-block" id="low_branch_length_large_clusters_axon"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.low_branch_length_large_clusters_axon">[docs]</a><span class="k">def</span> <span class="nf">low_branch_length_large_clusters_axon</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#8_000,</span>
    <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#16,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">max_skeletal_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_skeletal_length</span> <span class="o">=</span> <span class="n">max_skeletal_length_low_branch_clusters_axon_global</span>
    <span class="k">if</span> <span class="n">min_n_nodes_in_cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_n_nodes_in_cluster</span> <span class="o">=</span> <span class="n">min_n_nodes_in_cluster_low_branch_clusters_axon_global</span>
    
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">low_branch_length_large_clusters</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">max_skeletal_length</span><span class="o">=</span><span class="n">max_skeletal_length</span><span class="p">,</span>
        <span class="n">min_n_nodes_in_cluster</span><span class="o">=</span><span class="n">min_n_nodes_in_cluster</span><span class="p">,</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        
    <span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_low_branch_length_clusters_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_low_branch_length_clusters_dendrite">[docs]</a><span class="k">def</span> <span class="nf">filter_away_low_branch_length_clusters_dendrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">low_branch_length_large_clusters_dendrite</span><span class="p">,</span>
                 <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="filter_away_low_branch_length_clusters_axon"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.filter_away_low_branch_length_clusters_axon">[docs]</a><span class="k">def</span> <span class="nf">filter_away_low_branch_length_clusters_axon</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">return_error_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">plot_final_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">filter_away_limb_branch_dict_with_function</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                 <span class="n">limb_branch_dict_function</span><span class="o">=</span><span class="n">pru</span><span class="o">.</span><span class="n">low_branch_length_large_clusters_axon</span><span class="p">,</span>
                 <span class="n">return_error_info</span><span class="o">=</span><span class="n">return_error_info</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_away</span><span class="o">=</span><span class="n">plot_limb_branch_filter_away</span><span class="p">,</span>
                <span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="o">=</span><span class="n">plot_limb_branch_filter_with_disconnect_effect</span><span class="p">,</span>
                 <span class="n">plot_final_neuron</span><span class="o">=</span><span class="n">plot_final_neuron</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="n">low_branch_length_clusters_axon_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_branch_length_clusters_axon&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_branch_length_clusters_axon</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>

<span class="n">low_branch_length_clusters_dendrite_filter</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_branch_length_clusters_dendrite&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_branch_length_clusters_dendrite</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span>


<span class="c1"># -------------- version 7 filters ---------------------------------</span>
<div class="viewcode-block" id="exc_axon_on_dendrite_merges_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_axon_on_dendrite_merges_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_axon_on_dendrite_merges_filter</span><span class="p">(</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;axon_on_dendrite_merges&quot;</span><span class="p">,</span>
                                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_axon_on_dendrite_merges_old</span><span class="p">,</span>
                                         <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                                             <span class="nb">dict</span><span class="p">(</span><span class="n">use_pre_existing_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                             <span class="n">kwargs</span><span class="p">,])</span>
                                              
                                        <span class="p">)</span></div>

<div class="viewcode-block" id="exc_high_degree_branching_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_high_degree_branching_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_high_degree_branching_filter</span><span class="p">(</span>
    <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_branching&quot;</span><span class="p">,</span>
                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching</span><span class="p">,</span>
                          <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                                        <span class="nb">dict</span><span class="p">(),</span>
                                        <span class="n">kwargs</span><span class="p">,]),</span>
                             <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">,</span>
                         <span class="p">)</span></div>

<div class="viewcode-block" id="exc_high_degree_branching_dendrite_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_high_degree_branching_dendrite_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_high_degree_branching_dendrite_filter</span><span class="p">(</span>
    <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;high_degree_branching_dendrite&quot;</span><span class="p">,</span>
                         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching_dendrite</span><span class="p">,</span>
                          <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                                        <span class="nb">dict</span><span class="p">(),</span>
                                        <span class="n">kwargs</span><span class="p">,]),</span>
                             <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">,</span>
                         <span class="p">)</span></div>

<div class="viewcode-block" id="exc_low_degree_branching_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_low_degree_branching_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_low_degree_branching_filter</span><span class="p">(</span>
    <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_degree_branching&quot;</span><span class="p">,</span>
             <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_degree_branching</span><span class="p">,</span>
              <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                                        <span class="nb">dict</span><span class="p">(),</span>
                                        <span class="n">kwargs</span><span class="p">,]),</span>
                 <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">,</span>
             <span class="p">)</span></div>

<div class="viewcode-block" id="exc_width_jump_up_dendrite_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_width_jump_up_dendrite_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_width_jump_up_dendrite_filter</span><span class="p">(</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;width_jump_up_dendrite&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_width_jump_up_dendrite</span><span class="p">,</span>
                                     <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                                        <span class="nb">dict</span><span class="p">(),</span>
                                        <span class="n">kwargs</span><span class="p">,]),</span>
                                    <span class="p">)</span></div>

<div class="viewcode-block" id="exc_width_jump_up_axon_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_width_jump_up_axon_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_width_jump_up_axon_filter</span><span class="p">(</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;width_jump_up_axon&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_width_jump_up_axon</span><span class="p">,</span>
                                     <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                                        <span class="nb">dict</span><span class="p">(),</span>
                                        <span class="n">kwargs</span><span class="p">,]),</span>
                                    <span class="p">)</span></div>

<div class="viewcode-block" id="exc_double_back_dendrite_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.exc_double_back_dendrite_filter">[docs]</a><span class="k">def</span> <span class="nf">exc_double_back_dendrite_filter</span><span class="p">(</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_dendrite&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_double_back_dendrite</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">()</span>
                                    <span class="p">)</span></div>

<div class="viewcode-block" id="inh_double_back_dendrite_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.inh_double_back_dendrite_filter">[docs]</a><span class="k">def</span> <span class="nf">inh_double_back_dendrite_filter</span><span class="p">(</span>
    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">double_back_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="n">double_back_threshold_inh_double_b_global</span>
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;double_back_dendrite&quot;</span><span class="p">,</span>
                                     <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_double_back_dendrite</span><span class="p">,</span>
                                     <span class="nb">dict</span><span class="p">(</span><span class="n">double_back_threshold</span><span class="o">=</span><span class="n">double_back_threshold</span><span class="p">)</span>
                                    <span class="p">)</span></div>

<div class="viewcode-block" id="inh_high_degree_branching_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.inh_high_degree_branching_filter">[docs]</a><span class="k">def</span> <span class="nf">inh_high_degree_branching_filter</span><span class="p">(</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_high_low_degree_inh_global</span>
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max_high_low_degree_inh_global</span>
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span>
        <span class="s2">&quot;high_degree_branching&quot;</span><span class="p">,</span>
        <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching</span><span class="p">,</span>
        <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                <span class="nb">dict</span><span class="p">(</span>
                      <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">,</span> <span class="c1">#setting the width max for crossovers a little smaller</span>
                      <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max</span><span class="p">,</span>
                  <span class="p">),</span>
                <span class="n">kwargs</span><span class="p">,]),</span>
          
             <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">,</span>
         <span class="p">)</span></div>

<div class="viewcode-block" id="inh_high_degree_branching_dendrite_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.inh_high_degree_branching_dendrite_filter">[docs]</a><span class="k">def</span> <span class="nf">inh_high_degree_branching_dendrite_filter</span><span class="p">(</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_high_high_degree_inh_dendr_global</span>
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max_high_high_degree_inh_dendr_global</span>
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span>
        <span class="s2">&quot;high_degree_branching_dendrite&quot;</span><span class="p">,</span>
        <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_high_degree_branching_dendrite</span><span class="p">,</span>
        <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
                <span class="nb">dict</span><span class="p">(</span>
                      <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">,</span> <span class="c1">#setting the width max for crossovers a little smaller</span>
                      <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max</span><span class="p">,</span>
                  <span class="p">),</span>
                <span class="n">kwargs</span><span class="p">,]),</span>
          
             <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">,</span>
         <span class="p">)</span></div>


<div class="viewcode-block" id="axon_on_dendrite_plus_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.axon_on_dendrite_plus_downstream">[docs]</a><span class="k">def</span> <span class="nf">axon_on_dendrite_plus_downstream</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-error&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lb</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_donwstream_branches_from_limb_branch</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">lb</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">lb</span></div>


<div class="viewcode-block" id="inh_low_degree_branching_filter"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.inh_low_degree_branching_filter">[docs]</a><span class="k">def</span> <span class="nf">inh_low_degree_branching_filter</span><span class="p">(</span>
    <span class="n">width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">filters_to_run</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">catch_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max_high_low_degree_inh_global</span>
    <span class="k">if</span> <span class="n">upstream_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max_high_low_degree_inh_global</span>
    <span class="k">if</span> <span class="n">max_degree_to_resolve_absolute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_absolute_low_degree_inh_global</span>
        
    
    <span class="k">if</span> <span class="n">filters_to_run</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filters_to_run</span> <span class="o">=</span> <span class="p">[</span>
                     <span class="n">gf</span><span class="o">.</span><span class="n">axon_webbing_filter</span><span class="p">,</span>
                     <span class="n">gf</span><span class="o">.</span><span class="n">thick_t_filter</span><span class="p">,</span>
                     <span class="c1">#gf.axon_double_back_filter,</span>
                      <span class="n">gf</span><span class="o">.</span><span class="n">axon_double_back_inh_filter</span><span class="p">,</span>
                     <span class="n">gf</span><span class="o">.</span><span class="n">fork_divergence_filter</span><span class="p">,</span>
                     <span class="n">gf</span><span class="o">.</span><span class="n">fork_min_skeletal_distance_filter</span><span class="p">,</span>

                  <span class="p">]</span>
    
    <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">make_filter_dict</span><span class="p">(</span><span class="s2">&quot;low_degree_branching&quot;</span><span class="p">,</span>
         <span class="n">pru</span><span class="o">.</span><span class="n">filter_away_low_degree_branching</span><span class="p">,</span>
         <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
          <span class="nb">dict</span><span class="p">(</span>
              <span class="c1">#perform_synapse_filter = False</span>
              <span class="n">width_max</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">,</span>
              <span class="n">upstream_width_max</span> <span class="o">=</span> <span class="n">upstream_width_max</span><span class="p">,</span>
              <span class="n">max_degree_to_resolve_absolute</span> <span class="o">=</span> <span class="n">max_degree_to_resolve_absolute</span><span class="p">,</span>
              <span class="n">filters_to_run</span><span class="o">=</span><span class="n">filters_to_run</span>
              
          <span class="p">),</span>
             <span class="n">kwargs</span><span class="p">,]),</span>
             <span class="n">catch_error</span><span class="o">=</span><span class="n">catch_error</span><span class="p">,</span>
         <span class="p">)</span></div>

    
<div class="viewcode-block" id="v7_exc_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v7_exc_filters">[docs]</a><span class="k">def</span> <span class="nf">v7_exc_filters</span><span class="p">(</span><span class="n">dendrite_branching_filters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">dendrite_branching_filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dendrite_branching_filters</span> <span class="o">=</span> <span class="n">dendrite_branching_filters_global</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v7 Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">dendrite_branching_filters</span><span class="p">:</span>
        
        <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
            <span class="n">exc_high_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">exc_low_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">exc_high_degree_branching_dendrite_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
            <span class="n">exc_double_back_dendrite_filter</span><span class="p">(),</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">exc_filters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
            <span class="n">exc_high_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">exc_low_degree_branching_filter</span><span class="p">(),</span>
            <span class="c1">#exc_high_degree_branching_dendrite_filter(),</span>
            <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
            <span class="n">exc_double_back_dendrite_filter</span><span class="p">(),</span>
        <span class="p">]</span>
        
    
    <span class="k">return</span> <span class="n">exc_filters</span></div>

<div class="viewcode-block" id="v7_inh_filters"><a class="viewcode-back" href="../../neurd.html#neurd.proofreading_utils.v7_inh_filters">[docs]</a><span class="k">def</span> <span class="nf">v7_inh_filters</span><span class="p">(</span><span class="n">dendrite_branching_filters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">dendrite_branching_filters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dendrite_branching_filters</span> <span class="o">=</span> <span class="n">dendrite_branching_filters_inh_global</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*****Using v7 INHIBITORY Filters!!!</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">dendrite_branching_filters</span><span class="p">:</span>
        <span class="n">inh_filters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
            <span class="n">inh_high_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">inh_low_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">inh_high_degree_branching_dendrite_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
            <span class="n">inh_double_back_dendrite_filter</span><span class="p">(),</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inh_filters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">exc_axon_on_dendrite_merges_filter</span><span class="p">(),</span>
            <span class="n">inh_high_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">inh_low_degree_branching_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_dendrite_filter</span><span class="p">(),</span>
            <span class="n">exc_width_jump_up_axon_filter</span><span class="p">(),</span>
            <span class="n">inh_double_back_dendrite_filter</span><span class="p">(),</span>
        <span class="p">]</span>
        
    
    <span class="k">return</span> <span class="n">inh_filters</span></div>





<span class="c1"># ------------- parameters for stats ---------------</span>

<span class="n">global_parameters_dict_default_split</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># ------------- parameters for the splitting ----------------</span>
    
    <span class="n">remove_segment_threshold</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span><span class="c1">#the segments along path that should be combined</span>
    <span class="n">remove_segment_threshold_round_2</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">,</span>
    <span class="n">consider_path_neighbors_for_removal</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="c1">#paraeters for high degree nodes</span>
    <span class="n">offset_high_degree</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span><span class="c1">#2500,#1500,</span>
    <span class="n">comparison_distance_high_degree</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">match_threshold_high_degree</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span><span class="c1">#65,#35,#45,#35,</span>

    <span class="c1">#parameter for both width and doubling back</span>
    <span class="c1"># This will prevent the edges that were added to extend to the soma from causing the doulbing back or width threshold errors</span>
    <span class="n">skip_small_soma_connectors</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">small_soma_connectors_skeletal_threshold</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">,</span>

    <span class="c1"># parameters for the doubling back</span>
    <span class="n">double_back_threshold</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span><span class="c1">#100,# 130,</span>
    <span class="n">offset_double_back</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">comparison_distance_double_back</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">,</span>

    <span class="c1">#parameters for the width threshold</span>
    <span class="n">width_jump_threshold</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>


    <span class="n">simple_path_of_2_cut</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="n">apply_double_back_first</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">double_back_threshold_at_first</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
    
    <span class="c1">#--- split neuron function parameters --</span>
    <span class="n">min_skeletal_length_limb</span><span class="o">=</span> <span class="mi">15_000</span><span class="p">,</span>

<span class="p">)</span>

<span class="n">global_parameters_dict_default_low_branch_clusters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># ---- for filtering away large clusters -------</span>
    <span class="n">max_skeletal_length_low_branch_clusters_dendrite</span> <span class="o">=</span> <span class="mi">8_000</span><span class="p">,</span>
    <span class="n">min_n_nodes_in_cluster_low_branch_clusters_dendrite</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
    
    <span class="n">max_skeletal_length_low_branch_clusters_axon</span> <span class="o">=</span> <span class="mi">8_000</span><span class="p">,</span>
    <span class="n">min_n_nodes_in_cluster_low_branch_clusters_axon</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
    
    <span class="n">skeletal_distance_from_soma_min_axon</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default_auto_proof</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># ---- inh_high_degree_branching_filter and inh_low_degree_branching_filter---</span>
    <span class="n">width_max_high_low_degree_inh</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span> <span class="c1">#setting the width max for crossovers a little smaller</span>
    <span class="n">upstream_width_max_high_low_degree_inh</span> <span class="o">=</span> <span class="mi">180</span><span class="p">,</span>
    <span class="n">max_degree_to_resolve_absolute_low_degree_inh</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    
    <span class="n">width_max_high_high_degree_inh_dendr</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    <span class="n">upstream_width_max_high_high_degree_inh_dendr</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
    
    <span class="n">dendrite_branching_filters</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">dendrite_branching_filters_inh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    
    <span class="c1">#--double back filters </span>
    <span class="n">double_back_threshold_inh_double_b</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default_red_blue_multi_soma</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">include_one_hop_downstream_error_branches_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">one_hop_downstream_error_branches_max_distance_red_blue</span> <span class="o">=</span> <span class="mi">4_000</span><span class="p">,</span><span class="c1">#10_000,</span>
    <span class="n">offset_distance_for_points_valid_red_blue</span> <span class="o">=</span> <span class="mi">3_000</span><span class="p">,</span><span class="c1">#500,#1000,</span>
    <span class="n">offset_distance_for_points_error_red_blue</span> <span class="o">=</span> <span class="mi">3_000</span><span class="p">,</span><span class="c1">#500,#1000,</span>
    <span class="n">n_points_red_blue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="c1">#3,</span>
    <span class="n">n_red_points_red_blue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">n_blue_points_red_blue</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">red_blue_points_method_red_blue</span> <span class="o">=</span> <span class="s2">&quot;closest_mesh_face&quot;</span><span class="p">,</span>
    <span class="n">pair_conn_comp_by_common_upstream_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">pair_conn_comp_errors_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">group_all_conn_comp_together_red_blue</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">only_outermost_branches_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">min_error_downstream_length_total_red_blue</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span><span class="c1"># None,#5_000,</span>

    <span class="n">split_red_blue_by_common_upstream_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">use_undirected_graph_red_blue</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">avoid_one_red_or_blue_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">min_cancel_distance_absolute_red_blue</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span><span class="c1">#2000,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default_red_blue_multi_axon_on_dendrite</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">include_one_hop_downstream_error_branches_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">one_hop_downstream_error_branches_max_distance_red_blue</span> <span class="o">=</span> <span class="mi">1_000</span><span class="p">,</span><span class="c1">#10_000,</span>
    <span class="n">offset_distance_for_points_valid_red_blue</span> <span class="o">=</span> <span class="mi">1700</span><span class="p">,</span><span class="c1">#3_000,#500,#1000,</span>
    <span class="n">offset_distance_for_points_error_red_blue</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span><span class="c1">#3_000,#500,#1000,</span>
    <span class="n">n_points_red_blue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="c1">#3,</span>
    <span class="n">n_red_points_red_blue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">n_blue_points_red_blue</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="c1">#None,</span>
    <span class="n">red_blue_points_method_red_blue</span> <span class="o">=</span> <span class="s2">&quot;closest_mesh_face&quot;</span><span class="p">,</span>
    <span class="n">pair_conn_comp_by_common_upstream_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">pair_conn_comp_errors_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">group_all_conn_comp_together_red_blue</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">only_outermost_branches_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">min_error_downstream_length_total_red_blue</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span><span class="c1"># None,#5_000,</span>

    <span class="n">split_red_blue_by_common_upstream_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span><span class="c1">#False,</span>
    <span class="n">use_undirected_graph_red_blue</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">avoid_one_red_or_blue_red_blue</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="n">min_cancel_distance_absolute_red_blue</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span><span class="c1">#2000,</span>
<span class="p">)</span>


<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_default_split</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_low_branch_clusters</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_auto_proof</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_red_blue_multi_axon_on_dendrite</span><span class="p">,</span>
    
<span class="p">])</span>



<span class="c1"># print(f&quot;mvu.data_interface.voxel_to_nm_scaling = {mvu.data_interface.voxel_to_nm_scaling}&quot;)</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">vdi</span> <span class="o">=</span> <span class="n">mvu</span><span class="o">.</span><span class="n">data_interface</span><span class="p">,</span>
    <span class="n">exc_filters_auto_proof</span> <span class="o">=</span> <span class="n">v7_exc_filters</span><span class="p">,</span>
    <span class="n">inh_filters_auto_proof</span> <span class="o">=</span> <span class="n">v7_inh_filters</span><span class="p">,</span>
<span class="p">)</span>    


<span class="c1"># ------- microns -----------</span>
<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">global_parameters_dict_microns_split</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">global_parameters_dict_microns_auto_proof</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">global_parameters_dict_microns_low_branch_clusters</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">global_parameters_dict_default_red_blue</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">n_red_points_red_blue</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_microns_split</span><span class="p">,</span>
    <span class="n">global_parameters_dict_microns_low_branch_clusters</span><span class="p">,</span>
    <span class="n">global_parameters_dict_microns_auto_proof</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_red_blue</span>
<span class="p">])</span>

<span class="c1"># --------- spiltting -------------</span>
<span class="n">global_parameters_dict_h01_split</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">global_parameters_dict_h01_auto_proof</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">width_max_high_low_degree_inh</span> <span class="o">=</span> <span class="mi">160</span><span class="p">,</span> <span class="c1">#setting the width max for crossovers a little smaller</span>
    <span class="n">upstream_width_max_high_low_degree_inh</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    
    <span class="n">width_max_high_high_degree_inh_dendr</span> <span class="o">=</span> <span class="mi">650</span><span class="p">,</span>
    <span class="n">upstream_width_max_high_high_degree_inh_dendr</span> <span class="o">=</span> <span class="mi">650</span><span class="p">,</span>
    
    <span class="n">dendrite_branching_filters</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">dendrite_branching_filters_inh</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="c1">#--double back filters </span>
    <span class="n">double_back_threshold_inh_double_b</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>

<span class="p">)</span>
<span class="n">global_parameters_dict_h01_low_branch_clusters</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_h01_split</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_low_branch_clusters</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_auto_proof</span>
<span class="p">])</span>

<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">vdi</span> <span class="o">=</span> <span class="n">hvu</span><span class="o">.</span><span class="n">data_interface</span>
<span class="p">)</span>



<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>
<span class="c1"># modules_to_set = [pru,ed,nst]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">apical_utils</span> <span class="k">as</span> <span class="n">apu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">classification_utils</span> <span class="k">as</span> <span class="n">clu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">error_detection</span> <span class="k">as</span> <span class="n">ed</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">graph_filters</span> <span class="k">as</span> <span class="n">gf</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_simplification</span> <span class="k">as</span> <span class="n">nsimp</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_simplification</span> <span class="k">as</span> <span class="n">nsimp</span> 
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">preprocess_neuron</span> <span class="k">as</span> <span class="n">pre</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spine_utils</span> <span class="k">as</span> <span class="n">spu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">cell_type_utils</span> <span class="k">as</span> <span class="n">ctu</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
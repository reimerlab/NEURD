<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.classification_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.classification_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.classification_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>



<span class="sd">Utils for helping with the classification of a neuron</span>
<span class="sd">for compartments like axon, apical, basal...</span>




<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>

<span class="n">top_volume_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<div class="viewcode-block" id="axon_candidates"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_candidates">[docs]</a><span class="k">def</span> <span class="nf">axon_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">possible_axon_limbs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">ais_threshold</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
                   <span class="n">plot_close_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">plot_candidats_after_elimination</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">plot_candidates_after_adding_back</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return with a list of the possible </span>
<span class="sd">    axon subgraphs of the limbs of a neuron object</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all the branches in the possible ais range and delete them from the concept networks</span>
<span class="sd">    2) Collect all the leftover branches subgraph as candidates</span>
<span class="sd">    3) Add back the candidates that were deleted</span>
<span class="sd">    4) Combining all the candidates in one list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    <span class="k">if</span> <span class="n">possible_axon_limbs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">possible_axon_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_names_from_concept_network</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
    
    
    
    <span class="n">close_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                            <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">skeletal_distance_from_soma</span><span class="p">],</span>
                                            <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;skeletal_distance_from_soma&lt;</span><span class="si">{</span><span class="n">ais_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                            <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">limbs_to_process</span><span class="o">=</span><span class="n">possible_axon_limbs</span><span class="p">),</span>
                                             <span class="c1">#return_dataframe=False</span>


                                            <span class="p">)</span>
    <span class="n">outside_bubble_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                            <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">skeletal_distance_from_soma</span><span class="p">],</span>
                                            <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;skeletal_distance_from_soma&gt;=</span><span class="si">{</span><span class="n">ais_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                            <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">limbs_to_process</span><span class="o">=</span><span class="n">possible_axon_limbs</span><span class="p">),</span>
                                             <span class="c1">#return_dataframe=False</span>


                                            <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_close_branches</span><span class="p">:</span>
        <span class="n">colors_dict_returned</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                              <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">close_limb_branch_dict</span><span class="p">,</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                             <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        
        
        
    
    <span class="c1"># 2) --------Delete the nodes from the branch graph and then group into connected ocmponents</span>
    <span class="c1"># into candidates</span>

    <span class="n">limbs_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">possible_axon_limbs</span><span class="p">]</span>

    <span class="n">sub_limb_color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">total_sub_limbs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1">#will map the limbs to the connected components</span>


    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limbs_to_check</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Phase 2: Working on Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#initializing the candidate list and the color dictionary for visualization</span>
        <span class="n">total_sub_limbs</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sub_limb_color_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>



        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">close_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">nodes_to_eliminate</span> <span class="o">=</span> <span class="n">close_limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes_to_eliminate</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#the nodes that were eliminated we need to show deleted colors</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_eliminate</span><span class="p">:</span>
            <span class="n">sub_limb_color_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_eliminate = </span><span class="si">{</span><span class="n">nodes_to_eliminate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">curr_filt_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
        <span class="n">curr_filt_network</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_eliminate</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_filt_network</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The filtered network is empty so just leaving the candidates as empty lists&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">curr_limb_conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">curr_filt_network</span><span class="p">))</span>


        <span class="n">total_sub_limbs</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_conn_comp</span><span class="p">]</span>

        <span class="n">colors_to_use</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_unique_random_color_list</span><span class="p">(</span><span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_conn_comp</span><span class="p">),</span><span class="n">colors_to_omit</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">,</span><span class="s2">&quot;midnightblue&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">c_comp</span><span class="p">,</span><span class="n">curr_random_color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">curr_limb_conn_comp</span><span class="p">,</span><span class="n">colors_to_use</span><span class="p">)):</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c_comp</span><span class="p">:</span>
                <span class="n">sub_limb_color_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_random_color</span>


                
    <span class="k">if</span> <span class="n">plot_candidats_after_elimination</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="n">sub_limb_color_dict</span><span class="p">,</span>
                             <span class="n">mesh_fill_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
        
        
        
        
        
        
        
    <span class="c1"># ----------- Part 3: ------------------#</span>
<span class="w">        </span>
<span class="w">        </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3) Adding back all endpoints that were eliminated in step 2: Process is below</span>

<span class="sd">    For each limb</span>

<span class="sd">    0) Get all of the endpoint nodes in the whole directed concept network</span>
<span class="sd">    - remove the starting node from the list</span>
<span class="sd">    1) Find the shortest path from every endpoint to the starting node</span>
<span class="sd">    2) Concatenate shortest paths into dictionary mapping node to number of</span>
<span class="sd">    occurances in the shortest paths</span>
<span class="sd">    3) Find all of the endpoints that were eliminated with the restriction</span>
<span class="sd">    4) Filter those endpoint paths for nodes that only have an </span>
<span class="sd">    occurance of one for the lookup dictionary</span>
<span class="sd">    5) Add all deleted endpoint filtered shortest paths as candidates</span>

<span class="sd">    How to handle corner cases:</span>
<span class="sd">    1) If only starting node that got deleted</span>
<span class="sd">    --&gt; just add that as a candidate</span>
<span class="sd">    2) If all of network got deleted, current way will work</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">removed_candidates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">limbs_to_check</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">----Working on Limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">-----&quot;</span><span class="p">)</span>

        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>    

        <span class="n">removed_candidates</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">close_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">nodes_to_eliminate</span> <span class="o">=</span> <span class="n">close_limb_branch_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodes_to_eliminate</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No nodes were eliminated so don&#39;t need to add back any candidates&quot;</span><span class="p">)</span>
            <span class="k">continue</span>


        <span class="n">curr_network</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
        <span class="n">curr_starting_node</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span>

        <span class="c1">#covering the corner case that only the root node existed</span>
        <span class="c1">#and it was deleted</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_to_eliminate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_network</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;network was only of size 1 and that node was eliminated so returning that as the only candidate&quot;</span><span class="p">)</span>
            <span class="n">removed_candidates</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">curr_starting_node</span><span class="p">]]</span>

            <span class="c1">#adding the color</span>
            <span class="n">curr_random_color</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_unique_random_color_list</span><span class="p">(</span><span class="n">n_colors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">colors_to_omit</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">,</span><span class="s2">&quot;midnightblue&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sub_limb_color_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_random_color</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#0) Get all of the endpoint nodes in the whole directed concept network</span>
            <span class="c1">#- remove the starting node from the list</span>
            <span class="n">curr_endpoints</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_starting_node</span> <span class="ow">in</span> <span class="n">curr_endpoints</span><span class="p">:</span>
                <span class="n">curr_endpoints</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">curr_starting_node</span><span class="p">)</span>


            <span class="c1">#3) Find all of the endpoints that were eliminated with the restriction</span>
            <span class="n">endpoints_eliminated</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_endpoints</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes_to_eliminate</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints_eliminated</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No endpoints were eliminated so don&#39;t need to add back any candidates&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1">#1) Find the shortest path from every endpoint to the starting node</span>
            <span class="n">shortest_paths_endpoints</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">curr_endpoints</span><span class="p">:</span>
                <span class="n">en_shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_network</span><span class="p">,</span>
                                <span class="n">source</span> <span class="o">=</span> <span class="n">en</span><span class="p">,</span>
                                 <span class="n">target</span> <span class="o">=</span> <span class="n">curr_starting_node</span><span class="p">)</span>
                <span class="n">shortest_paths_endpoints</span><span class="p">[</span><span class="n">en</span><span class="p">]</span> <span class="o">=</span> <span class="n">en_shortest_path</span>

            <span class="c1">#2) Concatenate shortest paths into dictionary mapping node to number of</span>
            <span class="c1">#occurances in the shortest paths</span>
            <span class="n">node_occurance</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">curr_path</span> <span class="ow">in</span> <span class="n">shortest_paths_endpoints</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_path</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_occurance</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">node_occurance</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node_occurance</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1">#4) Filter those endpoint paths for nodes that only have an </span>
            <span class="c1">#occurance of one for the lookup dictionary</span>
            <span class="n">added_back_candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">en_elim</span> <span class="ow">in</span> <span class="n">endpoints_eliminated</span><span class="p">:</span>
                <span class="n">filtered_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shortest_paths_endpoints</span><span class="p">[</span><span class="n">en_elim</span><span class="p">]</span> <span class="k">if</span> <span class="n">node_occurance</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">added_back_candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filtered_path</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New candidates added back: </span><span class="si">{</span><span class="n">added_back_candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">removed_candidates</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">added_back_candidates</span>

        <span class="c1">#5) Adding the new paths to the color dictionary for visualization </span>
        <span class="n">colors_to_use</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_unique_random_color_list</span><span class="p">(</span><span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">removed_candidates</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]),</span><span class="n">colors_to_omit</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">,</span><span class="s2">&quot;midnightblue&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">add_path</span><span class="p">,</span><span class="n">curr_random_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">removed_candidates</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">],</span><span class="n">colors_to_use</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">add_path</span><span class="p">:</span>
                <span class="n">sub_limb_color_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_random_color</span>

    <span class="c1"># checking that adding back the candidates went well</span>

    <span class="k">if</span> <span class="n">plot_candidates_after_adding_back</span><span class="p">:</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="n">sub_limb_color_dict</span><span class="p">,</span>
                             <span class="n">mesh_fill_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
        
        
        
        
    <span class="c1"># --------- Part 4: Combining All the Candidates ------------ #</span>
    
    <span class="n">all_candidates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">limbs_to_check</span><span class="p">:</span>
        <span class="n">all_candidates</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">limb_name</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span> <span class="o">=</span> <span class="n">total_sub_limbs</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">removed_candidates</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final Candidates&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span> <span class="n">list_of_subgraphs</span> <span class="ow">in</span> <span class="n">all_candidates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">sg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_subgraphs</span><span class="p">):</span>
                <span class="n">curr_color</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">convert_rgb_to_name</span><span class="p">(</span><span class="n">sub_limb_color_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">sg</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Candidate </span><span class="si">{</span><span class="n">jj</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">curr_color</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">all_candidates</span></div>


<div class="viewcode-block" id="candidate_starting_skeletal_angle"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.candidate_starting_skeletal_angle">[docs]</a><span class="k">def</span> <span class="nf">candidate_starting_skeletal_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">candidate_nodes</span><span class="p">,</span>
                                      <span class="n">offset</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span><span class="c1">#20000,</span>
                                    <span class="n">axon_sk_direction_comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span><span class="c1">#5000,</span>
                                    <span class="n">buffer_for_skeleton</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                                      <span class="n">top_volume_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                                      <span class="n">plot_skeleton_paths_before_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">plot_skeleton_paths_after_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">return_restricted_skeletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">branches_not_to_consider_for_end_nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the skeleton that represents the starting skeleton</span>
<span class="sd">    --&gt; and then find the projection angle to filter it away or not</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) convert the graph into a skeleton (this is when self touches could be a problem)</span>
<span class="sd">    2) Find all skeleton points that are within a certain distance of the starting coordinate</span>
<span class="sd">    3) Find all end-degree nodes (except for the start)</span>
<span class="sd">    4) Find path back to start for all end-nodes</span>
<span class="sd">    5) Find paths that are long enough for the offset plus test --&gt; if none then don&#39;t filter</span>
<span class="sd">    anyway</span>

<span class="sd">    For each valid path (make them ordered paths):</span>
<span class="sd">    6) Get the offset + test subskeletons for all valid paths</span>
<span class="sd">    7) Get the angle of the sksletons vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">debug_cancellation</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="c1"># -- Renaming the variables --</span>
    <span class="n">subgraph_branches</span> <span class="o">=</span> <span class="n">candidate_nodes</span>
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">limb_obj</span>
    
    
    <span class="n">sk_size_to_compare</span> <span class="o">=</span> <span class="n">axon_sk_direction_comparison_distance</span> <span class="o">+</span> <span class="n">offset</span>
    <span class="n">total_distance</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">axon_sk_direction_comparison_distance</span> <span class="o">+</span> <span class="n">buffer_for_skeleton</span>
    
    
    
    <span class="c1">#1) convert the graph into a skeleton (this is when self touches could be a problem)</span>
    <span class="n">candidate_sk</span><span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subgraph_branches</span><span class="p">])</span>
    <span class="n">candidate_sk_graph</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">candidate_sk</span><span class="p">)</span>

    <span class="c1">#2) Find all skeleton points that are within a certain distance of the starting coordinate</span>
    <span class="n">starting_sk_coord</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span>
    <span class="n">starting_sk_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">candidate_sk_graph</span><span class="p">,</span><span class="n">starting_sk_coord</span><span class="p">)</span>
    <span class="n">skeletons_nodes_for_comparison</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span>
        <span class="n">candidate_sk_graph</span><span class="p">,</span>
        <span class="n">starting_sk_node</span><span class="p">,</span><span class="n">total_distance</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">skeletons_nodes_for_comparison</span><span class="p">))</span>
    <span class="n">comparison_subgraph</span> <span class="o">=</span> <span class="n">candidate_sk_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">skeletons_nodes_for_comparison</span><span class="p">)</span>
    
    <span class="c1">#3) Find all edn-degree nodes (except for the start)</span>
    <span class="n">all_endnodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">starting_coordinate_endnode</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span>
        <span class="n">comparison_subgraph</span><span class="p">,</span>
        <span class="n">starting_sk_coord</span><span class="p">)</span>
    
    
        
    
    <span class="n">endnodes_to_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_endnodes</span><span class="p">,[</span><span class="n">starting_coordinate_endnode</span><span class="p">])</span>
    
    
    <span class="c1"># ------------ 1/24 Addition: Will get rid of end nodes that are on dendritic portions ----- #</span>
    <span class="k">if</span> <span class="n">branches_not_to_consider_for_end_nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        1) Get coordinate of end node</span>
<span class="sd">        2) Get the branches that belong to that coordinate</span>
<span class="sd">        3) Subtract off the branches that shouldn&#39;t be considered</span>
<span class="sd">        4) If empty then skip, if not then add</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">debug_cancellation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">new_endnodes_to_test</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">debug_cancellation</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches_not_to_consider_for_end_nodes: </span><span class="si">{</span><span class="n">branches_not_to_consider_for_end_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">curr_endpoint</span> <span class="ow">in</span> <span class="n">endnodes_to_test</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">debug_cancellation</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;working on endpoint: </span><span class="si">{</span><span class="n">curr_endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">curr_endpoint_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="p">,</span>
                                                                      <span class="n">curr_endpoint</span><span class="p">)</span>
            
            <span class="n">branches_of_endnode</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                           <span class="n">curr_endpoint_coordinate</span><span class="p">)</span>
            <span class="n">viable_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">branches_of_endnode</span><span class="p">,</span><span class="n">branches_not_to_consider_for_end_nodes</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug_cancellation</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches_of_endnode: </span><span class="si">{</span><span class="n">branches_of_endnode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;viable_branches: </span><span class="si">{</span><span class="n">viable_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">new_endnodes_to_test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_endpoint</span><span class="p">)</span>
        
        <span class="n">endnodes_to_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_endnodes_to_test</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug_cancellation</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endnodes_to_test AFTER FILTERING= </span><span class="si">{</span><span class="n">endnodes_to_test</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endnodes_to_test = </span><span class="si">{</span><span class="n">endnodes_to_test</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="c1"># nviz.plot_objects(curr_limb.mesh,</span>
    <span class="c1">#             skeletons=[sk.convert_graph_to_skeleton(comparison_subgraph)],</span>
    <span class="c1">#                  )</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endnodes_to_test</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_restricted_skeletons</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        
        
    <span class="c1">#4) Find path back to start for all end-nodes</span>
    
    <span class="n">paths_to_test</span> <span class="o">=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="p">,</span>
                                      <span class="n">starting_coordinate_endnode</span><span class="p">,</span>
                                      <span class="n">k</span>
                                     <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">endnodes_to_test</span><span class="p">]</span>
    <span class="n">sk_paths_to_test</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">paths_to_test</span><span class="p">]</span>
    <span class="n">sk_paths_to_test_ordered</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">order_skeleton</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>
                                                  <span class="n">start_endpoint_coordinate</span> <span class="o">=</span> <span class="n">starting_sk_coord</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_paths_to_test</span><span class="p">]</span>
    


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_paths_to_test_ordered</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Found no skeleton paths&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_skeleton_paths_before_restriction</span><span class="p">:</span>
        <span class="n">endpoint_scatters</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="p">,</span><span class="n">endnodes_to_test</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">sc_point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sk_paths_to_test_ordered</span><span class="p">,</span><span class="n">endpoint_scatters</span><span class="p">):</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">sc_point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
            
            
    <span class="c1">#5) Find paths that are long enough for the offset plus test --&gt; if none then don&#39;t filter any</span>
    <span class="n">sk_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_paths_to_test_ordered</span><span class="p">])</span>
    <span class="n">filtered_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sk_distances</span><span class="o">&gt;=</span><span class="n">sk_size_to_compare</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_indexes</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">filtered_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk_paths_to_test_ordered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">filtered_indexes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filtered_skeletons</span> <span class="o">=</span> <span class="n">sk_paths_to_test_ordered</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skeleton paths distances = </span><span class="si">{</span><span class="n">sk_distances</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtered indexes = </span><span class="si">{</span><span class="n">filtered_indexes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;len(filtered_skeletons) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_skeletons</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
    
    <span class="c1">#6) Get the offset + test subskeletons for all valid paths</span>
    <span class="n">filtered_skeletons_restricted</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>
                                        <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                        <span class="n">comparison_distance</span><span class="o">=</span><span class="n">axon_sk_direction_comparison_distance</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">filtered_skeletons</span><span class="p">]</span>
    
    

    <span class="k">if</span> <span class="n">plot_skeleton_paths_after_restriction</span><span class="p">:</span>
        <span class="n">endpoint_scatters</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">comparison_subgraph</span><span class="p">,</span><span class="n">endnodes_to_test</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">sc_point</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filtered_skeletons_restricted</span><span class="p">,</span><span class="n">endpoint_scatters</span><span class="p">):</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                             <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">sc_point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">filtered_skeletons_restricted</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                                      <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">])</span>
            
    <span class="c1">#7) Get the angle of the sletons vectors</span>

    <span class="c1">#angle between going down and skeleton vector</span>
    <span class="n">sk_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">skeleton_endpoint_vector</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">filtered_skeletons_restricted</span><span class="p">]</span>
    <span class="n">sk_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">top_volume_vector</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_vectors</span><span class="p">])</span>

    

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_angles = </span><span class="si">{</span><span class="n">sk_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">return_restricted_skeletons</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk_angles</span><span class="p">,</span><span class="n">filtered_skeletons_restricted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk_angles</span></div>
    
    

<div class="viewcode-block" id="filter_axon_candiates_old"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.filter_axon_candiates_old">[docs]</a><span class="k">def</span> <span class="nf">filter_axon_candiates_old</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">axon_subgraph_candidates</span><span class="p">,</span>
    <span class="n">axon_angle_threshold_relaxed</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span><span class="c1">#90,</span>
    <span class="n">axon_angle_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
    <span class="n">relaxation_percentage</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
    <span class="n">relaxation_axon_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="c1">#40_000,</span>
                              
                          
    <span class="c1">#parameters for computing the skeletal angle</span>
     
    <span class="n">skeletal_angle_offset</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">skeletal_angle_comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">skeletal_angle_buffer</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                          
    <span class="n">axon_like_limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          
    <span class="n">min_ais_width</span><span class="o">=</span><span class="mi">85</span><span class="p">,</span><span class="c1">#85,</span>
    <span class="n">use_beginning_ais_for_width_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          
    <span class="n">extra_ais_checks</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#feature that is not needed with new flip_dendrite_to_axon added at axon-like identification step</span>
    <span class="n">extra_ais_width_threshold</span> <span class="o">=</span>  <span class="mi">650</span><span class="p">,</span>
    <span class="n">extra_ais_spine_density_threshold</span> <span class="o">=</span> <span class="mf">0.00015</span><span class="p">,</span>
    <span class="n">extra_ais_angle_threshold</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
                          
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
                          
    <span class="n">return_axon_angles</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">best_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">best_axon_skeletal_legnth_ratio</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>

<span class="sd">    For each candidate: </span>

<span class="sd">    0) If all Axon? (Have a more relaxed threshold for the skeleton angle)</span>
<span class="sd">    1) Find the starting direction, and if not downwards --&gt; then not axon</span>
<span class="sd">    2) ------------- Check if too thin at the start --&gt; Not Axon (NOT GOING TO DO THIS) -------------</span>
<span class="sd">    3) If first branch is axon --&gt; classify as axon</span>
<span class="sd">    4) Trace back to starting node and add all branches that are axon like</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">axon_like_limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_like_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;matching_label&quot;</span><span class="p">],</span>
               <span class="n">query</span><span class="o">=</span><span class="s2">&quot;matching_label==True&quot;</span><span class="p">,</span>
               <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">]),</span>
               <span class="p">)</span>
        
        
<span class="c1">#     su.compressed_pickle(axon_subgraph_candidates,&quot;axon_subgraph_candidates&quot;)</span>
<span class="c1">#     su.compressed_pickle(axon_like_limb_branch_dict,&quot;axon_like_limb_branch_dict&quot;)</span>
<span class="c1">#     raise Exception(&quot;&quot;)</span>
        
    <span class="n">final_axon_like_classification</span> <span class="o">=</span> <span class="n">axon_like_limb_branch_dict</span>
    <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    <span class="n">axon_candidate_filtered</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">axon_candidate_filtered_angles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    
    <span class="n">best_axon_candidate_filtered</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">best_axon_candidate_filtered_angles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">best_axon_soma_angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">best_axon_axon_angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">best_axon_skeletal_length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">candidate_filt_dicts</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">limb_candidate_grouped_branches</span> <span class="ow">in</span> <span class="n">axon_subgraph_candidates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    
        <span class="n">curr_limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
        
        
        
        <span class="k">for</span> <span class="n">curr_candidate_idx</span><span class="p">,</span><span class="n">curr_candidate_subgraph</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_candidate_grouped_branches</span><span class="p">):</span>
            <span class="n">curr_candidate_subgraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> --- Working on limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">, candidate # </span><span class="si">{</span><span class="n">curr_candidate_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_candidate_subgraph = </span><span class="si">{</span><span class="n">curr_candidate_subgraph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            
            <span class="c1"># ---------- Part Prework:  --------------------------------------------- #</span>
            
            <span class="c1"># ----------- Getting the path to the starting soma ----#</span>
            <span class="n">curr_limb</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">undirectional_limb_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>

            <span class="n">current_shortest_path</span><span class="p">,</span><span class="n">st_node</span><span class="p">,</span><span class="n">end_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span>
                <span class="n">undirectional_limb_graph</span><span class="p">,[</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">],</span>
                <span class="n">curr_candidate_subgraph</span><span class="p">)</span>
            <span class="n">candidate_starting_node</span> <span class="o">=</span> <span class="n">current_shortest_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_shortest_path = </span><span class="si">{</span><span class="n">current_shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;candidate_starting_node = </span><span class="si">{</span><span class="n">candidate_starting_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
            <span class="c1"># -------- getting the axon branches ------------- #</span>
            <span class="k">if</span> <span class="n">curr_limb_name</span> <span class="ow">in</span> <span class="n">final_axon_like_classification</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">axon_branches_on_limb</span> <span class="o">=</span> <span class="n">final_axon_like_classification</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axon_branches_on_limb</span> <span class="o">=</span> <span class="p">[]</span>
            
            
            <span class="c1"># ------ 2/3 Addition: Will add back AIS if not there and meets strict requirements ------ #</span>
            <span class="c1">#get the soma angle</span>
            <span class="n">curr_soma_angle</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                      <span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">extra_ais_checks</span> <span class="ow">and</span> <span class="n">candidate_starting_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axon_branches_on_limb</span><span class="p">:</span>
                
                <span class="n">curr_ais_width</span>  <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">]</span>
                <span class="n">curr_ais_spine_density</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">spine_density</span>
                
                
                
                
                <span class="n">add_back_ais</span> <span class="o">=</span> <span class="p">((</span><span class="n">curr_ais_width</span> <span class="o">&lt;</span> <span class="n">extra_ais_width_threshold</span><span class="p">)</span> <span class="ow">and</span>
                                <span class="p">(</span><span class="n">curr_ais_spine_density</span> <span class="o">&lt;</span> <span class="n">extra_ais_spine_density_threshold</span><span class="p">)</span> <span class="ow">and</span> 
                                       <span class="p">(</span><span class="n">curr_soma_angle</span> <span class="o">&gt;</span><span class="n">extra_ais_angle_threshold</span><span class="p">))</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Apply extra conditions in order to add back AIS to axons&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_soma_angle = </span><span class="si">{</span><span class="n">curr_soma_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_ais_width = </span><span class="si">{</span><span class="n">curr_ais_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_ais_spine_density = </span><span class="si">{</span><span class="n">curr_ais_spine_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add_back_ais = </span><span class="si">{</span><span class="n">add_back_ais</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="n">add_back_ais</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding the starting candidate (</span><span class="si">{</span><span class="n">candidate_starting_node</span><span class="si">}</span><span class="s2">) to the axon_branches_on_limb&quot;</span><span class="p">)</span>
                    <span class="n">axon_branches_on_limb</span>  <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axon_branches_on_limb</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span>
                    

            
            <span class="c1"># ------------- Part A: Filtering For Axon Composition ------------------</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) Get the number of branches in the candidate that are axons</span>
<span class="sd">            2a) If all are axons --&gt; choose the relaxed axon angle threshold</span>
<span class="sd">            2b) If none are axons --&gt; remove as not a candidate</span>
<span class="sd">            2c) if some are --&gt; use standard axon threshold</span>

<span class="sd">            &quot;&quot;&quot;</span>
            
                
                
                
                
                
            
                
            <span class="n">axon_branches_on_subgraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_branches_on_limb</span><span class="p">,</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span>
            

            <span class="n">axon_percentage_n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_branches_on_subgraph</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span>
            <span class="n">axon_percentage</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axon_branches_on_subgraph</span><span class="p">])</span><span class="o">/</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_candidate_subgraph</span><span class="p">]))</span>
            <span class="n">axon_length_over_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axon_branches_on_subgraph</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">axon_branches_on_subgraph</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span><span class="si">}</span><span class="s2"> branches are axons&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axon percentage = </span><span class="si">{</span><span class="n">axon_percentage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_percentage_n_nodes = </span><span class="si">{</span><span class="n">axon_percentage_n_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_length_over_nodes = </span><span class="si">{</span><span class="n">axon_length_over_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">axon_percentage</span> <span class="o">&gt;</span> <span class="n">relaxation_percentage</span> <span class="ow">or</span> <span class="n">axon_length_over_nodes</span> <span class="o">&gt;</span> <span class="n">relaxation_axon_length</span><span class="p">:</span>
                <span class="n">curr_axon_angle_threshold</span> <span class="o">=</span> <span class="n">axon_angle_threshold_relaxed</span>
                
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_branches_on_subgraph</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding candidate no axon branches detected &quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_axon_angle_threshold</span> <span class="o">=</span> <span class="n">axon_angle_threshold</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_axon_angle_threshold = </span><span class="si">{</span><span class="n">curr_axon_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>






            <span class="c1"># ---------  Part B: Filtering For Starting Skeleton Angle -------------</span>
            


            <span class="n">candidate_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">curr_candidate_subgraph</span><span class="p">,</span><span class="n">current_shortest_path</span><span class="p">]))</span>
            
            <span class="c1"># ----- 1/24: Filtering out the nodes that are on branches that are not axons --------- #</span>
            <span class="n">non_axon_branches_on_subgraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">candidate_nodes</span><span class="p">,</span><span class="n">axon_branches_on_limb</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;candidate_nodes = </span><span class="si">{</span><span class="n">candidate_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;non_axon_branches_on_subgraph = </span><span class="si">{</span><span class="n">non_axon_branches_on_subgraph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



            <span class="n">candidate_angles</span><span class="p">,</span><span class="n">restr_skels</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">candidate_starting_skeletal_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                              <span class="n">candidate_nodes</span><span class="o">=</span><span class="n">candidate_nodes</span><span class="p">,</span>
                                  <span class="n">offset</span> <span class="o">=</span> <span class="n">skeletal_angle_offset</span><span class="p">,</span>
                                <span class="n">axon_sk_direction_comparison_distance</span> <span class="o">=</span> <span class="n">skeletal_angle_comparison_distance</span><span class="p">,</span>
                                <span class="n">buffer_for_skeleton</span> <span class="o">=</span> <span class="n">skeletal_angle_buffer</span><span class="p">,</span>
                                  <span class="n">top_volume_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                                  <span class="n">plot_skeleton_paths_before_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">plot_skeleton_paths_after_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">return_restricted_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                   <span class="n">branches_not_to_consider_for_end_nodes</span> <span class="o">=</span> <span class="n">non_axon_branches_on_subgraph</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span>
                                 <span class="p">)</span>
            <span class="c1">#print(f&quot;candidate_angles,restr_skels = {candidate_angles,restr_skels}&quot;)</span>
            
            <span class="k">if</span> <span class="n">candidate_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sk_passing_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">candidate_angles</span><span class="o">&gt;</span><span class="n">curr_axon_angle_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sk_passing_threshold</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_passing_threshold</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding candidate because no angles (</span><span class="si">{</span><span class="n">candidate_angles</span><span class="si">}</span><span class="s2">)&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; passed the threhold </span><span class="si">{</span><span class="n">curr_axon_angle_threshold</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="k">continue</span>





            <span class="c1"># -----------Part C: Filtering by Axon Being the Current Starting Piece -------------</span>

            <span class="k">if</span> <span class="n">candidate_starting_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axon_branches_on_limb</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding candidate the first branch was not an axon &quot;</span><span class="p">)</span>
                <span class="k">continue</span>
                
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_beginning_ais_for_width_filter</span><span class="p">:</span>
                <span class="n">ais_width</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1">#get the closest endpoint</span>
                    <span class="n">endpoint_closest_to_limb_starting_coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">closest_branch_endpoint_to_limb_starting_coordinate</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="o">=</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">],</span>
                                                       <span class="p">)</span>
                    
                    
                    <span class="p">(</span><span class="n">base_final_skeleton</span><span class="p">,</span>
                    <span class="n">base_final_widths</span><span class="p">,</span>
                    <span class="n">base_final_seg_lengths</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_and_restrict_branch</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">],</span>
                                              <span class="n">common_endpoint</span><span class="o">=</span><span class="n">endpoint_closest_to_limb_starting_coordinate</span><span class="p">,</span>
                                             <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                             <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                             <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="p">)</span>
                    
                    <span class="n">ais_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">base_final_widths</span><span class="p">)</span>
                    <span class="n">overall_ais_width</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;base_final_widths = </span><span class="si">{</span><span class="n">base_final_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;overall_ais_width = </span><span class="si">{</span><span class="n">overall_ais_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ais_width = </span><span class="si">{</span><span class="n">ais_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Problem with calculating restricted ais so just using overall segment width&quot;</span><span class="p">)</span>
                    <span class="n">ais_width</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
                
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ais_width  = </span><span class="si">{</span><span class="n">ais_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ais_width</span> <span class="o">&lt;</span> <span class="n">min_ais_width</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Not adding candidate the because AIS width was not higher than threshold (</span><span class="si">{</span><span class="n">min_ais_width</span><span class="si">}</span><span class="s1">): </span><span class="si">{</span><span class="n">ais_width</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                
            
             
                




            <span class="c1"># ----Part D: Add all of the candidates branches and those backtracking to mesh that are axon-like</span>
            <span class="n">extra_nodes_to_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_branches_on_limb</span><span class="p">,</span><span class="n">current_shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">true_axon_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">curr_candidate_subgraph</span><span class="p">,</span><span class="n">extra_nodes_to_add</span><span class="p">])</span>

            

            <span class="k">if</span> <span class="n">curr_limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axon_candidate_filtered</span><span class="p">:</span>
                <span class="n">axon_candidate_filtered</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">axon_candidate_filtered_angles</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">axon_candidate_filtered</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">][</span><span class="n">curr_candidate_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_axon_branches</span>
            <span class="n">max_axon_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">candidate_angles</span><span class="p">)</span>
            <span class="n">axon_candidate_filtered_angles</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">][</span><span class="n">curr_candidate_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_axon_angle</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding the following branches as true axons: </span><span class="si">{</span><span class="n">true_axon_branches</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;curr_soma_angle = </span><span class="si">{</span><span class="n">curr_soma_angle</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;max_axon_angle = </span><span class="si">{</span><span class="n">max_axon_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            1) if the soma angle is better and the other angle is not greater than 150, replace</span>
<span class="sd">            2) if both soma angles are being compared are 150, then choose the best</span>
<span class="sd">            candidate based on then choose based on best axon angle</span>
<span class="sd">            </span>
<span class="sd">            **might want to add something where not choose the really short one over</span>
<span class="sd">            the longer axon **</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">comparison_angle_threshold</span> <span class="o">=</span> <span class="mi">110</span>
            <span class="n">replace_flag</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----- Atempting to decide to replace best candidate&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_soma_angle  = </span><span class="si">{</span><span class="n">curr_soma_angle</span><span class="si">}</span><span class="s2">, best_axon_soma_angle = </span><span class="si">{</span><span class="n">best_axon_soma_angle</span><span class="si">}</span><span class="s2"> (comparison_angle_threshold = </span><span class="si">{</span><span class="n">comparison_angle_threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                
                
                
            <span class="n">current_candidate_limb_branch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_limb_idx</span><span class="p">:</span><span class="n">curr_candidate_subgraph</span><span class="p">}</span>
            <span class="n">candidate_filt_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">candidate_idx</span> <span class="o">=</span> <span class="n">curr_candidate_idx</span><span class="p">,</span>
                <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">curr_limb_idx</span><span class="p">,</span>
                <span class="n">soma_angle</span><span class="o">=</span><span class="n">curr_soma_angle</span><span class="p">,</span>
                <span class="n">axon_angle</span> <span class="o">=</span> <span class="n">max_axon_angle</span><span class="p">,</span>
                <span class="n">axon_skeletal_length</span> <span class="o">=</span>  <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                            <span class="p">{</span><span class="n">curr_limb_idx</span><span class="p">:{</span><span class="n">curr_candidate_idx</span><span class="p">:</span><span class="n">true_axon_branches</span><span class="p">}},</span>
                                                                                 <span class="s2">&quot;skeletal_length&quot;</span><span class="p">),</span>
                <span class="n">best_axon_candidate_filtered</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_limb_idx</span><span class="p">:{</span><span class="n">curr_candidate_idx</span><span class="p">:</span><span class="n">true_axon_branches</span><span class="p">}},</span>
                
                
                
            <span class="p">))</span>    
                
            
            
            <span class="k">if</span> <span class="n">curr_soma_angle</span> <span class="o">&gt;</span> <span class="n">best_axon_soma_angle</span> <span class="ow">and</span>  <span class="n">best_axon_soma_angle</span> <span class="o">&lt;</span> <span class="n">comparison_angle_threshold</span><span class="p">:</span>
                
                <span class="n">replace_flag</span> <span class="o">=</span> <span class="kc">True</span>
                
            <span class="k">elif</span> <span class="n">curr_soma_angle</span> <span class="o">&gt;=</span> <span class="n">best_axon_soma_angle</span> <span class="ow">or</span> <span class="n">curr_soma_angle</span> <span class="o">&gt;=</span> <span class="n">comparison_angle_threshold</span><span class="p">:</span>
                
                <span class="c1">#want to compute the lengths of each of these axons</span>
                
                <span class="n">current_candidate_limb_branch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_limb_idx</span><span class="p">:</span><span class="n">curr_candidate_subgraph</span><span class="p">}</span>
                <span class="n">curr_skeletal_length</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                             <span class="n">current_candidate_limb_branch_dict</span><span class="p">,</span>
                                                                             <span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>
                <span class="n">skeletal_length_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_axon_skeletal_length</span><span class="o">/</span><span class="n">curr_skeletal_length</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_skeletal_length = </span><span class="si">{</span><span class="n">curr_skeletal_length</span><span class="si">}</span><span class="s2">, best_axon_skeletal_length= </span><span class="si">{</span><span class="n">best_axon_skeletal_length</span><span class="si">}</span><span class="s2">, skeletal_length_ratio = </span><span class="si">{</span><span class="n">skeletal_length_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
                <span class="k">if</span> <span class="n">max_axon_angle</span> <span class="o">&gt;=</span> <span class="n">best_axon_axon_angle</span> <span class="ow">or</span> <span class="p">(</span><span class="n">best_axon_axon_angle</span> <span class="o">&gt;</span> <span class="mi">120</span> <span class="ow">and</span> <span class="n">skeletal_length_ratio</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">best_axon_skeletal_legnth_ratio</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">skeletal_length_ratio</span><span class="o">&lt;</span><span class="n">best_axon_skeletal_legnth_ratio</span><span class="p">:</span>
                        <span class="n">replace_flag</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not replacing best axon because skeletal length ration (</span><span class="si">{</span><span class="n">skeletal_length_ratio</span><span class="si">}</span><span class="s2">) was greater than threshold of </span><span class="si">{</span><span class="n">best_axon_skeletal_legnth_ratio</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not replacing best axon because angle (</span><span class="si">{</span><span class="n">max_axon_angle</span><span class="si">}</span><span class="s2">) was less than the </span><span class="si">{</span><span class="n">best_axon_axon_angle</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">and/or &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;skeletal_length_ratio (</span><span class="si">{</span><span class="n">skeletal_length_ratio</span><span class="si">}</span><span class="s2">) was not less than 1/best_axon_skeletal_legnth_ratio (</span><span class="si">{</span><span class="mi">1</span><span class="o">/</span><span class="n">best_axon_skeletal_legnth_ratio</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">replace_flag</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Changing to a better axon candidate&quot;</span><span class="p">)</span>
                <span class="n">best_axon_axon_angle</span> <span class="o">=</span> <span class="n">max_axon_angle</span>
                <span class="n">best_axon_soma_angle</span> <span class="o">=</span> <span class="n">curr_soma_angle</span>
                <span class="n">best_axon_candidate_filtered</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_limb_idx</span><span class="p">:{</span><span class="n">curr_candidate_idx</span><span class="p">:</span><span class="n">true_axon_branches</span><span class="p">}}</span>
                <span class="n">best_axon_candidate_filtered_angles</span> <span class="o">=</span> <span class="p">{</span><span class="n">curr_limb_idx</span><span class="p">:{</span><span class="n">curr_candidate_idx</span><span class="p">:</span><span class="n">max_axon_angle</span><span class="p">}}</span>
                <span class="n">best_axon_skeletal_length</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                                 <span class="n">best_axon_candidate_filtered</span><span class="p">,</span>
                                                                                 <span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>
    
    <span class="c1">#compiling list into limb_branch dict that is easy to use</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span> <span class="n">limb_info</span> <span class="ow">in</span> <span class="n">axon_candidate_filtered</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cand_idx</span><span class="p">,</span><span class="n">cand_list</span> <span class="ow">in</span> <span class="n">limb_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">curr_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand_list</span><span class="p">)</span>
        <span class="n">limb_branch_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">curr_branches</span><span class="p">)</span>
        
    <span class="c1">#compiling list into limb_branch dict that is easy to use</span>
    <span class="n">best_limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span> <span class="n">limb_info</span> <span class="ow">in</span> <span class="n">best_axon_candidate_filtered</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">curr_branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cand_idx</span><span class="p">,</span><span class="n">cand_list</span> <span class="ow">in</span> <span class="n">limb_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">curr_branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand_list</span><span class="p">)</span>
        <span class="n">best_limb_branch_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">curr_branches</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">best_axon</span><span class="p">:</span>
        <span class="c1"># --- 2_17: Will add back axon parts that should be accounted for </span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        if there even is an axon</span>
<span class="sd">        1) Get the limb name of the best axon</span>
<span class="sd">        2) Get the concept network of the limb and the starting node</span>
<span class="sd">        3) Get the branches that would be axon</span>
<span class="sd">        4) Delete the branches from the concept network</span>
<span class="sd">        5) For each connected component in the leftover network</span>
<span class="sd">        - if not have starting node and all in axon-like: </span>
<span class="sd">        add to list to add to the true axon</span>

<span class="sd">        6) add the new nodes to the axon group</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_limb_branch_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1">#1) Get the limb name of the best axon</span>
            <span class="n">limb_name_of_axon</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">best_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_name_of_axon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Excpetion</span><span class="p">(</span><span class="s2">&quot;More than 1 axon key&quot;</span><span class="p">)</span>

            <span class="n">limb_name_of_axon</span> <span class="o">=</span> <span class="n">limb_name_of_axon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span>
            <span class="c1">#2) Get the concept network of the limb and the starting node</span>
            <span class="n">conc_net</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
            <span class="n">start_node</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span>

            <span class="c1">#3) Get the branches that would be axon</span>
            <span class="n">axon_branches</span> <span class="o">=</span> <span class="n">best_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span>
            <span class="n">axon_like_branches</span> <span class="o">=</span> <span class="n">axon_like_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span>

            <span class="c1">#4) Delete the branches from the concept network</span>
            <span class="n">conc_net</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">)</span>


            <span class="c1">#5) For each connected component in the leftover network</span>
            <span class="n">new_axon_branches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">conn_comp</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">conc_net</span><span class="p">):</span>
                <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span>

                <span class="c1">#- if not have starting node and all in axon-like: </span>
                <span class="c1">#add to list to add to the true axon</span>
                <span class="n">axon_like_in_conn_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_like_branches</span><span class="p">,</span><span class="n">conn_comp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">start_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conn_comp</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_like_in_conn_comp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">):</span>
                    <span class="n">new_axon_branches</span> <span class="o">+=</span> <span class="n">conn_comp</span>

    
        
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_axon_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">best_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_axon_branches</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the best axon approach&quot;</span><span class="p">)</span>
                    
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">best_limb_branch_dict</span> 
        <span class="n">axon_candidate_filtered_angles</span> <span class="o">=</span> <span class="n">best_axon_candidate_filtered_angles</span>
        
        <span class="c1"># ------- 2/17: Wil add back axon branches that have been cut off by best axon feature</span>
<span class="c1">#         from datasci_tools import system_utils as su</span>
<span class="c1">#         su.compressed_pickle(axon_like_limb_branch_dict,&quot;axon_like_limb_branch_dict&quot;)</span>
<span class="c1">#         su.compressed_pickle(best_limb_branch_dict,&quot;best_limb_branch_dict&quot;)</span>
        
    <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict</span><span class="p">,</span> <span class="n">axon_candidate_filtered_angles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_branch_dict</span></div>

    
<span class="c1"># --------- arguments to use for the axon identification -----------</span>
<span class="n">axon_width_like_requirement</span> <span class="o">=</span> <span class="s2">&quot;(median_mesh_center &lt; 200)&quot;</span><span class="c1"># or no_spine_median_mesh_center &lt; 150)&quot;</span>
<span class="n">ais_axon_width_like_requirement</span> <span class="o">=</span> <span class="s2">&quot;(median_mesh_center &lt; 600)&quot;</span> <span class="c1">#this will get all of axons including the axon </span>
<div class="viewcode-block" id="axon_width_like_query_revised"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_width_like_query_revised">[docs]</a><span class="k">def</span> <span class="nf">axon_width_like_query_revised</span><span class="p">(</span><span class="n">width_to_use</span><span class="p">,</span>
                                  <span class="n">spine_limit</span><span class="p">,</span>
                                 <span class="n">spine_density</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
   
    <span class="n">axon_width_like_query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;((n_spines &lt; 7) and (</span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2">) and spine_density &lt;= 0.00008)&quot;</span>
    <span class="k">return</span> <span class="n">axon_width_like_query</span></div>

<div class="viewcode-block" id="axon_width_like_segments"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_width_like_segments">[docs]</a><span class="k">def</span> <span class="nf">axon_width_like_segments</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                      <span class="n">current_query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">current_functions_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">include_ais</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             
                             <span class="c1">#arguments for the axon finding</span>
                             <span class="n">non_ais_width</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#200,</span>
                             <span class="n">ais_width</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#600,</span>
                             <span class="n">max_n_spines</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#7</span>
                             <span class="n">max_spine_density</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#0.00008</span>
                             <span class="n">width_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            
                            <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will get all of the branches that look like spines</span>
<span class="sd">    based on width and spine properties</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="n">non_ais_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">non_ais_width</span> <span class="o">=</span> <span class="n">non_ais_width_axon_global</span>
    <span class="k">if</span> <span class="n">ais_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ais_width</span> <span class="o">=</span> <span class="n">ais_width_axon_global</span>
    <span class="k">if</span> <span class="n">max_n_spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_n_spines</span> <span class="o">=</span> <span class="n">max_n_spines_axon_global</span>
    <span class="k">if</span> <span class="n">max_spine_density</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_spine_density</span> <span class="o">=</span> <span class="n">max_spine_density_axon_global</span>
    
    <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;n_spines&quot;</span><span class="p">,</span>
                     <span class="s2">&quot;spine_density&quot;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">current_functions_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">current_functions_list</span> <span class="o">=</span> <span class="n">functions_list</span>
        
    <span class="k">if</span> <span class="n">current_query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">width_to_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width_expression</span>  <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(median_mesh_center &lt; </span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_ais</span><span class="p">:</span>
                <span class="n">spine_limit</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="n">width_expression</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(median_mesh_center &lt; </span><span class="si">{</span><span class="n">ais_width</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spine_limit</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">width_expression</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(median_mesh_center &lt; </span><span class="si">{</span><span class="n">non_ais_width</span><span class="si">}</span><span class="s2">)&quot;</span>
                
                
        <span class="n">current_query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;((n_spines &lt; </span><span class="si">{</span><span class="n">max_n_spines</span><span class="si">}</span><span class="s2">) and (</span><span class="si">{</span><span class="n">width_expression</span><span class="si">}</span><span class="s2">) and spine_density &lt;= </span><span class="si">{</span><span class="n">max_spine_density</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="c1">#current_query = axon_width_like_query_revised(width_expression,spine_limit)</span>
        
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_query = </span><span class="si">{</span><span class="n">current_query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                       <span class="c1">#query=&quot;n_spines &lt; 4 and no_spine_average_mesh_center &lt; 400&quot;,</span>
                                       <span class="n">query</span><span class="o">=</span><span class="n">current_query</span><span class="p">,</span>
                                       <span class="c1">#return_dataframe=True,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="n">current_functions_list</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict= </span><span class="si">{</span><span class="n">limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">limb_branch_dict</span></div>


    
<div class="viewcode-block" id="axon_like_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_like_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">axon_like_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                                <span class="n">width_match_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                               <span class="n">downstream_non_axon_percentage_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                               <span class="n">distance_for_downstream_check</span><span class="o">=</span><span class="mi">40000</span><span class="p">,</span>
                               <span class="n">max_skeletal_length_can_flip</span><span class="o">=</span><span class="mi">70000</span><span class="p">,</span>
                              <span class="n">include_ais</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">plot_axon_like</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">axon_like_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_width_like_segments</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">include_ais</span><span class="o">=</span><span class="n">include_ais</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_like_limb_branch_dict = </span><span class="si">{</span><span class="n">axon_like_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    

    <span class="n">current_functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon_segment&quot;</span><span class="p">]</span>
    <span class="n">final_axon_like_classification</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>

                                       <span class="n">query</span><span class="o">=</span><span class="s2">&quot;axon_segment==True&quot;</span><span class="p">,</span>
                                       <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">limb_branch_dict</span> <span class="o">=</span><span class="n">axon_like_limb_branch_dict</span><span class="p">,</span>
                                                            <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="n">downstream_face_threshold</span><span class="p">,</span>
                                                            <span class="n">width_match_threshold</span><span class="o">=</span><span class="n">width_match_threshold</span><span class="p">,</span>
                                                            <span class="n">downstream_non_axon_percentage_threshold</span><span class="o">=</span><span class="n">downstream_non_axon_percentage_threshold</span><span class="p">,</span>
                                                            <span class="n">distance_for_downstream_check</span><span class="o">=</span><span class="n">distance_for_downstream_check</span><span class="p">,</span>
                                                            <span class="n">max_skeletal_length_can_flip</span><span class="o">=</span><span class="n">max_skeletal_length_can_flip</span><span class="p">,</span>
                                                            
                                                           <span class="n">print_flag</span><span class="o">=</span><span class="n">verbose</span><span class="p">),</span>
                                       <span class="n">functions_list</span><span class="o">=</span><span class="n">current_functions_list</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_axon_like_classification = </span><span class="si">{</span><span class="n">final_axon_like_classification</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_axon_like</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">final_axon_like_classification</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_axon_like_classification</span></div>
    
    
<div class="viewcode-block" id="clear_axon_labels_from_dendritic_paths_to_starter_node"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.clear_axon_labels_from_dendritic_paths_to_starter_node">[docs]</a><span class="k">def</span> <span class="nf">clear_axon_labels_from_dendritic_paths_to_starter_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                          <span class="n">axon_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                          <span class="n">dendritic_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To make sure that no axon branches are on path of dendritic branches</span>
<span class="sd">    back to the starting node of that limb</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1a) if dendritic branches are None then use axon branches to figure out</span>
<span class="sd">    1b) If axon branches are None....</span>
<span class="sd">    2) If dendritic branches or axon branches are empty then just return original axon branches</span>
<span class="sd">    3) Find starting node of branch</span>
<span class="sd">    4) for all dendritic branches:</span>
<span class="sd">        i) find the shortest path back to starting node</span>
<span class="sd">        ii) Add those nodes on path to a list to make sure is not included in axons</span>
<span class="sd">    5) Subtract all the non-axon list from the axon branches</span>
<span class="sd">    6) Return the new axon list</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    final_axon_branches = clu.clear_axon_labels_from_dendritic_paths_to_starter_node(limb_obj=neuron_obj[&quot;L4&quot;],</span>
<span class="sd">                                                          axon_branches=neuron_obj.axon_limb_branch_dict[&quot;L4&quot;],</span>
<span class="sd">                                                          dendritic_branches=None,</span>
<span class="sd">                                                          verbose=True)</span>
<span class="sd">    final_axon_branches</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_limb_branches</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_limb_branches = </span><span class="si">{</span><span class="n">curr_limb_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">dendritic_branches</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axon_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;At least dendritic_branches or axon_branches needs to be non-None &quot;</span><span class="p">)</span>
    
    <span class="c1"># 1a) if dendritic branches are None then use axon branches to figure out</span>
    <span class="k">if</span> <span class="n">dendritic_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dendritic_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_limb_branches</span><span class="p">,</span><span class="n">axon_branches</span><span class="p">)</span>
    
    <span class="c1">#1b) If axon branches are None....</span>
    <span class="k">if</span> <span class="n">axon_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_limb_branches</span><span class="p">,</span><span class="n">dendritic_branches</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dendritic_branches = </span><span class="si">{</span><span class="n">dendritic_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_branches = </span><span class="si">{</span><span class="n">axon_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="c1">#2) If dendritic branches or axon branches are empty then just return original axon branches</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dendritic_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No processing needed beause dendrites or axon are empty&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axon_branches</span>
    
    <span class="c1">#3) Find starting node of branch</span>
    <span class="n">starting_branch</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span>
    
    <span class="n">dendritic_nodes_by_path_check</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">branches_to_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dendritic_branches</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches_to_check</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_b</span> <span class="o">=</span> <span class="n">branches_to_check</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">curr_shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                              <span class="n">curr_b</span><span class="p">,</span>
                                             <span class="n">starting_branch</span><span class="p">)</span>

        <span class="n">dendritic_nodes_by_path_check</span> <span class="o">+=</span> <span class="n">curr_shortest_path</span>
        
        <span class="n">branches_to_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">branches_to_check</span><span class="p">,</span><span class="n">curr_shortest_path</span><span class="p">)</span>
    
    <span class="n">final_non_axonal_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dendritic_nodes_by_path_check</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_non_axonal_branches = </span><span class="si">{</span><span class="n">final_non_axonal_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">final_axon_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">,</span><span class="n">final_non_axonal_branches</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_axon_list</span></div>

<div class="viewcode-block" id="axon_classification"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_classification">[docs]</a><span class="k">def</span> <span class="nf">axon_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        
                        
    <span class="n">error_on_multi_soma</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">ais_threshold</span> <span class="o">=</span> <span class="mi">14_000</span><span class="p">,</span><span class="c1">#9000,# 5000,#10000,</span>
                        
                        <span class="c1">#Part 1: for axon-like classification</span>
                        <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                        <span class="n">width_match_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                        <span class="n">plot_axon_like_segments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        
                        <span class="c1">#Part 2: Filter limbs by starting angle</span>
                        <span class="n">axon_soma_angle_threshold</span> <span class="o">=</span> <span class="mi">70</span><span class="p">,</span>
                        
                        <span class="c1">#Part 3: Creating Candidates</span>
                        <span class="n">plot_candidates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        
                        <span class="c1">#Part 4: Filtering Candidates</span>
                        <span class="n">plot_axons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">plot_axon_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        
                        <span class="n">axon_angle_threshold_relaxed</span> <span class="o">=</span> <span class="mi">95</span><span class="p">,</span><span class="c1">#110,</span>
                        <span class="n">axon_angle_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
                        
    
    <span class="n">add_axon_labels</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">clean_prior_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  
    <span class="n">label_axon_errors</span> <span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        
    <span class="n">error_width_max</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span>
    <span class="n">error_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#5000,</span>
                        
    <span class="n">return_axon_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">return_axon_angles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        
    <span class="n">return_error_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">best_axon</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        
    <span class="n">no_dendritic_branches_off_axon</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        
                        
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    To put the whole axon classificatoin steps </span>
<span class="sd">    together into one function that will labels</span>
<span class="sd">    branches as axon-like, axon and error</span>
<span class="sd">    </span>
<span class="sd">    1) Classify All Axon-Like Segments</span>
<span class="sd">    2) Filter Limbs By Starting Angle</span>
<span class="sd">    3) Get all of the Viable Candidates</span>
<span class="sd">    4) Filter Candidates</span>
<span class="sd">    5) Apply Labels</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">plot_candidates</span><span class="o">=</span> <span class="kc">False</span>
    <span class="n">plot_axon_like_segments</span> <span class="o">=</span> <span class="kc">False</span>
    
    
    <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    <span class="n">soma_names</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_names</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">soma_print</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;More than 1 soma: </span><span class="si">{</span><span class="n">soma_names</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">error_on_multi_soma</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">soma_print</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">soma_print</span><span class="p">)</span>

    <span class="n">soma_name</span> <span class="o">=</span> <span class="n">soma_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    
    
    
    
    <span class="c1">#  ------------- Part 1: Classify All Axon-Like Segments ----------------------------</span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;  Old way that did not use the classification</span>
<span class="sd">    </span>
<span class="sd">    axon_like_limb_branch_dict = ns.axon_width_like_segments(curr_neuron_obj,</span>
<span class="sd">                                                        include_ais=True)</span>

<span class="sd">    # nviz.visualize_neuron(curr_neuron_obj,</span>
<span class="sd">    #                       visualize_type=[&quot;mesh&quot;],</span>
<span class="sd">    #                      limb_branch_dict=axon_like_limb_branch_dict,</span>
<span class="sd">    #                      mesh_color=&quot;red&quot;,</span>
<span class="sd">    #                       mesh_color_alpha=1,</span>
<span class="sd">    #                      mesh_whole_neuron=True)</span>

<span class="sd">    current_functions_list = [&quot;axon_segment&quot;]</span>
<span class="sd">    final_axon_like_classification = ns.query_neuron(curr_neuron_obj,</span>

<span class="sd">                                       query=&quot;axon_segment==True&quot;,</span>
<span class="sd">                                       function_kwargs=dict(limb_branch_dict =axon_like_limb_branch_dict,</span>
<span class="sd">                                                            downstream_face_threshold=downstream_face_threshold,</span>
<span class="sd">                                                            width_match_threshold=width_match_threshold,</span>
<span class="sd">                                                           print_flag=False),</span>
<span class="sd">                                       functions_list=current_functions_list)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">final_axon_like_classification</span> <span class="o">=</span> <span class="n">axon_like_limb_branch_dict</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                                                <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="n">downstream_face_threshold</span><span class="p">,</span>
                                                                <span class="n">width_match_threshold</span><span class="o">=</span><span class="n">width_match_threshold</span><span class="p">,</span>
                                                               <span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_axon_like_segments</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">final_axon_like_classification</span><span class="p">,</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Part 1: Axon like branchese </span><span class="se">\n</span><span class="si">{</span><span class="n">final_axon_like_classification</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
    <span class="c1">#------------------ Part 2: Filter Limbs By Starting Angle  ------------------</span>
    
    
    

    <span class="n">soma_center</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>

    <span class="n">possible_axon_limbs_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                    <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;soma_starting_angle&gt;</span><span class="si">{</span><span class="n">axon_soma_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">],</span>
                   <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">soma_center</span><span class="o">=</span><span class="n">soma_center</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

    <span class="n">possible_axon_limbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">possible_axon_limbs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">possible_axon_limbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_int_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">possible_axon_limbs</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Part 2: possible_axon_limbs = </span><span class="si">{</span><span class="n">possible_axon_limbs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
              
              
                
                
    
    <span class="c1">#---------------------- Part 3: Get all of the Viable Candidates ----------------------</span>
    
    
    <span class="n">axon_subgraph_candidates</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_candidates</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                   <span class="n">possible_axon_limbs</span><span class="o">=</span><span class="n">possible_axon_limbs</span><span class="p">,</span>
                        <span class="n">ais_threshold</span><span class="o">=</span><span class="n">ais_threshold</span><span class="p">,</span>
                   <span class="n">plot_candidates_after_adding_back</span><span class="o">=</span><span class="n">plot_candidates</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                   
                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
              
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Part 3: axon_subgraph_candidates = </span><span class="si">{</span><span class="n">axon_subgraph_candidates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        
        
        
    
    <span class="c1">#---------------------- Part 4: Filtering The Candidates ----------------------</span>
    
    <span class="n">curr_result</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">filter_axon_candiates</span><span class="p">(</span>
                            <span class="n">curr_neuron_obj</span><span class="p">,</span>
                            <span class="n">axon_subgraph_candidates</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="n">axon_like_limb_branch_dict</span><span class="o">=</span><span class="n">final_axon_like_classification</span><span class="p">,</span>
                                <span class="n">return_axon_angles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">axon_angle_threshold_relaxed</span> <span class="o">=</span> <span class="n">axon_angle_threshold_relaxed</span><span class="p">,</span>
                                <span class="n">axon_angle_threshold</span> <span class="o">=</span> <span class="n">axon_angle_threshold</span><span class="p">,</span>
                                <span class="n">best_axon</span><span class="o">=</span><span class="n">best_axon</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span>
    
    
    
    
    <span class="n">final_true_axons</span><span class="p">,</span> <span class="n">axon_angles</span> <span class="o">=</span> <span class="n">curr_result</span>
    
    <span class="k">if</span> <span class="n">no_dendritic_branches_off_axon</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using </span><span class="si">{</span><span class="n">no_dendritic_branches_off_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">final_true_axons_new</span><span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">axon_branches</span> <span class="ow">in</span> <span class="n">final_true_axons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            
            <span class="n">new_axon_branches</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">clear_axon_labels_from_dendritic_paths_to_starter_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name</span><span class="p">],</span>
                                                          <span class="n">axon_branches</span><span class="o">=</span><span class="n">axon_branches</span><span class="p">,</span>
                                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">: Axon branches before dendritic path filter = </span><span class="si">{</span><span class="n">axon_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">: Axon branches AFTER dendritic path filter = </span><span class="si">{</span><span class="n">new_axon_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="n">final_true_axons_new</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_axon_branches</span>
        <span class="n">final_true_axons</span> <span class="o">=</span> <span class="n">final_true_axons_new</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Part 4: final_true_axons = </span><span class="si">{</span><span class="n">final_true_axons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_axons</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_true_axons</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                  <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                                 <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">final_true_axons</span><span class="p">,</span>
                                 <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                  <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                 <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO AXON DETECTED FOR PLOTTING&quot;</span><span class="p">)</span>
        
        
        
    <span class="c1">#---------------------- Part 5: Adding Labels ----------------------</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Clear the labels if option set</span>
<span class="sd">    2) Label all the true axon branches</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">clean_prior_axon_labels</span> <span class="ow">and</span> <span class="n">add_axon_labels</span><span class="p">:</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">clear_all_branch_labels</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,[</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span><span class="s2">&quot;axon-like&quot;</span><span class="p">,</span><span class="s2">&quot;axon-error&quot;</span><span class="p">])</span>
    
<span class="c1">#     nru.add_branch_label(curr_neuron_obj,</span>
<span class="c1">#                     limb_branch_dict=final_axon_like_classification,</span>
<span class="c1">#                     labels=&quot;axon-like&quot;)</span>
    
    <span class="c1">#adding the labels</span>
    <span class="k">if</span> <span class="n">add_axon_labels</span><span class="p">:</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">final_true_axons</span><span class="p">,</span>
                        <span class="n">labels</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">)</span>

        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                    <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">final_axon_like_classification</span><span class="p">,</span>
                    <span class="n">labels</span><span class="o">=</span><span class="s2">&quot;axon-like&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="p">(</span><span class="n">label_axon_errors</span> <span class="ow">or</span> <span class="n">return_error_labels</span><span class="p">)</span> <span class="ow">and</span> <span class="n">add_axon_labels</span><span class="p">:</span>
        
        
        <span class="k">if</span> <span class="n">error_width_max</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">error_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">error_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                 <span class="n">matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">],</span>
                                 <span class="n">not_matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span>
                                 <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_length_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error_length_min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">error_width_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error_width_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            
            <span class="n">error_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;(labels_restriction == True) and (median_mesh_center &lt; </span><span class="si">{</span><span class="n">error_width_max</span><span class="si">}</span><span class="s2">) &quot;</span>
                                                     <span class="sa">f</span><span class="s2">&quot;and (skeletal_length &gt; </span><span class="si">{</span><span class="n">error_length_min</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;labels_restriction&quot;</span><span class="p">,</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">],</span>
                   <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">],</span>
                                        <span class="n">not_matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span>
                                       <span class="p">)</span>
                           <span class="p">)</span>

        <span class="k">if</span> <span class="n">label_axon_errors</span><span class="p">:</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                            <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">error_limb_branch_dict</span><span class="p">,</span>
                            <span class="n">labels</span><span class="o">=</span><span class="s2">&quot;axon-error&quot;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">plot_axon_errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_limb_branch_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                      <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">error_limb_branch_dict</span><span class="p">,</span>
                                     <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                      <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO AXON ERRORS DETECTED FOR PLOTTING!!&quot;</span><span class="p">)</span>
        

    <span class="k">if</span> <span class="n">return_axon_labels</span> <span class="ow">and</span> <span class="n">return_error_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_true_axons</span><span class="p">,</span><span class="n">axon_angles</span><span class="p">,</span><span class="n">error_limb_branch_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_true_axons</span><span class="p">,</span><span class="n">error_limb_branch_dict</span>
    <span class="k">elif</span> <span class="n">return_axon_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_true_axons</span><span class="p">,</span><span class="n">axon_angles</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_true_axons</span>
    <span class="k">elif</span> <span class="n">return_error_labels</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error_limb_branch_dict</span></div>
                                                    
        

        
<span class="c1"># ----------- 2/15: Visualizing the Axon Classification --------- #</span>


<div class="viewcode-block" id="axon_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">axon_limb_branch_dict</span></div>

<div class="viewcode-block" id="dendrite_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.dendrite_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">dendrite_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">dendrite_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">not_matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dendrite_limb_branch_dict</span></div>

<div class="viewcode-block" id="dendrite_branches_on_limb"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.dendrite_branches_on_limb">[docs]</a><span class="k">def</span> <span class="nf">dendrite_branches_on_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limb_name</span><span class="p">):</span>
    <span class="n">dendrite_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">limb_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">dendrite_limb_branch_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dendrite_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></div>

<div class="viewcode-block" id="axon_mesh_from_labels"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_mesh_from_labels">[docs]</a><span class="k">def</span> <span class="nf">axon_mesh_from_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">plot_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will compile the axon mesh from the </span>
<span class="sd">    labels stored in the neuron object</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    clu.axon_mesh_from_labels(neuron_obj,</span>
<span class="sd">                     plot_axon=False,</span>
<span class="sd">                     verbose=True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axon_limb_branch</span> <span class="o">=</span> <span class="n">axon_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    
    <span class="n">axon_meshes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                    <span class="n">axon_limb_branch</span><span class="p">,</span>
                                                    <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span>
                                                   <span class="p">)</span>
    <span class="n">axon_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">axon_meshes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final axon_mesh = </span><span class="si">{</span><span class="n">axon_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_axon</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">axon_mesh</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">axon_mesh</span></div>

<span class="k">def</span> <span class="nf">axon_faces_from_labels_on_original_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">original_mesh</span><span class="p">,</span>
                                           <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                            <span class="n">plot_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the axon face indices on the original mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the original mesh if not passed</span>
<span class="sd">    2) Get the axon mesh of the neuron object</span>
<span class="sd">    3) Map the axon mesh to the original mesh</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    clu.axon_faces_from_labels_on_original_mesh(neuron_obj,</span>
<span class="sd">                                            plot_axon=True,</span>
<span class="sd">                                           verbose=True,</span>
<span class="sd">                                           original_mesh=original_mesh,</span>
<span class="sd">                                           original_mesh_kdtree=original_mesh_kdtree)</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="n">axon_mesh</span> <span class="o">=</span> <span class="n">axon_mesh_from_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">axon_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                        <span class="n">axon_mesh</span><span class="p">,</span>
                                                        <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_axon</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                          <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">axon_mesh_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">axon_mesh_faces</span>

        
        
        
<span class="c1"># ----------- 1/22: Apical Classification (The beginning parts): ----------------- #</span>


<div class="viewcode-block" id="apical_branch_candidates_on_limb"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.apical_branch_candidates_on_limb">[docs]</a><span class="k">def</span> <span class="nf">apical_branch_candidates_on_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                     
                                     
                                    <span class="n">apical_check_distance_max</span> <span class="o">=</span> <span class="mi">90000</span><span class="p">,</span>
                                    <span class="n">apical_check_distance_min</span> <span class="o">=</span> <span class="mi">25000</span><span class="p">,</span>
                                    <span class="n">plot_restricted_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">plot_restricted_skeleton_with_endnodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     
                                     
                                    <span class="n">angle_threshold</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
                                    <span class="n">top_volume_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                                     
                                     <span class="n">spine_density_threshold</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">,</span>
                                    <span class="n">total_skeleton_distance_threshold_multiplier</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                                    <span class="c1">#apical_width_threshold = 350,</span>
                                     <span class="n">apical_width_threshold</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
                                    <span class="n">upward_distance_to_skeletal_distance_ratio_threshold</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
                                    
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To identify the branches on the limb that are most likely </span>
<span class="sd">    part of a large upward apical branch</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Psuedoode:</span>
<span class="sd">    0a) Getting the subskeleton region to analyze</span>
<span class="sd">    0b) Divided the Restricted Skeleton into components to analyze</span>
<span class="sd">    </span>
<span class="sd">    For each connected component</span>
<span class="sd">    1) Get all the end nodes of the subgraph</span>
<span class="sd">    2) Subtract of the closest subgraph node to limb start</span>
<span class="sd">    For each end node</span>
<span class="sd">    3) Look at the vector between end nodes and closest node </span>
<span class="sd">        (continue if not approximately straight up) and not long enough</span>
<span class="sd">    4) Find the branches that contain the two ends of the path</span>

<span class="sd">    For all combinations of branches:</span>

<span class="sd">    5) Find the shortest path between the two branches on the context network</span>
<span class="sd">    6) Get the subskeleton:</span>
<span class="sd">    - Analyze for width and spine density (and if too thin or not spiny enough then continue)</span>
<span class="sd">    7) If passed all tests then add the branch path as possible candidate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">limb_obj</span>
    <span class="n">apical_branches</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">total_skeleton_distance_threshold</span> <span class="o">=</span> <span class="n">total_skeleton_distance_threshold_multiplier</span><span class="o">*</span><span class="p">(</span><span class="n">apical_check_distance_max</span> <span class="o">-</span> <span class="n">apical_check_distance_min</span><span class="p">)</span>
    
    
    <span class="c1">#0a) Getting the subskeleton region to analyze</span>
    
    
    <span class="n">limb_gr</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="n">st_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_graph_node_by_coordinate</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">)</span>
    <span class="n">nodes_max_distance</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">st_node</span><span class="p">,</span><span class="n">apical_check_distance_max</span><span class="p">)</span>
    <span class="n">nodes_min_distance</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_nodes_within_certain_distance_of_target_node</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">st_node</span><span class="p">,</span><span class="n">apical_check_distance_min</span><span class="p">)</span>
    <span class="n">nodes_with_distance_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes_max_distance</span><span class="p">),</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes_min_distance</span><span class="p">))</span>


    <span class="n">restricted_limb_gr</span> <span class="o">=</span> <span class="n">limb_gr</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nodes_with_distance_range</span><span class="p">)</span>
    <span class="n">restricted_limb_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">restricted_limb_gr</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_restricted_skeleton</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">restricted_limb_sk</span><span class="p">])</span>
        
        
    <span class="c1">#0b) Divided the Restricted Skeleton into components to analyze</span>
        
    <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">restricted_limb_gr</span><span class="p">)])</span>
    <span class="n">conn_comp_closest_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,[</span><span class="n">st_node</span><span class="p">],</span><span class="n">k</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">conn_comp</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot_restricted_skeleton_with_endnodes</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">restricted_limb_sk</span><span class="p">],</span>
                     <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">conn_comp_closest_nodes</span><span class="p">)],</span>
                     <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        
    
    <span class="k">for</span> <span class="n">component_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)):</span>
        
        <span class="c1"># 1) Get all the end nodes of the subgraph</span>
        <span class="n">curr_cmpnt</span> <span class="o">=</span> <span class="n">conn_comp</span><span class="p">[</span><span class="n">component_idx</span><span class="p">]</span>
        <span class="n">closest_node</span> <span class="o">=</span> <span class="n">conn_comp_closest_nodes</span><span class="p">[</span><span class="n">component_idx</span><span class="p">]</span>
        <span class="n">closest_node_coordinate</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">closest_node</span><span class="p">)</span>

        <span class="n">c_subgraph</span> <span class="o">=</span> <span class="n">restricted_limb_gr</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">curr_cmpnt</span><span class="p">)</span>
        <span class="n">endnodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_nodes_of_degree_k</span><span class="p">(</span><span class="n">c_subgraph</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#2) Subtract of the closest subgraph node to limb start</span>
        <span class="n">filtered_endnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">endnodes</span><span class="p">,</span><span class="n">closest_node</span><span class="p">)</span>
        <span class="n">filtered_endnodes_coordinates</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_coordinate_by_graph_node</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">filtered_endnodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filered End nodes for component </span><span class="si">{</span><span class="n">component_idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">filtered_endnodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        
        
        <span class="k">for</span> <span class="n">e_node_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_endnodes</span><span class="p">)):</span>
            
            <span class="c1">#3) Look at the vector between end nodes and closest node </span>
            <span class="n">e_node</span> <span class="o">=</span> <span class="n">filtered_endnodes</span><span class="p">[</span><span class="n">e_node_idx</span><span class="p">]</span>
            <span class="n">e_node_coordinate</span> <span class="o">=</span> <span class="n">filtered_endnodes_coordinates</span><span class="p">[</span><span class="n">e_node_idx</span><span class="p">]</span>

            <span class="c1"># nviz.plot_objects(curr_limb.mesh,</span>
            <span class="c1">#                  skeletons=[restricted_limb_sk],</span>
            <span class="c1">#                  scatters=[xu.get_coordinate_by_graph_node(limb_gr,[closest_node,e_node])],</span>
            <span class="c1">#                  scatter_size=1)</span>

            <span class="n">curr_vector</span> <span class="o">=</span> <span class="n">e_node_coordinate</span><span class="o">-</span><span class="n">closest_node_coordinate</span>
            <span class="n">curr_vector_upward_distance</span> <span class="o">=</span> <span class="o">-</span><span class="n">curr_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">curr_vector_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">curr_vector</span><span class="p">)</span>

            <span class="n">curr_vector_angle</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">top_volume_vector</span><span class="p">,</span><span class="n">curr_vector</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;End Node Candidate </span><span class="si">{</span><span class="n">e_node_idx</span><span class="si">}</span><span class="s2"> angle = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">curr_vector_angle</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    Upward distance </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">curr_vector_upward_distance</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">reject_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">curr_vector_angle</span> <span class="o">&gt;</span> <span class="n">angle_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rejecting candidate because did not pass angle threshold of ess than </span><span class="si">{</span><span class="n">angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
                
                
                
            <span class="c1">#4) Find the branches that contain the two ends of the path</span>
            <span class="n">curr_skeleton_path</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_graph_to_skeleton</span><span class="p">(</span><span class="n">limb_gr</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">limb_gr</span><span class="p">,</span><span class="n">closest_node</span><span class="p">,</span><span class="n">e_node</span><span class="p">)))</span>
            <span class="n">curr_skeleton_path_len</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_skeleton_path</span><span class="p">)</span>

            <span class="n">e_node_branches</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">e_node_coordinate</span><span class="p">)</span>

            <span class="n">closest_node_branches</span> <span class="o">=</span>  <span class="n">nru</span><span class="o">.</span><span class="n">find_branch_with_specific_coordinate</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">closest_node_coordinate</span><span class="p">)</span>

            <span class="c1">#get all possible combinations</span>
            <span class="n">all_branch_pairings</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">unique_pairings_between_2_arrays</span><span class="p">(</span><span class="n">closest_node_branches</span><span class="p">,</span>
                                                                      <span class="n">e_node_branches</span>
                                                                     <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_branch_pairings = </span><span class="si">{</span><span class="n">all_branch_pairings</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                
                
            
            <span class="c1">#for st_branch,end_branch in all_branch_pairings</span>
            <span class="c1">#5) Find the shortest path between the two branches on the context network</span>

            <span class="k">for</span> <span class="n">curr_pairing_idx</span>  <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_branch_pairings</span><span class="p">)):</span>

                <span class="n">st_branch</span> <span class="o">=</span> <span class="n">all_branch_pairings</span><span class="p">[</span><span class="n">curr_pairing_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end_branch</span> <span class="o">=</span> <span class="n">all_branch_pairings</span><span class="p">[</span><span class="n">curr_pairing_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">branch_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">st_branch</span><span class="p">,</span><span class="n">end_branch</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couln&#39;t find path between branches&quot;</span><span class="p">)</span>

                <span class="c1">#6) Get the subskeleton:</span>
                <span class="c1">#- Analyze for width and spine density (and if too thin or not spiny enough then continue)</span>

                <span class="c1">#total_skeleton = sk.stack_skeletons([curr_limb[k].skeleton for k in branch_path])</span>
                <span class="n">skeleton_distance_per_branch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_path</span><span class="p">])</span>
                <span class="n">branch_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_path</span><span class="p">])</span>
                <span class="n">branch_spines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">n_spines</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_path</span><span class="p">])</span>

                <span class="n">total_skeleton_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skeleton_distance_per_branch</span><span class="p">)</span>
                <span class="n">total_spine_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">branch_spines</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skeleton_distance_per_branch</span><span class="p">)</span>
                <span class="n">scaled_branch_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">skeleton_distance_per_branch</span><span class="o">*</span><span class="n">branch_widths</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">total_skeleton_distance</span><span class="p">)</span>
                <span class="n">curr_vector_upward_distance</span>
                <span class="n">upward_to_skeletal_length_ratio</span> <span class="o">=</span> <span class="n">curr_vector_upward_distance</span><span class="o">/</span><span class="n">curr_skeleton_path_len</span>


                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_spine_density = </span><span class="si">{</span><span class="n">total_spine_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;scaled_branch_width = </span><span class="si">{</span><span class="n">scaled_branch_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_skeleton_path_len = </span><span class="si">{</span><span class="n">curr_skeleton_path_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_vector_upward_distance = </span><span class="si">{</span><span class="n">curr_vector_upward_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upward ratio to length = </span><span class="si">{</span><span class="n">upward_to_skeletal_length_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                <span class="c1"># Apply the restrictions</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">total_spine_density</span> <span class="o">&gt;</span> <span class="n">spine_density_threshold</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">total_skeleton_distance</span> <span class="o">&gt;</span> <span class="n">total_skeleton_distance_threshold</span><span class="p">)</span> <span class="ow">and</span> 
                    <span class="p">(</span><span class="n">scaled_branch_width</span> <span class="o">&gt;</span> <span class="n">apical_width_threshold</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">upward_to_skeletal_length_ratio</span> <span class="o">&gt;</span> <span class="n">upward_distance_to_skeletal_distance_ratio_threshold</span><span class="p">)):</span>
                    
                    <span class="c1">#print(f&quot;Adding the following branch path as a apical pathway: {branch_path}&quot;)</span>
                    <span class="n">apical_branches</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">branch_path</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Did not pass final filters to continuing&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">apical_branches</span><span class="p">)</span></div>
            

<div class="viewcode-block" id="apical_classification"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.apical_classification">[docs]</a><span class="k">def</span> <span class="nf">apical_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          
                        <span class="n">skip_splitting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          
                          <span class="n">apical_soma_angle_threshold</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                          <span class="n">plot_viable_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">label_neuron_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">plot_apical</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will compute a limb branch dict of all </span>
<span class="sd">    the branches that are part of a probably </span>
<span class="sd">    long reaching apical branch</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Split the neuron and take the first neuron obj (assume only some in neuron)</span>
<span class="sd">    2) Check only 1 soma </span>
<span class="sd">    3) Filter the limbs for viable aplical limbs based on the soma angle</span>
<span class="sd">    4) Iterate through the viable limbs to find the apical branches on each limb</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    apical_classification(neuron_obj,</span>
<span class="sd">                          apical_soma_angle_threshold=40,</span>
<span class="sd">                          plot_viable_limbs = False,</span>
<span class="sd">                          label_neuron_branches=True,</span>
<span class="sd">                          plot_apical=True,</span>
<span class="sd">                          verbose=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">split_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_splitting</span><span class="p">:</span>
        <span class="n">neuron_obj_list</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">split_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                          <span class="n">plot_seperated_neurons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for split = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">split_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj_list</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Split Neurons not just one: </span><span class="si">{</span><span class="n">neuron_obj_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    
    <span class="n">viable_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">viable_axon_limbs_by_starting_angle</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                       <span class="n">soma_angle_threshold</span><span class="o">=</span><span class="n">apical_soma_angle_threshold</span><span class="p">,</span>
                                       <span class="n">above_threshold</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;viable_limbs = </span><span class="si">{</span><span class="n">viable_limbs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">plot_viable_limbs</span><span class="p">:</span>
        <span class="n">ret_col</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                     <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="s2">&quot;all&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">viable_limbs</span><span class="p">},</span>
                     <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    
    <span class="n">apical_limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">viable_limbs</span><span class="p">:</span>
        
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on limb </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">curr_limb_apical_branches</span> <span class="o">=</span> <span class="n">apical_branch_candidates_on_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_apical_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apical_limb_branch_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">curr_limb_apical_branches</span><span class="p">})</span>
        
    
    <span class="k">if</span> <span class="n">plot_apical</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">apical_limb_branch_dict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                 <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                                 <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">apical_limb_branch_dict</span><span class="p">,</span>
                                 <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                                 <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO APICAL BRANCHES TO PLOT&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">label_neuron_branches</span><span class="p">:</span>
        <span class="n">nru</span><span class="o">.</span><span class="n">add_branch_label</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                    <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">apical_limb_branch_dict</span><span class="p">,</span>
                    <span class="n">labels</span><span class="o">=</span><span class="s2">&quot;apical&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">apical_limb_branch_dict</span></div>


        
        
<span class="c1"># ---------- For inhibitory and excitatory classification ---------- #</span>
<div class="viewcode-block" id="contains_excitatory_apical"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.contains_excitatory_apical">[docs]</a><span class="k">def</span> <span class="nf">contains_excitatory_apical</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">plot_apical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">return_n_apicals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">apical_limb_branch_dict</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">apical_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">plot_apical</span><span class="o">=</span><span class="n">plot_apical</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">apical_limb_branch_dict</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">apical_flag</span><span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">apical_flag</span><span class="o">=</span> <span class="kc">False</span>
        
    <span class="k">if</span> <span class="n">return_n_apicals</span><span class="p">:</span>
        <span class="n">apical_conn_comp</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_dict_to_connected_components</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">apical_limb_branch_dict</span><span class="p">,</span>
                                            <span class="n">use_concept_network_directional</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">apical_flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">apical_conn_comp</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">apical_flag</span></div>
    
<div class="viewcode-block" id="contains_excitatory_axon"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.contains_excitatory_axon">[docs]</a><span class="k">def</span> <span class="nf">contains_excitatory_axon</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">plot_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">return_axon_angles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">return_n_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">label_axon_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             
                             <span class="c1">#input arguments that indicate axon classification has already been performed</span>
                             <span class="n">axon_limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">axon_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">axon_limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">return_axon_angles</span> <span class="ow">and</span> <span class="n">axon_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_classification</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                        <span class="n">return_error_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">plot_axons</span><span class="o">=</span><span class="n">plot_axons</span><span class="p">,</span>
                                                        <span class="n">label_axon_errors</span><span class="o">=</span><span class="n">label_axon_errors</span><span class="p">,</span>
                                                        <span class="n">return_axon_angles</span><span class="o">=</span><span class="n">return_axon_angles</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
            <span class="n">axon_limb_branch_dict</span><span class="p">,</span><span class="n">axon_angles</span> <span class="o">=</span> <span class="n">return_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">return_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using pre-computed axon classification for contains_excitatory_axon&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_limb_branch_dict = </span><span class="si">{</span><span class="n">axon_limb_branch_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_angles = </span><span class="si">{</span><span class="n">axon_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_limb_branch_dict</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">axon_exist_flag</span> <span class="o">=</span>  <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axon_exist_flag</span> <span class="o">=</span>  <span class="kc">False</span>
        
        
    <span class="k">if</span> <span class="n">return_n_axons</span><span class="p">:</span>
        <span class="n">axon_conn_comp</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_dict_to_connected_components</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                            <span class="n">use_concept_network_directional</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">axon_exist_flag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_conn_comp</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">axon_exist_flag</span><span class="p">,</span><span class="n">axon_angles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">axon_exist_flag</span></div>

<div class="viewcode-block" id="spine_level_classifier"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.spine_level_classifier">[docs]</a><span class="k">def</span> <span class="nf">spine_level_classifier</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">sparsely_spiney_threshold</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
                     <span class="n">spine_density_threshold</span> <span class="o">=</span> <span class="mf">0.0003</span><span class="p">,</span>
                     <span class="c1">#min_n_processed_branches=2,</span>
                           <span class="n">min_processed_skeletal_length</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span>
                           <span class="n">return_spine_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Calculate the spine density and use it to classify</span>
<span class="sd">    a neuron as one of the following categories based on the spine</span>
<span class="sd">    density of high interest branches</span>
<span class="sd">    </span>
<span class="sd">    1) no_spine</span>
<span class="sd">    2) sparsely_spine</span>
<span class="sd">    3) densely_spine</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="p">(</span><span class="n">neuron_spine_density</span><span class="p">,</span> 
     <span class="n">n_branches_processed</span><span class="p">,</span> <span class="n">skeletal_length_processed</span><span class="p">,</span>
     <span class="n">n_branches_in_search_radius</span><span class="p">,</span><span class="n">skeletal_length_in_search_radius</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_spine_density</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                        <span class="n">plot_candidate_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_branch_processed_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;neuron_spine_density = </span><span class="si">{</span><span class="n">neuron_spine_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal_length_processed = </span><span class="si">{</span><span class="n">skeletal_length_processed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_branches_processed = </span><span class="si">{</span><span class="n">n_branches_processed</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal_length_in_search_radius = </span><span class="si">{</span><span class="n">skeletal_length_in_search_radius</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
<span class="c1">#     if n_branches_processed &lt; min_n_processed_branches:</span>
<span class="c1">#         final_label= &quot;no_spined&quot;</span>

    <span class="k">if</span> <span class="n">skeletal_length_processed</span> <span class="o">&lt;</span> <span class="n">min_processed_skeletal_length</span> <span class="ow">or</span> <span class="n">neuron_spine_density</span> <span class="o">&lt;</span> <span class="n">sparsely_spiney_threshold</span><span class="p">:</span>
        <span class="n">final_label</span><span class="o">=</span><span class="s2">&quot;no_spined&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">neuron_spine_density</span> <span class="o">&gt;</span> <span class="n">spine_density_threshold</span><span class="p">:</span>
            <span class="n">final_label</span><span class="o">=</span> <span class="s2">&quot;densely_spined&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_label</span><span class="o">=</span> <span class="s2">&quot;sparsely_spined&quot;</span>
            
    <span class="k">if</span> <span class="n">return_spine_statistics</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">final_label</span><span class="p">,</span><span class="n">neuron_spine_density</span><span class="p">,</span>
                <span class="n">n_branches_processed</span><span class="p">,</span> <span class="n">skeletal_length_processed</span><span class="p">,</span>
                <span class="n">n_branches_in_search_radius</span><span class="p">,</span><span class="n">skeletal_length_in_search_radius</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_label</span></div>
        
<div class="viewcode-block" id="inhibitory_excitatory_classifier"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.inhibitory_excitatory_classifier">[docs]</a><span class="k">def</span> <span class="nf">inhibitory_excitatory_classifier</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">return_spine_classification</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">return_axon_angles</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">return_n_axons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">return_n_apicals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">return_spine_statistics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                     <span class="n">axon_inhibitory_angle</span> <span class="o">=</span> <span class="mi">150</span><span class="p">,</span>
                                     <span class="c1">#axon_inhibitory_width_threshold = 350,</span>
                                     <span class="n">axon_inhibitory_width_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                     
                                     <span class="c1">#precomputed axon classifier info to speed up computation</span>
                                     <span class="n">axon_limb_branch_dict_precomputed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">axon_angles_precomputed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">ret_value</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">spine_level_classifier</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                <span class="n">return_spine_statistics</span><span class="o">=</span><span class="n">return_spine_statistics</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_spine_statistics</span><span class="p">:</span>
        <span class="p">(</span><span class="n">spine_category</span><span class="p">,</span><span class="n">neuron_spine_density</span><span class="p">,</span>
        <span class="n">n_branches_processed</span><span class="p">,</span> <span class="n">skeletal_length_processed</span><span class="p">,</span>
                <span class="n">n_branches_in_search_radius</span><span class="p">,</span><span class="n">skeletal_length_in_search_radius</span><span class="p">)</span> <span class="o">=</span> <span class="n">ret_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spine_category</span> <span class="o">=</span> <span class="n">ret_value</span>
    
    
    <span class="n">n_axons</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_apicals</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">axon_angles</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">inh_exc_category</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_category = </span><span class="si">{</span><span class="n">spine_category</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">spine_category</span> <span class="o">==</span> <span class="s2">&quot;no_spined&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spine_category was </span><span class="si">{</span><span class="n">spine_category</span><span class="si">}</span><span class="s2"> so determined as inhibitory&quot;</span><span class="p">)</span>
        <span class="n">inh_exc_category</span> <span class="o">=</span> <span class="s2">&quot;inhibitory&quot;</span>
    <span class="k">elif</span> <span class="n">spine_category</span> <span class="o">==</span> <span class="s2">&quot;densely_spined&quot;</span><span class="p">:</span>
        <span class="n">inh_exc_category</span> <span class="o">=</span> <span class="s2">&quot;excitatory&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        
        <span class="n">n_apicals</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">contains_excitatory_apical</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">return_n_apicals</span><span class="o">=</span><span class="n">return_n_apicals</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">contains_excitatory_axon</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                 <span class="n">return_axon_angles</span><span class="o">=</span><span class="n">return_axon_angles</span><span class="p">,</span>
                                                   <span class="n">return_n_axons</span><span class="o">=</span><span class="n">return_n_axons</span><span class="p">,</span> 
                                                    
                                                    <span class="n">axon_limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict_precomputed</span><span class="p">,</span>
                                                    <span class="n">axon_angles</span><span class="o">=</span><span class="n">axon_angles_precomputed</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
            <span class="n">n_axons</span><span class="p">,</span><span class="n">axon_angles</span> <span class="o">=</span> <span class="n">return_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_axons</span> <span class="o">=</span> <span class="n">return_value</span>
        
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_apicals = </span><span class="si">{</span><span class="n">n_apicals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_axons = </span><span class="si">{</span><span class="n">n_axons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_angles = </span><span class="si">{</span><span class="n">axon_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">n_apicals</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">n_axons</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#---------- 1/25 Addition: If have very bottom limb and not axon and above certain width </span>
                <span class="c1">#--&gt; means it is inhibitory</span>
            
            <span class="n">inh_exc_category</span> <span class="o">=</span> <span class="s2">&quot;excitatory&quot;</span>
            
            <span class="k">if</span> <span class="n">n_axons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nullifying_limbs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">viable_axon_limbs_by_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">soma_angle_threshold</span><span class="o">=</span><span class="n">axon_inhibitory_angle</span><span class="p">,</span>
                                       <span class="n">above_threshold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">n_limb</span> <span class="ow">in</span> <span class="n">nullifying_limbs</span><span class="p">:</span>
                    
                    <span class="n">st_node</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">n_limb</span><span class="p">]</span><span class="o">.</span><span class="n">current_starting_node</span>
                    <span class="n">st_node_width</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">n_limb</span><span class="p">][</span><span class="n">st_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>
                    
                    <span class="k">if</span> <span class="p">(</span> <span class="n">st_node_width</span><span class="o">&gt;</span><span class="n">axon_inhibitory_width_threshold</span><span class="p">):</span>
                        
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Classifying as inhibitory because have large downshoot (</span><span class="si">{</span><span class="n">st_node_width</span><span class="si">}</span><span class="s2">) that is not an axon&quot;</span><span class="p">)</span>
                        <span class="n">inh_exc_category</span> <span class="o">=</span> <span class="s2">&quot;inhibitory&quot;</span>
                        <span class="k">break</span>
         
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inh_exc_category</span> <span class="o">=</span> <span class="s2">&quot;inhibitory&quot;</span>
        
    
    <span class="k">if</span> <span class="p">(</span><span class="n">return_axon_angles</span> <span class="ow">or</span> <span class="n">return_n_axons</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_axons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">contains_excitatory_axon</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                 <span class="n">return_axon_angles</span><span class="o">=</span><span class="n">return_axon_angles</span><span class="p">,</span>
                                                    <span class="n">return_n_axons</span><span class="o">=</span><span class="n">return_n_axons</span><span class="p">,</span> 
                                                    <span class="n">axon_limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict_precomputed</span><span class="p">,</span>
                                                    <span class="n">axon_angles</span><span class="o">=</span><span class="n">axon_angles_precomputed</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
            <span class="n">n_axons</span><span class="p">,</span><span class="n">axon_angles</span> <span class="o">=</span> <span class="n">return_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_axons</span> <span class="o">=</span> <span class="n">return_value</span>
            
    <span class="k">if</span> <span class="n">return_n_apicals</span> <span class="ow">and</span> <span class="n">n_apicals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_apicals</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">contains_excitatory_apical</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                   <span class="n">return_n_apicals</span><span class="o">=</span><span class="n">return_n_apicals</span><span class="p">,</span>
                                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    
    
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">return_spine_classification</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_axon_angles</span> 
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_n_apicals</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_n_axons</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">inh_exc_category</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">inh_exc_category</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">return_spine_classification</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spine_category</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axon_angles</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_n_axons</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_axons</span><span class="p">)</span> 
    
    <span class="k">if</span> <span class="n">return_n_apicals</span><span class="p">:</span>
        <span class="n">return_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_apicals</span><span class="p">)</span> 
        
    <span class="k">if</span> <span class="n">return_spine_statistics</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">neuron_spine_density</span><span class="p">,</span> <span class="n">n_branches_processed</span><span class="p">,</span> <span class="n">skeletal_length_processed</span><span class="p">,</span>
                            <span class="n">n_branches_in_search_radius</span><span class="p">,</span><span class="n">skeletal_length_in_search_radius</span><span class="p">]</span>
        
        
    <span class="k">return</span> <span class="n">return_value</span></div>
    
    

<div class="viewcode-block" id="axon_starting_branch"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_starting_branch">[docs]</a><span class="k">def</span> <span class="nf">axon_starting_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">axon_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the branch that is starting the</span>
<span class="sd">    axon according to the concept network</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axon_limb_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axon_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax_limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No Axon in the neuron, so returning None as starting coordinate&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ax_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">axon_branches</span> <span class="o">=</span> <span class="n">ax_limb_branch_dict</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span>

        
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span>
    <span class="n">starting_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span>
    <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span>

    <span class="c1">#1) Find the axon branch that is closest to the starting </span>
    <span class="n">shortest_path</span><span class="p">,</span><span class="n">_</span><span class="p">,</span> <span class="n">closest_branch</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span>
                                                                                 <span class="p">[</span><span class="n">starting_branch</span><span class="p">],</span><span class="n">axon_branches</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_branch = </span><span class="si">{</span><span class="n">closest_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">closest_branch</span></div>
        
        
<div class="viewcode-block" id="axon_starting_coordinate"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_starting_coordinate">[docs]</a><span class="k">def</span> <span class="nf">axon_starting_coordinate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                            <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">axon_branches</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">plot_axon_starting_endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the skeleton endpoint that is closest to the </span>
<span class="sd">    starting node</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the axon branch that is closest to the starting </span>
<span class="sd">    node on the concept network</span>
<span class="sd">    --&gt; if it is the starting node then just return the current starting coordinate</span>
<span class="sd">    2) Find the endpoints of the closest branch</span>
<span class="sd">    3) Find the endpoint that is closest to the starting coordinate along the skeleton</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axon_limb_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axon_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax_limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax_limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No Axon in the neuron, so returning None as starting coordinate&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ax_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">axon_branches</span> <span class="o">=</span> <span class="n">ax_limb_branch_dict</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span>

        
    <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">]</span>
    <span class="n">starting_branch</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span>
    <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_coordinate</span>

    <span class="c1">#1) Find the axon branch that is closest to the starting </span>
    <span class="n">shortest_path</span><span class="p">,</span><span class="n">_</span><span class="p">,</span> <span class="n">closest_branch</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,[</span><span class="n">starting_branch</span><span class="p">],</span><span class="n">axon_branches</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_branch = </span><span class="si">{</span><span class="n">closest_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#--&gt; if it is the starting node then just return the current starting coordinate</span>
    <span class="n">limb_skeleton</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">closest_branch</span> <span class="o">==</span> <span class="n">starting_branch</span><span class="p">:</span>
        <span class="n">axon_starting_endpoint</span> <span class="o">=</span> <span class="n">starting_coordinate</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;axon_starting_endpoint was same as starting_coordinate&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#2) Find the endpoints of the closest branch</span>
        <span class="n">closest_branch_endpoints</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">closest_branch</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span>
        <span class="n">limb_skeleton</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">skeleton</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;closest_branch_endpoints= </span><span class="si">{</span><span class="n">closest_branch_endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#3) Find the endpoint that is closest to the starting coordinate along the skeleton</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">axon_starting_endpoint</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shortest_path_between_two_sets_of_skeleton_coordiantes</span><span class="p">(</span>
                        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">limb_skeleton</span><span class="p">,</span>
                        <span class="n">coordinates_list_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                        <span class="n">coordinates_list_2</span> <span class="o">=</span> <span class="n">closest_branch_endpoints</span><span class="p">,</span>
                        <span class="n">return_closest_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_closest_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_axon_starting_endpoint</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">limb_skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_skeleton</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">skeleton</span>
        <span class="n">axon_branches_skeleton</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axon_branches</span><span class="p">])</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_skeleton</span><span class="o">=</span><span class="n">limb_skeleton</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">axon_branches_skeleton</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="n">axon_starting_endpoint</span><span class="p">],</span>
                         <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lime&quot;</span><span class="p">,</span><span class="s2">&quot;red&quot;</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="p">[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.3</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">axon_starting_endpoint</span></div>


<span class="c1"># ----------------- 1/24/22: Rewrote the filtering function to be cleaner and have better picking from candidates -----</span>

<div class="viewcode-block" id="filter_axon_candiates"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.filter_axon_candiates">[docs]</a><span class="k">def</span> <span class="nf">filter_axon_candiates</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">axon_subgraph_candidates</span><span class="p">,</span>

    <span class="n">axon_like_limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="c1"># adjusting the axon angle thresholds based on the axon composition</span>
    <span class="n">axon_angle_threshold_relaxed</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span><span class="c1">#90,</span>
    <span class="n">axon_angle_threshold</span> <span class="o">=</span> <span class="mi">120</span><span class="p">,</span>
    <span class="n">relaxation_percentage</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
    <span class="n">relaxation_axon_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="c1">#40_000,</span>

    <span class="c1">#parameters for computing skeletal angle</span>
    <span class="n">skeletal_angle_offset</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">skeletal_angle_comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">skeletal_angle_buffer</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    

    <span class="c1">#parameters for ais filtering</span>
    <span class="n">min_ais_width</span><span class="o">=</span><span class="mi">85</span><span class="p">,</span><span class="c1">#85,</span>
    <span class="n">use_beginning_ais_for_width_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>



    <span class="n">comparison_soma_angle_threshold</span> <span class="o">=</span> <span class="mi">110</span><span class="p">,</span>
    <span class="n">axon_angle_winning_buffer</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
    <span class="n">axon_angle_winning_buffer_backup</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">soma_angle_winning_buffer_backup</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">skeletal_length_winning_buffer</span> <span class="o">=</span> <span class="mi">30_000</span><span class="p">,</span>
    <span class="n">skeletal_length_winning_min</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">tie_breaker_axon_attribute</span> <span class="o">=</span> <span class="s2">&quot;soma_plus_axon_angle&quot;</span><span class="p">,</span><span class="c1">#&quot;axon_angle&quot;,</span>

    <span class="c1">#for last booking on the final winning candidate</span>
    <span class="n">best_axon</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1">#plotting at end</span>
    <span class="n">plot_winning_candidate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_axon_angles</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the winning</span>
<span class="sd">    axon candidate from a list</span>


<span class="sd">    # Pseudocode: </span>
<span class="sd">    # 1) Get the axon-like limb branch dict (to be used for later)</span>

<span class="sd">    # Iterate through all of the candidates</span>
<span class="sd">    # 2) Get the AIS branch and path back from the soma to branch</span>
<span class="sd">    # 3) Get the axon branches on entire limb</span>
<span class="sd">    # 4) Get the soma starting angle</span>
<span class="sd">    # 5) Calculate percentage of axon branches in the candidate</span>
<span class="sd">    # 6) Adjusts the soma axon angle threshold based on the axon percentage</span>
<span class="sd">    # 7) Calculate the skeletonstarting angle</span>
<span class="sd">    # 8) Filter the candidates based on the ais starting width</span>
<span class="sd">    # 9) adding the candidate to be considered----</span>


<span class="sd">    # 10) Choose the final candidates with list of queries</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span>

    <span class="c1"># Global lists</span>

    <span class="n">candidate_filt_dicts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">axon_like_limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_like_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;matching_label&quot;</span><span class="p">],</span>
               <span class="n">query</span><span class="o">=</span><span class="s2">&quot;matching_label==True&quot;</span><span class="p">,</span>
               <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">]),</span>
               <span class="p">)</span>

    <span class="n">final_axon_like_classification</span> <span class="o">=</span> <span class="n">axon_like_limb_branch_dict</span>
    <span class="n">curr_neuron_obj</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span>


    <span class="n">axon_candidates</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">candidates_from_limb_branch_candidates</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span>
                                              <span class="n">axon_subgraph_candidates</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">curr_candidate_idx</span><span class="p">,</span><span class="n">axon_cand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axon_candidates</span><span class="p">):</span>

        <span class="n">curr_limb_idx</span> <span class="o">=</span> <span class="n">axon_cand</span><span class="p">[</span><span class="s1">&#39;limb_idx&#39;</span><span class="p">]</span>
        <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">curr_neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span>
        <span class="n">curr_limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">curr_limb_idx</span><span class="p">)</span>

        <span class="c1"># 2) Get the AIS branch and path back from the soma to branch</span>
        <span class="n">curr_candidate_subgraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axon_cand</span><span class="p">[</span><span class="s1">&#39;branches&#39;</span><span class="p">])</span>
        <span class="n">candidate_starting_node</span><span class="o">=</span> <span class="n">axon_cand</span><span class="p">[</span><span class="s1">&#39;start_node&#39;</span><span class="p">]</span>

        <span class="n">current_shortest_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span>
            <span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_start_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                          <span class="n">candidate_starting_node</span><span class="p">,</span>
                                         <span class="n">include_branch_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">---Working on axon candidate </span><span class="si">{</span><span class="n">curr_candidate_idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">,start_node= </span><span class="si">{</span><span class="n">candidate_starting_node</span><span class="si">}</span><span class="s2">, branches = </span><span class="si">{</span><span class="n">curr_candidate_subgraph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_shortest_path = </span><span class="si">{</span><span class="n">current_shortest_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1"># 3) Get the axon branches on entire limb</span>
        <span class="k">if</span> <span class="n">curr_limb_name</span> <span class="ow">in</span> <span class="n">final_axon_like_classification</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">axon_branches_on_limb</span> <span class="o">=</span> <span class="n">final_axon_like_classification</span><span class="p">[</span><span class="n">curr_limb_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axon_branches_on_limb</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_branches_on_limb = </span><span class="si">{</span><span class="n">axon_branches_on_limb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 4) Get the soma starting angle</span>
        <span class="n">curr_soma_angle</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                          <span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_soma_angle = </span><span class="si">{</span><span class="n">curr_soma_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="c1">#5) Calculate percentage of axon branches in the candidate</span>
        <span class="n">axon_branches_on_subgraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_branches_on_limb</span><span class="p">,</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span>
        <span class="n">axon_percentage_n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_branches_on_subgraph</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span>
        <span class="n">axon_percentage</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axon_branches_on_subgraph</span><span class="p">])</span><span class="o">/</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_candidate_subgraph</span><span class="p">]))</span>
        <span class="n">axon_length_over_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axon_branches_on_subgraph</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">axon_branches_on_subgraph</span><span class="p">)</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_candidate_subgraph</span><span class="p">)</span><span class="si">}</span><span class="s2"> branches are axons&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axon percentage = </span><span class="si">{</span><span class="n">axon_percentage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_percentage_n_nodes = </span><span class="si">{</span><span class="n">axon_percentage_n_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_length_over_nodes = </span><span class="si">{</span><span class="n">axon_length_over_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1">#6) Adjusts the soma axon angle threshold based on the axon percentage</span>
        <span class="k">if</span> <span class="n">axon_percentage</span> <span class="o">&gt;</span> <span class="n">relaxation_percentage</span> <span class="ow">or</span> <span class="n">axon_length_over_nodes</span> <span class="o">&gt;</span> <span class="n">relaxation_axon_length</span><span class="p">:</span>
            <span class="n">curr_axon_angle_threshold</span> <span class="o">=</span> <span class="n">axon_angle_threshold_relaxed</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_branches_on_subgraph</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding candidate no axon branches detected &quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_axon_angle_threshold</span> <span class="o">=</span> <span class="n">axon_angle_threshold</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_axon_angle_threshold = </span><span class="si">{</span><span class="n">curr_axon_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



        <span class="c1">#7) Calculate the skeletonstarting angle</span>
        <span class="n">candidate_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">curr_candidate_subgraph</span><span class="p">,</span><span class="n">current_shortest_path</span><span class="p">]))</span>

        <span class="c1"># ----- 1/24: Filtering out the nodes that are on branches that are not axons --------- #</span>
        <span class="n">non_axon_branches_on_subgraph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">candidate_nodes</span><span class="p">,</span><span class="n">axon_branches_on_limb</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;candidate_nodes = </span><span class="si">{</span><span class="n">candidate_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;non_axon_branches_on_subgraph = </span><span class="si">{</span><span class="n">non_axon_branches_on_subgraph</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>




        <span class="n">candidate_angles</span><span class="p">,</span><span class="n">restr_skels</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">candidate_starting_skeletal_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                          <span class="n">candidate_nodes</span><span class="o">=</span><span class="n">candidate_nodes</span><span class="p">,</span>
                              <span class="n">offset</span> <span class="o">=</span> <span class="n">skeletal_angle_offset</span><span class="p">,</span>
                            <span class="n">axon_sk_direction_comparison_distance</span> <span class="o">=</span> <span class="n">skeletal_angle_comparison_distance</span><span class="p">,</span>
                            <span class="n">buffer_for_skeleton</span> <span class="o">=</span> <span class="n">skeletal_angle_buffer</span><span class="p">,</span>
                              <span class="n">top_volume_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                              <span class="n">plot_skeleton_paths_before_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">plot_skeleton_paths_after_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">return_restricted_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">branches_not_to_consider_for_end_nodes</span> <span class="o">=</span> <span class="n">non_axon_branches_on_subgraph</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span>
                             <span class="p">)</span>
        <span class="c1">#print(f&quot;candidate_angles,restr_skels = {candidate_angles,restr_skels}&quot;)</span>

        <span class="k">if</span> <span class="n">candidate_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sk_passing_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">candidate_angles</span><span class="o">&gt;</span><span class="n">curr_axon_angle_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sk_passing_threshold</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_passing_threshold</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding candidate because no angles (</span><span class="si">{</span><span class="n">candidate_angles</span><span class="si">}</span><span class="s2">)&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot; passed the threhold </span><span class="si">{</span><span class="n">curr_axon_angle_threshold</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">continue</span>



        <span class="c1">#8) Filter the candidates based on the ais starting width</span>
        <span class="k">if</span> <span class="n">candidate_starting_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axon_branches_on_limb</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not adding candidate the first branch was not an axon &quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_beginning_ais_for_width_filter</span><span class="p">:</span>
            <span class="n">ais_width</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ais_width</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_near_branch_endpoint</span><span class="p">(</span>
                                    <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">,</span>
                                    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">candidate_starting_node</span><span class="p">,</span>
                                    <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># if None then will select most upstream endpoint of branch</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="p">)</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Problem with calculating restricted ais so just using overall segment width&quot;</span><span class="p">)</span>
                <span class="n">ais_width</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">candidate_starting_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ais_width  = </span><span class="si">{</span><span class="n">ais_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ais_width</span> <span class="o">&lt;</span> <span class="n">min_ais_width</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Not adding candidate the because AIS width was not higher than threshold (</span><span class="si">{</span><span class="n">min_ais_width</span><span class="si">}</span><span class="s1">): </span><span class="si">{</span><span class="n">ais_width</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="k">continue</span>


        <span class="c1"># 9) adding the candidate to be considered----</span>

        <span class="n">extra_nodes_to_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_branches_on_limb</span><span class="p">,</span><span class="n">current_shortest_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">true_axon_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">curr_candidate_subgraph</span><span class="p">,</span><span class="n">extra_nodes_to_add</span><span class="p">])</span>
        <span class="n">max_axon_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">candidate_angles</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding the following branches as true axons: </span><span class="si">{</span><span class="n">true_axon_branches</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;curr_soma_angle = </span><span class="si">{</span><span class="n">curr_soma_angle</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;max_axon_angle = </span><span class="si">{</span><span class="n">max_axon_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding axon candidate to be considered for final&quot;</span><span class="p">)</span>
        <span class="n">candidate_filt_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">axon_cand</span><span class="p">,</span>
            <span class="n">true_axon_branches</span> <span class="o">=</span> <span class="n">true_axon_branches</span><span class="p">,</span>
            <span class="n">candidate_idx</span> <span class="o">=</span> <span class="n">curr_candidate_idx</span><span class="p">,</span>
            <span class="n">soma_angle</span><span class="o">=</span><span class="n">curr_soma_angle</span><span class="p">,</span>
            <span class="n">axon_angle</span> <span class="o">=</span> <span class="n">max_axon_angle</span><span class="p">,</span>
            <span class="n">soma_plus_axon_angle</span> <span class="o">=</span> <span class="n">curr_soma_angle</span> <span class="o">+</span> <span class="n">max_axon_angle</span><span class="p">,</span>
            <span class="n">axon_skeletal_length</span> <span class="o">=</span>  <span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_over_candidate</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span><span class="n">axon_cand</span><span class="p">),</span>
            <span class="n">width</span> <span class="o">=</span>  <span class="n">nst</span><span class="o">.</span><span class="n">width_over_candidate</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span><span class="n">axon_cand</span><span class="p">),</span>

        <span class="p">))</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidate_filt_dicts</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filt cand </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">= </span><span class="se">\n</span><span class="si">{</span><span class="n">cand</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_filt_dicts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">flu</span><span class="o">.</span><span class="n">Comparator</span><span class="p">(</span><span class="n">candidate_filt_dicts</span><span class="p">,</span>
                          <span class="c1">#object_attributes=candidate_filt_dicts_atts</span>
                          <span class="p">)</span>

        <span class="n">C</span><span class="o">.</span><span class="n">compute_global_functions</span><span class="p">(</span>
            <span class="n">attributes_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;soma_angle&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;axon_angle&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;axon_skeletal_length&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;soma_plus_axon_angle&quot;</span><span class="p">],</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="p">)</span>


        <span class="n">objs_filt</span><span class="p">,</span><span class="n">df</span> <span class="o">=</span> <span class="n">flu</span><span class="o">.</span><span class="n">filter_to_one_by_query</span><span class="p">(</span>
            <span class="n">C</span><span class="p">,</span>
            <span class="n">queries</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;soma_angle &gt;= </span><span class="si">{</span><span class="n">comparison_soma_angle_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                       <span class="sa">f</span><span class="s2">&quot;(axon_skeletal_length &gt; </span><span class="si">{</span><span class="n">skeletal_length_winning_min</span><span class="si">}</span><span class="s2">) and &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;(axon_angle_diff_from_max &gt; -</span><span class="si">{</span><span class="n">axon_angle_winning_buffer</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;(axon_skeletal_length &gt; </span><span class="si">{</span><span class="n">skeletal_length_winning_min</span><span class="si">}</span><span class="s2">) and &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;(axon_angle_diff_from_max &gt; -</span><span class="si">{</span><span class="n">axon_angle_winning_buffer_backup</span><span class="si">}</span><span class="s2">) and&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;(soma_angle_diff_from_max &gt; - </span><span class="si">{</span><span class="n">soma_angle_winning_buffer_backup</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                       
<span class="c1">#                        f&quot;(axon_skeletal_length &gt; {skeletal_length_winning_min}) and &quot;</span>
<span class="c1">#                        f&quot;(axon_skeletal_length_diff_from_max &gt; -{skeletal_length_winning_buffer})&quot;,</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tie_breaker_axon_attribute</span><span class="si">}</span><span class="s2"> == MAX(</span><span class="si">{</span><span class="n">tie_breaker_axon_attribute</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">],</span>
        <span class="n">return_df_before_query</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="s2">&quot;df_candidates&quot;</span><span class="p">)</span>

        <span class="n">winning_candidate</span> <span class="o">=</span> <span class="n">objs_filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">winning_limb_idx</span> <span class="o">=</span> <span class="n">winning_candidate</span><span class="p">[</span><span class="s2">&quot;candidate&quot;</span><span class="p">][</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]</span>
        <span class="n">best_axon_candidate_filtered</span> <span class="o">=</span> <span class="p">{</span><span class="n">winning_limb_idx</span><span class="p">:</span><span class="n">winning_candidate</span><span class="p">[</span><span class="s2">&quot;true_axon_branches&quot;</span><span class="p">]}</span>
        <span class="n">best_axon_candidate_filtered_angles</span> <span class="o">=</span> <span class="p">{</span><span class="n">winning_limb_idx</span><span class="p">:</span>
                                               <span class="p">{</span><span class="n">winning_candidate</span><span class="p">[</span><span class="s2">&quot;candidate_idx&quot;</span><span class="p">]:</span><span class="n">winning_candidate</span><span class="p">[</span><span class="s2">&quot;axon_angle&quot;</span><span class="p">]}}</span>

        <span class="k">if</span> <span class="n">best_axon</span><span class="p">:</span>
            <span class="c1"># --- 2_17: Will add back axon parts that should be accounted for </span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            if there even is an axon</span>
<span class="sd">            1) Get the limb name of the best axon</span>
<span class="sd">            2) Get the concept network of the limb and the starting node</span>
<span class="sd">            3) Get the branches that would be axon</span>
<span class="sd">            4) Delete the branches from the concept network</span>
<span class="sd">            5) For each connected component in the leftover network</span>
<span class="sd">            - if not have starting node and all in axon-like: </span>
<span class="sd">            add to list to add to the true axon</span>

<span class="sd">            6) add the new nodes to the axon group</span>
<span class="sd">            &quot;&quot;&quot;</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_axon_candidate_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1">#1) Get the limb name of the best axon</span>
                <span class="n">limb_name_of_axon</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">best_axon_candidate_filtered</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_name_of_axon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">Excpetion</span><span class="p">(</span><span class="s2">&quot;More than 1 axon key&quot;</span><span class="p">)</span>

                <span class="n">limb_name_of_axon</span> <span class="o">=</span> <span class="n">limb_name_of_axon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span>
                <span class="c1">#2) Get the concept network of the limb and the starting node</span>
                <span class="n">conc_net</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
                <span class="n">start_node</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">current_starting_node</span>

                <span class="c1">#3) Get the branches that would be axon</span>
                <span class="n">axon_branches</span> <span class="o">=</span> <span class="n">best_axon_candidate_filtered</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span>
                <span class="n">axon_like_branches</span> <span class="o">=</span> <span class="n">axon_like_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span>

                <span class="c1">#4) Delete the branches from the concept network</span>
                <span class="n">conc_net</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">)</span>


                <span class="c1">#5) For each connected component in the leftover network</span>
                <span class="n">new_axon_branches</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">conn_comp</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">conc_net</span><span class="p">):</span>
                    <span class="n">conn_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span>

                    <span class="c1">#- if not have starting node and all in axon-like: </span>
                    <span class="c1">#add to list to add to the true axon</span>
                    <span class="n">axon_like_in_conn_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">axon_like_branches</span><span class="p">,</span><span class="n">conn_comp</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">start_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conn_comp</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axon_like_in_conn_comp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">):</span>
                        <span class="n">new_axon_branches</span> <span class="o">+=</span> <span class="n">conn_comp</span>



                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_axon_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_axon_candidate_filtered</span><span class="p">[</span><span class="n">limb_name_of_axon</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">axon_branches</span><span class="p">)</span> <span class="o">+</span> <span class="n">new_axon_branches</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the best axon approach&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">best_axon_candidate_filtered</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">best_axon_candidate_filtered_angles</span> <span class="o">=</span> <span class="p">{}</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;best_axon_candidate_filtered= </span><span class="si">{</span><span class="n">best_axon_candidate_filtered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;best_axon_candidate_filtered_angles= </span><span class="si">{</span><span class="n">best_axon_candidate_filtered_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_winning_candidate</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_axon_candidate_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;best_axon_candidate_filtered= </span><span class="si">{</span><span class="n">best_axon_candidate_filtered</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">curr_neuron_obj</span><span class="p">,</span><span class="n">best_axon_candidate_filtered</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">return_axon_angles</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">best_axon_candidate_filtered</span><span class="p">,</span><span class="n">best_axon_candidate_filtered_angles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">best_axon_candidate_filtered</span></div>

<div class="viewcode-block" id="axon_faces_from_labels_on_original_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.classification_utils.axon_faces_from_labels_on_original_mesh">[docs]</a><span class="k">def</span> <span class="nf">axon_faces_from_labels_on_original_mesh</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">original_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the axon face indices on the original mesh</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the original mesh if not passed</span>
<span class="sd">    2) Get the axon mesh of the neuron object</span>
<span class="sd">    3) Map the axon mesh to the original mesh</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    clu.axon_faces_from_labels_on_original_mesh(neuron_obj,</span>
<span class="sd">                                            plot_axon=True,</span>
<span class="sd">                                           verbose=True,</span>
<span class="sd">                                           original_mesh=original_mesh,</span>
<span class="sd">                                           original_mesh_kdtree=original_mesh_kdtree)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">original_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No original mesh found so pulling from the database&quot;</span><span class="p">)</span>
        <span class="n">original_mesh</span>  <span class="o">=</span> <span class="n">vdi</span><span class="o">.</span><span class="n">fetch_segment_id_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="p">)</span>
        
    <span class="n">axon_mesh</span> <span class="o">=</span> <span class="n">axon_mesh_from_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">axon_mesh_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                                                        <span class="n">axon_mesh</span><span class="p">,</span>
                                                        <span class="n">exact_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">original_mesh_kdtree</span><span class="o">=</span><span class="n">original_mesh_kdtree</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_axon</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span>
                          <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">original_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">axon_mesh_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">axon_mesh_faces</span></div>

<span class="c1"># ----------------- Parameters ------------------------</span>

<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    
<span class="p">)</span>

<span class="n">global_parameters_dict_default_axon</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">non_ais_width_axon</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">ais_width_axon</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>
    <span class="n">max_n_spines_axon</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">max_spine_density_axon</span> <span class="o">=</span> <span class="mf">0.00008</span><span class="p">,</span>
<span class="p">)</span>


<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">vdi</span> <span class="o">=</span> <span class="n">mvu</span><span class="o">.</span><span class="n">data_interface</span>
<span class="p">)</span>  


<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">global_parameters_dict_h01_axon</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">max_spine_density_axon</span> <span class="o">=</span> <span class="mf">0.00008</span><span class="p">,</span>
    <span class="n">max_n_spines_axon</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">ais_width_axon</span> <span class="o">=</span> <span class="mi">650</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="p">{}</span>




<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">vdi</span> <span class="o">=</span> <span class="n">hvu</span><span class="o">.</span><span class="n">data_interface</span>
<span class="p">)</span>


<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>

<span class="c1"># modules_to_set = [clu]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">filtering_utils</span> <span class="k">as</span> <span class="n">flu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">classification_utils</span> <span class="k">as</span> <span class="n">clu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
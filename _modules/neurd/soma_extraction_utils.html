<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.soma_extraction_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.soma_extraction_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.soma_extraction_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">datajoint</span> <span class="k">as</span> <span class="nn">dj</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pykdtree.kdtree</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">data_struct_utils</span> <span class="k">as</span> <span class="n">dsu</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cgal_Segmentation_Module</span> <span class="k">as</span> <span class="nn">csm</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1">#from mesh_tools.trimesh_utils import split_significant_pieces,split</span>
<span class="c1">#from python_tools import numpy_utils as np</span>

<span class="n">save_mesh_intermediates</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">soma_connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Checking the new validation checks</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="side_length_ratios"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.side_length_ratios">[docs]</a><span class="k">def</span> <span class="nf">side_length_ratios</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will compute the ratios of the bounding box sides</span>
<span class="sd">    To be later used to see if there is skewness</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># bbox = current_mesh.bounding_box_oriented.vertices</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">bounding_box_oriented</span><span class="o">.</span><span class="n">vertices</span>
    <span class="n">x_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">y_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">z_axis_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bbox</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">x_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">y_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">z_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_axis_unique</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_axis_unique</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="c1">#print(x_length,y_length,z_length)</span>
    <span class="c1">#compute the ratios:</span>
    <span class="n">xy_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_length</span><span class="o">/</span><span class="n">y_length</span><span class="p">)</span>
    <span class="n">xz_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_length</span><span class="o">/</span><span class="n">z_length</span><span class="p">)</span>
    <span class="n">yz_ratio</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y_length</span><span class="o">/</span><span class="n">z_length</span><span class="p">)</span>
    <span class="n">side_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">xy_ratio</span><span class="p">,</span><span class="n">xz_ratio</span><span class="p">,</span><span class="n">yz_ratio</span><span class="p">]</span>
    <span class="n">flipped_side_ratios</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">side_ratios</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">flipped_side_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flipped_side_ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flipped_side_ratios</span></div>

<div class="viewcode-block" id="side_length_check"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.side_length_check">[docs]</a><span class="k">def</span> <span class="nf">side_length_check</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">side_length_ratio_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">side_length_ratio_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span><span class="s2">&quot;xz&quot;</span><span class="p">,</span><span class="s2">&quot;yz&quot;</span><span class="p">]</span>
    <span class="n">side_ratios</span> <span class="o">=</span> <span class="n">side_length_ratios</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)</span>
    <span class="n">pass_threshold</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">side_length_ratio_threshold</span><span class="p">)</span> <span class="ow">and</span>
                      <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">/</span><span class="n">side_length_ratio_threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">side_ratios</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">rt</span><span class="p">,</span><span class="n">truth</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">side_ratios</span><span class="p">,</span><span class="n">pass_threshold</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">truth</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">side_length_ratio_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">rt</span><span class="si">}</span><span class="s2"> ratio was beyong </span><span class="si">{</span><span class="n">side_length_ratio_threshold</span><span class="si">}</span><span class="s2"> multiplier&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="kc">False</span> <span class="ow">in</span> <span class="n">pass_threshold</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="largest_mesh_piece"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.largest_mesh_piece">[docs]</a><span class="k">def</span> <span class="nf">largest_mesh_piece</span><span class="p">(</span><span class="n">msh</span><span class="p">):</span>
    <span class="n">mesh_splits_inner</span> <span class="o">=</span> <span class="n">msh</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">total_mesh_split_lengths_inner</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_splits_inner</span><span class="p">]</span>
    <span class="n">ordered_mesh_splits_inner</span> <span class="o">=</span> <span class="n">mesh_splits_inner</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">total_mesh_split_lengths_inner</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">ordered_mesh_splits_inner</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="soma_volume_ratio"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.soma_volume_ratio">[docs]</a><span class="k">def</span> <span class="nf">soma_volume_ratio</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span>
                     <span class="c1">#watertight_method=&quot;fill_holes,</span>
                     <span class="n">watertight_method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span>
                      <span class="n">max_value</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    bounding_box_oriented: rotates the box to be less volume</span>
<span class="sd">    bounding_box : does not rotate the box and makes it axis aligned</span>
<span class="sd">    </span>
<span class="sd">    ** checks to see if closed mesh and if not then make closed **</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">poisson_temp_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;Poisson_temp&quot;</span>
    <span class="n">poisson_temp_folder</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="n">poisson_temp_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">Poisson_obj_temp</span><span class="p">:</span>

        <span class="c1">#get the largest piece</span>
        <span class="n">lrg_mesh</span> <span class="o">=</span> <span class="n">largest_mesh_piece</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lrg_mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">:</span>
            <span class="c1">#lrg_mesh.export(&quot;lrg_mesh_in_soma_volume.off&quot;)</span>
            <span class="k">if</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;poisson&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using Poisson Surface Reconstruction for watertightness in soma_volume_ratio&quot;</span><span class="p">)</span>
                <span class="c1">#run the Poisson Surface reconstruction and get the largest piece</span>
                <span class="n">new_mesh_inner</span><span class="p">,</span><span class="n">poisson_file_obj</span> <span class="o">=</span> <span class="n">Poisson_obj_temp</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                       <span class="n">faces</span><span class="o">=</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                       <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">segment_id</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">999999</span><span class="p">))</span>
                <span class="n">lrg_mesh</span> <span class="o">=</span> <span class="n">largest_mesh_piece</span><span class="p">(</span><span class="n">new_mesh_inner</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">watertight_method</span> <span class="o">==</span> <span class="s2">&quot;fill_holes&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the close holes feature for watertightness in soma_volume_ratio&quot;</span><span class="p">)</span>
                <span class="n">fill_hole_obj</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">FillHoles</span><span class="p">(</span><span class="n">max_hole_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                                 <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">mesh_filled_holes</span><span class="p">,</span><span class="n">fillholes_file_obj</span> <span class="o">=</span> <span class="n">fill_hole_obj</span><span class="p">(</span>   
                                                    <span class="n">vertices</span><span class="o">=</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                                     <span class="n">faces</span><span class="o">=</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                                     <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                     <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="p">)</span>
                <span class="n">lrg_mesh</span> <span class="o">=</span> <span class="n">largest_mesh_piece</span><span class="p">(</span><span class="n">mesh_filled_holes</span><span class="p">)</span>
                
                    
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unimplemented watertight_method requested: </span><span class="si">{</span><span class="n">watertight_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#turn the mesh into a closed mesh based on </span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh.is_watertight = </span><span class="si">{</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lrg_mesh</span><span class="o">.</span><span class="n">is_watertight</span><span class="p">:</span>
            <span class="n">lrg_mesh</span> <span class="o">=</span> <span class="n">lrg_mesh</span><span class="o">.</span><span class="n">convex_hull</span>
        
        <span class="n">ratio_val</span> <span class="o">=</span> <span class="n">lrg_mesh</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">volume</span><span class="o">/</span><span class="n">lrg_mesh</span><span class="o">.</span><span class="n">volume</span>
    <span class="c1">#     if ratio_val &lt; 1:</span>
    <span class="c1">#         raise Exception(&quot;Less than 1 value in volume ratio computation&quot;)</span>
    <span class="k">if</span> <span class="n">ratio_val</span> <span class="o">&lt;</span> <span class="n">max_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ratio_val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_value</span></div>

<div class="viewcode-block" id="soma_volume_check"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.soma_volume_check">[docs]</a><span class="k">def</span> <span class="nf">soma_volume_check</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">multiplier</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">ratio_val</span><span class="o">=</span> <span class="n">soma_volume_ratio</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside sphere validater: ratio_val = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ratio_val</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ratio_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">multiplier</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<span class="c1"># -------------- Function that will extract the soma ------- #</span>


<div class="viewcode-block" id="filter_away_inside_soma_pieces"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.filter_away_inside_soma_pieces">[docs]</a><span class="k">def</span> <span class="nf">filter_away_inside_soma_pieces</span><span class="p">(</span>
                            <span class="n">main_mesh_total</span><span class="p">,</span>
                            <span class="n">pieces_to_test</span><span class="p">,</span>
                            <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                            <span class="n">n_sample_points</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                            <span class="n">required_outside_percentage</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
                            <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">return_inside_pieces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">main_mesh_total</span><span class="p">):</span>
        <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_mesh_total</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">pieces_to_test</span><span class="p">):</span>
        <span class="n">pieces_to_test</span> <span class="o">=</span> <span class="p">[</span><span class="n">pieces_to_test</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pieces_to_test</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pieces_to_test was empty so returning empty list or pieces&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pieces_to_test</span>
    
    <span class="n">significant_pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">pieces_to_test</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">significance_threshold</span><span class="p">]</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2"> pieces found after size threshold&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">)</span> <span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;THERE WERE NO MESH PIECES GREATER THAN THE significance_threshold&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="n">final_mesh_pieces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">inside_pieces</span> <span class="o">=</span> <span class="p">[]</span>
    

    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">significant_pieces</span><span class="p">):</span>
        <span class="n">outside_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">main_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">main_mesh_total</span><span class="p">):</span>
            <span class="c1">#gets the number of samples on the mesh to test (only the indexes)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span><span class="n">n_sample_points</span> <span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
            
            <span class="c1">#gets the sample&#39;s vertices</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">,:]</span>

            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

            <span class="c1">#find the signed distance from the sampled vertices to the main mesh</span>
            <span class="c1"># Points outside the mesh will be negative</span>
            <span class="c1"># Points inside the mesh will be positive</span>
            <span class="n">signed_distance</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">proximity</span><span class="o">.</span><span class="n">signed_distance</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span><span class="n">points</span><span class="p">)</span>

            <span class="c1">#gets the </span>
            <span class="n">outside_percentage</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">signed_distance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">n_sample_points</span>
            
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh piece </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> has outside_percentage </span><span class="si">{</span><span class="n">outside_percentage</span><span class="si">}</span><span class="s2">, idx = </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">outside_percentage</span> <span class="o">&lt;</span> <span class="n">required_outside_percentage</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh piece </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">mesh</span><span class="si">}</span><span class="s2">) inside mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> :( &quot;</span><span class="p">)</span>
                <span class="n">outside_flag</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">inside_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">outside_flag</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh piece </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> OUTSIDE all meshes (corrected)&quot;</span><span class="p">)</span>
            <span class="n">final_mesh_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">return_inside_pieces</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_mesh_pieces</span><span class="p">,</span><span class="n">inside_pieces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">final_mesh_pieces</span></div>


<span class="c1"># subtacting the soma</span>

<span class="sd">&#39;&#39;&#39; old version </span>
<span class="sd">def subtract_soma(current_soma,main_mesh,</span>
<span class="sd">                 significance_threshold=200,</span>
<span class="sd">                 distance_threshold = 550):</span>
<span class="sd">    print(&quot;\ninside Soma subtraction&quot;)</span>
<span class="sd">    start_time = time.time()</span>
<span class="sd">    face_midpoints_soma = np.mean(current_soma.vertices[current_soma.faces],axis=1)</span>


<span class="sd">    curr_mesh_bbox_restriction,faces_bbox_inclusion = (</span>
<span class="sd">                    tu.bbox_mesh_restriction(main_mesh,</span>
<span class="sd">                                             current_soma.bounds,</span>
<span class="sd">                                            mult_ratio=1.3)</span>
<span class="sd">    )</span>

<span class="sd">    face_midpoints_neuron = np.mean(curr_mesh_bbox_restriction.vertices[curr_mesh_bbox_restriction.faces],axis=1)</span>

<span class="sd">    soma_kdtree = KDTree(face_midpoints_soma)</span>

<span class="sd">    distances,closest_node = soma_kdtree.query(face_midpoints_neuron)</span>

<span class="sd">    distance_passed_faces  = distances&lt;distance_threshold</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot; Older way of doing difference</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    faces_to_keep = np.array(list(set(np.arange(0,len(main_mesh.faces))).difference(set(faces_bbox_inclusion[distance_passed_faces]))))</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    #newer way: using numpy functions</span>
<span class="sd">    faces_to_keep = np.delete(np.arange(len(main_mesh.faces)),</span>
<span class="sd">                                    faces_bbox_inclusion[distance_passed_faces])</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    #didn&#39;t work</span>
<span class="sd">    distance_passed_faces  = distances&gt;=distance_threshold</span>
<span class="sd">    faces_to_keep = faces_bbox_inclusion[distance_passed_faces]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    without_soma_mesh = main_mesh.submesh([faces_to_keep],append=True)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    #get the significant mesh pieces</span>
<span class="sd">    mesh_pieces = split_significant_pieces(without_soma_mesh,significance_threshold=significance_threshold)</span>
<span class="sd">    print(f&quot;mesh pieces in subtact soma BEFORE the filtering inside pieces = {mesh_pieces}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    mesh_pieces = filter_away_inside_soma_pieces(current_soma,mesh_pieces,</span>
<span class="sd">                                                           significance_threshold=significance_threshold)</span>
<span class="sd">    print(f&quot;mesh pieces in subtact soma AFTER the filtering inside pieces = {mesh_pieces}&quot;)</span>
<span class="sd">    print(f&quot;Total Time for soma mesh cancellation = {np.round(time.time() - start_time,3)}&quot;)</span>
<span class="sd">    return mesh_pieces</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="subtract_soma"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.subtract_soma">[docs]</a><span class="k">def</span> <span class="nf">subtract_soma</span><span class="p">(</span><span class="n">current_soma_list</span><span class="p">,</span><span class="n">main_mesh</span><span class="p">,</span>
                 <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                 <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span>
                  <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
                 <span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">current_soma_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="n">current_soma_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_soma_list</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">current_soma_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Subtract soma was not passed a trimesh object or list for it&#39;s soma parameter&quot;</span><span class="p">)</span>

        
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">inside Soma subtraction&quot;</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">current_soma</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">current_soma_list</span><span class="p">)</span>
    <span class="n">face_midpoints_soma</span> <span class="o">=</span> <span class="n">current_soma</span><span class="o">.</span><span class="n">triangles_center</span>

    <span class="n">all_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">bounds</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>  <span class="n">current_soma_list</span><span class="p">]</span>
    

    <span class="n">curr_mesh_bbox_restriction</span><span class="p">,</span><span class="n">faces_bbox_inclusion</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">tu</span><span class="o">.</span><span class="n">bbox_mesh_restriction</span><span class="p">(</span><span class="n">main_mesh</span><span class="p">,</span>
                                            <span class="n">all_bounds</span> <span class="p">,</span>
                                            <span class="n">mult_ratio</span><span class="o">=</span><span class="mf">1.3</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">face_midpoints_neuron</span> <span class="o">=</span> <span class="n">curr_mesh_bbox_restriction</span><span class="o">.</span><span class="n">triangles_center</span>

    <span class="n">soma_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">face_midpoints_soma</span><span class="p">)</span>

    <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">soma_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">face_midpoints_neuron</span><span class="p">)</span>

    <span class="n">distance_passed_faces</span>  <span class="o">=</span> <span class="n">distances</span><span class="o">&lt;</span><span class="n">distance_threshold</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; Older way of doing difference</span>


<span class="sd">    faces_to_keep = np.array(list(set(np.arange(0,len(main_mesh.faces))).difference(set(faces_bbox_inclusion[distance_passed_faces]))))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#newer way: using numpy functions</span>
    <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span>
                                    <span class="n">faces_bbox_inclusion</span><span class="p">[</span><span class="n">distance_passed_faces</span><span class="p">])</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    #didn&#39;t work</span>
<span class="sd">    distance_passed_faces  = distances&gt;=distance_threshold</span>
<span class="sd">    faces_to_keep = faces_bbox_inclusion[distance_passed_faces]</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">without_soma_mesh</span> <span class="o">=</span> <span class="n">main_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces_to_keep</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>




    <span class="c1">#get the significant mesh pieces</span>
    <span class="n">mesh_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">without_soma_mesh</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="n">significance_threshold</span><span class="p">,</span>
                                             <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    
    <span class="c1"># ----- 11/22 turns out weren&#39;t even using this part --------- #</span>
<span class="c1">#     print(f&quot;mesh pieces in subtact soma BEFORE the filtering inside pieces = {mesh_pieces}&quot;)</span>

<span class="c1">#     current_mesh_pieces = filter_away_inside_soma_pieces(current_soma,mesh_pieces,</span>
<span class="c1">#                                          significance_threshold=significance_threshold,</span>
<span class="c1">#                                                         n_sample_points=5,</span>
<span class="c1">#                                                         required_outside_percentage=0.9)</span>
<span class="c1">#     print(f&quot;mesh pieces in subtact soma AFTER the filtering inside pieces = {mesh_pieces}&quot;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Time for soma mesh cancellation = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_time</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">mesh_pieces</span></div>

<div class="viewcode-block" id="find_soma_centroids"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.find_soma_centroids">[docs]</a><span class="k">def</span> <span class="nf">find_soma_centroids</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return a list of soma centers if given one mesh or list of meshes</span>
<span class="sd">    the center is just found by averaging the vertices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">):</span>
        <span class="n">soma_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_mesh_list</span><span class="p">]</span>
    <span class="n">soma_mesh_list_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_mesh_list</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">soma_mesh_list_centers</span></div>


<div class="viewcode-block" id="find_soma_centroid_containing_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.find_soma_centroid_containing_meshes">[docs]</a><span class="k">def</span> <span class="nf">find_soma_centroid_containing_meshes</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span>
                                            <span class="n">split_meshes</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the mesh piece that most likely has the </span>
<span class="sd">    soma that was found by the poisson soma finding process</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">containing_mesh_indices</span><span class="o">=</span><span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">sm_c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">sm_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">):</span>
        <span class="n">sm_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">sm_mesh</span><span class="p">)</span>
        <span class="n">viable_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span> 
                 <span class="k">if</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span><span class="n">sm_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                        <span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;viable_meshes = </span><span class="si">{</span><span class="n">viable_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The Soma </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> with mesh </span><span class="si">{</span><span class="n">sm_center</span><span class="si">}</span><span class="s2"> was not contained in any of the boundying boxes&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">viable_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">containing_mesh_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">viable_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#find which mesh is closer to the soma midpoint (NOT ACTUALLY WHAT WE WANT)</span>
            <span class="n">min_distances_to_soma</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dist_min_to_soma</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v_i</span> <span class="ow">in</span> <span class="n">viable_meshes</span><span class="p">:</span>
                <span class="c1"># build the KD Tree</span>
                <span class="n">viable_neuron_kdtree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">[</span><span class="n">v_i</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">viable_neuron_kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">sm_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                <span class="n">min_distances_to_soma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
                <span class="n">dist_min_to_soma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_distances_to_soma = </span><span class="si">{</span><span class="n">min_distances_to_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dist_min_to_soma = </span><span class="si">{</span><span class="n">dist_min_to_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">containing_mesh_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">viable_meshes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">min_distances_to_soma</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">containing_mesh_indices</span></div>
    
<div class="viewcode-block" id="grouping_containing_mesh_indices"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.grouping_containing_mesh_indices">[docs]</a><span class="k">def</span> <span class="nf">grouping_containing_mesh_indices</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a dictionary that maps the soma indiece to the </span>
<span class="sd">             mesh piece containing the indices: {0: 0, 1: 0}</span>
<span class="sd">             </span>
<span class="sd">             and to rearrange that to a dictionary that maps the mesh piece</span>
<span class="sd">             to a list of all the somas contained inside of it </span>
<span class="sd">             </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get all the unique mesh pieces and create a dictionary with an empty list</span>
<span class="sd">    2) iterate through the containing_mesh_indices dictionary and add each</span>
<span class="sd">       soma index to the list of the containing mesh index</span>
<span class="sd">    3) check that none of the lists are empty or else something has failed</span>
<span class="sd">             </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">unique_meshes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">mesh_groupings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,[])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_meshes</span><span class="p">])</span>
    
    <span class="c1">#2) iterate through the containing_mesh_indices dictionary and add each</span>
    <span class="c1">#   soma index to the list of the containing mesh index</span>
    
    <span class="k">for</span> <span class="n">soma_idx</span><span class="p">,</span> <span class="n">mesh_idx</span> <span class="ow">in</span> <span class="n">containing_mesh_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">mesh_groupings</span><span class="p">[</span><span class="n">mesh_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">soma_idx</span><span class="p">)</span>
    
    <span class="c1">#3) check that none of the lists are empty or else something has failed</span>
    <span class="n">len_lists</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_groupings</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">len_lists</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;One of the lists is empty when grouping somas lists&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">mesh_groupings</span></div>



<span class="sd">&quot;&quot;&quot; ---------- 9/23: Addition to help filter away false somas&quot;&quot;&quot;</span>


<div class="viewcode-block" id="original_mesh_soma"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.original_mesh_soma">[docs]</a><span class="k">def</span> <span class="nf">original_mesh_soma</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">original_mesh</span><span class="p">,</span>
    <span class="n">bbox_restriction_multiplying_ratio</span> <span class="o">=</span> <span class="mf">1.7</span><span class="p">,</span>
    <span class="n">match_distance_threshold</span> <span class="o">=</span> <span class="mi">1500</span><span class="p">,</span>
    <span class="n">mesh_significance_threshold</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">return_inside_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">return_multiple_pieces_above_threshold</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take an approximation of the soma mesh (usually from a poisson surface reconstruction)</span>
<span class="sd">    and map it to faces on the original mesh</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) restrict the larger mesh with a bounding box or current</span>
<span class="sd">    2) Remove all interior pieces</span>
<span class="sd">    3) Save the interior pieces if asked for a pass-back</span>
<span class="sd">    4) Split the Main Mesh</span>
<span class="sd">    5) Find the Meshes that contain the soma</span>
<span class="sd">    6) Map to the original with a high distance threshold</span>
<span class="sd">    7) Split the new mesh and take the largest</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">soma_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mesh</span><span class="p">]</span>

    <span class="c1">#1) restrict the larger mesh with a bounding box or current</span>
    <span class="n">restricted_big_mesh</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bbox_mesh_restriction</span><span class="p">(</span><span class="n">original_mesh</span><span class="p">,</span><span class="n">mesh</span><span class="p">,</span><span class="n">mult_ratio</span><span class="o">=</span><span class="n">bbox_restriction_multiplying_ratio</span><span class="p">)</span>

    <span class="c1"># -- Split into largest piece -- #</span>
<span class="c1">#     restr_split = tu.split_significant_pieces(restricted_big_mesh,</span>
<span class="c1">#                                               significance_threshold=mesh_significance_threshold,connectivity=&quot;edges&quot;)</span>
<span class="c1">#     restr_mesh_to_test = restr_split[0]</span>

    <span class="n">restr_mesh_to_test</span> <span class="o">=</span> <span class="n">restricted_big_mesh</span>


    <span class="c1">#nviz.plot_objects(restricted_big_mesh)</span>

    <span class="c1">#2) Remove all interior pieces</span>
    <span class="n">orig_mesh_to_map</span><span class="p">,</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">restr_mesh_to_test</span><span class="p">,</span><span class="n">return_removed_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; Old way that did a lot of splits: but not doing splits anymore</span>
<span class="sd">#     #nviz.plot_objects(restr_without_interior)</span>
<span class="sd">#     split_meshes = tu.split_significant_pieces(restr_without_interior,</span>
<span class="sd">#                                                significance_threshold=mesh_significance_threshold,connectivity=&quot;edges&quot;)</span>

<span class="sd">#     split_meshes = [restr_without_interior]</span>

<span class="sd">#     #nviz.plot_objects(meshes=split_meshes)</span>

<span class="sd">#     #5) Find the Meshes that contain the soma</span>
<span class="sd">#     containing_mesh_indices = find_soma_centroid_containing_meshes(soma_mesh_list,</span>
<span class="sd">#                                                 split_meshes,</span>
<span class="sd">#                                                 verbose=True)</span>

<span class="sd">#     soma_containing_meshes = grouping_containing_mesh_indices(containing_mesh_indices)</span>

<span class="sd">#     soma_touching_meshes = [split_meshes[k] for k in soma_containing_meshes.keys()]</span>

<span class="sd">#     if len(soma_touching_meshes) != 1:</span>
<span class="sd">#         raise Exception(f&quot;soma_touching_meshes not of size 1 {soma_touching_meshes}&quot;)</span>

<span class="sd">#     orig_mesh_to_map = soma_touching_meshes[0]</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">#6) Map to the original with a high distance threshold</span>
    <span class="n">prelim_soma_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">orig_mesh_to_map</span><span class="p">,</span>
                              <span class="n">submesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
                              <span class="n">matching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">match_threshold</span> <span class="o">=</span> <span class="n">match_distance_threshold</span><span class="p">,</span>
                              <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#nviz.plot_objects(prelim_soma_mesh)</span>

    <span class="c1">#7) Split the new mesh and take the largest</span>
    <span class="n">split_meshes_after_backtrack</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">prelim_soma_mesh</span><span class="p">,</span>
                                <span class="n">significance_threshold</span><span class="o">=</span><span class="n">mesh_significance_threshold</span><span class="p">,</span>
                                                              <span class="n">connectivity</span><span class="o">=</span><span class="n">soma_connectivity</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split_meshes_after_backtrack = </span><span class="si">{</span><span class="n">split_meshes_after_backtrack</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_size_threshold = </span><span class="si">{</span><span class="n">soma_size_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">save_mesh_intermediates</span><span class="p">:</span>
        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">split_meshes_after_backtrack</span><span class="p">,</span><span class="s2">&quot;split_meshes_after_backtrack_2&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_meshes_after_backtrack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">return_mesh</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_multiple_pieces_above_threshold</span><span class="p">:</span>
            <span class="n">return_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">split_meshes_after_backtrack</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="o">&gt;</span><span class="n">soma_size_threshold</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_inside_pieces</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_mesh</span><span class="p">,</span><span class="n">inside_pieces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_mesh</span></div>


<div class="viewcode-block" id="original_mesh_soma_old"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.original_mesh_soma_old">[docs]</a><span class="k">def</span> <span class="nf">original_mesh_soma_old</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">soma_meshes</span><span class="p">,</span>
    <span class="n">sig_th_initial_split</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">subtract_soma_distance_threshold</span><span class="o">=</span><span class="mi">550</span><span class="p">,</span>
    <span class="n">split_meshes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will help backtrack the Poisson surface reconstruction soma </span>
<span class="sd">    to the soma of the actual mesh</span>
<span class="sd">    </span>
<span class="sd">    Application: By backtracking to mesh it will help with figuring</span>
<span class="sd">    out false somas from neural 3D junk</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    multi_soma_seg_ids = np.unique(multi_soma_seg_ids)</span>
<span class="sd">    seg_id_idx = -2</span>
<span class="sd">    seg_id = multi_soma_seg_ids[seg_id_idx]</span>

<span class="sd">    dec_mesh = get_decimated_mesh(seg_id)</span>
<span class="sd">    curr_soma_meshes = get_seg_extracted_somas(seg_id)</span>
<span class="sd">    curr_soma_mesh_list = get_soma_mesh_list(seg_id)</span>

<span class="sd">    from mesh_tools import skeleton_utils as sk</span>
<span class="sd">    sk.graph_skeleton_and_mesh(main_mesh_verts=dec_mesh.vertices,</span>
<span class="sd">                               main_mesh_faces=dec_mesh.faces,</span>
<span class="sd">                            other_meshes=curr_soma_meshes,</span>
<span class="sd">                              other_meshes_colors=&quot;red&quot;)</span>
<span class="sd">    </span>

<span class="sd">    soma_meshes_new = original_mesh_soma(</span>
<span class="sd">        mesh = dec_mesh,</span>
<span class="sd">        soma_meshes=curr_soma_meshes,</span>
<span class="sd">        sig_th_initial_split=15)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">):</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_meshes</span><span class="p">]</span>
    
    <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">soma_mesh_list_centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_meshes</span><span class="p">]</span>
    <span class="n">soma_mesh_list</span><span class="o">=</span><span class="n">soma_meshes</span>
    
    

    <span class="c1">#--- 2) getting the soma submeshes that are connected to each soma and identifiying those that aren&#39;t (and eliminating any mesh pieces inside the soma)</span>

    <span class="c1">#finding the mesh pieces that contain the soma</span>
    <span class="c1">#splitting the current neuron into distinct pieces</span>
    
    <span class="k">if</span> <span class="n">split_meshes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">split_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span>
                                    <span class="n">main_mesh_total</span><span class="p">,</span>
                                    <span class="n">significance_threshold</span><span class="o">=</span><span class="n">sig_th_initial_split</span><span class="p">,</span>
                                    <span class="n">connectivity</span><span class="o">=</span><span class="n">soma_connectivity</span><span class="p">,</span>
                                    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# total split meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#returns the index of the split_meshes index that contains each soma    </span>
    <span class="n">containing_mesh_indices</span> <span class="o">=</span> <span class="n">find_soma_centroid_containing_meshes</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span>
                                            <span class="n">split_meshes</span><span class="p">,</span>
                                            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># filtering away any of the inside floating pieces: </span>
    <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">split_meshes</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>


    <span class="c1">#Adding the step that will filter away any pieces that are inside the soma</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_soma_touching_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *** want to save these pieces that are inside of the soma***</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">non_soma_touching_meshes</span><span class="p">,</span><span class="n">inside_pieces</span> <span class="o">=</span> <span class="n">filter_away_inside_soma_pieces</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">,</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
                                        <span class="n">significance_threshold</span><span class="o">=</span><span class="n">sig_th_initial_split</span><span class="p">,</span>
                                        <span class="n">return_inside_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>                                                      


    <span class="n">split_meshes</span> <span class="c1"># the meshes of the original mesh</span>
    <span class="n">containing_mesh_indices</span> <span class="c1">#the mapping of each soma centroid to the correct split mesh</span>
    <span class="n">soma_containing_meshes</span> <span class="o">=</span> <span class="n">grouping_containing_mesh_indices</span><span class="p">(</span><span class="n">containing_mesh_indices</span><span class="p">)</span>

    <span class="n">soma_touching_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>


    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of soma containing seperate meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_touching_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;meshes with somas = </span><span class="si">{</span><span class="n">soma_containing_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1">#Ex: {0: [0, 1]}</span>







    <span class="c1">#--- 3)  Soma Extraction was great (but it wasn&#39;t the original soma faces), so now need to get the original soma faces and the original non-soma faces of original pieces</span>


<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for each soma touching mesh get the following:</span>
<span class="sd">    1) original soma meshes</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">soma_meshes_new</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">)</span>

    
    <span class="k">for</span> <span class="n">z</span><span class="p">,(</span><span class="n">mesh_idx</span><span class="p">,</span> <span class="n">soma_idxes</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_containing_meshes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">----Working on soma-containing mesh piece </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">----&quot;</span><span class="p">)</span>

        <span class="c1">#1) Final all soma faces (through soma extraction and then soma original faces function)</span>
        <span class="n">current_mesh</span> <span class="o">=</span> <span class="n">split_meshes</span><span class="p">[</span><span class="n">mesh_idx</span><span class="p">]</span> <span class="c1">#gets the current soma containing mesh</span>

        <span class="n">current_soma_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_mesh_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_idxes</span><span class="p">]</span>

        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_soma_mesh_list = </span><span class="si">{</span><span class="n">current_soma_mesh_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_mesh = </span><span class="si">{</span><span class="n">current_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">mesh_pieces_without_soma</span> <span class="o">=</span> <span class="n">subtract_soma</span><span class="p">(</span><span class="n">current_soma_mesh_list</span><span class="p">,</span><span class="n">current_mesh</span><span class="p">,</span>
                                                 <span class="n">distance_threshold</span><span class="o">=</span><span class="n">subtract_soma_distance_threshold</span><span class="p">,</span>
                                                    <span class="n">significance_threshold</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_pieces_without_soma = </span><span class="si">{</span><span class="n">mesh_pieces_without_soma</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_pieces_without_soma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Subtract Soam = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        
        
        
        <span class="n">mesh_pieces_without_soma_stacked</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">mesh_pieces_without_soma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mesh_pieces_without_soma_stacked = </span><span class="si">{</span><span class="n">mesh_pieces_without_soma_stacked</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># find the original soma faces of mesh</span>
        <span class="n">soma_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">,</span><span class="n">mesh_pieces_without_soma_stacked</span><span class="p">,</span><span class="n">matching</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for Original_mesh_faces_map for mesh_pieces without soma= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">current_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_faces = </span><span class="si">{</span><span class="n">soma_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">current_mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">soma_faces</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_meshes = </span><span class="si">{</span><span class="n">soma_meshes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#How to seperate the mesh faces</span>
        <span class="n">seperate_soma_meshes</span><span class="p">,</span><span class="n">soma_face_components</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1">#take the top largest ones depending how many were originally in the soma list</span>
        
        <span class="n">seperate_soma_meshes</span> <span class="o">=</span> <span class="n">seperate_soma_meshes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)]</span>
        
        <span class="n">soma_face_components</span> <span class="o">=</span> <span class="n">soma_face_components</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)]</span>


        
        <span class="c1">#storing the new somas</span>
        <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">s_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_idxes</span><span class="p">):</span>
            <span class="n">soma_meshes_new</span><span class="p">[</span><span class="n">s_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">seperate_soma_meshes</span><span class="p">[</span><span class="n">zz</span><span class="p">]</span>
            
        
    <span class="k">return</span> <span class="n">soma_meshes_new</span></div>
    
<div class="viewcode-block" id="extract_soma_center"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.extract_soma_center">[docs]</a><span class="k">def</span> <span class="nf">extract_soma_center</span><span class="p">(</span>
    <span class="n">segment_id</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
    <span class="n">current_mesh_verts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">current_mesh_faces</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="n">outer_decimation_ratio</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">large_mesh_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#60000,</span>
    <span class="n">large_mesh_threshold_inner</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#was changed so dont filter away som somas</span>
    <span class="n">soma_width_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#changed this to smaller so didn&#39;t filter some somas away</span>
    <span class="n">inner_decimation_ratio</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="n">segmentation_clusters</span> <span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">segmentation_smoothness</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>

    <span class="n">volume_mulitplier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1">#side_length_ratio_threshold=3</span>
    <span class="n">side_length_ratio_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_size_threshold_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#240000,#192000, #this puts at 12000 once decimated, another possible is 256000</span>
    <span class="n">delete_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">backtrack_soma_mesh_to_original</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#should either be None or </span>
    <span class="n">boundary_vertices_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#700 the previous threshold used</span>
    <span class="n">poisson_backtrack_distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="c1">#1500 the previous threshold used</span>
    <span class="n">close_holes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>

    <span class="c1">#------- 11/12 Additions --------------- #</span>

    <span class="c1">#these arguments are for removing inside pieces</span>
    <span class="n">remove_inside_pieces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="c1">#size accounting for the decimation</span>


    <span class="n">pymeshfix_clean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">check_holes_before_pymeshfix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">second_poisson</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">segmentation_at_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">last_size_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#1300,</span>

    <span class="n">largest_hole_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_fail_loops</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#np.inf,</span>
    <span class="n">perform_pairing</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

    <span class="n">return_glia_nuclei_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">backtrack_soma_size_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">backtrack_match_distance_threshold</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>

    <span class="n">filter_inside_meshes_after_glia_removal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">max_mesh_sized_filtered_away</span> <span class="o">=</span> <span class="mi">90000</span><span class="p">,</span>

    <span class="n">filter_inside_somas</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">backtrack_segmentation_on_fail</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="c1">#arguments for the glia pieces</span>
    <span class="n">glia_pieces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nuclei_pieces</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">glia_volume_threshold_in_um</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#minimum volume of glia mesh</span>
    <span class="n">glia_n_faces_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#minimum number of faes for glia mesh if volume is not defined</span>
    <span class="n">glia_n_faces_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#minimum number of faes for glia mesh if glia volume defined</span>
    <span class="n">nucleus_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#minimum number of faces for nuclei mesh peices</span>
    <span class="n">nucleus_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#maximum number of faces for nuclie mesh pieces if glia volume is not defined</span>

    <span class="n">second_pass_size_threshold</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="c1"># ------- Nuclei parameters -------------</span>
    <span class="k">if</span> <span class="n">nucleus_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nucleus_min</span> <span class="o">=</span> <span class="n">nucleus_min_global</span>
        
    <span class="k">if</span> <span class="n">nucleus_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nucleus_max</span> <span class="o">=</span> <span class="n">nucleus_max_global</span>
        
    <span class="c1"># ------ Glia parameters ------------</span>
    <span class="k">if</span> <span class="n">glia_volume_threshold_in_um</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">glia_volume_threshold_in_um</span> <span class="o">=</span> <span class="n">glia_volume_threshold_in_um_global</span>
        
    <span class="k">if</span> <span class="n">glia_n_faces_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">glia_n_faces_threshold</span> <span class="o">=</span> <span class="n">glia_n_faces_threshold_global</span>
        
    <span class="k">if</span> <span class="n">glia_n_faces_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">glia_n_faces_min</span> <span class="o">=</span> <span class="n">glia_n_faces_min_global</span>
        
    <span class="c1"># -------- Soma parameters -----------</span>
    <span class="k">if</span> <span class="n">outer_decimation_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outer_decimation_ratio</span> <span class="o">=</span> <span class="n">outer_decimation_ratio_global</span>
        
    <span class="k">if</span> <span class="n">large_mesh_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">large_mesh_threshold</span> <span class="o">=</span> <span class="n">large_mesh_threshold_global</span>
    
    <span class="k">if</span> <span class="n">large_mesh_threshold_inner</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">large_mesh_threshold_inner</span> <span class="o">=</span> <span class="n">large_mesh_threshold_inner_global</span>
    
    <span class="k">if</span> <span class="n">inner_decimation_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inner_decimation_ratio</span> <span class="o">=</span> <span class="n">inner_decimation_ratio_global</span>
        
        
    <span class="k">if</span> <span class="n">max_fail_loops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_fail_loops</span> <span class="o">=</span> <span class="n">max_fail_loops_global</span>
    <span class="k">if</span> <span class="n">remove_inside_pieces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">remove_inside_pieces</span> <span class="o">=</span> <span class="n">remove_inside_pieces_global</span>
    <span class="k">if</span> <span class="n">size_threshold_to_remove</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size_threshold_to_remove</span> <span class="o">=</span> <span class="n">size_threshold_to_remove_global</span>
    <span class="k">if</span> <span class="n">pymeshfix_clean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pymeshfix_clean</span> <span class="o">=</span> <span class="n">pymeshfix_clean_global</span>
    <span class="k">if</span> <span class="n">check_holes_before_pymeshfix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">check_holes_before_pymeshfix</span> <span class="o">=</span> <span class="n">check_holes_before_pymeshfix_global</span>
    <span class="k">if</span> <span class="n">second_poisson</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">second_poisson</span> <span class="o">=</span> <span class="n">second_poisson_global</span>
    <span class="k">if</span> <span class="n">soma_width_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_width_threshold</span> <span class="o">=</span> <span class="n">soma_width_threshold_global</span>
    <span class="k">if</span> <span class="n">soma_size_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="n">soma_size_threshold_global</span>
    <span class="k">if</span> <span class="n">soma_size_threshold_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_size_threshold_max</span> <span class="o">=</span> <span class="n">soma_size_threshold_max_global</span>
    <span class="k">if</span> <span class="n">volume_mulitplier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">volume_mulitplier</span> <span class="o">=</span> <span class="n">volume_mulitplier_global</span>
    <span class="k">if</span> <span class="n">side_length_ratio_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">side_length_ratio_threshold</span> <span class="o">=</span> <span class="n">side_length_ratio_threshold_global</span>
    <span class="k">if</span> <span class="n">perform_pairing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">perform_pairing</span> <span class="o">=</span> <span class="n">perform_pairing_global</span>
    <span class="k">if</span> <span class="n">backtrack_soma_mesh_to_original</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">backtrack_soma_mesh_to_original</span> <span class="o">=</span> <span class="n">backtrack_soma_mesh_to_original_global</span>
    <span class="k">if</span> <span class="n">backtrack_soma_size_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">backtrack_soma_size_threshold</span> <span class="o">=</span> <span class="n">backtrack_soma_size_threshold_global</span>
    <span class="k">if</span> <span class="n">poisson_backtrack_distance_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">poisson_backtrack_distance_threshold</span> <span class="o">=</span> <span class="n">poisson_backtrack_distance_threshold_global</span>
    <span class="k">if</span> <span class="n">close_holes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">close_holes</span> <span class="o">=</span> <span class="n">close_holes_global</span>
    <span class="k">if</span> <span class="n">boundary_vertices_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">boundary_vertices_threshold</span> <span class="o">=</span> <span class="n">boundary_vertices_threshold_global</span>
    <span class="k">if</span> <span class="n">last_size_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">last_size_threshold</span> <span class="o">=</span> <span class="n">last_size_threshold_global</span>
    <span class="k">if</span> <span class="n">segmentation_at_end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">segmentation_at_end</span> <span class="o">=</span> <span class="n">segmentation_at_end_global</span>
    <span class="k">if</span> <span class="n">largest_hole_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">largest_hole_threshold</span> <span class="o">=</span> <span class="n">largest_hole_threshold_global</span>
    <span class="k">if</span> <span class="n">second_pass_size_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">second_pass_size_threshold</span> <span class="o">=</span> <span class="n">second_pass_size_threshold_global</span>
<span class="w">        </span>
<span class="w">    </span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To extract the glia/neurons and soma fetures</span>
<span class="sd">    </span>
<span class="sd">    Argumetns for glia/nucleus extraction: </span>
<span class="sd">    glia_volume_threshold_in_um = 2500 #minimum volume of glia mesh</span>
<span class="sd">    glia_n_faces_threshold = 400000 #minimum number of faes for glia mesh if volume is not defined</span>
<span class="sd">    glia_n_faces_min = 100000 #minimum number of faes for glia mesh if glia volume defined</span>
<span class="sd">    nucleus_min = 700 #minimum number of faces for nuclei mesh peices</span>
<span class="sd">    nucleus_max = None #maximum number of faces for nuclie mesh pieces if glia volume is not defined</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Arguments for soma extraction: </span>
<span class="sd">    # **Note: All of the thresholds get scaled by the decimation ratios applied before</span>

<span class="sd">    outer_decimation_ratio= 0.25 #decimation ratio for 1st round of decimation</span>
<span class="sd">    large_mesh_threshold = 20000 #minimum face count threshold after 1st round of decimation</span>
<span class="sd">    large_mesh_threshold_inner = 13000 #minimum face count threshold after poisson reconstruction and split</span>
<span class="sd">    inner_decimation_ratio = 0.25 #decimation ratio for 2nd round of decimation after poisson reconstruction</span>
<span class="sd">    max_fail_loops = 10 #number of times soma finding can fail in finding an invalid soma in the outer/inner decimation loop</span>

<span class="sd">    # other cleaning methods to run on segments after first decimation</span>
<span class="sd">    remove_inside_pieces = True #whether to remove inside pieces before processing</span>
<span class="sd">    size_threshold_to_remove=1000, #minium number of faces of mesh piece to remove</span>
<span class="sd">    pymeshfix_clean=False</span>
<span class="sd">    check_holes_before_pymeshfix=False</span>
<span class="sd">    second_poisson=False</span>

<span class="sd">    #after 2nd round of decimation and mesh segmentation is applied</span>
<span class="sd">    soma_width_threshold = 0.32 # minimuum sdf values of mesh segments</span>
<span class="sd">    soma_size_threshold = 9000 # minimum face count threshold of mesh segments</span>
<span class="sd">    soma_size_threshold_max=1_200_000# maximum face count threshold of mesh segments</span>

<span class="sd">    #parameters for checking possible viable somas after mesh segmentation</span>
<span class="sd">    volume_mulitplier=8 #for soma_volume_check funcion that makes sure not highly skewed bounding box volume to mesh volume </span>
<span class="sd">    side_length_ratio_threshold=6 #for side_length_check function making sure not highly swkewed x,y,z side length ratios</span>
<span class="sd">    delete_files=True #deletes all files in temp folder</span>

<span class="sd">    #whether to group certain poisson representations of somas together before backtrack to mesh</span>
<span class="sd">    perform_pairing = False</span>


<span class="sd">    backtrack_soma_mesh_to_original=True #will backtrack the poisson reconstruction soma to the original mesh</span>
<span class="sd">    backtrack_soma_size_threshold=8000 #minimum number of faces for a backtracked mesh</span>


<span class="sd">    #for filtering away somas once get backtracked to original mesh with certain filters</span>
<span class="sd">    poisson_backtrack_distance_threshold=None #maximum distance between poisson reconstruction and backtracked soma</span>
<span class="sd">    close_holes=False #whether to close holes when doing poisson backtrack</span>

<span class="sd">    boundary_vertices_threshold=None #filter away somas if too many boundary vertices</span>


<span class="sd">    #filters at the very end for meshes that made it thorugh</span>
<span class="sd">    last_size_threshold = 2000 #min faces count</span>

<span class="sd">    segmentation_at_end=True #whether to attempt to split meshes at end</span>
<span class="sd">    largest_hole_threshold = 17000 #maximum hole length for a soma to allow the segmentaiton split at end</span>

<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">global_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1">#Adjusting the thresholds based on the decimations</span>
    <span class="n">large_mesh_threshold</span> <span class="o">=</span> <span class="n">large_mesh_threshold</span><span class="o">*</span><span class="n">outer_decimation_ratio</span>
    <span class="n">large_mesh_threshold_inner</span> <span class="o">=</span> <span class="n">large_mesh_threshold_inner</span><span class="o">*</span><span class="n">outer_decimation_ratio</span>
    <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="n">soma_size_threshold</span><span class="o">*</span><span class="n">outer_decimation_ratio</span>
    <span class="n">soma_size_threshold_max</span> <span class="o">=</span> <span class="n">soma_size_threshold_max</span><span class="o">*</span><span class="n">outer_decimation_ratio</span>
    <span class="n">max_mesh_sized_filtered_away</span> <span class="o">=</span> <span class="n">max_mesh_sized_filtered_away</span><span class="o">*</span><span class="n">outer_decimation_ratio</span>

    <span class="c1">#adjusting for inner decimation</span>
    <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="n">soma_size_threshold</span><span class="o">*</span><span class="n">inner_decimation_ratio</span>
    <span class="n">soma_size_threshold_max</span> <span class="o">=</span> <span class="n">soma_size_threshold_max</span><span class="o">*</span><span class="n">inner_decimation_ratio</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current Arguments Using (adjusted for decimation):</span><span class="se">\n</span><span class="s2"> large_mesh_threshold= </span><span class="si">{</span><span class="n">large_mesh_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">large_mesh_threshold_inner = </span><span class="si">{</span><span class="n">large_mesh_threshold_inner</span><span class="si">}</span><span class="s2">&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">soma_size_threshold = </span><span class="si">{</span><span class="n">soma_size_threshold</span><span class="si">}</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">soma_size_threshold_max = </span><span class="si">{</span><span class="n">soma_size_threshold_max</span><span class="si">}</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">outer_decimation_ratio = </span><span class="si">{</span><span class="n">outer_decimation_ratio</span><span class="si">}</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">inner_decimation_ratio = </span><span class="si">{</span><span class="n">inner_decimation_ratio</span><span class="si">}</span><span class="s2">&quot;</span>
         <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">max_mesh_sized_filtered_away = </span><span class="si">{</span><span class="n">max_mesh_sized_filtered_away</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1"># ------------------------------</span>


    <span class="n">temp_folder</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;./</span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">temp_object</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">temp_folder</span><span class="p">)</span>
    <span class="c1">#make the temp folder if it doesn&#39;t exist</span>
    <span class="n">temp_object</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">#making the decimation and poisson objections</span>
    <span class="n">Dec_outer</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Decimator</span><span class="p">(</span><span class="n">outer_decimation_ratio</span><span class="p">,</span><span class="n">temp_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Dec_inner</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Decimator</span><span class="p">(</span><span class="n">inner_decimation_ratio</span><span class="p">,</span><span class="n">temp_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">Poisson_obj</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="n">temp_folder</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">recov_orig_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">current_mesh_verts</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="n">current_mesh_faces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">recov_orig_mesh</span> <span class="o">=</span> <span class="n">mesh</span>
    
    
    <span class="k">if</span> <span class="n">glia_pieces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nuclei_pieces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">recov_orig_mesh_no_interior</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">recov_orig_mesh</span><span class="p">,[</span><span class="n">glia_pieces</span><span class="p">,</span><span class="n">nuclei_pieces</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">recov_orig_mesh_no_interior</span><span class="p">,</span> <span class="n">glia_pieces</span><span class="p">,</span> <span class="n">nuclei_pieces</span>  <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">remove_nuclei_and_glia_meshes</span><span class="p">(</span>
                <span class="n">recov_orig_mesh</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">glia_volume_threshold_in_um</span> <span class="o">=</span> <span class="n">glia_volume_threshold_in_um</span><span class="p">,</span>
                <span class="n">glia_n_faces_threshold</span> <span class="o">=</span> <span class="n">glia_n_faces_threshold</span><span class="p">,</span>
                <span class="n">glia_n_faces_min</span> <span class="o">=</span> <span class="n">glia_n_faces_min</span><span class="p">,</span>
                <span class="n">nucleus_min</span><span class="o">=</span> <span class="n">nucleus_min</span><span class="p">,</span>
                <span class="n">nucleus_max</span><span class="o">=</span><span class="n">nucleus_max</span><span class="p">,</span>                                                                                

                <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**Unable to remove_nuclei_and_glia_meshes: so just continuing without doing so **&quot;</span><span class="p">)</span>
            <span class="n">recov_orig_mesh_no_interior</span> <span class="o">=</span> <span class="n">recov_orig_mesh</span>
            <span class="n">glia_pieces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">nuclei_pieces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#recov_orig_mesh_no_interior = tu.remove_mesh_interior(recov_orig_mesh)</span>

    

    <span class="c1">#Step 1: Decimate the Mesh and then split into the seperate pieces</span>
    <span class="n">new_mesh</span><span class="p">,</span><span class="n">output_obj</span> <span class="o">=</span> <span class="n">Dec_outer</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">recov_orig_mesh_no_interior</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
             <span class="n">faces</span><span class="o">=</span><span class="n">recov_orig_mesh_no_interior</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
             <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
             <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># if remove_inside_pieces:</span>
    <span class="c1">#     print(&quot;removing mesh interior after decimation&quot;)</span>
    <span class="c1">#     new_mesh = tu.remove_mesh_interior(new_mesh,size_threshold_to_remove=size_threshold_to_remove)</span>

    <span class="c1">#preforming the splits of the decimated mesh</span>

    <span class="n">mesh_splits</span> <span class="o">=</span> <span class="n">new_mesh</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1">#get the largest mesh</span>
    <span class="n">mesh_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">split</span> <span class="ow">in</span> <span class="n">mesh_splits</span><span class="p">])</span>


    <span class="n">total_mesh_split_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_splits</span><span class="p">]</span>
    <span class="n">ordered_mesh_splits</span> <span class="o">=</span> <span class="n">mesh_splits</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">total_mesh_split_lengths</span><span class="p">))]</span>
    <span class="n">list_of_largest_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_mesh_splits</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">large_mesh_threshold</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total found significant pieces before Poisson = </span><span class="si">{</span><span class="n">list_of_largest_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># --------- 1/11 Addition: Filtering away large meshes that are inside another --------- #</span>
    <span class="k">if</span> <span class="n">filter_inside_meshes_after_glia_removal</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering away larger meshes that are inside others, before # of meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_largest_mesh</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">list_of_largest_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_away_inside_meshes</span><span class="p">(</span><span class="n">list_of_largest_mesh</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_meshes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">max_mesh_sized_filtered_away</span><span class="o">=</span><span class="n">max_mesh_sized_filtered_away</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After # of meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">list_of_largest_mesh</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1">#if no significant pieces were found then will use smaller threshold</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_largest_mesh</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using smaller large_mesh_threshold because no significant pieces found with </span><span class="si">{</span><span class="n">large_mesh_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">list_of_largest_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_mesh_splits</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">large_mesh_threshold</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">total_soma_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_poisson_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_soma_list_sdf</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">second_pass_size_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not need to do a second pass because already found a soma&quot;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">delete_files</span><span class="p">:</span>
                <span class="c1">#now erase all of the files used</span>
                <span class="kn">from</span> <span class="nn">shutil</span> <span class="kn">import</span> <span class="n">rmtree</span>

                <span class="c1">#remove the directory with the meshes</span>
                <span class="n">rmtree</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">temp_object</span><span class="o">.</span><span class="n">absolute</span><span class="p">()))</span>

                <span class="c1">#removing the temporary files</span>
                <span class="n">temp_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./temp&quot;</span><span class="p">)</span>
                <span class="n">temp_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;**/*&#39;</span><span class="p">)]</span>
                <span class="n">seg_temp_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp_files</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">seg_temp_files</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
            <span class="k">break</span>
            
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using backup size thresholds&quot;</span><span class="p">)</span>

            <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="n">second_pass_size_threshold</span>
            <span class="n">last_size_threshold</span> <span class="o">=</span> <span class="n">second_pass_size_threshold</span>
            <span class="n">backtrack_soma_size_threshold</span> <span class="o">=</span> <span class="n">second_pass_size_threshold</span>


        
        <span class="c1">#start iterating through where go through all pieces before the poisson reconstruction</span>
        <span class="n">no_somas_found_in_big_loop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">largest_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_largest_mesh</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----- working on large mesh #</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">largest_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">remove_inside_pieces</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;remove_inside_pieces requested &quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">largest_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">largest_mesh</span><span class="p">,</span>
                                                           <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="n">size_threshold_to_remove</span><span class="p">,</span>
                                                          <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to remove inside pieces in list_of_largest_mesh&quot;</span><span class="p">)</span>
                    <span class="n">largest_mesh</span> <span class="o">=</span> <span class="n">largest_mesh</span>


            <span class="k">if</span> <span class="n">pymeshfix_clean</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Requested pymeshfix_clean&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Don&#39;t have to check if manifold anymore actually just have to plug the holes</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">hole_groups</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_face_groups</span><span class="p">(</span><span class="n">largest_mesh</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">largest_mesh_filled_holes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">largest_mesh</span><span class="p">,</span><span class="n">max_hole_size</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">largest_mesh_filled_holes</span> <span class="o">=</span> <span class="n">largest_mesh</span>

                <span class="k">if</span> <span class="n">check_holes_before_pymeshfix</span><span class="p">:</span>
                    <span class="n">hole_groups</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_face_groups</span><span class="p">(</span><span class="n">largest_mesh_filled_holes</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not checking if there are still existing holes before pymeshfix&quot;</span><span class="p">)</span>
                    <span class="n">hole_groups</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#segmentation_at_end = False</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*** COULD NOT FILL HOLES WITH MAX SIZE OF </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">hole_groups</span><span class="p">])</span><span class="si">}</span><span class="s2"> so not applying pymeshfix and segmentation_at_end = </span><span class="si">{</span><span class="n">segmentation_at_end</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#                 tu.write_neuron_off(largest_mesh_filled_holes,&quot;largest_mesh_filled_holes&quot;)</span>
        <span class="c1">#                 raise Exception()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Applying pymeshfix_clean because no more holes&quot;</span><span class="p">)</span>
                    <span class="n">largest_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">pymeshfix_clean</span><span class="p">(</span><span class="n">largest_mesh_filled_holes</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">second_poisson</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Applying second poisson run&quot;</span><span class="p">)</span>
                <span class="n">current_neuron_poisson</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">poisson_surface_reconstruction</span><span class="p">(</span><span class="n">largest_mesh</span><span class="p">)</span>
                <span class="n">largest_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">current_neuron_poisson</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">soma_connectivity</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">somas_found_in_big_loop</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">largest_file_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_obj</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_largest_piece.off&quot;</span>
            <span class="n">pre_largest_mesh_path</span> <span class="o">=</span> <span class="n">temp_object</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_obj</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_largest_piece.off&quot;</span><span class="p">)</span>
            <span class="n">pre_largest_mesh_path</span> <span class="o">=</span> <span class="n">pre_largest_mesh_path</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pre_largest_mesh_path = </span><span class="si">{</span><span class="n">pre_largest_mesh_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># ******* This ERRORED AND CALLED OUR NERUON NONE: 77697401493989254 *********</span>
            <span class="n">new_mesh_inner</span><span class="p">,</span><span class="n">poisson_file_obj</span> <span class="o">=</span> <span class="n">Poisson_obj</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">largest_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                       <span class="n">faces</span><span class="o">=</span><span class="n">largest_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                       <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">mesh_filename</span><span class="o">=</span><span class="n">largest_file_name</span><span class="p">,</span>
                       <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


            <span class="c1">#splitting the Poisson into the largest pieces and ordering them</span>
            <span class="n">mesh_splits_inner</span> <span class="o">=</span> <span class="n">new_mesh_inner</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">only_watertight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">total_mesh_split_lengths_inner</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mesh_splits_inner</span><span class="p">]</span>
            <span class="n">ordered_mesh_splits_inner</span> <span class="o">=</span> <span class="n">mesh_splits_inner</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">total_mesh_split_lengths_inner</span><span class="p">))]</span>

            <span class="n">list_of_largest_mesh_inner</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ordered_mesh_splits_inner</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">large_mesh_threshold_inner</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total found significant pieces AFTER Poisson = </span><span class="si">{</span><span class="n">list_of_largest_mesh_inner</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">n_failed_inner_soma_loops</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">largest_mesh_inner</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_largest_mesh_inner</span><span class="p">):</span>
                <span class="n">to_add_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">to_add_list_sdf</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;----- working on mesh after poisson #</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">largest_mesh_inner</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">largest_mesh_path_inner</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">poisson_file_obj</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_largest_inner.off&quot;</span>

                <span class="c1">#Decimate the inner poisson piece</span>
                <span class="n">largest_mesh_path_inner_decimated</span><span class="p">,</span><span class="n">output_obj_inner</span> <span class="o">=</span> <span class="n">Dec_inner</span><span class="p">(</span>
                                    <span class="n">vertices</span><span class="o">=</span><span class="n">largest_mesh_inner</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                     <span class="n">faces</span><span class="o">=</span><span class="n">largest_mesh_inner</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                    <span class="n">mesh_filename</span><span class="o">=</span><span class="n">largest_mesh_path_inner</span><span class="p">,</span>
                                     <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">dec_splits</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">largest_mesh_path_inner_decimated</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                                                        <span class="n">connectivity</span><span class="o">=</span><span class="n">soma_connectivity</span><span class="p">,)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-------Splits after inner decimation len = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dec_splits</span><span class="p">)</span><span class="si">}</span><span class="s2">--------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dec_splits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There were no signifcant splits after inner decimation&quot;</span><span class="p">)</span>
                    <span class="n">n_failed_inner_soma_loops</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;done exporting decimated mesh: </span><span class="si">{</span><span class="n">largest_mesh_path_inner</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">largest_mesh_path_inner_decimated_clean</span> <span class="o">=</span> <span class="n">dec_splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">save_mesh_intermediates</span><span class="p">:</span>
                        <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">largest_mesh_path_inner_decimated_clean</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;largest_mesh_path_inner_decimated_clean_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot; # ----------- 1/12: Addition that does the segmentation again -------------------- #&quot;&quot;&quot;</span>

                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    --- On segmentation loop </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2"> --&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;largest_mesh_path_inner_decimated_clean = </span><span class="si">{</span><span class="n">largest_mesh_path_inner_decimated_clean</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="w">                        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                        faces = np.array(largest_mesh_path_inner_decimated_clean.faces)</span>
<span class="sd">                        verts = np.array(largest_mesh_path_inner_decimated_clean.vertices)</span>

<span class="sd">                        # may need to do some processing</span>


<span class="sd">                        segment_id_new = int(str(segment_id) + f&quot;{i}{j}&quot;)</span>
<span class="sd">                        #print(f&quot;Before the classifier the pymeshfix_clean = {pymeshfix_clean}&quot;)</span>
<span class="sd">                        verts_labels, faces_labels, soma_value,classifier = wcda.extract_branches_whole_neuron(</span>
<span class="sd">                                                import_Off_Flag=False,</span>
<span class="sd">                                                segment_id=segment_id_new,</span>
<span class="sd">                                                vertices=verts,</span>
<span class="sd">                                                 triangles=faces,</span>
<span class="sd">                                                pymeshfix_Flag=False,</span>
<span class="sd">                                                 import_CGAL_Flag=False,</span>
<span class="sd">                                                 return_Only_Labels=True,</span>
<span class="sd">                                                 clusters=3,</span>
<span class="sd">                                                 smoothness=0.2,</span>
<span class="sd">                                                soma_only=True,</span>
<span class="sd">                                                return_classifier = True</span>
<span class="sd">                                                )</span>
<span class="sd">                        print(f&quot;soma_sdf_value = {soma_value}&quot;)</span>


<span class="sd">                        #total_poisson_list.append(largest_mesh_path_inner_decimated)</span>

<span class="sd">                        # Save all of the portions that resemble a soma</span>
<span class="sd">                        median_values = np.array([v[&quot;median&quot;] for k,v in classifier.sdf_final_dict.items()])</span>
<span class="sd">                        segmentation = np.array([k for k,v in classifier.sdf_final_dict.items()])</span>

<span class="sd">                        #order the compartments by greatest to smallest</span>
<span class="sd">                        sorted_medians = np.flip(np.argsort(median_values))</span>
<span class="sd">                        print(f&quot;segmentation[sorted_medians],median_values[sorted_medians] = {(segmentation[sorted_medians],median_values[sorted_medians])}&quot;)</span>
<span class="sd">                        print(f&quot;Sizes = {[classifier.sdf_final_dict[g][&#39;n_faces&#39;] for g in segmentation[sorted_medians]]}&quot;)</span>
<span class="sd">                        print(f&quot;soma_size_threshold = {soma_size_threshold}&quot;)</span>
<span class="sd">                        print(f&quot;soma_size_threshold_max={soma_size_threshold_max}&quot;)</span>

<span class="sd">                        valid_soma_segments_width = [g for g,h in zip(segmentation[sorted_medians],median_values[sorted_medians]) if ((h &gt; soma_width_threshold)</span>
<span class="sd">                                                                            and (classifier.sdf_final_dict[g][&quot;n_faces&quot;] &gt; soma_size_threshold)</span>
<span class="sd">                                                                            and (classifier.sdf_final_dict[g][&quot;n_faces&quot;] &lt; soma_size_threshold_max))]</span>
<span class="sd">                        valid_soma_segments_sdf = [h for g,h in zip(segmentation[sorted_medians],median_values[sorted_medians]) if ((h &gt; soma_width_threshold)</span>
<span class="sd">                                                                            and (classifier.sdf_final_dict[g][&quot;n_faces&quot;] &gt; soma_size_threshold)</span>
<span class="sd">                                                                            and (classifier.sdf_final_dict[g][&quot;n_faces&quot;] &lt; soma_size_threshold_max))]</span>

<span class="sd">                        print(&quot;valid_soma_segments_width&quot;)</span>
<span class="sd">                        &#39;&#39;&#39;</span>

<span class="w">                        </span><span class="sd">&quot;&quot;&quot;# ----------- 1/14 Addition that will just use the trimesh segmentation function ------------&quot;&quot;&quot;</span>
                        
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;largest_mesh_path_inner_decimated_clean = </span><span class="si">{</span><span class="n">largest_mesh_path_inner_decimated_clean</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_size_threshold = </span><span class="si">{</span><span class="n">soma_size_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_size_threshold_max = </span><span class="si">{</span><span class="n">soma_size_threshold_max</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_width_threshold = </span><span class="si">{</span><span class="n">soma_width_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        
                        <span class="n">divided_meshes</span><span class="p">,</span><span class="n">divided_meshes_sdf</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">largest_mesh_path_inner_decimated_clean</span><span class="p">,</span><span class="n">clusters</span><span class="o">=</span><span class="n">segmentation_clusters</span><span class="p">,</span>
                                                                                 <span class="n">smoothness</span><span class="o">=</span><span class="n">segmentation_smoothness</span><span class="p">)</span>

                        <span class="n">divided_meshes_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">divided_meshes</span><span class="p">])</span>
                        <span class="n">valid_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">divided_meshes_len</span> <span class="o">&gt;</span> <span class="n">soma_size_threshold</span><span class="p">)</span> <span class="o">&amp;</span> 
                                                 <span class="p">(</span><span class="n">divided_meshes_len</span> <span class="o">&lt;</span> <span class="n">soma_size_threshold_max</span><span class="p">)</span> <span class="o">&amp;</span> 
                                                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">divided_meshes_sdf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">soma_width_threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="n">valid_soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">divided_meshes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">valid_indexes</span><span class="p">]</span>
                        <span class="n">valid_soma_segments_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">divided_meshes_sdf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">valid_indexes</span><span class="p">]</span>
                        
                        <span class="k">if</span> <span class="n">save_mesh_intermediates</span><span class="p">:</span>
                            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">valid_soma_meshes</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;valid_soma_meshes_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">valid_soma_meshes</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;valid_soma_segments_width_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



<span class="w">                        </span><span class="sd">&quot;&quot;&quot;# =------------- 1/12: Addition that will repeat this loop --------------&quot;&quot;&quot;</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_soma_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
<span class="w">                            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            Pseudocode: </span>
<span class="sd">                            Get the largest mesh segment</span>

<span class="sd">                            Old:</span>
<span class="sd">                            new_mesh_try_faces = np.where(classifier.labels_list == nu.mode_1d(classifier.labels_list))[0]</span>
<span class="sd">                            largest_mesh_path_inner_decimated_clean = largest_mesh_path_inner_decimated_clean.submesh([new_mesh_try_faces],append=True)</span>
<span class="sd">                            &quot;&quot;&quot;</span>
                            <span class="n">largest_mesh_path_inner_decimated_clean</span> <span class="o">=</span> <span class="n">divided_meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_soma_segments_width</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      ------ Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_soma_segments_width</span><span class="p">)</span><span class="si">}</span><span class="s2"> viable somas: </span><span class="si">{</span><span class="n">valid_soma_segments_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">somas_found_in_big_loop</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="c1">#get the meshes only if signfiicant length</span>

                        <span class="k">for</span> <span class="n">soma_mesh</span><span class="p">,</span><span class="n">sdf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">valid_soma_meshes</span><span class="p">,</span><span class="n">valid_soma_segments_width</span><span class="p">):</span>


                            <span class="c1"># ---------- No longer doing the extra checks in here --------- #</span>


                            <span class="n">curr_side_len_check</span> <span class="o">=</span> <span class="n">side_length_check</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">side_length_ratio_threshold</span><span class="p">)</span>
                            <span class="n">curr_volume_check</span> <span class="o">=</span> <span class="n">soma_volume_check</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">volume_mulitplier</span><span class="p">)</span>


                            <span class="k">if</span> <span class="n">curr_side_len_check</span> <span class="ow">and</span> <span class="n">curr_volume_check</span><span class="p">:</span>
                                <span class="c1">#check if we can split this into two</span>
                                <span class="n">to_add_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">)</span>
                                <span class="n">to_add_list_sdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdf</span><span class="p">)</span>

<span class="w">                                </span><span class="sd">&quot;&quot;&quot;  -----------Removed 1/12: When trying to force a split between them </span>
<span class="sd">                                possible_smoothness = [0.2,0.05,0.01]</span>
<span class="sd">                                for smooth_value in possible_smoothness:</span>
<span class="sd">                                    #1) Run th esegmentation algorithm again to segment the mesh (had to run the higher smoothing to seperate some)</span>
<span class="sd">                                    mesh_extra, mesh_extra_sdf = tu.mesh_segmentation(soma_mesh,clusters=3,smoothness=smooth_value,verbose=True)</span>
<span class="sd">                                    mesh_extra = np.array(mesh_extra)</span>

<span class="sd">                                    #2) Filter out meshes by sizs and sdf threshold</span>
<span class="sd">                                    mesh_extra_lens = np.array([len(kk.faces) for kk in mesh_extra])</span>
<span class="sd">                                    filtered_meshes_idx = np.where((mesh_extra_lens &gt;= soma_size_threshold) &amp; (mesh_extra_lens &lt;= soma_size_threshold_max) &amp; (mesh_extra_sdf&gt;soma_width_threshold))[0]</span>

<span class="sd">                                    if len(filtered_meshes_idx) &gt;= 2:</span>
<span class="sd">                                        if verbose:</span>
<span class="sd">                                            print(f&quot;Breakin on smoothness: {smooth_value}&quot;)</span>
<span class="sd">                                        break</span>

<span class="sd">                                if len(filtered_meshes_idx) &gt;= 2:</span>
<span class="sd">                                    filtered_meshes = mesh_extra[filtered_meshes_idx]</span>
<span class="sd">                                    filtered_meshes_sdf = mesh_extra_sdf[filtered_meshes_idx]</span>

<span class="sd">                                    to_add_list_retry = []</span>
<span class="sd">                                    to_add_list_sdf_retry = []</span>

<span class="sd">                                    for f_m,f_m_sdf in zip(filtered_meshes,filtered_meshes_sdf):</span>
<span class="sd">                                        curr_side_len_check_retry = side_length_check(f_m,side_length_ratio_threshold)</span>
<span class="sd">                                        curr_volume_check_retry = soma_volume_check(f_m,volume_mulitplier)</span>

<span class="sd">                                        if curr_side_len_check_retry and curr_volume_check_retry:</span>
<span class="sd">                                            to_add_list_retry.append(f_m)</span>
<span class="sd">                                            to_add_list_sdf_retry.append(f_m_sdf)</span>

<span class="sd">                                    if len(to_add_list_retry)&gt;1:</span>
<span class="sd">                                        if verbose:</span>
<span class="sd">                                            print(&quot;Using the new feature that split the soma further into more groups&quot;)</span>
<span class="sd">                                        to_add_list += to_add_list_retry</span>
<span class="sd">                                        to_add_list_sdf += to_add_list_sdf_retry</span>

<span class="sd">                                    else:</span>
<span class="sd">                                        to_add_list.append(soma_mesh)</span>
<span class="sd">                                        to_add_list_sdf.append(sdf)</span>


<span class="sd">                                else:</span>
<span class="sd">                                    to_add_list.append(soma_mesh)</span>
<span class="sd">                                    to_add_list_sdf.append(sdf)</span>
<span class="sd">                                &quot;&quot;&quot;</span>

                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># ---------- 1/7 Addition: Trying one more additional cgal segmentation to see if there is actually a soma ---</span>
<span class="w">                                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                                Pseudocode: </span>
<span class="sd">                                1) Run th esegmentation algorithm again to segment the mesh</span>
<span class="sd">                                2) Filter out meshes by sizs and sdf threshold</span>
<span class="sd">                                3) If there are any remaining meshes, pick the largest sdf mesh and test for volume and side length check</span>
<span class="sd">                                --&gt; if matches then adds</span>
<span class="sd">                                &quot;&quot;&quot;</span>

                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-&gt;Attempting retry of soma because failed first checks: &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;soma_mesh = </span><span class="si">{</span><span class="n">soma_mesh</span><span class="si">}</span><span class="s2">, curr_side_len_check = </span><span class="si">{</span><span class="n">curr_side_len_check</span><span class="si">}</span><span class="s2">, curr_volume_check = </span><span class="si">{</span><span class="n">curr_volume_check</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="c1">#1) Run th esegmentation algorithm again to segment the mesh</span>
                                <span class="n">mesh_extra</span><span class="p">,</span> <span class="n">mesh_extra_sdf</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">smoothness</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="n">mesh_extra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh_extra</span><span class="p">)</span>

                                <span class="c1">#2) Filter out meshes by sizs and sdf threshold</span>
                                <span class="n">mesh_extra_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">kk</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">mesh_extra</span><span class="p">])</span>
                                <span class="n">filtered_meshes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">mesh_extra_lens</span> <span class="o">&gt;=</span> <span class="n">soma_size_threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mesh_extra_lens</span> <span class="o">&lt;=</span> <span class="n">soma_size_threshold_max</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mesh_extra_sdf</span><span class="o">&gt;</span><span class="n">soma_width_threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>


                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_meshes_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">filtered_meshes</span> <span class="o">=</span> <span class="n">mesh_extra</span><span class="p">[</span><span class="n">filtered_meshes_idx</span><span class="p">]</span>
                                    <span class="n">filtered_meshes_sdf</span> <span class="o">=</span> <span class="n">mesh_extra_sdf</span><span class="p">[</span><span class="n">filtered_meshes_idx</span><span class="p">]</span>

                                    <span class="n">sdf_winning_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">filtered_meshes_sdf</span><span class="p">)</span>
                                    <span class="n">soma_mesh_retry</span> <span class="o">=</span> <span class="n">filtered_meshes</span><span class="p">[</span><span class="n">sdf_winning_index</span><span class="p">]</span>
                                    <span class="n">sdf_retry</span> <span class="o">=</span> <span class="n">filtered_meshes_sdf</span><span class="p">[</span><span class="n">sdf_winning_index</span><span class="p">]</span>

                                    <span class="n">curr_side_len_check_retry</span> <span class="o">=</span> <span class="n">side_length_check</span><span class="p">(</span><span class="n">soma_mesh_retry</span><span class="p">,</span><span class="n">side_length_ratio_threshold</span><span class="p">)</span>
                                    <span class="n">curr_volume_check_retry</span> <span class="o">=</span> <span class="n">soma_volume_check</span><span class="p">(</span><span class="n">soma_mesh_retry</span><span class="p">,</span><span class="n">volume_mulitplier</span><span class="p">)</span>

                                    <span class="k">if</span> <span class="n">curr_side_len_check_retry</span> <span class="ow">and</span> <span class="n">curr_volume_check_retry</span><span class="p">:</span>
                                        <span class="n">to_add_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">soma_mesh_retry</span><span class="p">)</span>
                                        <span class="n">to_add_list_sdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sdf_retry</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---&gt;This soma mesh was not added because failed retry of sphere validation:</span><span class="se">\n</span><span class="s2"> &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;soma_mesh = </span><span class="si">{</span><span class="n">soma_mesh_retry</span><span class="si">}</span><span class="s2">, curr_side_len_check = </span><span class="si">{</span><span class="n">curr_side_len_check_retry</span><span class="si">}</span><span class="s2">, curr_volume_check = </span><span class="si">{</span><span class="n">curr_volume_check_retry</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                        <span class="k">continue</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find valid soma mesh in retry&quot;</span><span class="p">)</span>
                                    <span class="k">continue</span>


                        <span class="n">n_failed_inner_soma_loops</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">n_failed_inner_soma_loops</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">total_soma_list_sdf</span> <span class="o">+=</span> <span class="n">to_add_list_sdf</span>
                <span class="n">total_soma_list</span> <span class="o">+=</span> <span class="n">to_add_list</span>

                <span class="c1"># --------------- KEEP TRACK IF FAILED TO FIND SOMA (IF TOO MANY FAILS THEN BREAK)</span>
                <span class="k">if</span> <span class="n">n_failed_inner_soma_loops</span> <span class="o">&gt;=</span> <span class="n">max_fail_loops</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;breaking inner loop because </span><span class="si">{</span><span class="n">max_fail_loops</span><span class="si">}</span><span class="s2"> soma fails in a row&quot;</span><span class="p">)</span>
                    <span class="k">break</span>


            <span class="c1"># --------------- KEEP TRACK IF FAILED TO FIND SOMA (IF TOO MANY FAILS THEN BREAK)</span>
            <span class="k">if</span> <span class="n">somas_found_in_big_loop</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">no_somas_found_in_big_loop</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">no_somas_found_in_big_loop</span> <span class="o">&gt;=</span> <span class="n">max_fail_loops</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;breaking because </span><span class="si">{</span><span class="n">max_fail_loops</span><span class="si">}</span><span class="s2"> fails in a row in big loop&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">no_somas_found_in_big_loop</span> <span class="o">=</span> <span class="mi">0</span>





<span class="w">        </span><span class="sd">&quot;&quot;&quot; IF THERE ARE MULTIPLE SOMAS THAT ARE WITHIN A CERTAIN DISTANCE OF EACH OTHER THEN JUST COMBINE THEM INTO ONE&quot;&quot;&quot;</span>
        <span class="n">pairings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">perform_pairing</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">soma_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">total_soma_list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">z</span><span class="p">,</span><span class="n">soma_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">total_soma_list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">y</span><span class="o">&lt;</span><span class="n">z</span><span class="p">:</span>
                        <span class="n">mesh_tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">soma_1</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                        <span class="n">distances</span><span class="p">,</span><span class="n">closest_node</span> <span class="o">=</span> <span class="n">mesh_tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">soma_2</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4000</span><span class="p">:</span>
                            <span class="n">pairings</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>


        <span class="c1">#creating the combined meshes from the list</span>
        <span class="n">total_soma_list_revised</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">total_soma_list_revised_sdf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            Use a network function to find components</span>

<span class="sd">            &quot;&quot;&quot;</span>


            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
            <span class="n">new_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
            <span class="n">new_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">pairings</span><span class="p">)</span>
            <span class="n">grouped_somas</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">new_graph</span><span class="p">))</span>

            <span class="n">somas_being_combined</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were soma pairings: Connected components in = </span><span class="si">{</span><span class="n">grouped_somas</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">grouped_somas</span><span class="p">:</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
                <span class="n">somas_being_combined</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
                <span class="n">current_mesh</span> <span class="o">=</span> <span class="n">total_soma_list</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)):</span>
                    <span class="n">current_mesh</span> <span class="o">+=</span> <span class="n">total_soma_list</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="c1">#just combining the actual meshes</span>

                <span class="n">total_soma_list_revised</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_mesh</span><span class="p">)</span>
                <span class="c1">#where can average all of the sdf values</span>
                <span class="n">total_soma_list_revised_sdf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">total_soma_list_sdf</span><span class="p">)[</span><span class="n">comp</span><span class="p">]))</span>

            <span class="c1">#add those that weren&#39;t combined to total_soma_list_revised</span>
            <span class="n">leftover_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">total_soma_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">total_soma_list</span><span class="p">))</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">somas_being_combined</span><span class="p">]</span>
            <span class="n">leftover_somas_sdfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">total_soma_list_sdf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">total_soma_list</span><span class="p">))</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">somas_being_combined</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover_somas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">total_soma_list_revised</span> <span class="o">+=</span> <span class="n">leftover_somas</span>
                <span class="n">total_soma_list_revised_sdf</span> <span class="o">+=</span> <span class="n">leftover_somas_sdfs</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final total_soma_list_revised = </span><span class="si">{</span><span class="n">total_soma_list_revised</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final total_soma_list_revised_sdf = </span><span class="si">{</span><span class="n">total_soma_list_revised_sdf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_soma_list_revised</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">total_soma_list_revised</span> <span class="o">=</span> <span class="n">total_soma_list</span>
            <span class="n">total_soma_list_revised_sdf</span> <span class="o">=</span> <span class="n">total_soma_list_sdf</span>

        <span class="n">run_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">global_start_time</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2"> Total time for run = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">global_start_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before Filtering the number of somas found = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_soma_list_revised</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_mesh_intermediates</span><span class="p">:</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">total_soma_list_revised</span><span class="p">,</span><span class="s2">&quot;total_soma_list_revised_1&quot;</span><span class="p">)</span>

        <span class="c1">#     from python_tools import system_utils as su</span>
        <span class="c1">#     su.compressed_pickle(total_soma_list_revised,&quot;total_soma_list_revised&quot;)</span>
        <span class="c1">#     su.compressed_pickle(new_mesh,&quot;original_mesh&quot;)</span>

        <span class="c1">#need to erase all of the temporary files ******</span>
        <span class="c1">#import shutil</span>
        <span class="c1">#shutil.rmtree(directory)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Running the extra tests that depend on</span>
<span class="sd">        - border vertices</span>
<span class="sd">        - how well the poisson matches the backtracked soma to the real mesh</span>
<span class="sd">        - other size checks</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_soma_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">filtered_soma_list_sdf</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">yy</span><span class="p">,(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">curr_soma_sdf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">total_soma_list_revised</span><span class="p">,</span><span class="n">total_soma_list_revised_sdf</span><span class="p">)):</span>
            <span class="n">add_inside_pieces_flag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">backtrack_soma_mesh_to_original</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">---Performing Soma Mesh Backtracking to original mesh for poisson soma </span><span class="si">{</span><span class="n">yy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">soma_mesh_poisson</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">)</span>
                    <span class="c1">#print(&quot;About to find original mesh&quot;)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;backtrack_soma_size_threshold = </span><span class="si">{</span><span class="n">backtrack_soma_size_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">soma_mesh_list</span><span class="p">,</span><span class="n">soma_mesh_inside_pieces</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">original_mesh_soma</span><span class="p">(</span>
                                                    <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">recov_orig_mesh_no_interior</span><span class="p">,</span>
                                                    <span class="n">mesh</span><span class="o">=</span><span class="n">soma_mesh_poisson</span><span class="p">,</span>
                                                    <span class="n">soma_size_threshold</span><span class="o">=</span><span class="n">backtrack_soma_size_threshold</span><span class="p">,</span>
                                                    <span class="n">match_distance_threshold</span><span class="o">=</span><span class="n">backtrack_match_distance_threshold</span><span class="p">,</span>
                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>

                <span class="k">except</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">traceback</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---&gt;This soma mesh was not added because Was not able to backtrack soma to mesh&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">soma_mesh_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---&gt;This soma mesh was not added because Was not able to backtrack soma to mesh&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>



                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After backtrack the found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> possible somas: </span><span class="si">{</span><span class="n">soma_mesh_list</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">rr</span><span class="p">,</span><span class="n">soma_mesh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soma_mesh_list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- working on backtrack soma </span><span class="si">{</span><span class="n">rr</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">soma_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;poisson_backtrack_distance_threshold = </span><span class="si">{</span><span class="n">poisson_backtrack_distance_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="c1">#do the check that tests if there is a max distance between poisson and backtrack:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">poisson_backtrack_distance_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">poisson_backtrack_distance_threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                        <span class="c1">#soma_mesh.export(&quot;soma_mesh.off&quot;)</span>
                        <span class="k">if</span> <span class="n">close_holes</span><span class="p">:</span> 
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using the close holes feature&quot;</span><span class="p">)</span>
                            <span class="n">fill_hole_obj</span> <span class="o">=</span> <span class="n">meshlab</span><span class="o">.</span><span class="n">FillHoles</span><span class="p">(</span><span class="n">max_hole_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                                             <span class="n">self_itersect_faces</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                            <span class="n">soma_mesh_filled_holes</span><span class="p">,</span><span class="n">output_subprocess_obj</span> <span class="o">=</span> <span class="n">fill_hole_obj</span><span class="p">(</span>   
                                                                <span class="n">vertices</span><span class="o">=</span><span class="n">soma_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                                                 <span class="n">faces</span><span class="o">=</span><span class="n">soma_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                                                                 <span class="n">return_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">delete_temp_files</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">soma_mesh_filled_holes</span> <span class="o">=</span> <span class="n">soma_mesh</span>


                        <span class="c1">#soma_mesh_filled_holes.export(&quot;soma_mesh_filled_holes.off&quot;)</span>



                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;APPLYING poisson_backtrack_distance_threshold CHECKS&quot;</span><span class="p">)</span>
                        <span class="n">mesh_1</span> <span class="o">=</span> <span class="n">soma_mesh_filled_holes</span>
                        <span class="n">mesh_2</span> <span class="o">=</span> <span class="n">soma_mesh_poisson</span>

                        <span class="n">poisson_max_distance</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">max_distance_betwee_mesh_vertices</span><span class="p">(</span><span class="n">mesh_1</span><span class="p">,</span><span class="n">mesh_2</span><span class="p">,</span>
                                                                          <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;poisson_max_distance = </span><span class="si">{</span><span class="n">poisson_max_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">poisson_max_distance</span> <span class="o">&gt;</span> <span class="n">poisson_backtrack_distance_threshold</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---&gt;This soma mesh was not added because it did not pass the poisson_backtrack_distance check:</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot; poisson_max_distance = </span><span class="si">{</span><span class="n">poisson_max_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">continue</span>


                    <span class="c1">#do the boundary check:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">boundary_vertices_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;USING boundary_vertices_threshold CHECK&quot;</span><span class="p">)</span>
                        <span class="n">soma_boundary_groups_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_border_face_groups</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">)])</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;soma_boundary_groups_sizes = </span><span class="si">{</span><span class="n">soma_boundary_groups_sizes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">large_boundary_groups</span> <span class="o">=</span> <span class="n">soma_boundary_groups_sizes</span><span class="p">[</span><span class="n">soma_boundary_groups_sizes</span><span class="o">&gt;</span><span class="n">boundary_vertices_threshold</span><span class="p">]</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;large_boundary_groups = </span><span class="si">{</span><span class="n">large_boundary_groups</span><span class="si">}</span><span class="s2"> with boundary_vertices_threshold = </span><span class="si">{</span><span class="n">boundary_vertices_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">large_boundary_groups</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---&gt;This soma mesh was not added because it did not pass the boundary vertices validation:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot; large_boundary_groups = </span><span class="si">{</span><span class="n">large_boundary_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">continue</span>

                    <span class="n">curr_side_len_check</span> <span class="o">=</span> <span class="n">side_length_check</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">side_length_ratio_threshold</span><span class="p">)</span>
                    <span class="n">curr_volume_check</span> <span class="o">=</span> <span class="n">soma_volume_check</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">volume_mulitplier</span><span class="p">)</span>


                    <span class="c1"># -------- 1/12 Addition: Does a second round of segmentation after to see if can split somas at all ---- #</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">curr_side_len_check</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">curr_volume_check</span><span class="p">):</span>

                        <span class="k">if</span> <span class="n">backtrack_segmentation_on_fail</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Trying backtrack segmentation&quot;</span><span class="p">)</span>
                            <span class="n">mesh_tests</span><span class="p">,</span><span class="n">mesh_tests_sdf</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">,</span><span class="n">clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">smoothness</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

                            <span class="n">soma_mesh_filtered</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="n">soma_mesh_sdf_filtered</span> <span class="o">=</span> <span class="p">[]</span>

                            <span class="k">for</span> <span class="n">m_test</span><span class="p">,</span><span class="n">m_test_sdf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mesh_tests</span><span class="p">,</span><span class="n">mesh_tests_sdf</span><span class="p">):</span>

                                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_test</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">backtrack_soma_size_threshold</span> <span class="ow">and</span> <span class="n">m_test_sdf</span> <span class="o">&gt;=</span><span class="n">soma_width_threshold</span><span class="p">:</span>

                                    <span class="k">if</span> <span class="n">side_length_check</span><span class="p">(</span><span class="n">m_test</span><span class="p">,</span><span class="n">side_length_ratio_threshold</span><span class="p">)</span> <span class="ow">and</span> <span class="n">soma_volume_check</span><span class="p">(</span><span class="n">m_test</span><span class="p">,</span><span class="n">volume_mulitplier</span><span class="p">):</span>

                                        <span class="n">soma_mesh_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_test</span><span class="p">)</span>
                                        <span class="n">soma_mesh_sdf_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_test_sdf</span><span class="p">)</span>

                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_filtered</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---&gt;This soma mesh was not added because it did not pass the sphere validation EVEN AFTER SEGMENTATION:</span><span class="se">\n</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;soma_mesh = </span><span class="si">{</span><span class="n">soma_mesh</span><span class="si">}</span><span class="s2">, curr_side_len_check = </span><span class="si">{</span><span class="n">curr_side_len_check</span><span class="si">}</span><span class="s2">, curr_volume_check = </span><span class="si">{</span><span class="n">curr_volume_check</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                <span class="k">continue</span>


                        <span class="k">else</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---&gt;This soma mesh was not added because it did not pass the sphere validation:</span><span class="se">\n</span><span class="s2"> &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;soma_mesh = </span><span class="si">{</span><span class="n">soma_mesh</span><span class="si">}</span><span class="s2">, curr_side_len_check = </span><span class="si">{</span><span class="n">curr_side_len_check</span><span class="si">}</span><span class="s2">, curr_volume_check = </span><span class="si">{</span><span class="n">curr_volume_check</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>


                        <span class="n">soma_mesh_filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_mesh</span><span class="p">]</span>
                        <span class="n">soma_mesh_sdf_filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_soma_sdf</span><span class="p">]</span>



                    <span class="c1">#tu.write_neuron_off(soma_mesh_poisson,&quot;original_poisson.off&quot;)</span>
                    <span class="c1">#If made it through all the checks then add to final list</span>
                    <span class="n">filtered_soma_list</span> <span class="o">+=</span> <span class="n">soma_mesh_filtered</span>
                    <span class="n">filtered_soma_list_sdf</span> <span class="o">+=</span> <span class="n">soma_mesh_sdf_filtered</span>
                    <span class="n">add_inside_pieces_flag</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1">#setting flag so will add inside pieces</span>


            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh_inside_pieces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">add_inside_pieces_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;About to add the following inside nuclei pieces after soma backtrack: </span><span class="si">{</span><span class="n">nuclei_pieces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">nuclei_pieces</span> <span class="o">+=</span><span class="n">soma_mesh_inside_pieces</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Need to delete all files in the temp folder *****</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ----------- 11 /11 Addition that does a last step segmentation of the soma --------- #</span>
        <span class="c1">#return total_soma_list, run_time</span>
        <span class="c1">#return total_soma_list_revised,run_time,total_soma_list_revised_sdf</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Things we should ask about the segmentation:</span>

<span class="sd">        Advantages: </span>
<span class="sd">        1) could help filter away negatives</span>

<span class="sd">        Disadvantages:</span>
<span class="sd">        1) Can actually cut up the soma and then filter away the soma (not what we want)</span>
<span class="sd">        2) Could introduce a big hole (don&#39;t think can guard against this)</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1">#filtered_soma_list_saved = copy.deepcopy(filtered_soma_list)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_soma_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">filtered_soma_list_revised</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filtered_soma_list_sdf_revised</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f_soma</span><span class="p">,</span><span class="n">f_soma_sdf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filtered_soma_list</span><span class="p">,</span><span class="n">filtered_soma_list_sdf</span><span class="p">):</span>

                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping the segmentatio filter at end&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_soma</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">last_size_threshold</span> <span class="ow">and</span> <span class="n">f_soma_sdf</span> <span class="o">&gt;=</span> <span class="n">soma_width_threshold</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma (size = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">f_soma</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">, width=</span><span class="si">{</span><span class="n">soma_width_threshold</span><span class="si">}</span><span class="s2">) did not pass thresholds (size threshold=</span><span class="si">{</span><span class="n">last_size_threshold</span><span class="si">}</span><span class="s2">, width threshold = </span><span class="si">{</span><span class="n">soma_width_threshold</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">)</span>
                    <span class="k">continue</span>


                <span class="k">if</span> <span class="n">segmentation_at_end</span><span class="p">:</span>


                    <span class="k">if</span> <span class="n">remove_inside_pieces</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;removing mesh interior before segmentation&quot;</span><span class="p">)</span>
                        <span class="n">f_soma</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">f_soma</span><span class="p">,</span><span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="n">size_threshold_to_remove</span><span class="p">)</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Doing the soma segmentation filter at end&quot;</span><span class="p">)</span>

                    <span class="n">meshes_split</span><span class="p">,</span><span class="n">meshes_split_sdf</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_segmentation</span><span class="p">(</span>
                        <span class="n">mesh</span> <span class="o">=</span> <span class="n">f_soma</span><span class="p">,</span>
                        <span class="n">smoothness</span><span class="o">=</span><span class="mf">0.5</span>
                    <span class="p">)</span>
        <span class="c1">#                 print(f&quot;meshes_split = {meshes_split}&quot;)</span>
        <span class="c1">#                 print(f&quot;meshes_split_sdf = {meshes_split_sdf}&quot;)</span>

                    <span class="c1">#applying the soma width and the soma size threshold</span>
                    <span class="n">above_width_threshold_mask</span> <span class="o">=</span> <span class="n">meshes_split_sdf</span><span class="o">&gt;=</span><span class="n">soma_width_threshold</span>
                    <span class="n">meshes_split_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meshes_split</span><span class="p">])</span>
                    <span class="n">above_size_threshold_mask</span> <span class="o">=</span> <span class="n">meshes_split_sizes</span> <span class="o">&gt;=</span> <span class="n">last_size_threshold</span>

                    <span class="n">above_width_threshold_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">above_width_threshold_mask</span> <span class="o">&amp;</span> <span class="n">above_size_threshold_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">above_width_threshold_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No split meshes were above the width threshold (</span><span class="si">{</span><span class="n">soma_width_threshold</span><span class="si">}</span><span class="s2">) and size threshold (</span><span class="si">{</span><span class="n">last_size_threshold</span><span class="si">}</span><span class="s2">) so continuing&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;So just going with old somas&quot;</span><span class="p">)</span>

                        <span class="n">f_soma_final</span> <span class="o">=</span> <span class="n">f_soma</span>
                        <span class="n">f_soma_sdf_final</span> <span class="o">=</span> <span class="n">f_soma_sdf</span>


                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">meshes_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meshes_split</span><span class="p">)</span>
                        <span class="n">meshes_split_sdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meshes_split_sdf</span><span class="p">)</span>

                        <span class="n">meshes_split_filtered</span> <span class="o">=</span> <span class="n">meshes_split</span><span class="p">[</span><span class="n">above_width_threshold_idx</span><span class="p">]</span>
                        <span class="n">meshes_split_sdf_filtered</span> <span class="o">=</span> <span class="n">meshes_split_sdf</span><span class="p">[</span><span class="n">above_width_threshold_idx</span><span class="p">]</span>

                        <span class="n">soma_width_threshold</span>
                        <span class="c1">#way to choose the index of the top candidate</span>
                        <span class="n">top_candidate</span> <span class="o">=</span> <span class="mi">0</span>


                        <span class="n">largest_hole_before_seg</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">largest_hole_length</span><span class="p">(</span><span class="n">f_soma</span><span class="p">)</span>
                        <span class="n">largest_hole_after_seg</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">largest_hole_length</span><span class="p">(</span><span class="n">meshes_split_filtered</span><span class="p">[</span><span class="n">top_candidate</span><span class="p">])</span>

                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Largest hole before segmentation = </span><span class="si">{</span><span class="n">largest_hole_before_seg</span><span class="si">}</span><span class="s2">, after = </span><span class="si">{</span><span class="n">largest_hole_after_seg</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">largest_hole_before_seg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                              <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ratio = </span><span class="si">{</span><span class="n">largest_hole_after_seg</span><span class="o">/</span><span class="n">largest_hole_before_seg</span><span class="si">}</span><span class="s2">, difference = </span><span class="si">{</span><span class="n">largest_hole_after_seg</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">largest_hole_before_seg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">largest_hole_after_seg</span> <span class="o">&lt;</span> <span class="n">largest_hole_threshold</span><span class="p">:</span>
                            <span class="n">f_soma_final</span> <span class="o">=</span> <span class="n">meshes_split_filtered</span><span class="p">[</span><span class="n">top_candidate</span><span class="p">]</span>
                            <span class="n">f_soma_sdf_final</span> <span class="o">=</span> <span class="n">meshes_split_sdf_filtered</span><span class="p">[</span><span class="n">top_candidate</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">f_soma_final</span> <span class="o">=</span> <span class="n">f_soma</span>
                            <span class="n">f_soma_sdf_final</span> <span class="o">=</span> <span class="n">f_soma_sdf</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_soma_final</span> <span class="o">=</span> <span class="n">f_soma</span>
                    <span class="n">f_soma_sdf_final</span> <span class="o">=</span> <span class="n">f_soma_sdf</span>


                <span class="n">filtered_soma_list_revised</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_soma_final</span><span class="p">)</span>
                <span class="n">filtered_soma_list_sdf_revised</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_soma_sdf_final</span><span class="p">)</span>




            <span class="n">filtered_soma_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_soma_list_revised</span><span class="p">)</span>
            <span class="n">filtered_soma_list_sdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_soma_list_sdf_revised</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            # ----------- 1/7/21 ---------------#</span>
<span class="sd">            Now was to stitch the somas together if they are touching</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_soma_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">connected_meshes_components</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_connectivity</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">filtered_soma_list</span><span class="p">,</span>
                                         <span class="n">main_mesh</span><span class="o">=</span><span class="n">recov_orig_mesh_no_interior</span><span class="p">,</span>
                                                            <span class="n">return_connected_components</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">filtered_soma_list</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">connected_meshes_components</span><span class="p">])</span>
                <span class="n">filtered_soma_list_sdf_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">filtered_soma_list_sdf</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">connected_meshes_components</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_soma_list</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="n">filtered_soma_list</span>
                <span class="n">filtered_soma_list_sdf_components</span> <span class="o">=</span> <span class="n">filtered_soma_list_sdf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">filtered_soma_list_sdf_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filtered_soma_list_sdf_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>



        <span class="c1">#----------- 1/9 Addition: Final Size Threshold ------------- #</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtered_soma_list_components = </span><span class="si">{</span><span class="n">filtered_soma_list_components</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_mesh_intermediates</span><span class="p">:</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">,</span><span class="s2">&quot;filtered_soma_list_components&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">backtrack_soma_mesh_to_original</span><span class="p">:</span>

            <span class="n">filtered_soma_list_components_new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">filtered_soma_list_sdf_components_new</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">soma_mesh</span><span class="p">,</span> <span class="n">soma_mesh_sdf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">,</span><span class="n">filtered_soma_list_sdf_components</span><span class="p">):</span>
                <span class="c1"># --------- 1/9: Extra Size Threshold For Somas ------------- #</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">backtrack_soma_size_threshold</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;---&gt;This soma mesh with size </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2"> was not bigger than the threshold </span><span class="si">{</span><span class="n">backtrack_soma_size_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">filtered_soma_list_components_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">soma_mesh</span><span class="p">)</span>
                    <span class="n">filtered_soma_list_sdf_components_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">soma_mesh_sdf</span><span class="p">)</span>

            <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="n">filtered_soma_list_components_new</span>
            <span class="n">filtered_soma_list_sdf_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered_soma_list_sdf_components_new</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filter_inside_somas</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_away_inside_meshes</span><span class="p">(</span><span class="n">mesh_list</span> <span class="o">=</span> <span class="n">filtered_soma_list_components</span><span class="p">,</span>
                                            <span class="n">distance_type</span><span class="o">=</span><span class="s2">&quot;shortest_vertex_distance&quot;</span><span class="p">,</span>
                                            <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                                            <span class="n">inside_percentage_threshold</span> <span class="o">=</span> <span class="mf">0.20</span><span class="p">,</span>
                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="n">return_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                            <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keep_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">))</span>

            <span class="n">filtered_soma_list_components</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_indices</span><span class="p">]</span>
            <span class="n">filtered_soma_list_sdf_components</span> <span class="o">=</span> <span class="n">filtered_soma_list_sdf_components</span><span class="p">[</span><span class="n">keep_indices</span><span class="p">]</span>

    

    
    <span class="k">if</span> <span class="n">return_glia_nuclei_pieces</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">),</span><span class="n">run_time</span><span class="p">,</span><span class="n">filtered_soma_list_sdf_components</span><span class="p">,</span><span class="n">glia_pieces</span><span class="p">,</span> <span class="n">nuclei_pieces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">filtered_soma_list_components</span><span class="p">),</span><span class="n">run_time</span><span class="p">,</span><span class="n">filtered_soma_list_sdf_components</span></div>
    
    
<div class="viewcode-block" id="remove_nuclei_and_glia_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.remove_nuclei_and_glia_meshes">[docs]</a><span class="k">def</span> <span class="nf">remove_nuclei_and_glia_meshes</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">glia_volume_threshold_in_um</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#the volume of a large soma mesh is 800 billion</span>
    <span class="n">glia_n_faces_threshold</span> <span class="o">=</span> <span class="mi">400000</span><span class="p">,</span>
    <span class="n">glia_n_faces_min</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span>
    <span class="n">nucleus_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nucleus_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">connectivity</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
    <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_glia_nucleus_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will remove interior faces of a mesh with a certain significant size</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Run the mesh interior</span>
<span class="sd">    2) Divide all of the interior meshes into glia (those above the threshold) and nuclei (those below)</span>
<span class="sd">    For Glia:</span>
<span class="sd">    3) Do all of the removal process and get resulting neuron</span>
<span class="sd">    </span>
<span class="sd">    For nuclei:</span>
<span class="sd">    4) Do removal process from mesh that already has glia removed (use subtraction with exact_match = False )</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ------- Nuclei Parameters ---------</span>
    <span class="k">if</span> <span class="n">nucleus_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nucleus_min</span> <span class="o">=</span> <span class="n">nucleus_min_global</span>
    
    <span class="k">if</span> <span class="n">nucleus_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nucleus_max</span> <span class="o">=</span> <span class="n">nucleus_max_global</span>
        
    <span class="c1"># --------- Glia Parameters ----------</span>
    <span class="k">if</span> <span class="n">glia_volume_threshold_in_um</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">glia_volume_threshold_in_um</span><span class="o">=</span> <span class="n">glia_volume_threshold_in_um_global</span>
    
    
    <span class="n">glia_volume_threshold</span> <span class="o">=</span> <span class="n">glia_volume_threshold_in_um</span><span class="o">*</span><span class="mi">1000000000</span>
    
    <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">original_mesh_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
    
    <span class="c1">#1) Run the mesh interior</span>
    <span class="n">curr_interior_mesh_non_split</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_interior</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">return_interior</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">curr_interior_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_significant_pieces</span><span class="p">(</span><span class="n">curr_interior_mesh_non_split</span><span class="p">,</span><span class="n">significance_threshold</span><span class="o">=</span><span class="n">nucleus_min</span><span class="p">,</span>
                                            <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>
    
    <span class="c1">#su.compressed_pickle(curr_interior_mesh,&quot;curr_interior_mesh&quot;)</span>
    
    <span class="n">curr_interior_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">curr_interior_mesh</span><span class="p">)</span>
    <span class="n">curr_interior_mesh_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_interior_mesh</span><span class="p">])</span>
    
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There were </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_interior_mesh</span><span class="p">)</span><span class="si">}</span><span class="s2"> total interior meshes&quot;</span><span class="p">)</span>
    
    <span class="c1">#2) Divide all of the interior meshes into glia (those above the threshold) and nuclei (those below)</span>
    <span class="k">if</span> <span class="n">glia_volume_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nucleus_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nucleus_max</span> <span class="o">=</span> <span class="n">glia_n_faces_threshold</span>
        
        

        <span class="n">nucleus_pieces</span> <span class="o">=</span> <span class="n">curr_interior_mesh</span><span class="p">[(</span><span class="n">curr_interior_mesh_len</span> <span class="o">&gt;=</span> <span class="n">nucleus_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">curr_interior_mesh_len</span><span class="o">&lt;</span> <span class="n">nucleus_max</span><span class="p">)]</span>
        <span class="n">glia_pieces</span> <span class="o">=</span> <span class="n">curr_interior_mesh</span><span class="p">[</span> <span class="p">(</span><span class="n">curr_interior_mesh_len</span> <span class="o">&gt;=</span> <span class="n">glia_n_faces_threshold</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pieces satisfying glia requirements (n_faces) (x &gt;= </span><span class="si">{</span><span class="n">glia_n_faces_threshold</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pieces satisfying nuclie requirements (n_faces) (</span><span class="si">{</span><span class="n">nucleus_min</span><span class="si">}</span><span class="s2"> &lt;= x &lt; </span><span class="si">{</span><span class="n">nucleus_max</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nucleus_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Psuedocode:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curr_interior_mesh_volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">volume</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_interior_mesh</span><span class="p">])</span>
        
        <span class="n">glia_pieces</span> <span class="o">=</span> <span class="n">curr_interior_mesh</span><span class="p">[</span> <span class="p">(</span><span class="n">curr_interior_mesh_volume</span> <span class="o">&gt;=</span> <span class="n">glia_volume_threshold</span><span class="p">)</span> <span class="o">&amp;</span>
                                           <span class="p">(</span><span class="n">curr_interior_mesh_len</span> <span class="o">&gt;=</span> <span class="n">glia_n_faces_min</span><span class="p">)]</span>
        <span class="n">nucleus_pieces</span> <span class="o">=</span> <span class="n">curr_interior_mesh</span><span class="p">[(</span><span class="n">curr_interior_mesh_len</span> <span class="o">&gt;=</span> <span class="n">nucleus_min</span><span class="p">)</span> <span class="o">&amp;</span> 
                                            <span class="p">(</span><span class="n">curr_interior_mesh_volume</span> <span class="o">&lt;</span> <span class="n">glia_volume_threshold</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pieces satisfying glia requirements (volume) (x &gt;= </span><span class="si">{</span><span class="n">glia_volume_threshold</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pieces satisfying nuclie requirements: n_faces (</span><span class="si">{</span><span class="n">nucleus_min</span><span class="si">}</span><span class="s2"> &lt;= x)&quot;</span>
                  <span class="sa">f</span><span class="s2">&quot; and volume (x &lt; </span><span class="si">{</span><span class="n">glia_volume_threshold</span><span class="si">}</span><span class="s2">) : </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nucleus_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="c1">#3) Do the Glia removal process</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mesh_removed_glia</span><span class="p">,</span><span class="n">glia_submesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">find_large_dense_submesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                                                        <span class="n">glia_pieces</span><span class="o">=</span><span class="n">glia_pieces</span><span class="p">,</span>
                                                                        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                                                                            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">glia_submesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">glia_submesh</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glia_submesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">glia_submesh</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mesh_removed_glia</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="n">glia_submesh</span> <span class="o">=</span> <span class="p">[]</span>
        
    
    <span class="c1">#4) Do the Nucleus removal process</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nucleus_pieces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">main_mesh_total</span><span class="p">,</span><span class="n">inside_nucleus_pieces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">remove_mesh_interior</span><span class="p">(</span><span class="n">mesh_removed_glia</span><span class="p">,</span>
                                                                        <span class="n">inside_pieces</span><span class="o">=</span><span class="n">nucleus_pieces</span><span class="p">,</span>
                                                                        <span class="n">return_removed_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                        <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                                                                        <span class="n">size_threshold_to_remove</span> <span class="o">=</span> <span class="n">nucleus_min</span><span class="p">,</span>
                                                                   <span class="n">try_hole_close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                                        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">main_mesh_total</span> <span class="o">=</span> <span class="n">mesh_removed_glia</span>
        <span class="n">inside_nucleus_pieces</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Original Mesh size: </span><span class="si">{</span><span class="n">original_mesh_size</span><span class="si">}</span><span class="s2">, Final mesh size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">main_mesh_total</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_glia_nucleus_pieces</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">main_mesh_total</span><span class="p">,</span><span class="n">glia_submesh</span><span class="p">,</span><span class="n">inside_nucleus_pieces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">main_mesh_total</span></div>
    
    
<div class="viewcode-block" id="glia_nuclei_faces_from_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.glia_nuclei_faces_from_mesh">[docs]</a><span class="k">def</span> <span class="nf">glia_nuclei_faces_from_mesh</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">glia_meshes</span><span class="p">,</span>
    <span class="n">nuclei_meshes</span><span class="p">,</span>
    <span class="n">return_n_faces</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To map the glia and nuclei</span>
<span class="sd">    meshes to the </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_meshes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">glia_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">glia_meshes</span><span class="p">))</span>
        <span class="n">n_glia_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">glia_faces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">glia_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_glia_faces</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_meshes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">original_mesh_faces_map</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">nuclei_meshes</span><span class="p">))</span>
        <span class="n">n_nuclei_faces</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nuclei_faces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nuclei_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_nuclei_faces</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_glia_faces = </span><span class="si">{</span><span class="n">n_glia_faces</span><span class="si">}</span><span class="s2">, n_nuclei_faces = </span><span class="si">{</span><span class="n">n_nuclei_faces</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_n_faces</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">glia_faces</span><span class="p">,</span><span class="n">nuclei_faces</span><span class="p">,</span><span class="n">n_glia_faces</span><span class="p">,</span><span class="n">n_nuclei_faces</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">glia_faces</span><span class="p">,</span><span class="n">nuclei_faces</span></div>
    
<div class="viewcode-block" id="plot_soma_products"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.plot_soma_products">[docs]</a><span class="k">def</span> <span class="nf">plot_soma_products</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">soma_products</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_soma_extraction_meshes</span><span class="p">(</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">,</span>
            <span class="n">soma_meshes</span> <span class="o">=</span> <span class="n">soma_products</span><span class="o">.</span><span class="n">soma_meshes</span><span class="p">,</span>
            <span class="n">glia_meshes</span> <span class="o">=</span> <span class="n">soma_products</span><span class="o">.</span><span class="n">glia_meshes</span><span class="p">,</span>
            <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="n">soma_products</span><span class="o">.</span><span class="n">nuclei_meshes</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="soma_indentification"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.soma_indentification">[docs]</a><span class="k">def</span> <span class="nf">soma_indentification</span><span class="p">(</span>
    <span class="n">mesh_decimated</span><span class="p">,</span>
    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">soma_extraction_parameters</span>
    <span class="p">):</span>

    <span class="p">(</span><span class="n">total_soma_list</span><span class="p">,</span> 
     <span class="n">run_time</span><span class="p">,</span> 
     <span class="n">total_soma_list_sdf</span><span class="p">,</span>
     <span class="n">glia_pieces</span><span class="p">,</span>
     <span class="n">nuclei_pieces</span><span class="p">)</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">extract_soma_center</span><span class="p">(</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_decimated</span><span class="p">,</span>
        <span class="n">return_glia_nuclei_pieces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="o">**</span><span class="n">soma_extraction_parameters</span>
    <span class="p">)</span>

    <span class="n">soma_products</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">StageProducts</span><span class="p">(</span>
        <span class="n">soma_extraction_parameters</span> <span class="o">=</span> <span class="n">soma_extraction_parameters</span><span class="p">,</span>
        <span class="n">soma_meshes</span><span class="o">=</span><span class="n">total_soma_list</span><span class="p">,</span>
        <span class="n">soma_run_time</span><span class="o">=</span><span class="n">run_time</span><span class="p">,</span> 
        <span class="n">soma_sdfs</span><span class="o">=</span><span class="n">total_soma_list_sdf</span><span class="p">,</span>
        <span class="n">glia_meshes</span><span class="o">=</span><span class="n">glia_pieces</span><span class="p">,</span>
        <span class="n">nuclei_meshes</span><span class="o">=</span><span class="n">nuclei_pieces</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_soma_products</span><span class="p">(</span>
            <span class="n">mesh_decimated</span><span class="p">,</span>
            <span class="n">soma_products</span> <span class="o">=</span> <span class="n">soma_products</span><span class="p">,</span>
        <span class="p">)</span>


    <span class="k">return</span> <span class="n">soma_products</span></div>
    
    
<span class="c1"># ------------------------- Parameters ---------------------</span>
<span class="c1"># ------------- Setting up parameters -----------</span>

<span class="c1"># -- default</span>
<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="p">)</span>    



<span class="n">global_parameters_dict_default_nuclei</span> <span class="o">=</span> <span class="n">dsu</span><span class="o">.</span><span class="n">DictType</span><span class="p">(</span>
    <span class="n">nucleus_min</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span> <span class="c1">#minimum number of faces for nuclei mesh peices</span>
    <span class="n">nucleus_max</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;int unsigned&quot;</span><span class="p">),</span> <span class="c1">#maximum number of faces for nuclie mesh pieces if glia volume is not defined</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default_glia</span> <span class="o">=</span> <span class="n">dsu</span><span class="o">.</span><span class="n">DictType</span><span class="p">(</span>
    <span class="n">glia_volume_threshold_in_um</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">,</span> <span class="c1">#minimum volume of glia mesh</span>
    <span class="n">glia_n_faces_threshold</span> <span class="o">=</span> <span class="mi">400_000</span><span class="p">,</span> <span class="c1">#minimum number of faes for glia mesh if volume is not defined</span>
    <span class="n">glia_n_faces_min</span> <span class="o">=</span> <span class="mi">100_000</span><span class="p">,</span> <span class="c1">#minimum number of faes for glia mesh if glia volume defined</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default_soma</span>  <span class="o">=</span> <span class="n">dsu</span><span class="o">.</span><span class="n">DictType</span><span class="p">(</span>
    <span class="n">outer_decimation_ratio</span><span class="o">=</span><span class="mf">0.25</span> <span class="p">,</span> <span class="c1">#decimation ratio for 1st round of decimation</span>
    <span class="n">large_mesh_threshold</span> <span class="o">=</span> <span class="mi">20_000</span><span class="p">,</span> <span class="c1">#minimum face count threshold after 1st round of decimation</span>
    <span class="n">large_mesh_threshold_inner</span> <span class="o">=</span> <span class="mi">13_000</span><span class="p">,</span> <span class="c1">#minimum face count threshold after poisson reconstruction and split</span>
    <span class="n">inner_decimation_ratio</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span> <span class="c1">#decimation ratio for 2nd round of decimation after poisson reconstruction</span>
    <span class="n">max_fail_loops</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="c1">#number of times soma finding can fail in finding an invalid soma in the outer/inner decimation loop</span>

    <span class="c1"># other cleaning methods to run on segments after first decimation</span>
    <span class="n">remove_inside_pieces</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="c1">#whether to remove inside pieces before processing</span>
    <span class="n">size_threshold_to_remove</span><span class="o">=</span><span class="mi">1_000</span><span class="p">,</span> <span class="c1">#minium number of faces of mesh piece to remove</span>
    <span class="n">pymeshfix_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">check_holes_before_pymeshfix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">second_poisson</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>

    <span class="c1">#after 2nd round of decimation and mesh segmentation is applied</span>
    <span class="n">soma_width_threshold</span> <span class="o">=</span> <span class="mf">0.32</span><span class="p">,</span> <span class="c1"># minimuum sdf values of mesh segments</span>
    <span class="n">soma_size_threshold</span> <span class="o">=</span> <span class="mi">9_000</span><span class="p">,</span> <span class="c1"># minimum face count threshold of mesh segments</span>
    <span class="n">soma_size_threshold_max</span><span class="o">=</span><span class="mi">1_200_000</span><span class="p">,</span><span class="c1"># maximum face count threshold of mesh segments</span>

    <span class="c1">#parameters for checking possible viable somas after mesh segmentation</span>
    <span class="n">volume_mulitplier</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="c1">#for soma_volume_check funcion that makes sure not highly skewed bounding box volume to mesh volume </span>
    <span class="n">side_length_ratio_threshold</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="c1">#for side_length_check function making sure not highly swkewed x,y,z side length ratios</span>

    <span class="c1">#whether to group certain poisson representations of somas together before backtrack to mesh</span>
    <span class="n">perform_pairing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>


    <span class="n">backtrack_soma_mesh_to_original</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#will backtrack the poisson reconstruction soma to the original mesh</span>
    <span class="n">backtrack_soma_size_threshold</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span> <span class="c1">#minimum number of faces for a backtracked mesh</span>


    <span class="c1">#for filtering away somas once get backtracked to original mesh with certain filters</span>
    <span class="n">poisson_backtrack_distance_threshold</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;int unsigned&quot;</span><span class="p">),</span> <span class="c1">#maximum distance between poisson reconstruction and backtracked soma</span>
    <span class="n">close_holes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1">#whether to close holes when doing poisson backtrack</span>

    <span class="n">boundary_vertices_threshold</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;int unsigned&quot;</span><span class="p">),</span> <span class="c1">#filter away somas if too many boundary vertices</span>


    <span class="c1">#filters at the very end for meshes that made it thorugh</span>
    <span class="n">last_size_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span> <span class="c1">#min faces count</span>

    <span class="n">segmentation_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#whether to attempt to split meshes at end</span>
    <span class="n">largest_hole_threshold</span> <span class="o">=</span> <span class="mi">17000</span><span class="p">,</span> <span class="c1">#maximum hole length for a soma to allow the segmentaiton split at end</span>

    <span class="n">second_pass_size_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;int unsigned&quot;</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_default_nuclei</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_glia</span><span class="p">,</span>
    <span class="n">global_parameters_dict_default_soma</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># -- microns--</span>
<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1">#-- h01--</span>
<span class="n">global_parameters_dict_h01_glia</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">glia_n_faces_threshold</span><span class="o">=</span><span class="mi">3000000</span><span class="p">,</span>
    <span class="n">glia_n_faces_min</span><span class="o">=</span><span class="mi">3000000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01_nuclei</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01_soma</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    
    <span class="n">large_mesh_threshold</span><span class="o">=</span><span class="mi">40000</span><span class="p">,</span>
    <span class="n">large_mesh_threshold_inner</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
    <span class="n">soma_size_threshold</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span>
    <span class="n">soma_size_threshold_max</span><span class="o">=</span><span class="mi">2000000</span><span class="p">,</span>
    <span class="n">backtrack_soma_size_threshold</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span>
    <span class="n">last_size_threshold</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span>
    <span class="n">second_pass_size_threshold</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([</span>
    <span class="n">global_parameters_dict_h01_glia</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_nuclei</span><span class="p">,</span>
    <span class="n">global_parameters_dict_h01_soma</span>
<span class="p">])</span>

<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>
<span class="c1"># modules_to_set = [sm]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="c1"># def output_global_parameters_nuclei(**kwargs):</span>
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     algorithms = [&quot;nuclei&quot;],</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = True,</span>
<span class="c1">#         **kwargs</span>
<span class="c1">#     )</span>

<span class="c1"># def output_global_parameters_soma(**kwargs):</span>
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     algorithms = [&quot;soma&quot;],</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = True,</span>
<span class="c1">#         **kwargs</span>
<span class="c1">#     )</span>



<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">meshlab</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from python_tools ---</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">data_struct_utils</span> <span class="k">as</span> <span class="n">dsu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span> 
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>
<span class="kn">from</span> <span class="nn">python_tools</span> <span class="kn">import</span> <span class="n">pipeline</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">soma_extraction_utils</span> <span class="k">as</span> <span class="n">sm</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parameter_utils</span> <span class="k">as</span> <span class="n">paru</span>
<div class="viewcode-block" id="output_global_parameters_glia"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.output_global_parameters_glia">[docs]</a><span class="k">def</span> <span class="nf">output_global_parameters_glia</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">paru</span><span class="o">.</span><span class="n">category_param_from_module</span><span class="p">(</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sm</span><span class="p">,</span>
        <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;glia&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>
    
    
    <span class="c1"># return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
    <span class="c1">#     [sm],</span>
    <span class="c1">#     algorithms = [&quot;glia&quot;],</span>
    <span class="c1">#     include_default = True,</span>
    <span class="c1">#     algorithms_only = True,</span>
    <span class="c1">#         **kwargs</span>
    <span class="c1"># )</span>
    
<div class="viewcode-block" id="output_global_parameters_nuclei"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.output_global_parameters_nuclei">[docs]</a><span class="k">def</span> <span class="nf">output_global_parameters_nuclei</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">paru</span><span class="o">.</span><span class="n">category_param_from_module</span><span class="p">(</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sm</span><span class="p">,</span>
        <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;nuclei&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>
    
    
    <span class="c1"># return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
    <span class="c1">#     [sm],</span>
    <span class="c1">#     algorithms = [&quot;nuclei&quot;],</span>
    <span class="c1">#     include_default = True,</span>
    <span class="c1">#     algorithms_only = True,</span>
    <span class="c1">#         **kwargs</span>
    <span class="c1"># )</span>
    
<div class="viewcode-block" id="output_global_parameters_soma"><a class="viewcode-back" href="../../neurd.html#neurd.soma_extraction_utils.output_global_parameters_soma">[docs]</a><span class="k">def</span> <span class="nf">output_global_parameters_soma</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">paru</span><span class="o">.</span><span class="n">category_param_from_module</span><span class="p">(</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">sm</span><span class="p">,</span>
        <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;soma&quot;</span><span class="p">,</span>
    <span class="p">)</span></div>
    
    
    <span class="c1"># return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
    <span class="c1">#     [sm],</span>
    <span class="c1">#     algorithms = [&quot;soma&quot;],</span>
    <span class="c1">#     include_default = True,</span>
    <span class="c1">#     algorithms_only = True,</span>
    <span class="c1">#         **kwargs</span>
    <span class="c1"># )</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
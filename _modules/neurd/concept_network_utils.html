

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.concept_network_utils &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.concept_network_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.concept_network_utils</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">non_branching_upstream</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="distance_between_nodes_di"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.distance_between_nodes_di">[docs]</a><span class="k">def</span> <span class="nf">distance_between_nodes_di</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">start_idx</span><span class="p">,</span>
                      <span class="n">destination_idx</span><span class="p">,</span>
                      <span class="n">reverse_di_graph</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the distance</span>
<span class="sd">    between two nodes along a path</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branch_path</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">start_idx</span><span class="o">=</span><span class="n">start_idx</span><span class="p">,</span>
                       <span class="n">destination_idx</span><span class="o">=</span><span class="n">destination_idx</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">include_last_branch_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">reverse_di_graph</span><span class="o">=</span><span class="n">reverse_di_graph</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">branch_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_along_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance_between_nodes_di_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.distance_between_nodes_di_upstream">[docs]</a><span class="k">def</span> <span class="nf">distance_between_nodes_di_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">start_idx</span><span class="p">,</span>
                      <span class="n">destination_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the upstream distance</span>
<span class="sd">    from branch_idx to start_idx</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">distance_between_nodes_di</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">start_idx</span><span class="p">,</span>
                      <span class="n">destination_idx</span><span class="p">,</span>
                      <span class="n">reverse_di_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance_between_nodes_di_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.distance_between_nodes_di_downstream">[docs]</a><span class="k">def</span> <span class="nf">distance_between_nodes_di_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">start_idx</span><span class="p">,</span>
                      <span class="n">destination_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the upstream distance</span>
<span class="sd">    from branch_idx to start_idx</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">distance_between_nodes_di</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">start_idx</span><span class="p">,</span>
                      <span class="n">destination_idx</span><span class="p">,</span>
                      <span class="n">reverse_di_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="branches_within_distance"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.branches_within_distance">[docs]</a><span class="k">def</span> <span class="nf">branches_within_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">dist_func</span><span class="p">,</span>
                            <span class="n">distance_threshold</span><span class="p">,</span>
                            <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find all branches with a certain downstream distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branch_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">())</span>
    <span class="n">branch_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_names</span><span class="p">])</span>
    <span class="c1">#print(f&quot;branch_names and dist = \n {np.vstack([branch_names,branch_dist]).T.astype(&quot;int&quot;)}&quot;)</span>
    
    <span class="n">branches_within_dist</span> <span class="o">=</span> <span class="n">branch_names</span><span class="p">[(</span><span class="n">branch_dist</span><span class="o">&lt;=</span><span class="n">distance_threshold</span><span class="p">)</span> <span class="o">&amp;</span> 
                                       <span class="p">(</span><span class="n">branch_dist</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="n">include_branch_idx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branches_within_dist</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branches_within_dist</span><span class="p">[</span><span class="n">branches_within_dist</span> <span class="o">!=</span> <span class="n">branch_idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="branches_within_distance_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.branches_within_distance_upstream">[docs]</a><span class="k">def</span> <span class="nf">branches_within_distance_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                                     <span class="n">distance_threshold</span><span class="p">,</span>
                                     <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branches_within_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">dist_func</span><span class="o">=</span><span class="n">cnu</span><span class="o">.</span><span class="n">distance_between_nodes_di_upstream</span><span class="p">,</span>
                                   <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_threshold</span><span class="p">,</span>
                                   <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="branches_within_distance_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.branches_within_distance_downstream">[docs]</a><span class="k">def</span> <span class="nf">branches_within_distance_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                                     <span class="n">distance_threshold</span><span class="p">,</span>
                                       <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.branches_within_distance_downstream(limb_obj,223,</span>
<span class="sd">                                       2000)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">branches_within_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">dist_func</span><span class="o">=</span><span class="n">cnu</span><span class="o">.</span><span class="n">distance_between_nodes_di_downstream</span><span class="p">,</span>
                                   <span class="n">distance_threshold</span><span class="o">=</span><span class="n">distance_threshold</span><span class="p">,</span>
                                   <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">)</span></div>

<span class="c1">#find all end nodes within a downstream threshold</span>
<div class="viewcode-block" id="endnode_branches_of_branches_within_distance_downtream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.endnode_branches_of_branches_within_distance_downtream">[docs]</a><span class="k">def</span> <span class="nf">endnode_branches_of_branches_within_distance_downtream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                   <span class="n">branch_idx</span><span class="p">,</span>
                                                   <span class="n">skip_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                                           <span class="n">return_skipped_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the branches that are a certain distance</span>
<span class="sd">    away from a branch but to only return the furthermost branches</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    limb_obj = neuron_obj[0]</span>
<span class="sd">    branch_idx = 223</span>

<span class="sd">    cnu.endnode_branches_of_branches_within_distance_downtream(limb_obj,</span>
<span class="sd">                                                          branch_idx,</span>
<span class="sd">                                                          0)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">branches_within_distance_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                                           <span class="n">skip_distance</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>
    <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span>

    <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">end_nodes_of_digraph</span><span class="p">(</span><span class="n">G_sub</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_skipped_branches</span><span class="p">:</span>
        <span class="n">skipped_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">end_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">end_nodes</span><span class="p">,</span><span class="n">skipped_branches</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">end_nodes</span></div>


<div class="viewcode-block" id="branches_with_parent_branching"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.branches_with_parent_branching">[docs]</a><span class="k">def</span> <span class="nf">branches_with_parent_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_with_parent_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span></div>

<div class="viewcode-block" id="branches_with_parent_non_branching"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.branches_with_parent_non_branching">[docs]</a><span class="k">def</span> <span class="nf">branches_with_parent_non_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To see if a branch had a parent node</span>
<span class="sd">    that branched off into multiple branches</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">nodes_with_parent_non_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span></div>




<div class="viewcode-block" id="subgraph_around_branch"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.subgraph_around_branch">[docs]</a><span class="k">def</span> <span class="nf">subgraph_around_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branch_idx</span><span class="p">,</span>
                           <span class="n">upstream_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">downstream_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">distance</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">distance_attribute</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
                          <span class="n">include_branch_in_upstream_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">include_branch_in_downstream_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">only_non_branching_downstream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">only_non_branching_upstream</span> <span class="o">=</span> <span class="n">non_branching_upstream</span><span class="p">,</span> 
                           <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_branch_idxs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">plot_subgraph</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">nodes_to_include</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
                          <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return a subgraph around a certain </span>
<span class="sd">    branch to find all the nodes upstream and/or downstream</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find all the branches upstream of branch </span>
<span class="sd">    (subtract the skeletal length of branch if included in upstream dist )</span>
<span class="sd">    2) Find all the branches downstrem of branch </span>
<span class="sd">    (subtract the skeletal length of branch if included in upstream dist )</span>
<span class="sd">    3) Find the upstream and downstream nodes a certain distance away</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    cnu.subgraph_around_branch(limb_obj,</span>
<span class="sd">                           branch_idx=97,</span>
<span class="sd">                           upstream_distance=1000000,</span>
<span class="sd">                           downstream_distance=1000000,</span>
<span class="sd">                           distance = None,</span>
<span class="sd">                           distance_attribute = &quot;skeletal_length&quot;,</span>
<span class="sd">                          include_branch_in_upstream_dist=True,</span>
<span class="sd">                          include_branch_in_downstream_dist=True,</span>
<span class="sd">                          only_non_branching_downstream=True,</span>
<span class="sd">                           include_branch_idx = False,</span>
<span class="sd">                          return_branch_idxs=True,</span>
<span class="sd">                           plot_subgraph = True,</span>
<span class="sd">                           verbose = False</span>
<span class="sd">                          )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">upstream_distance</span> <span class="o">=</span> <span class="n">downstream_distance</span> <span class="o">=</span> <span class="n">distance</span>
    
    <span class="n">branch_idx_dist</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">],</span><span class="n">distance_attribute</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">include_branch_in_upstream_dist</span><span class="p">:</span>
        <span class="n">upstream_distance</span> <span class="o">=</span> <span class="n">upstream_distance</span> <span class="o">-</span> <span class="n">branch_idx_dist</span>
            
    <span class="k">if</span> <span class="n">include_branch_in_downstream_dist</span><span class="p">:</span>
        <span class="n">downstream_distance</span> <span class="o">=</span> <span class="n">downstream_distance</span> <span class="o">-</span> <span class="n">branch_idx_dist</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_idx_dist = </span><span class="si">{</span><span class="n">branch_idx_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_distance = </span><span class="si">{</span><span class="n">upstream_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_distance = </span><span class="si">{</span><span class="n">downstream_distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">upstream_branches</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">branches_within_distance_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                          <span class="n">branch_idx</span><span class="p">,</span>
                                                          <span class="n">upstream_distance</span><span class="p">,</span>
                                                          <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">)</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">branches_within_distance_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                          <span class="n">branch_idx</span><span class="p">,</span>
                                                          <span class="n">downstream_distance</span><span class="p">,</span>
                                                          <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_branches= </span><span class="si">{</span><span class="n">upstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">nodes_to_exclude</span>
        
    <span class="c1">#print(f&quot;nodes_to_exclude = {nodes_to_exclude}&quot;)</span>
    
    <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="n">upstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">upstream_branches</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Excluding Nodes: </span><span class="si">{</span><span class="n">nodes_to_exclude</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After exclusion:</span><span class="se">\n</span><span class="s2"> downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="se">\n</span><span class="s2">upstream_branches = </span><span class="si">{</span><span class="n">upstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">nodes_to_include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">nodes_to_include</span><span class="p">)</span>
        <span class="n">upstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">upstream_branches</span><span class="p">,</span><span class="n">nodes_to_include</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limiting to only Include Nodes: </span><span class="si">{</span><span class="n">nodes_to_include</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After inclusion:</span><span class="se">\n</span><span class="s2"> downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="se">\n</span><span class="s2">upstream_branches = </span><span class="si">{</span><span class="n">upstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
        
    <span class="k">if</span> <span class="n">only_non_branching_upstream</span><span class="p">:</span>
        <span class="n">upstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">upstream_branches</span><span class="p">,</span><span class="n">cnu</span><span class="o">.</span><span class="n">upstream_nodes_without_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                                                                                                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After only_non_branching_upstream:</span><span class="se">\n</span><span class="s2">upstream_branches = </span><span class="si">{</span><span class="n">upstream_branches</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">only_non_branching_downstream</span><span class="p">:</span>
<span class="c1">#         downstream_branches = np.setdiff1d(downstream_branches,cnu.branches_with_parent_branching(limb_obj))</span>
        <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">,</span><span class="n">cnu</span><span class="o">.</span><span class="n">downstream_nodes_without_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                                                                                                       <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After only_non_branching_downstream:</span><span class="se">\n</span><span class="s2">downstream_branches = </span><span class="si">{</span><span class="n">downstream_branches</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        
    <span class="n">total_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">upstream_branches</span><span class="p">,</span><span class="n">downstream_branches</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">include_branch_idx</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">total_branches</span><span class="p">:</span>
            <span class="n">total_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">total_branches</span><span class="p">,[</span><span class="n">branch_idx</span><span class="p">]])</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_branches = </span><span class="si">{</span><span class="n">total_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_branch_idxs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_branches</span>
    
    <span class="n">sub_G</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">total_branches</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_subgraph</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">sub_G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">sub_G</span></div>

<div class="viewcode-block" id="downstream_nodes_without_branching"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.downstream_nodes_without_branching">[docs]</a><span class="k">def</span> <span class="nf">downstream_nodes_without_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                      <span class="n">branch_idx</span><span class="p">,</span>
                                      <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return all nodes that are </span>
<span class="sd">    downstream of a branch but not after a branching point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">nodes_to_exclude</span>
    
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_node</span> <span class="o">=</span> <span class="n">branch_idx</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()):</span>
        <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">curr_node</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">downstream_nodes</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">d_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">downstream_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">downstream_nodes</span></div>

<div class="viewcode-block" id="upstream_nodes_without_branching"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.upstream_nodes_without_branching">[docs]</a><span class="k">def</span> <span class="nf">upstream_nodes_without_branching</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                      <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return all nodes that are </span>
<span class="sd">    downstream of a branch but not after a branching point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">nodes_to_exclude</span>
    
    <span class="n">upstream_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_node</span> <span class="o">=</span> <span class="n">branch_idx</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()):</span>
        <span class="n">u_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">upstream_nodes</span>
        
        <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">u_node</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">upstream_nodes</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">u_node</span>
            <span class="n">upstream_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">upstream_nodes</span></div>


<span class="c1"># ------ 6/25: Helps find attributes that are downstream or upstream -------</span>

<span class="sd">&#39;&#39;&#39;def downstream_attribute(limb_obj,</span>
<span class="sd">                                 branch_idx,</span>
<span class="sd">                                 attribute_name,</span>
<span class="sd">                                 concat_func = np.concatenate,</span>
<span class="sd">                         downstream_distance = np.inf,</span>
<span class="sd">                         include_branch_in_downstream_dist = True,</span>
<span class="sd">                         only_non_branching_downstream = True,</span>
<span class="sd">                         include_branch_idx = True,</span>
<span class="sd">                         verbose = False,</span>
<span class="sd">                         nodes_to_exclude = None,</span>
<span class="sd">                         return_nodes = False,</span>
<span class="sd">                                 ):</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To retrieve and concatenate</span>
<span class="sd">    the attributes of a branch and</span>
<span class="sd">    all of the branches downsream</span>
<span class="sd">    of the branch until there is a branching point</span>
<span class="sd">    or within a certain distance</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the branches that are downstream</span>
<span class="sd">    (either up to branch point or within certain distance)</span>
<span class="sd">    2) Get the attributes of the branch and all those downstream</span>
<span class="sd">    3) concatenate the attributes using the prescribed function</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    # 1) Get all of the branches that are downstream</span>
<span class="sd">    # (either up to branch point or within certain distance)</span>
<span class="sd">    all_downstream_nodes = cnu.subgraph_around_branch(limb_obj,</span>
<span class="sd">                                                      branch_idx = branch_idx,</span>
<span class="sd">                                                      include_branch_idx=include_branch_idx,</span>
<span class="sd">                                                      include_branch_in_downstream_dist = include_branch_in_downstream_dist,</span>
<span class="sd">                                    downstream_distance = downstream_distance,</span>
<span class="sd">                                                      upstream_distance = -1,</span>
<span class="sd">                                    only_non_branching_downstream=only_non_branching_downstream,</span>
<span class="sd">                                                      verbose = verbose</span>
<span class="sd">                                    )</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;With downstream_distance= {downstream_distance}, only_non_branching_downstream = {only_non_branching_downstream}&quot;)</span>
<span class="sd">        print(f&quot;all_downstream_nodes = {all_downstream_nodes}&quot;)</span>
<span class="sd">        </span>
<span class="sd">    if nodes_to_exclude is not None:</span>
<span class="sd">        all_downstream_nodes = np.setdiff1d(all_downstream_nodes,nodes_to_exclude)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Excluding Nodes: {nodes_to_exclude}&quot;)</span>
<span class="sd">            print(f&quot;After exclusion: all_downstream_nodes = {all_downstream_nodes}&quot;)</span>

<span class="sd">    #2) Get the attributes of the branch and all those downstream</span>
<span class="sd">    down_attr = [getattr(limb_obj[k],attribute_name) for k in all_downstream_nodes]</span>

<span class="sd">    #3) concatenate the attributes using the prescribed function</span>
<span class="sd">    if len(down_attr) &gt; 0:</span>
<span class="sd">        down_attr_concat = concat_func(down_attr)</span>
<span class="sd">    else:</span>
<span class="sd">        down_attr_concat = down_attr </span>
<span class="sd">        </span>

<span class="sd">    if return_nodes:</span>
<span class="sd">        return down_attr_concat,all_downstream_nodes</span>
<span class="sd">    else:</span>
<span class="sd">        return down_attr_concat</span>
<span class="sd">&#39;&#39;&#39;</span>
<div class="viewcode-block" id="other_direction"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.other_direction">[docs]</a><span class="k">def</span> <span class="nf">other_direction</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">direction</span><span class="o">==</span><span class="s2">&quot;upstream&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;downstream&quot;</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;downstream&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;upstream&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown direction: </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="nodes_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.nodes_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">nodes_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">direction</span><span class="p">,</span>
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">nodes_to_include</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return nodes that are upstream or downstream by a certain dist</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arg_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;include_branch_in_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">_dist&quot;</span><span class="p">:</span><span class="n">include_branch_in_dist</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;only_non_branching_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">only_non_branching</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">_distance&quot;</span><span class="p">:</span><span class="n">distance</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">other_direction</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span><span class="si">}</span><span class="s2">_distance&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
                

    <span class="c1"># 1) Get all of the branches that are downstream</span>
    <span class="c1"># (either up to branch point or within certain distance)</span>
    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">subgraph_around_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                      <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
                                                      <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">,</span>
                                                      <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                      <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                                      <span class="n">nodes_to_include</span><span class="o">=</span><span class="n">nodes_to_include</span><span class="p">,</span>
                                                      <span class="o">**</span><span class="n">arg_dict</span>
                                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With direction = </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">, distance= </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">, only_non_branching = </span><span class="si">{</span><span class="n">only_non_branching</span><span class="si">}</span><span class="s2">, include_branch_in_dist = </span><span class="si">{</span><span class="n">include_branch_in_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">_nodes = </span><span class="si">{</span><span class="n">all_downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">all_downstream_nodes</span></div>

<div class="viewcode-block" id="nodes_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.nodes_downstream">[docs]</a><span class="k">def</span> <span class="nf">nodes_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                          <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">nodes_to_include</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nodes_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
                                    <span class="n">nodes_to_include</span><span class="o">=</span><span class="n">nodes_to_include</span><span class="p">,)</span></div>

<div class="viewcode-block" id="nodes_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.nodes_upstream">[docs]</a><span class="k">def</span> <span class="nf">nodes_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                          <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">nodes_to_include</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nodes_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
                                    <span class="n">nodes_to_include</span><span class="o">=</span><span class="n">nodes_to_include</span><span class="p">,)</span></div>
                    
                     
        
<div class="viewcode-block" id="attribute_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.attribute_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">branch_idx</span><span class="p">,</span>
                                  <span class="n">direction</span><span class="p">,</span>
                                  <span class="n">attribute_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">attribute_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">concat_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">,</span>
                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                         <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                 <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To retrieve and concatenate</span>
<span class="sd">    the attributes of a branch and</span>
<span class="sd">    all of the branches downsream</span>
<span class="sd">    of the branch until there is a branching point</span>
<span class="sd">    or within a certain distance</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the branches that are downstream</span>
<span class="sd">    (either up to branch point or within certain distance)</span>
<span class="sd">    2) Get the attributes of the branch and all those downstream</span>
<span class="sd">    3) concatenate the attributes using the prescribed function</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    arg_dict = {f&quot;include_branch_in_{direction}_dist&quot;:include_branch_in_dist,</span>
<span class="sd">                f&quot;only_non_branching_{direction}&quot;:only_non_branching,</span>
<span class="sd">                f&quot;{direction}_distance&quot;:distance,</span>
<span class="sd">                f&quot;{other_direction(direction)}_distance&quot;:-1}</span>
<span class="sd">                </span>

<span class="sd">    # 1) Get all of the branches that are downstream</span>
<span class="sd">    # (either up to branch point or within certain distance)</span>
<span class="sd">    all_downstream_nodes = cnu.subgraph_around_branch(limb_obj,</span>
<span class="sd">                                                      branch_idx = branch_idx,</span>
<span class="sd">                                                      include_branch_idx=include_branch_idx,</span>
<span class="sd">                                                      verbose = verbose,</span>
<span class="sd">                                                      nodes_to_exclude=nodes_to_exclude,</span>
<span class="sd">                                                      **arg_dict</span>
<span class="sd">                                    )</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;With direction = {direction}, distance= {distance}, only_non_branching = {only_non_branching}, include_branch_in_dist = {include_branch_in_dist}&quot;)</span>
<span class="sd">        print(f&quot;all_{direction}_nodes = {all_downstream_nodes}&quot;)&#39;&#39;&#39;</span>

    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">nodes_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">direction</span><span class="p">,</span>
                             <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                         <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
                         <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,)</span>
        

    <span class="c1">#2) Get the attributes of the branch and all those downstream</span>
    <span class="k">if</span> <span class="n">attribute_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">down_attr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">attribute_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_downstream_nodes</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">down_attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">attribute_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_downstream_nodes</span><span class="p">]</span>

    <span class="c1">#3) concatenate the attributes using the prescribed function</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">down_attr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">concat_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">down_attr_concat</span> <span class="o">=</span> <span class="n">concat_func</span><span class="p">(</span><span class="n">down_attr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">down_attr_concat</span> <span class="o">=</span> <span class="n">down_attr</span> 
        

    <span class="k">if</span> <span class="n">return_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">down_attr_concat</span><span class="p">,</span><span class="n">all_downstream_nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">down_attr_concat</span></div>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def upstream_attribute(limb_obj,</span>
<span class="sd">                                 branch_idx,</span>
<span class="sd">                                 attribute_name,</span>
<span class="sd">                                 concat_func = np.concatenate,</span>
<span class="sd">                         upstream_distance = np.inf,</span>
<span class="sd">                         include_branch_in_upstream_dist = True,</span>
<span class="sd">                         only_non_branching_upstream = non_branching_upstream,</span>
<span class="sd">                         include_branch_idx = True,</span>
<span class="sd">                         verbose = False,</span>
<span class="sd">                       return_nodes=False,</span>
<span class="sd">                       nodes_to_exclude = None,</span>
<span class="sd">                                 **kwargs):</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To retrieve and concatenate</span>
<span class="sd">    the attributes of a branch and</span>
<span class="sd">    all of the branches downsream</span>
<span class="sd">    of the branch until there is a branching point</span>
<span class="sd">    or within a certain distance</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the branches that are downstream</span>
<span class="sd">    (either up to branch point or within certain distance)</span>
<span class="sd">    2) Get the attributes of the branch and all those downstream</span>
<span class="sd">    3) concatenate the attributes using the prescribed function</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    # 1) Get all of the branches that are downstream</span>
<span class="sd">    # (either up to branch point or within certain distance)</span>
<span class="sd">    all_upstream_nodes = cnu.subgraph_around_branch(limb_obj,</span>
<span class="sd">                                                      branch_idx = branch_idx,</span>
<span class="sd">                                                      include_branch_idx=include_branch_idx,</span>
<span class="sd">                                                      include_branch_in_upstream_dist = include_branch_in_upstream_dist,</span>
<span class="sd">                                                    only_non_branching_upstream = only_non_branching_upstream</span>
<span class="sd">                                                      upstream_distance = upstream_distance,</span>
<span class="sd">                                                      downstream_distance = -1,</span>
<span class="sd">                                                      verbose = verbose</span>
<span class="sd">                                    )</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;With upstream_distance= {upstream_distance}, only_non_branching_upstream = {only_non_branching_upstream}, include_branch_idx = {include_branch_idx}&quot;)</span>
<span class="sd">        print(f&quot;all_upstream_nodes = {all_upstream_nodes}&quot;)</span>
<span class="sd">        </span>
<span class="sd">    if nodes_to_exclude is not None:</span>
<span class="sd">        all_upstream_nodes = np.setdiff1d(all_upstream_nodes,nodes_to_exclude)</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;Excluding Nodes: {nodes_to_exclude}&quot;)</span>
<span class="sd">            print(f&quot;After exclusion: all_upstream_nodes = {all_upstream_nodes}&quot;)</span>

<span class="sd">    #2) Get the attributes of the branch and all those downstream</span>
<span class="sd">    up_attr = [getattr(limb_obj[k],attribute_name) for k in all_upstream_nodes]</span>

<span class="sd">    #3) concatenate the attributes using the prescribed function</span>
<span class="sd">    up_attr_concat = concat_func(up_attr)</span>

<span class="sd">    if return_nodes:</span>
<span class="sd">        return up_attr_concat,all_upstream_nodes</span>
<span class="sd">    else:</span>
<span class="sd">        return up_attr_concat</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="downstream_nodes_mesh_connected"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.downstream_nodes_mesh_connected">[docs]</a><span class="k">def</span> <span class="nf">downstream_nodes_mesh_connected</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                                   <span class="n">n_points_of_contact</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">downstream_branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: will determine if at least N number of points of</span>
<span class="sd">    contact between the upstream and downstream meshes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.downstream_nodes_mesh_connected(limb_obj,147,</span>
<span class="sd">                               verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">branch_idx</span>
    <span class="k">if</span> <span class="n">downstream_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">downstream_branches</span>
    
    <span class="k">if</span> <span class="n">n_points_of_contact</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n_points_of_contact</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span>
    <span class="n">conn_array</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_list_connectivity</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span> <span class="p">],</span>
                             <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
    <span class="c1">#intersect_array = nu.intersect2d(conn_array,np.array([[0,1],[0,2]]))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conn_array = </span><span class="si">{</span><span class="n">conn_array</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_points_of_contact = </span><span class="si">{</span><span class="n">n_points_of_contact</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n_points_of_contact</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="skeleton_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeleton_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">skeleton_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                                 <span class="n">direction</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the downstream skeleton of a branch</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    skel = downstream_skeleton(limb_obj,</span>
<span class="sd">                    96,</span>
<span class="sd">                           only_non_branching_downstream = False,</span>
<span class="sd">                           downstream_distance = 30000</span>
<span class="sd">                   )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">skel</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span>
    <span class="n">concat_func</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">,</span>
    <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">skel</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">skel</span></div>

<div class="viewcode-block" id="skeleton_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeleton_downstream">[docs]</a><span class="k">def</span> <span class="nf">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">):</span>
    <span class="k">return</span> <span class="n">skeleton_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                        <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                        <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="n">plot_skeleton</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeleton_upstream">[docs]</a><span class="k">def</span> <span class="nf">skeleton_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">):</span>
    <span class="k">return</span> <span class="n">skeleton_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                        <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                        <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="n">plot_skeleton</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">)</span></div>


<div class="viewcode-block" id="synapses_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.synapses_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">synapses_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                        <span class="n">direction</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                        <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the downstream synapses at a branch</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    syns = downstream_synapses(limb_obj,16,downstream_distance = 0, include_branch_in_downstream_dist = False,</span>
<span class="sd">                    only_non_branching_downstream=False,</span>
<span class="sd">                   plot_synapses=True)</span>
<span class="sd">                   </span>
<span class="sd">    E</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">syns</span><span class="p">,</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="n">synapse_type</span><span class="p">,</span>
    <span class="n">concat_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">,</span>
    <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of syns = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">syns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_synapses</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">branch_idx</span><span class="p">]</span>
        <span class="n">branch_idx_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">d_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="n">scatter_color</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span>
        <span class="n">scatter_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_idx (</span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">branch_idx_color</span><span class="si">}</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2"> nodes (</span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">d_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">main_mesh_color</span><span class="o">=</span><span class="n">branch_idx_color</span><span class="p">,</span>
                         <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">d_color</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[[</span><span class="n">s</span><span class="o">.</span><span class="n">coordinate</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syns</span><span class="p">]],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">syns</span><span class="p">,</span><span class="n">nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">syns</span></div>
    
<div class="viewcode-block" id="synapses_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.synapses_downstream">[docs]</a><span class="k">def</span> <span class="nf">synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                        <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">):</span>
    <span class="k">return</span> <span class="n">synapses_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                         <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                        <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                        <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                        <span class="n">return_nodes</span> <span class="o">=</span> <span class="n">return_nodes</span><span class="p">,</span>
                        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">)</span></div>

<div class="viewcode-block" id="synapses_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.synapses_upstream">[docs]</a><span class="k">def</span> <span class="nf">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                        <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">):</span>
    <span class="k">return</span> <span class="n">synapses_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                         <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                       <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                       <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                        <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
                        <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                        <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                        <span class="n">return_nodes</span> <span class="o">=</span> <span class="n">return_nodes</span><span class="p">,</span>
                        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span>
                       <span class="p">)</span></div>
    

<div class="viewcode-block" id="weighted_attribute_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.weighted_attribute_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">weighted_attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                          <span class="n">branch_idx</span><span class="p">,</span>
                                           <span class="n">direction</span><span class="p">,</span>
                                          <span class="n">attribute_name</span><span class="p">,</span>
                                           <span class="n">attribute_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                           <span class="n">filter_away_zero_sk_lengths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">sk_lengths</span><span class="p">,</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
    <span class="n">concat_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
     <span class="n">return_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">attr_values</span><span class="p">,</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="n">attribute_name</span><span class="p">,</span>
    <span class="n">attribute_func</span><span class="o">=</span><span class="n">attribute_func</span><span class="p">,</span>
    <span class="n">concat_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>           
     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">sk_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sk_lengths</span><span class="p">)</span>
    <span class="n">attr_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">attr_values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_lengths = </span><span class="si">{</span><span class="n">sk_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2"> (aka attribute value) = </span><span class="si">{</span><span class="n">attr_values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># if filter_away_zero_widths:</span>
    <span class="k">if</span> <span class="n">filter_away_zero_sk_lengths</span><span class="p">:</span>
        <span class="n">keep_mask</span> <span class="o">=</span> <span class="n">sk_lengths</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">attr_values</span> <span class="o">=</span> <span class="n">attr_values</span><span class="p">[</span><span class="n">keep_mask</span><span class="p">]</span>
        <span class="n">sk_lengths</span> <span class="o">=</span> <span class="n">sk_lengths</span><span class="p">[</span><span class="n">keep_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_away_zero_sk_lengths Set:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_lengths = </span><span class="si">{</span><span class="n">sk_lengths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attribute_name</span><span class="si">}</span><span class="s2"> (aka attribute value) = </span><span class="si">{</span><span class="n">attr_values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attr_values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_lengths</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attr_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">attr_values</span><span class="p">,</span><span class="n">sk_lengths</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>
    
<div class="viewcode-block" id="width_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.width_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">width_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">width_attribute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">weighted_attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                          <span class="n">branch_idx</span><span class="p">,</span>
                                          <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                                          <span class="n">attribute_name</span><span class="o">=</span><span class="n">width_attribute</span><span class="p">,</span>
                                        <span class="n">attribute_func</span> <span class="o">=</span> <span class="n">width_func</span><span class="p">,</span>
                                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                        <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">,</span>
                                        <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                                        <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
                                        <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
                                        <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def width_upstream_downstream(limb_obj,</span>
<span class="sd">    branch_idx,</span>
<span class="sd">    direction,</span>
<span class="sd">    distance = np.inf,</span>
<span class="sd">    only_non_branching=True,</span>
<span class="sd">    include_branch_in_dist = True,</span>
<span class="sd">    include_branch_idx = True,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    width_func = au.axon_width,</span>
<span class="sd">    width_attribute = None,</span>
<span class="sd">    return_nodes = False,</span>
<span class="sd">    nodes_to_exclude = None,</span>
<span class="sd">    filter_away_zero_sk_lengths = True,</span>
<span class="sd">                              **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the up and downstream width</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all up/down sk lengths</span>
<span class="sd">    2) Get all up/down widths</span>
<span class="sd">    3) Filter away non-zeros widths if argument set</span>
<span class="sd">    4) If arrays are non-empty, computed the weighted average</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="sd">    sk_lengths,nodes = cnu.attribute_upstream_downstream(limb_obj = limb_obj,</span>
<span class="sd">    branch_idx = branch_idx,</span>
<span class="sd">    direction=direction,</span>
<span class="sd">    attribute_name = &quot;skeletal_length&quot;,</span>
<span class="sd">    concat_func = None,</span>
<span class="sd">    include_branch_idx=include_branch_idx,</span>
<span class="sd">    distance = distance,</span>
<span class="sd">    only_non_branching = only_non_branching,</span>
<span class="sd">    include_branch_in_dist = include_branch_in_dist,</span>
<span class="sd">    verbose = verbose,</span>
<span class="sd">    nodes_to_exclude=nodes_to_exclude,</span>
<span class="sd">    return_nodes = True,</span>
<span class="sd">     **kwargs)</span>

<span class="sd">    widths,nodes = cnu.attribute_upstream_downstream(limb_obj = limb_obj,</span>
<span class="sd">    branch_idx = branch_idx,</span>
<span class="sd">    direction=direction,</span>
<span class="sd">    attribute_name = width_attribute,</span>
<span class="sd">    attribute_func = width_func,</span>
<span class="sd">    concat_func = None,</span>
<span class="sd">    include_branch_idx=include_branch_idx,</span>
<span class="sd">    distance = distance,</span>
<span class="sd">    only_non_branching = only_non_branching,</span>
<span class="sd">    include_branch_in_dist = include_branch_in_dist,</span>
<span class="sd">    verbose = verbose,</span>
<span class="sd">    nodes_to_exclude=nodes_to_exclude,</span>
<span class="sd">    return_nodes = True,</span>
<span class="sd">     **kwargs)</span>

<span class="sd">    sk_lengths = np.array(sk_lengths)</span>
<span class="sd">    widths = np.array(widths)</span>

<span class="sd">    if verbose:</span>
<span class="sd">        print(f&quot;sk_lengths = {sk_lengths}&quot;)</span>
<span class="sd">        print(f&quot;widths = {widths}&quot;)</span>

<span class="sd">    # if filter_away_zero_widths:</span>
<span class="sd">    if filter_away_zero_sk_lengths:</span>
<span class="sd">        keep_mask = sk_lengths &gt; 0</span>

<span class="sd">        widths = widths[keep_mask]</span>
<span class="sd">        sk_lengths = sk_lengths[keep_mask]</span>

<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;filter_away_zero_sk_lengths Set:&quot;)</span>
<span class="sd">            print(f&quot;sk_lengths = {sk_lengths}&quot;)</span>
<span class="sd">            print(f&quot;widths = {widths}&quot;)</span>

<span class="sd">    if len(widths) != len(sk_lengths):</span>
<span class="sd">        raise Exception(&quot;&quot;)</span>

<span class="sd">    if len(widths) &gt; 0:</span>
<span class="sd">        return nu.weighted_average(widths,sk_lengths)</span>
<span class="sd">    else:</span>
<span class="sd">        return 0</span>
<span class="sd">&#39;&#39;&#39;</span>
    
<div class="viewcode-block" id="width_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.width_upstream">[docs]</a><span class="k">def</span> <span class="nf">width_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">width_attribute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cnu.width_downstream(limb_obj,</span>
<span class="sd">    branch_idx = 65,</span>
<span class="sd">    distance = np.inf,</span>
<span class="sd">    only_non_branching=False,</span>
<span class="sd">    include_branch_in_dist = True,</span>
<span class="sd">    include_branch_idx = True,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    width_func = au.axon_width,</span>
<span class="sd">    width_attribute = None,</span>
<span class="sd">    return_nodes = False,</span>
<span class="sd">    nodes_to_exclude = None,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    
    <span class="k">return</span> <span class="n">width_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="n">width_func</span><span class="p">,</span>
    <span class="n">width_attribute</span> <span class="o">=</span> <span class="n">width_attribute</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="width_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.width_downstream">[docs]</a><span class="k">def</span> <span class="nf">width_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">width_attribute</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    
    <span class="k">return</span> <span class="n">width_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">width_func</span> <span class="o">=</span> <span class="n">width_func</span><span class="p">,</span>
    <span class="n">width_attribute</span> <span class="o">=</span> <span class="n">width_attribute</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeletal_length_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the up and downstream width</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all up/down sk lengths</span>
<span class="sd">    2) Get all up/down widths</span>
<span class="sd">    3) Filter away non-zeros widths if argument set</span>
<span class="sd">    4) If arrays are non-empty, computed the weighted average</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sk_len</span><span class="p">,</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
    <span class="n">concat_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
    <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_len = </span><span class="si">{</span><span class="n">sk_len</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="si">}</span><span class="s2"> branches (</span><span class="si">{</span><span class="n">nodes</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_nodes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk_len</span><span class="p">,</span><span class="n">nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sk_len</span></div>
    
    
<div class="viewcode-block" id="skeletal_length_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeletal_length_upstream">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">skeletal_length_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="n">return_nodes</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeletal_length_downstream">[docs]</a><span class="k">def</span> <span class="nf">skeletal_length_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">skeletal_length_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">return_nodes</span> <span class="o">=</span> <span class="n">return_nodes</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># ------------ synapse density ---------- #</span>



<div class="viewcode-block" id="synapse_density_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.synapse_density_upstream_downstream">[docs]</a><span class="k">def</span> <span class="nf">synapse_density_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">synapse_density_type</span> <span class="o">=</span> <span class="s2">&quot;synapse_density&quot;</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the up and downstream width</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all up/down sk lengths</span>
<span class="sd">    2) Get all up/down widths</span>
<span class="sd">    3) Filter away non-zeros widths if argument set</span>
<span class="sd">    4) If arrays are non-empty, computed the weighted average</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">weighted_attribute_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
    <span class="n">attribute_name</span> <span class="o">=</span> <span class="n">synapse_density_type</span><span class="p">,</span>
    <span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span> <span class="o">=</span> <span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="synapse_density_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.synapse_density_upstream">[docs]</a><span class="k">def</span> <span class="nf">synapse_density_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">synapse_density_type</span> <span class="o">=</span> <span class="s2">&quot;synapse_density&quot;</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_away_zero_widths</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cnu.width_downstream(limb_obj,</span>
<span class="sd">    branch_idx = 65,</span>
<span class="sd">    distance = np.inf,</span>
<span class="sd">    only_non_branching=False,</span>
<span class="sd">    include_branch_in_dist = True,</span>
<span class="sd">    include_branch_idx = True,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    width_func = au.axon_width,</span>
<span class="sd">    width_attribute = None,</span>
<span class="sd">    return_nodes = False,</span>
<span class="sd">    nodes_to_exclude = None,</span>
<span class="sd">    filter_away_zero_widths = True,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">synapse_density_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">synapse_density_type</span><span class="o">=</span><span class="n">synapse_density_type</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.synapse_density_downstream">[docs]</a><span class="k">def</span> <span class="nf">synapse_density_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">synapse_density_type</span><span class="o">=</span> <span class="s2">&quot;synapse_density&quot;</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">synapse_density_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
    <span class="n">only_non_branching</span><span class="o">=</span><span class="n">only_non_branching</span><span class="p">,</span>
    <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="n">include_branch_in_dist</span><span class="p">,</span>
    <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">synapse_density_type</span><span class="o">=</span><span class="n">synapse_density_type</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="downstream_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                    <span class="n">branch_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will give the downstream nodes excluding the </span>
<span class="sd">    nodes to be excluded</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">down_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">down_nodes</span><span class="p">,</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">nodes_to_exclude</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_downtream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_downtream_branches">[docs]</a><span class="k">def</span> <span class="nf">all_downtream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                          <span class="n">branch_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_downtream_branches_including_branch"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_downtream_branches_including_branch">[docs]</a><span class="k">def</span> <span class="nf">all_downtream_branches_including_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                          <span class="n">branch_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes_including_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_upstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_upstream_branches">[docs]</a><span class="k">def</span> <span class="nf">all_upstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                          <span class="n">branch_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_upstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="all_upstream_branches_including_branch"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_upstream_branches_including_branch">[docs]</a><span class="k">def</span> <span class="nf">all_upstream_branches_including_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                          <span class="n">branch_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_upstream_nodes_including_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>




<div class="viewcode-block" id="skeleton_downstream_restricted"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.skeleton_downstream_restricted">[docs]</a><span class="k">def</span> <span class="nf">skeleton_downstream_restricted</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                  <span class="n">branch_idx</span><span class="p">,</span>
                                   <span class="n">downstream_skeletal_length</span><span class="p">,</span>
                                  <span class="n">downstream_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">plot_downstream_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">plot_restricted_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get restricted downstream skeleton </span>
<span class="sd">    starting from the upstream node</span>
<span class="sd">    and going a certain distance</span>

<span class="sd">    Application: will help select a part of skeleton</span>
<span class="sd">    that we want to find the width around (for axon identification purposes)</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the downstream skeleton</span>
<span class="sd">    2) Get the upstream coordinate and restrict the skeleton to</span>
<span class="sd">    a certain distance away from the upstream coordinate</span>
<span class="sd">    3) Calculate the new width based on the skeleton and the meshes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1) Get the downstream skeleton</span>
    <span class="k">if</span> <span class="n">downstream_nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()),</span><span class="n">downstream_nodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_exclude = </span><span class="si">{</span><span class="n">nodes_to_exclude</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">downstream_sk</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branch_idx</span><span class="o">=</span><span class="n">branch_idx</span><span class="p">,</span>
                           <span class="n">distance</span><span class="o">=</span><span class="n">downstream_skeletal_length</span><span class="p">,</span>
                           <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                           <span class="n">plot_skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">upstream_coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_coordinate = </span><span class="si">{</span><span class="n">upstream_coordinate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_downstream_skeleton</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting Downstream skeleton:&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">downstream_sk</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">upstream_coordinate</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">restr_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_to_distance_from_coordinate</span><span class="p">(</span><span class="n">downstream_sk</span><span class="p">,</span>
               <span class="n">coordinate</span> <span class="o">=</span> <span class="n">upstream_coordinate</span><span class="p">,</span>
               <span class="n">distance_threshold</span><span class="o">=</span><span class="n">downstream_skeletal_length</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_restricted_skeleton</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting Restricted skeleton:&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">restr_sk</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">upstream_coordinate</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">restr_sk</span></div>


<div class="viewcode-block" id="width_downstream_restricted"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.width_downstream_restricted">[docs]</a><span class="k">def</span> <span class="nf">width_downstream_restricted</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                               <span class="n">branch_idx</span><span class="p">,</span>
                               <span class="n">downstream_skeletal_length</span><span class="p">,</span>
                               <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">plot_restricted_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">remove_spines_from_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the width around a </span>
<span class="sd">    skeleton starting from a certain branch</span>
<span class="sd">    and uptream coordinate</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    from neurd import concept_network_utils as cnu</span>
<span class="sd">    </span>
<span class="sd">    cnu.width_downstream_restricted(</span>
<span class="sd">    limb_obj = neuron_obj_exc_syn_sp[0],</span>
<span class="sd">    branch_idx = 21,</span>
<span class="sd">    downstream_skeletal_length = 30_000,</span>
<span class="sd">    downstream_nodes = [21,26,30,35],</span>
<span class="sd">    nodes_to_exclude=None,</span>
<span class="sd">    plot_restricted_skeleton = True,</span>
<span class="sd">    remove_spines_from_mesh = True,</span>
<span class="sd">    verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) Get the downstream skeleton</span>
    <span class="k">if</span> <span class="n">downstream_nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">()),</span><span class="n">downstream_nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_exclude = </span><span class="si">{</span><span class="n">nodes_to_exclude</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">old_width</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">width_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">distance</span><span class="o">=</span><span class="n">downstream_skeletal_length</span><span class="p">,</span>
                                    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                    <span class="c1">#width_func=nst.width_new,</span>
                                     <span class="n">width_func</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">width_basic</span><span class="p">,</span>
                                    <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;old_width = </span><span class="si">{</span><span class="n">old_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">restr_sk</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_downstream_restricted</span><span class="p">(</span>    
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
        <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
        <span class="n">downstream_skeletal_length</span> <span class="o">=</span> <span class="n">downstream_skeletal_length</span><span class="p">,</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">downstream_nodes</span><span class="p">,</span>
        <span class="n">plot_restricted_skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>

    <span class="n">ref_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">if</span> <span class="n">remove_spines_from_mesh</span><span class="p">:</span>
        <span class="n">spine_meshes</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">spines</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ref_mesh before spine remove = </span><span class="si">{</span><span class="n">ref_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ref_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">ref_mesh</span><span class="p">,</span><span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">),</span>
                                       <span class="n">error_for_exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ref_mesh after spine_remove = </span><span class="si">{</span><span class="n">ref_mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_restricted_skeleton</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting Restricted skeleton:&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">ref_mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">restr_sk</span><span class="p">],)</span>

    <span class="n">new_width</span> <span class="o">=</span> <span class="n">wu</span><span class="o">.</span><span class="n">new_width_from_mesh_skeleton</span><span class="p">(</span><span class="n">restr_sk</span><span class="p">,</span>
                                <span class="n">ref_mesh</span><span class="p">,</span>
                                <span class="n">backup_width</span><span class="o">=</span><span class="n">old_width</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new_width = </span><span class="si">{</span><span class="n">new_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_width</span></div>

<div class="viewcode-block" id="G_weighted_from_limb"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.G_weighted_from_limb">[docs]</a><span class="k">def</span> <span class="nf">G_weighted_from_limb</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                      <span class="n">weight_name</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
                                    <span class="n">upstream_attribute_for_weight</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
                                      <span class="n">node_properties</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Convert the concept_network_directional</span>
<span class="sd">    to a graph with weighted edges being </span>
<span class="sd">    the length of the upstream edge</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Copy the concept network directional</span>
<span class="sd">    2) Add the edge weight property</span>
<span class="sd">    3) Add any node properties requested</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    G = cnu.G_weighted_from_limb(limb_obj,</span>
<span class="sd">                                  weight_name = &quot;weight&quot;,</span>
<span class="sd">                                upstream_attribute_for_weight = &quot;skeletal_length&quot;,</span>
<span class="sd">                                  node_properties = [nst.width_new])</span>

<span class="sd">    from datasci_tools import numpy_utils as nu</span>
<span class="sd">    nu.turn_off_scientific_notation()</span>
<span class="sd">    xu.get_node_attributes(G,&quot;width_new&quot;,24)</span>
<span class="sd">    xu.get_edges_with_weights(G)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">copy_G_without_data</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="n">weight_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">get_stat</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span><span class="n">upstream_attribute_for_weight</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n_prop</span> <span class="ow">in</span> <span class="n">node_properties</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n_prop</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                    <span class="n">curr_name</span> <span class="o">=</span> <span class="n">n_prop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_prop</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

                <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">curr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">get_stat</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">n_prop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
<div class="viewcode-block" id="all_downstream_branches_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_downstream_branches_from_branches">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_branches_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                         <span class="n">branches</span><span class="p">,</span>
                                         <span class="n">include_original_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span><span class="p">]</span>
        
    <span class="n">all_downs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">cnu</span><span class="o">.</span><span class="n">all_downtream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                           <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">include_original_branches</span><span class="p">:</span>
        <span class="n">all_downs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">all_downs</span><span class="p">,</span><span class="n">branches</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_downs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_downs</span><span class="p">,</span><span class="n">branches</span><span class="p">)</span>
        
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_downs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">downstream_nodes</span></div>

<div class="viewcode-block" id="all_upstream_branches_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_upstream_branches_from_branches">[docs]</a><span class="k">def</span> <span class="nf">all_upstream_branches_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                         <span class="n">branches</span><span class="p">,</span>
                                         <span class="n">include_original_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span><span class="p">]</span>
        
    <span class="n">all_downs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">cnu</span><span class="o">.</span><span class="n">all_upstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                           <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">include_original_branches</span><span class="p">:</span>
        <span class="n">all_downs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">all_downs</span><span class="p">,</span><span class="n">branches</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_downs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_downs</span><span class="p">,</span><span class="n">branches</span><span class="p">)</span>
        
    <span class="n">upstream_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">all_downs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_nodes = </span><span class="si">{</span><span class="n">upstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">upstream_nodes</span></div>


<span class="c1"># ---- helps with developing statistics over current/above/below branches</span>
<div class="viewcode-block" id="feature_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.feature_over_branches">[docs]</a><span class="k">def</span> <span class="nf">feature_over_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#downstream or upstream</span>
    <span class="n">include_original_branches_in_direction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1"># argument for computing the feature</span>
    <span class="n">feature_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">combining_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_skeletal_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the average value over a list of branches</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) convert the branches list into the branches</span>
<span class="sd">    that will be used to compute the statistic</span>
<span class="sd">    2) Compute the skeletal length for all the branches</span>
<span class="sd">    3) Compute the statistic for all the nodes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    feature_over_branches(limb_obj = n_obj_2[6],</span>
<span class="sd">                                branches = [24,2],</span>
<span class="sd">                               direction=&quot;upstream&quot;,</span>
<span class="sd">                               verbose = True,</span>
<span class="sd">                               feature_function=ns.width</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#1) convert the branches list into the branches</span>
    <span class="c1">#that will be used to compute the statistic</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cnu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;all_</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">_branches_from_branches&quot;</span><span class="p">)(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                         <span class="n">branches</span><span class="p">,</span>
                                                                         <span class="n">include_original_branches</span><span class="o">=</span><span class="n">include_original_branches_in_direction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New branches computed with direction (</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#2) Compute the skeletal length for all the branches</span>
    <span class="n">sk_len</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sk_len = </span><span class="si">{</span><span class="n">sk_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#3) compute statistics over branches</span>
    <span class="n">branches_val</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                            <span class="n">branch_list</span> <span class="o">=</span> <span class="n">branches</span><span class="p">,</span>
                                            <span class="n">feature_name</span><span class="o">=</span><span class="n">feature_name</span><span class="p">,</span>
                                            <span class="n">feature_function</span><span class="o">=</span><span class="n">feature_function</span><span class="p">,</span>
                                            <span class="n">combining_function</span><span class="o">=</span><span class="n">combining_function</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branches_val = </span><span class="si">{</span><span class="n">branches_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_skeletal_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branches_val</span><span class="p">,</span><span class="n">sk_len</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branches_val</span></div>
    
<div class="viewcode-block" id="weighted_feature_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.weighted_feature_over_branches">[docs]</a><span class="k">def</span> <span class="nf">weighted_feature_over_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#downstream or upstream</span>
    <span class="n">include_original_branches_in_direction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1"># argument for computing the feature</span>
    <span class="n">feature_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">combining_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the average value over a list of branches</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find features over branches with skeletal length</span>
<span class="sd">    4) Do a weighted average based on skeletal length</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    weighted_feature_over_branches(limb_obj = n_obj_2[6],</span>
<span class="sd">                                branches = [24,2],</span>
<span class="sd">                               direction=&quot;upstream&quot;,</span>
<span class="sd">                               verbose = True,</span>
<span class="sd">                               feature_function=ns.width</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches_val</span><span class="p">,</span><span class="n">sk_len</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">feature_over_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span><span class="c1">#downstream or upstream</span>
    <span class="n">include_original_branches_in_direction</span> <span class="o">=</span> <span class="n">include_original_branches_in_direction</span><span class="p">,</span>
    <span class="c1"># argument for computing the feature</span>
    <span class="n">feature_name</span><span class="o">=</span><span class="n">feature_name</span><span class="p">,</span>
    <span class="n">feature_function</span><span class="o">=</span><span class="n">feature_function</span><span class="p">,</span>
    <span class="n">combining_function</span><span class="o">=</span><span class="n">combining_function</span><span class="p">,</span>
    <span class="n">return_skeletal_length</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">weighted_average</span><span class="p">(</span><span class="n">branches_val</span><span class="p">,</span><span class="n">sk_len</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Weighted value = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="sum_feature_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.sum_feature_over_branches">[docs]</a><span class="k">def</span> <span class="nf">sum_feature_over_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="c1">#downstream or upstream</span>
    <span class="n">include_original_branches_in_direction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1"># argument for computing the feature</span>
    <span class="n">feature_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">feature_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">combining_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the average value over a list of branches</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find features over branches with skeletal length</span>
<span class="sd">    4) Do a weighted average based on skeletal length</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    cnu.sum_feature_over_branches(limb_obj = n_obj_2[6],</span>
<span class="sd">                                branches = [24,2],</span>
<span class="sd">                               direction=&quot;upstream&quot;,</span>
<span class="sd">                               verbose = True,</span>
<span class="sd">                               feature_function=ns.width</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branches_val</span><span class="p">,</span><span class="n">sk_len</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">feature_over_branches</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">,</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span><span class="c1">#downstream or upstream</span>
    <span class="n">include_original_branches_in_direction</span> <span class="o">=</span> <span class="n">include_original_branches_in_direction</span><span class="p">,</span>
    <span class="c1"># argument for computing the feature</span>
    <span class="n">feature_name</span><span class="o">=</span><span class="n">feature_name</span><span class="p">,</span>
    <span class="n">feature_function</span><span class="o">=</span><span class="n">feature_function</span><span class="p">,</span>
    <span class="n">combining_function</span><span class="o">=</span><span class="n">combining_function</span><span class="p">,</span>
    <span class="n">return_skeletal_length</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">branches_val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sum value = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">return_value</span></div>
    
<div class="viewcode-block" id="all_downstream_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.all_downstream_nodes">[docs]</a><span class="k">def</span> <span class="nf">all_downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                   <span class="n">branch_idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="upstream_branches_in_branches_list"><a class="viewcode-back" href="../../neurd.html#neurd.concept_network_utils.upstream_branches_in_branches_list">[docs]</a><span class="k">def</span> <span class="nf">upstream_branches_in_branches_list</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                       <span class="n">branches</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return branch idxs where </span>
<span class="sd">    other branch idxs are in the downstream </span>
<span class="sd">    nodes of a current branch idx</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each branch idx</span>
<span class="sd">    1) Get all the downstream nodes</span>
<span class="sd">    2) Add it to the upstream list if intersect exists</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">upstream_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">all_down</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">all_downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">all_down</span><span class="p">,</span><span class="n">branches</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">upstream_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">upstream_nodes</span></div>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>   
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">width_utils</span> <span class="k">as</span> <span class="n">wu</span>  

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.neuron_visualizations &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.neuron_visualizations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.neuron_visualizations</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">ipyvolume</span> <span class="k">as</span> <span class="nn">ipv</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">reload</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">import</span> <span class="nn">ipyvolume</span> <span class="k">as</span> <span class="nn">ipv</span>

<span class="n">soma_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
<span class="n">glia_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span>
<span class="n">nuclei_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>

<div class="viewcode-block" id="plot_soma_limb_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_soma_limb_concept_network">[docs]</a><span class="k">def</span> <span class="nf">plot_soma_limb_concept_network</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">soma_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                  <span class="n">limb_color</span><span class="o">=</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                                   <span class="n">multi_touch_color</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span>
                                  <span class="n">node_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                                  <span class="n">font_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                                  <span class="n">node_colors</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot the connectivity of the soma and the meshes in the neuron</span>

<span class="sd">    How it was developed: </span>

<span class="sd">    from datasci_tools import networkx_utils as xu</span>
<span class="sd">    xu = reload(xu)</span>
<span class="sd">    node_list = xu.get_node_list(my_neuron.concept_network)</span>
<span class="sd">    node_list_colors = [&quot;red&quot; if &quot;S&quot; in n else &quot;blue&quot; for n in node_list]</span>
<span class="sd">    nx.draw(my_neuron.concept_network,with_labels=True,node_color=node_list_colors,</span>
<span class="sd">           font_color=&quot;white&quot;,node_size=500)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node_list</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_list</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
    <span class="n">multi_touch_nodes</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span>
    <span class="n">node_list_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_colors</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">curr_color</span> <span class="o">=</span> <span class="n">node_colors</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">curr_color</span> <span class="o">=</span> <span class="n">soma_color</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">in</span> <span class="n">multi_touch_nodes</span><span class="p">:</span>
                    <span class="n">curr_color</span> <span class="o">=</span> <span class="n">multi_touch_color</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">curr_color</span> <span class="o">=</span> <span class="n">limb_color</span>
        <span class="n">node_list_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_color</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;font_color = {font_color}&quot;)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">node_color</span><span class="o">=</span><span class="n">node_list_colors</span><span class="p">,</span>
           <span class="n">font_color</span><span class="o">=</span><span class="n">font_color</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="plot_limb_concept_network_2D"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_limb_concept_network_2D">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_concept_network_2D</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                 <span class="n">node_colors</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
                                 <span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">somas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">starting_soma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">starting_soma_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">default_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
                                  <span class="n">node_size</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                                  <span class="n">font_color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
                                 <span class="n">font_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
                                 <span class="n">directional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">plot_somas</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">soma_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                 <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">pos_width</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                                 <span class="n">width_min</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
                                 <span class="n">width_noise_ampl</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                                 <span class="n">pos_vertical_gap</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                                 <span class="n">fig_width</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                                 <span class="n">fig_height</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                                 <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot the concept network as a 2D networkx graph</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    0) If passed a neuron object then use the limb name to get the limb object</span>
<span class="sd">    - make copy of limb object</span>
<span class="sd">    1) Get the somas that will be used for concept network</span>
<span class="sd">    2) Assemble the network by concatenating (directional or undirectional)</span>
<span class="sd">    3) Assemble the color list to be used for the coloring of the nodes. Will take:</span>
<span class="sd">    a. dictionary</span>
<span class="sd">    b. List</span>
<span class="sd">    c. Scalar value for all nodes</span>
<span class="sd">    </span>
<span class="sd">    4) Add on the soma to the graphs if asked for it</span>
<span class="sd">    5) Generate a hierarchical positioning for graph if position argument not specified</span>
<span class="sd">    </span>
<span class="sd">    for all the starting somas</span>
<span class="sd">    4) Use the nx.draw function</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nviz = reload(nviz)</span>
<span class="sd">    xu = reload(xu)</span>
<span class="sd">    limb_idx = &quot;L3&quot;</span>
<span class="sd">    nviz.plot_limb_concept_network_2D(neuron_obj=uncompressed_neuron,</span>
<span class="sd">                                     limb_name=limb_idx,</span>
<span class="sd">                                     node_colors=color_dictionary)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#0) If passed a neuron object then use the limb name to get the limb object</span>
    <span class="c1">#- make copy of limb object</span>
    
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_colors</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1">#just strip the L name of the first key that is not the soma</span>
        <span class="n">limb_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_colors</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;S&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No limb name was given so using </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> because was the limb in the first key&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">limb_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Neuron object recieved but no limb name specified&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">))</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">Limb</span><span class="p">):</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non Limb or Neuron object recieved: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#1) Get the somas that will be used for concept network</span>
    <span class="k">if</span> <span class="n">somas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">somas</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">touching_somas</span><span class="p">()</span>
        <span class="n">somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">somas</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    
    <span class="c1">#2) Assemble the network by concatenating (directional or undirectional)</span>
    <span class="c1"># (COULD NOT END UP CONCATENATING AND JUST USE ONE SOMA AS STARTING POINT)</span>
    <span class="k">if</span> <span class="n">directional</span><span class="p">:</span>
        <span class="n">graph_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">starting_soma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">starting_soma_group</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">starting_soma</span><span class="p">,</span>
                                                     <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="n">starting_soma_group</span><span class="p">,</span>
                                                     <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="n">suppress_disconnected_errors</span><span class="p">)</span>
            <span class="n">full_concept_network</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">somas</span><span class="p">:</span>
                <span class="n">limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="n">suppress_disconnected_errors</span><span class="p">)</span>
                <span class="n">graph_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>
            <span class="n">full_concept_network</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">combine_graphs</span><span class="p">(</span><span class="n">graph_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">full_concept_network</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network</span>

    
    <span class="c1">#3) Assemble the color list to be used for the coloring of the nodes. Will take:</span>
    <span class="c1">#a. dictionary</span>
    <span class="c1">#b. List</span>
    <span class="c1">#c. Scalar value for all nodes</span>
    <span class="n">color_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_list</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_node_list</span><span class="p">(</span><span class="n">full_concept_network</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1">#check to see if it is a limb_branch_dict</span>
        <span class="n">L_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="s2">&quot;L&quot;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_colors</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        
        <span class="k">if</span> <span class="n">L_check</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Limb_branch dictionary given for node_colors but no limb name given to specify color mappings&quot;</span><span class="p">)</span>
            <span class="n">node_colors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">node_colors</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">k</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_colors</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Node_colors dictionary does not have all of the same keys so using default color (</span><span class="si">{</span><span class="n">default_color</span><span class="si">}</span><span class="s2">) for missing nodes&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node_colors</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_colors</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_color</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_colors</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;List of node_colors </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_colors</span><span class="p">))</span><span class="si">}</span><span class="s2"> passed does not match list of ndoes in limb graph </span><span class="si">{</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color_list</span> <span class="o">=</span> <span class="n">node_colors</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">color_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_colors</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">node_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved invalid node_list type of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node_colors</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1">#4) Add on the soma to the graphs if asked for it</span>
    <span class="k">if</span> <span class="n">plot_somas</span><span class="p">:</span>
        <span class="c1">#adding the new edges</span>
        <span class="n">new_edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">:</span>
            <span class="n">curr_soma</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span>
            <span class="n">curr_soma_group</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span>
            <span class="n">sm_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;S</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;soma_group_idx&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">curr_soma</span> <span class="o">==</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_soma</span> <span class="ow">and</span> <span class="n">curr_soma_group</span> <span class="o">==</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">current_soma_group_idx</span><span class="p">:</span>
                <span class="n">new_edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sm_name</span><span class="p">,</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">],</span><span class="n">sm_name</span><span class="p">))</span>
        <span class="c1">#new_edge_list = [(f&#39;S{k[&quot;starting_soma&quot;]}&#39;,k[&quot;starting_node&quot;]) for k in limb_obj.all_concept_network_data]</span>
        <span class="n">full_concept_network</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edge_list</span><span class="p">)</span>
        <span class="c1">#adding the new colors</span>
        <span class="n">color_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">soma_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">new_edge_list</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;full_concept_network.nodes = {full_concept_network.nodes}&quot;)</span>
    <span class="c1">#5) Generate a hierarchical positioning for graph if position argument not specified</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sm_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;S</span><span class="si">{</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_soma</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_soma_group_idx</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">plot_somas</span><span class="p">:</span>
            <span class="n">starting_hierarchical_node</span> <span class="o">=</span> <span class="n">sm_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">starting_hierarchical_node</span> <span class="o">=</span> <span class="p">{</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span><span class="p">}</span>
        <span class="c1">#print(f&quot;full_concept_network.nodes() = {full_concept_network.nodes()}&quot;)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">hierarchy_pos</span><span class="p">(</span><span class="n">full_concept_network</span><span class="p">,</span><span class="n">starting_hierarchical_node</span><span class="p">,</span>
                              <span class="n">width</span><span class="o">=</span><span class="n">pos_width</span><span class="p">,</span><span class="n">width_min</span><span class="o">=</span><span class="n">width_min</span><span class="p">,</span><span class="n">width_noise_ampl</span><span class="o">=</span><span class="n">width_noise_ampl</span><span class="p">,</span> <span class="n">vert_gap</span> <span class="o">=</span> <span class="n">pos_vertical_gap</span><span class="p">,</span> <span class="n">vert_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xcenter</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span>    
        <span class="c1">#print(f&quot;pos = {pos}&quot;)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_colors = </span><span class="si">{</span><span class="n">node_colors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="c1">#6) Use the nx.draw function</span>
    <span class="c1">#print(f&quot;pos={pos}&quot;)</span>
    
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">fig_width</span><span class="p">,</span><span class="n">fig_height</span><span class="p">))</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">full_concept_network</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span>
           <span class="n">font_color</span><span class="o">=</span><span class="n">font_color</span><span class="p">,</span>
            <span class="n">node_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
            <span class="n">font_size</span><span class="o">=</span><span class="n">font_size</span><span class="p">,</span>
           <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    


<div class="viewcode-block" id="plot_concept_network"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_concept_network">[docs]</a><span class="k">def</span> <span class="nf">plot_concept_network</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span>
                            <span class="n">arrow_size</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                            <span class="n">arrow_color</span> <span class="o">=</span> <span class="s2">&quot;maroon&quot;</span><span class="p">,</span>
                            <span class="n">edge_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
                            <span class="n">node_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                            <span class="n">scatter_size</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                            <span class="n">starting_node_color</span><span class="o">=</span><span class="s2">&quot;pink&quot;</span><span class="p">,</span>
                            <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">append_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">highlight_starting_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">starting_node_size</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                 <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">suppress_disconnected_errors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">starting_node_size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">starting_node_size</span> <span class="o">=</span> <span class="n">scatter_size</span><span class="o">*</span><span class="mi">3</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: 3D embedding plot of concept graph</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>

<span class="sd">    Pseudocode for visualizing direction concept graphs</span>
<span class="sd">    1) Get a dictionary of the node locations</span>
<span class="sd">    2) Get the edges of the graph</span>
<span class="sd">    3) Compute the mipoints and directions of all of the edges</span>
<span class="sd">    4) Plot a quiver plot using the midpoints and directions for the arrows</span>
<span class="sd">    5) Plot the nodes and edges of the graph</span>

<span class="sd">    </span>
<span class="sd">    Example of how to use with background plot of neuron:</span>
<span class="sd">    </span>
<span class="sd">    my_neuron #this is the curent neuron object</span>
<span class="sd">    plot_concept_network(curr_concept_network = curr_limb_concept_network_directional,</span>
<span class="sd">                        show_at_end=False,</span>
<span class="sd">                        append_figure=False)</span>

<span class="sd">    # Just graphing the normal edges without</span>

<span class="sd">    curr_neuron_mesh =  my_neuron.mesh</span>
<span class="sd">    curr_limb_mesh =  my_neuron.concept_network.nodes[f&quot;L{curr_limb_idx}&quot;][&quot;data&quot;].mesh</span>

<span class="sd">    sk.graph_skeleton_and_mesh(other_meshes=[curr_neuron_mesh,curr_limb_mesh],</span>
<span class="sd">                              other_meshes_colors=[&quot;olive&quot;,&quot;brown&quot;],</span>
<span class="sd">                              show_at_end=True,</span>
<span class="sd">                              append_figure=True)</span>
<span class="sd">                              </span>
<span class="sd">                              </span>
<span class="sd">    Another example wen testing: </span>
<span class="sd">    from neurd import neuron_visualizations as nviz</span>
<span class="sd">    nviz = reload(nviz)</span>
<span class="sd">    nru = reload(nru)</span>
<span class="sd">    sk = reload(sk)</span>

<span class="sd">    nviz.plot_concept_network(curr_concept_network = curr_limb_concept_network_directional,</span>
<span class="sd">                            scatter_size=0.3,</span>
<span class="sd">                            show_at_end=True,</span>
<span class="sd">                            append_figure=False)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">append_figure</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">hide_legend_panel</span><span class="p">()</span>
    
    <span class="n">node_locations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span>

    <span class="n">node_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>



    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()):</span>
        <span class="c1">#print(&quot;plotting a directional concept graph&quot;)</span>
        <span class="c1">#getting the midpoints then the directions of arrows for the quiver</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">node_locations</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span>
            <span class="n">midpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">+</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">midpoints</span><span class="p">)</span>



        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">directions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">directions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">directions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">size</span><span class="o">=</span><span class="n">arrow_size</span><span class="p">,</span>
                        <span class="n">size_selected</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="n">arrow_color</span><span class="p">)</span>

    <span class="c1">#graphing the nodes</span>

    <span class="c1"># nodes_mesh = ipv.pylab.scatter(node_locations_array[:,0], </span>
    <span class="c1">#                                 node_locations_array[:,1], </span>
    <span class="c1">#                                 node_locations_array[:,2],</span>
    <span class="c1">#                                 size = 0.01,</span>
    <span class="c1">#                                 marker = &quot;sphere&quot;)</span>

    <span class="n">node_locations_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_locations</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    <span class="c1">#print(f&quot;node_locations_array = {node_locations_array}&quot;)</span>

    
    
    <span class="k">if</span> <span class="n">highlight_starting_node</span><span class="p">:</span>
        <span class="n">starting_node_num</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">starting_node_num_coord</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_node_num</span><span class="p">]</span>
    
        <span class="c1">#print(f&quot;Highlighting starting node {starting_node_num} with coordinate = {starting_node_num_coord}&quot;)</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_node_num_coord</span><span class="p">:</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">graph_skeleton_and_mesh</span><span class="p">(</span>
                                       <span class="n">other_scatter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                       <span class="n">other_scatter_colors</span><span class="o">=</span><span class="n">starting_node_color</span><span class="p">,</span>
                                       <span class="n">scatter_size</span><span class="o">=</span><span class="n">starting_node_size</span><span class="p">,</span>
                                       <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span>
                                      <span class="p">)</span>
    
    <span class="c1">#print(f&quot;Current scatter size = {scatter_size}&quot;)</span>
    <span class="n">concept_network_skeleton</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">convert_concept_network_to_skeleton</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span>
    <span class="n">sk</span><span class="o">.</span><span class="n">graph_skeleton_and_mesh</span><span class="p">(</span><span class="n">other_skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">concept_network_skeleton</span><span class="p">],</span>
                              <span class="n">other_skeletons_colors</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span>
                               <span class="n">other_scatter</span><span class="o">=</span><span class="p">[</span><span class="n">node_locations_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                               <span class="n">other_scatter_colors</span><span class="o">=</span><span class="n">node_color</span><span class="p">,</span>
                               <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                               <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">,</span>
                              <span class="p">)</span>
    
    

    
    
    
    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="visualize_concept_map"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_concept_map">[docs]</a><span class="k">def</span> <span class="nf">visualize_concept_map</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span>
                            <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                            <span class="c1">#node_color=&quot;black&quot;,</span>
                            <span class="n">node_alpha</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                            <span class="n">edge_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                            <span class="n">node_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>

                            <span class="n">starting_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">starting_node_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
                            <span class="n">starting_node_color</span><span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
                            <span class="n">starting_node_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>

                            <span class="n">arrow_color</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span>
                            <span class="n">arrow_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                            <span class="n">arrow_size</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>

                            <span class="n">arrow_color_reciprocal</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span>
                            <span class="n">arrow_alpha_reciprocal</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
                            <span class="n">arrow_size_reciprocal</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                          
                            <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">append_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot a concept network with more</span>
<span class="sd">    parameters than previous plot_concept_network</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    </span>
<span class="sd">    neuron = reload(neuron)</span>
<span class="sd">    recovered_neuron = neuron.Neuron(recovered_neuron)</span>
<span class="sd">    nru = reload(nru)</span>
<span class="sd">    nviz = reload(nviz)</span>
<span class="sd">    returned_network = nru.whole_neuron_branch_concept_network(recovered_neuron,</span>
<span class="sd">                                      directional=True,</span>
<span class="sd">                                     limb_soma_touch_dictionary = &quot;all&quot;,</span>
<span class="sd">                                     print_flag = False)</span>
<span class="sd">    </span>
<span class="sd">    nviz.visualize_concept_map(returned_network,</span>
<span class="sd">                          #starting_node_size = 10,</span>
<span class="sd">                          arrow_color = &quot;green&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">append_figure</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">hide_legend_panel</span><span class="p">()</span>
    
    <span class="n">node_locations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span>
    
    <span class="n">node_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>


    <span class="c1">#Adding the arrows for a directional graph</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()):</span>
        <span class="c1">#getting the midpoints then the directions of arrows for the quiver</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">reciprocal_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">find_reciprocal_connections</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">redundant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="c1">#going to skip reciprocal connections because will do them later</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">matching_rows_old</span><span class="p">(</span><span class="n">reciprocal_edges</span><span class="p">,[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">node_locations</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
            <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span>
            <span class="n">midpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">+</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>
        <span class="n">midpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">midpoints</span><span class="p">)</span>

        <span class="n">arrow_rgba</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="n">arrow_color</span><span class="p">,</span><span class="n">arrow_alpha</span><span class="p">)</span>

        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">directions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">directions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">directions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">size</span><span class="o">=</span><span class="n">arrow_size</span><span class="p">,</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="n">arrow_rgba</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reciprocal_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#getting the midpoints then the directions of arrows for the quiver</span>
            <span class="n">midpoints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">reciprocal_edges</span><span class="p">:</span>
                <span class="c1">#going to skip reciprocal connections because will do them later</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="n">node_locations</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">-</span> <span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span>
                <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">difference</span><span class="p">)</span>
                <span class="n">midpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_locations</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="o">+</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>
            <span class="n">midpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">midpoints</span><span class="p">)</span>

            <span class="n">arrow_rgba</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="n">arrow_color_reciprocal</span><span class="p">,</span>
                                          <span class="n">arrow_alpha_reciprocal</span><span class="p">)</span>
            
            <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">midpoints</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">directions</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">directions</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">directions</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                            <span class="n">size</span><span class="o">=</span><span class="n">arrow_size_reciprocal</span><span class="p">,</span>
                            <span class="n">color</span> <span class="o">=</span> <span class="n">arrow_rgba</span><span class="p">)</span>

            
    <span class="k">if</span> <span class="n">starting_node</span><span class="p">:</span>
        <span class="n">starting_node_num</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_starting_node</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="n">only_one</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">starting_node_num_coord</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_node_num</span><span class="p">]</span>
    
        <span class="c1">#print(f&quot;Highlighting starting node {starting_node_num} with coordinate = {starting_node_num_coord}&quot;)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">starting_node_num_coord</span><span class="p">:</span>
<span class="c1">#             print(f&quot;mu.color_to_rgba(starting_node_color,starting_node_alpha) = {mu.color_to_rgba(starting_node_color,starting_node_alpha)}&quot;)</span>
<span class="c1">#             print(f&quot;[k] = {[k]}&quot;)</span>
<span class="c1">#             print(f&quot;scatter_size = {node_size}&quot;)</span>
            <span class="n">sk</span><span class="o">.</span><span class="n">graph_skeleton_and_mesh</span><span class="p">(</span>
                                       <span class="n">other_scatter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                       <span class="n">other_scatter_colors</span><span class="o">=</span><span class="p">[</span><span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="n">starting_node_color</span><span class="p">,</span><span class="n">starting_node_alpha</span><span class="p">)],</span>
                                       <span class="n">scatter_size</span><span class="o">=</span><span class="n">starting_node_size</span><span class="p">,</span>
                                       <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">flip_y</span><span class="o">=</span><span class="kc">False</span>
                
                                   <span class="p">)</span>
    
    <span class="c1">#print(&quot;************ Done plotting the starting nodes *******************&quot;)</span>
    <span class="c1">#plot all of the data points using the colors</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_color</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">color_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">node_color</span><span class="p">)</span>
        <span class="c1">#now go through and add the alpha levels to those that don&#39;t have it</span>
        <span class="n">color_list_alpha_fixed</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">color_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">node_alpha</span><span class="p">)</span>
        <span class="n">color_list_correct_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">user_colors</span><span class="o">=</span><span class="n">color_list_alpha_fixed</span><span class="p">,</span>
                                                                         <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
        <span class="n">node_locations_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_locations</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#if dictionary then check that all the color dictionary keys match</span>
        <span class="n">node_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">node_color</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">node_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node_color dictionary (</span><span class="si">{</span><span class="n">node_color</span><span class="si">}</span><span class="s2">) did not match the nodes in the concept network (</span><span class="si">{</span><span class="n">curr_concept_network</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
        <span class="c1">#assemble the color list and the </span>
        <span class="n">color_list_correct_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_color</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">]</span>
        <span class="n">node_locations_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_locations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">]</span>
        
<span class="c1">#     print(f&quot;node_locations = {node_locations}&quot;)</span>
<span class="c1">#     print(f&quot;\n\nnode_locations_array = {node_locations_array}&quot;)</span>
    <span class="c1">#print(&quot;***** About to do all the other scatter points ***********&quot;)</span>
    
    <span class="c1">#print(f&quot;Current scatter size = {scatter_size}&quot;)</span>
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge_color = </span><span class="si">{</span><span class="n">edge_color</span><span class="si">}</span><span class="s2"> IN SKELETON&quot;</span><span class="p">)</span>
    <span class="n">concept_network_skeleton</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">convert_concept_network_to_skeleton</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span>
    
    <span class="n">plot_ipv_skeleton</span><span class="p">(</span><span class="n">concept_network_skeleton</span><span class="p">,</span><span class="n">edge_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">sk</span><span class="o">.</span><span class="n">graph_skeleton_and_mesh</span><span class="p">(</span>
                              <span class="c1">#other_skeletons=[concept_network_skeleton],</span>
                              <span class="c1">#other_skeletons_colors=[edge_color],</span>
                               <span class="n">other_scatter</span><span class="o">=</span><span class="n">node_locations_array</span><span class="p">,</span>
                               <span class="n">other_scatter_colors</span><span class="o">=</span><span class="n">color_list_correct_size</span><span class="p">,</span>
                               <span class="n">scatter_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
                               <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">flip_y</span><span class="o">=</span><span class="kc">False</span>
                              <span class="p">)</span>

    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
        
        
        
    
    



<div class="viewcode-block" id="plot_branch_pieces"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_pieces">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_pieces</span><span class="p">(</span><span class="n">neuron_network</span><span class="p">,</span>
                       <span class="n">node_to_branch_dict</span><span class="p">,</span>
                      <span class="n">background_mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">background_mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">background_mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                                         <span class="n">faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        
    <span class="n">total_branch_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_branches</span> <span class="ow">in</span> <span class="n">node_to_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">meshes_to_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">neuron_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">curr_limb</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_branches</span><span class="p">]</span>
        <span class="n">total_branch_meshes</span> <span class="o">+=</span> <span class="n">meshes_to_plot</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_branch_meshes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;**** Warning: There were no branch meshes to visualize *******&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    
    <span class="n">sk</span><span class="o">.</span><span class="n">graph_skeleton_and_mesh</span><span class="p">(</span><span class="n">main_mesh_verts</span><span class="o">=</span><span class="n">background_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                              <span class="n">main_mesh_faces</span><span class="o">=</span><span class="n">background_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span>
                              <span class="n">other_meshes</span><span class="o">=</span><span class="n">total_branch_meshes</span><span class="p">,</span>
                              <span class="n">other_meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
    
<span class="c1">######  Don&#39;t think need general configurations because would like for mesh, skeleton and concept_network to have different defaults</span>
<span class="c1">#     #the general configurations      </span>
<span class="c1">#     configuration_dict=None,</span>
<span class="c1">#     limb_branch_dict=None</span>
<span class="c1">#     resolution=default_resolution,</span>
<span class="c1">#     color_grouping=&quot;branch&quot;,</span>
<span class="c1">#     color=&quot;random&quot;,</span>
<span class="c1">#     color_alpha=default_alpha,</span>
<span class="c1">#     soma=False,</span>
<span class="c1">#     soma_color=&quot;red&quot;,</span>
<span class="c1">#     soma_alpha=default_alpha,</span>
<span class="c1">#     whole_neuron=False,</span>
<span class="c1">#     whole_neuron_color=&quot;grey&quot;,</span>
<span class="c1">#     whole_neuron_alpha=default_alpha,</span>
    
    

<div class="viewcode-block" id="plot_ipv_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_ipv_mesh">[docs]</a><span class="k">def</span> <span class="nf">plot_ipv_mesh</span><span class="p">(</span><span class="n">elephant_mesh_sub</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.2</span><span class="p">],</span>
                 <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">elephant_mesh_sub</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">elephant_mesh_sub</span> <span class="o">=</span> <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">#check if the color is a dictionary</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1">#get the type of values stored in there</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">color</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        
        <span class="c1">#if the labels were stored as just numbers/decimals</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
            <span class="c1">#get all of the possible labels</span>
            <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="c1">#get random colors for all of the labels</span>
            <span class="n">colors_list</span> <span class="o">=</span>  <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span><span class="n">n_colors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lab</span><span class="p">,</span><span class="n">curr_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">,</span><span class="n">colors_list</span><span class="p">):</span>
                <span class="c1">#find the faces that correspond to that label</span>
                <span class="n">faces_to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">color</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">lab</span><span class="p">]</span>
                <span class="c1">#draw the mesh with that color</span>
                <span class="n">curr_mesh</span> <span class="o">=</span> <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">faces_to_keep</span><span class="p">],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="n">mesh4</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                               <span class="n">triangles</span><span class="o">=</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
                <span class="n">mesh4</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">curr_color</span>
                <span class="n">mesh4</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>          
        <span class="n">mesh4</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                                   <span class="n">triangles</span><span class="o">=</span><span class="n">elephant_mesh_sub</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>

        <span class="n">mesh4</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="n">mesh4</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span></div>
        
<div class="viewcode-block" id="plot_ipv_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_ipv_skeleton">[docs]</a><span class="k">def</span> <span class="nf">plot_ipv_skeleton</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(&quot;Edge coordinates in plot_ipv_skeleton were of 0 length so returning&quot;)</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">edge_coordinates</span> <span class="o">=</span> <span class="n">edge_coordinates</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">edge_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">edge_coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
    
    <span class="n">unique_skeleton_verts_final</span><span class="p">,</span><span class="n">edges_final</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">convert_skeleton_to_nodes_edges_optimized</span><span class="p">(</span><span class="n">edge_coordinates</span><span class="p">)</span>
    <span class="n">mesh2</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">plot_trisurf</span><span class="p">(</span><span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> 
                            <span class="n">unique_skeleton_verts_final</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> 
                            <span class="n">lines</span><span class="o">=</span><span class="n">edges_final</span><span class="p">)</span>
    <span class="c1">#print(f&quot;color in ipv_skeleton = {color}&quot;)</span>
    <span class="n">mesh2</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span> 
    <span class="n">mesh2</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="c1">#print(f&quot;Color in skeleton ipv plot local = {color}&quot;)</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">unique_skeleton_verts_final</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">unique_skeleton_verts_final</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unique_skeleton_verts_final</span></div>

<div class="viewcode-block" id="plot_ipv_scatter"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_ipv_scatter">[docs]</a><span class="k">def</span> <span class="nf">plot_ipv_scatter</span><span class="p">(</span><span class="n">scatter_points</span><span class="p">,</span><span class="n">scatter_color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span>
                    <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                    <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">scatter_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scatter_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">scatter_points</span> <span class="o">=</span> <span class="n">scatter_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scatter_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">scatter_points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scatter_points</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No scatter points to plot&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">mesh_5</span> <span class="o">=</span> <span class="n">ipv</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
            <span class="n">scatter_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
            <span class="n">scatter_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">scatter_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> 
            <span class="n">size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span> 
            <span class="n">color</span><span class="o">=</span><span class="n">scatter_color</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;sphere&quot;</span><span class="p">)</span>
    <span class="n">mesh_5</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">transparent</span> <span class="o">=</span> <span class="kc">True</span>    </div>


<span class="n">current_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>


<div class="viewcode-block" id="visualize_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron</span><span class="p">(</span>
    <span class="c1">#the neuron we want to visualize</span>
    <span class="n">input_neuron</span><span class="p">,</span>
    
    <span class="c1">#the categories that will be visualized</span>
    <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
    <span class="n">limb_branch_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">L0</span><span class="o">=</span><span class="p">[]),</span>
    <span class="c1">#limb_branch_dict=dict(L0=[]),</span>
    
    <span class="c1">#for the mesh type:</span>
    <span class="n">mesh_configuration_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
    <span class="n">mesh_limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh_resolution</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span>
    <span class="n">mesh_color_grouping</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span>
    <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">mesh_fill_color</span><span class="o">=</span><span class="s2">&quot;brown&quot;</span><span class="p">,</span>
    <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">mesh_soma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mesh_soma_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">mesh_soma_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh_whole_neuron_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
    <span class="n">mesh_whole_neuron_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">subtract_from_main_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    
    <span class="n">mesh_spines</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh_spines_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">mesh_spines_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    
    <span class="n">mesh_boutons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh_boutons_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
    <span class="n">mesh_boutons_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    
    <span class="n">mesh_web</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh_web_color</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
    <span class="n">mesh_web_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
            
    
    <span class="c1">#for the skeleton type:</span>
    <span class="n">skeleton_configuration_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
    <span class="n">skeleton_limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton_resolution</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span>
    <span class="n">skeleton_color_grouping</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span>
    <span class="n">skeleton_color</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">skeleton_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">skeleton_soma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">skeleton_fill_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
    <span class="n">skeleton_soma_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">skeleton_soma_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">skeleton_whole_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">skeleton_whole_neuron_color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
    <span class="n">skeleton_whole_neuron_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    
    <span class="c1">#for concept_network </span>
    <span class="n">network_configuration_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
    <span class="n">network_limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">network_resolution</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span>
    <span class="n">network_color_grouping</span><span class="o">=</span><span class="s2">&quot;branch&quot;</span><span class="p">,</span>
    <span class="n">network_color</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">network_color_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">network_soma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">network_fill_color</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span>
    <span class="n">network_soma_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">network_soma_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">network_whole_neuron</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">network_whole_neuron_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="n">network_whole_neuron_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">network_whole_neuron_node_size</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span>
    
    <span class="c1"># ------ specific arguments for the concept_network -----</span>
    <span class="n">network_directional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">limb_to_starting_soma</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
    
    <span class="n">edge_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="n">node_size</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span>
    
    <span class="n">starting_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">starting_node_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">starting_node_color</span><span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
    <span class="n">starting_node_alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    
    <span class="n">arrow_color</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span>
    <span class="n">arrow_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
    <span class="n">arrow_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
    
    <span class="n">arrow_color_reciprocal</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span><span class="c1">#&quot;brown&quot;,</span>
    <span class="n">arrow_alpha_reciprocal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="c1">#0.8,</span>
    <span class="n">arrow_size_reciprocal</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span><span class="c1">#0.3,</span>
    
    <span class="c1"># arguments for plotting other meshes associated with neuron #</span>
    
    <span class="n">inside_pieces</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">inside_pieces_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">inside_pieces_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    
    <span class="n">insignificant_limbs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">insignificant_limbs_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">insignificant_limbs_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    
    <span class="n">non_soma_touching_meshes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#whether to graph the inside pieces</span>
    <span class="n">non_soma_touching_meshes_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">non_soma_touching_meshes_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    
    
    
    <span class="c1"># arguments for how to display/save ipyvolume fig</span>
    <span class="n">buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">axis_box_off</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">html_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">show_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">append_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    
    <span class="c1"># arguments that will help with random colorization:</span>
    <span class="n">colors_to_omit</span><span class="o">=</span> <span class="p">[],</span>
    
    <span class="c1">#whether to return the color dictionary in order to help</span>
    <span class="c1">#locate certain colors</span>
    <span class="n">return_color_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#if return this then can use directly with plot_color_dict to visualize the colors of certain branches</span>
    
    
    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">print_time</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    
    <span class="c1">#arguments for scatter</span>
    <span class="n">scatters</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">main_scatter_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    
    <span class="n">soma_border_vertices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">soma_border_vertices_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="n">soma_border_vertices_color</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
    
    <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">subtract_glia</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    
    <span class="n">zoom_coordinate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">zoom_radius</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">zoom_radius_xyz</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    <span class="c1"># --- 6/9 parameters for synapses --- #</span>
    <span class="n">total_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">total_synapses_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    
    
    <span class="n">limb_branch_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">limb_branch_synapse_type</span> <span class="o">=</span> <span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
    <span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">soma_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="n">limb_branch_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">distance_errored_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh_errored_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    
    
    <span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ** tried to optimize for speed but did not find anything that really sped it up**</span>
<span class="sd">    ipv.serialize.performance = 0/1/2 was the only thing I really found but this didn&#39;t help</span>
<span class="sd">    (most of the time is spent on compiling the visualization and not on the python,</span>
<span class="sd">    can see this by turning on print_time=True, which only shows about 2 seconds for runtime</span>
<span class="sd">    but is really 45 seconds for large mesh)</span>
<span class="sd">    </span>
<span class="sd">    How to plot the spines:</span>
<span class="sd">    nviz.visualize_neuron(uncompressed_neuron,</span>
<span class="sd">                      limb_branch_dict = dict(),</span>
<span class="sd">                     #mesh_spines=True,</span>
<span class="sd">                      mesh_whole_neuron=True,</span>
<span class="sd">                      mesh_whole_neuron_alpha = 0.1,</span>
<span class="sd">                      </span>
<span class="sd">                    mesh_spines = True,</span>
<span class="sd">                    mesh_spines_color = &quot;red&quot;,</span>
<span class="sd">                    mesh_spines_alpha = 0.8,</span>
<span class="sd">                      </span>
<span class="sd">                     )</span>
<span class="sd">    Examples: </span>
<span class="sd">    How to do a concept_network graphing: </span>
<span class="sd">    nviz=reload(nviz)</span>
<span class="sd">    returned_color_dict = nviz.visualize_neuron(uncompressed_neuron,</span>
<span class="sd">                                                visualize_type=[&quot;network&quot;],</span>
<span class="sd">                                                network_resolution=&quot;branch&quot;,</span>
<span class="sd">                                                network_whole_neuron=True,</span>
<span class="sd">                                                network_whole_neuron_node_size=1,</span>
<span class="sd">                                                network_whole_neuron_alpha=0.2,</span>
<span class="sd">                                                network_directional=True,</span>

<span class="sd">                                                #network_soma=[&quot;S1&quot;,&quot;S0&quot;],</span>
<span class="sd">                                                #network_soma_color = [&quot;black&quot;,&quot;red&quot;],       </span>
<span class="sd">                                                limb_branch_dict=dict(L1=[11,15]),</span>
<span class="sd">                                                network_color=[&quot;pink&quot;,&quot;green&quot;],</span>
<span class="sd">                                                network_color_alpha=1,</span>
<span class="sd">                                                node_size = 5,</span>
<span class="sd">                                                arrow_size = 1,</span>
<span class="sd">                                                return_color_dict=True)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Cool facts: </span>
<span class="sd">    1) Can specify the soma names and not just say true so will</span>
<span class="sd">    only do certain somas</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    returned_color_dict = nviz.visualize_neuron(uncompressed_neuron,</span>
<span class="sd">                     visualize_type=[&quot;network&quot;],</span>
<span class="sd">                     network_resolution=&quot;limb&quot;,</span>
<span class="sd">                                            network_soma=[&quot;S0&quot;],</span>
<span class="sd">                    network_soma_color = [&quot;red&quot;,&quot;black&quot;],       </span>
<span class="sd">                     limb_branch_dict=dict(L1=[],L2=[]),</span>
<span class="sd">                     node_size = 5,</span>
<span class="sd">                     return_color_dict=True)</span>
<span class="sd">    </span>
<span class="sd">    2) Can put &quot;all&quot; for limb_branch_dict or can put &quot;all&quot;</span>
<span class="sd">    for the lists of each branch</span>
<span class="sd">    </span>
<span class="sd">    3) Can specify the somas you want to graph and their colors</span>
<span class="sd">    by sending lists</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex 3: How to specifically color just one branch and fill color the rest of limb</span>
<span class="sd">    limb_idx = &quot;L0&quot;</span>
<span class="sd">    ex_limb = uncompressed_neuron.concept_network.nodes[limb_idx][&quot;data&quot;]</span>
<span class="sd">    branch_idx = 3</span>
<span class="sd">    ex_branch = ex_limb.concept_network.nodes[2][&quot;data&quot;]</span>

<span class="sd">    nviz.visualize_neuron(double_neuron_processed,</span>
<span class="sd">                          visualize_type=[&quot;mesh&quot;],</span>
<span class="sd">                         limb_branch_dict=dict(L0=&quot;all&quot;),</span>
<span class="sd">                          mesh_color=dict(L1={3:&quot;red&quot;}),</span>
<span class="sd">                          mesh_fill_color=&quot;green&quot;</span>

<span class="sd">                         )</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reload</span><span class="p">(</span><span class="n">nviz</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total_synapses_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">total_synapses_size</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">default_synapse_size</span>
    <span class="k">if</span> <span class="n">limb_branch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_size</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">default_synapse_size</span>
    <span class="k">if</span> <span class="n">distance_errored_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">distance_errored_size</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">default_synapse_size</span>
    <span class="k">if</span> <span class="n">mesh_errored_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_errored_size</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">default_synapse_size</span>
    <span class="k">if</span> <span class="n">soma_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">soma_size</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">default_synapse_size</span>
    
    
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">:</span>
        <span class="n">ax_name</span> <span class="o">=</span> <span class="n">input_neuron</span><span class="o">.</span><span class="n">axon_limb_name</span>
        <span class="k">if</span> <span class="n">ax_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No axon to plot&quot;</span><span class="p">)</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">ax_name</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">}</span>
        
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">L0</span><span class="o">=</span><span class="p">[])</span>
        
    
    
    
    <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#print(f&quot;print_time = {print_time}&quot;)</span>
    
    
    <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">)</span>
    
    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">#To uncomment for full graphing</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">append_figure</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">))</span>
        <span class="n">ipvu</span><span class="o">.</span><span class="n">hide_legend_panel</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time for setting up figure = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="n">main_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#do the mesh visualization type</span>
    <span class="k">for</span> <span class="n">viz_type</span> <span class="ow">in</span> <span class="n">visualize_type</span><span class="p">:</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Working on visualization type: </span><span class="si">{</span><span class="n">viz_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">viz_type</span><span class="o">==</span><span class="s2">&quot;mesh&quot;</span><span class="p">:</span>
            <span class="n">current_type</span> <span class="o">=</span> <span class="s2">&quot;mesh&quot;</span>
            
            
            <span class="c1">#configuring the parameters</span>
            <span class="n">configuration_dict</span> <span class="o">=</span> <span class="n">mesh_configuration_dict</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">,</span><span class="n">mesh_limb_branch_dict</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;resolution&quot;</span><span class="p">,</span><span class="n">mesh_resolution</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color_grouping&quot;</span><span class="p">,</span><span class="n">mesh_color_grouping</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span><span class="n">mesh_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;fill_color&quot;</span><span class="p">,</span><span class="n">mesh_fill_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color_alpha&quot;</span><span class="p">,</span><span class="n">mesh_color_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span><span class="n">mesh_soma</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma_color&quot;</span><span class="p">,</span><span class="n">mesh_soma_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma_alpha&quot;</span><span class="p">,</span><span class="n">mesh_soma_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron&quot;</span><span class="p">,</span><span class="n">mesh_whole_neuron</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_color&quot;</span><span class="p">,</span><span class="n">mesh_whole_neuron_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">,</span><span class="n">mesh_whole_neuron_alpha</span><span class="p">)</span>
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_spines&quot;</span><span class="p">,</span><span class="n">mesh_spines</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_spines_color&quot;</span><span class="p">,</span><span class="n">mesh_spines_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_spines_alpha&quot;</span><span class="p">,</span><span class="n">mesh_spines_alpha</span><span class="p">)</span>
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_boutons&quot;</span><span class="p">,</span><span class="n">mesh_boutons</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_boutons_color&quot;</span><span class="p">,</span><span class="n">mesh_boutons_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_boutons_alpha&quot;</span><span class="p">,</span><span class="n">mesh_boutons_alpha</span><span class="p">)</span>
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_web&quot;</span><span class="p">,</span><span class="n">mesh_web</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_web_color&quot;</span><span class="p">,</span><span class="n">mesh_web_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;mesh_web_alpha&quot;</span><span class="p">,</span><span class="n">mesh_web_alpha</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">viz_type</span> <span class="o">==</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">:</span>
            <span class="n">current_type</span><span class="o">=</span><span class="s2">&quot;skeleton&quot;</span>
            
            <span class="c1">#configuring the parameters</span>
            <span class="n">configuration_dict</span> <span class="o">=</span> <span class="n">skeleton_configuration_dict</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">,</span><span class="n">skeleton_limb_branch_dict</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;resolution&quot;</span><span class="p">,</span><span class="n">skeleton_resolution</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color_grouping&quot;</span><span class="p">,</span><span class="n">skeleton_color_grouping</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span><span class="n">skeleton_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;fill_color&quot;</span><span class="p">,</span><span class="n">skeleton_fill_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color_alpha&quot;</span><span class="p">,</span><span class="n">skeleton_color_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span><span class="n">skeleton_soma</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma_color&quot;</span><span class="p">,</span><span class="n">skeleton_soma_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma_alpha&quot;</span><span class="p">,</span><span class="n">skeleton_soma_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron&quot;</span><span class="p">,</span><span class="n">skeleton_whole_neuron</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_color&quot;</span><span class="p">,</span><span class="n">skeleton_whole_neuron_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">,</span><span class="n">skeleton_whole_neuron_alpha</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">viz_type</span> <span class="o">==</span> <span class="s2">&quot;network&quot;</span><span class="p">:</span>
            <span class="n">current_type</span><span class="o">=</span><span class="s2">&quot;mesh_center&quot;</span>
            
            <span class="c1">#configuring the parameters</span>
            <span class="n">configuration_dict</span> <span class="o">=</span> <span class="n">network_configuration_dict</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">,</span><span class="n">network_limb_branch_dict</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;resolution&quot;</span><span class="p">,</span><span class="n">network_resolution</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color_grouping&quot;</span><span class="p">,</span><span class="n">network_color_grouping</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color&quot;</span><span class="p">,</span><span class="n">network_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;fill_color&quot;</span><span class="p">,</span><span class="n">network_fill_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;color_alpha&quot;</span><span class="p">,</span><span class="n">network_color_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma&quot;</span><span class="p">,</span><span class="n">network_soma</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma_color&quot;</span><span class="p">,</span><span class="n">network_soma_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;soma_alpha&quot;</span><span class="p">,</span><span class="n">network_soma_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron&quot;</span><span class="p">,</span><span class="n">network_whole_neuron</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_color&quot;</span><span class="p">,</span><span class="n">network_whole_neuron_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">,</span><span class="n">network_whole_neuron_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;whole_neuron_node_size&quot;</span><span class="p">,</span><span class="n">network_whole_neuron_node_size</span><span class="p">)</span>
            
            <span class="c1"># ------ specific arguments for the concept_network -----</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;network_directional&quot;</span><span class="p">,</span><span class="n">network_directional</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;limb_to_starting_soma&quot;</span><span class="p">,</span><span class="n">limb_to_starting_soma</span><span class="p">)</span>
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;node_size&quot;</span><span class="p">,</span><span class="n">node_size</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;edge_color&quot;</span><span class="p">,</span><span class="n">edge_color</span><span class="p">)</span>
            
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;starting_node&quot;</span><span class="p">,</span><span class="n">starting_node</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;starting_node_size&quot;</span><span class="p">,</span><span class="n">starting_node_size</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;starting_node_color&quot;</span><span class="p">,</span><span class="n">starting_node_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;starting_node_alpha&quot;</span><span class="p">,</span><span class="n">starting_node_alpha</span><span class="p">)</span>
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrow_color&quot;</span><span class="p">,</span><span class="n">arrow_color</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrow_alpha&quot;</span><span class="p">,</span><span class="n">arrow_alpha</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrow_size&quot;</span><span class="p">,</span><span class="n">arrow_size</span><span class="p">)</span>
            
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrow_color_reciprocal&quot;</span><span class="p">,</span><span class="n">arrow_color_reciprocal</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrow_alpha_reciprocal&quot;</span><span class="p">,</span><span class="n">arrow_alpha_reciprocal</span><span class="p">)</span>
            <span class="n">configuration_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;arrow_size_reciprocal&quot;</span><span class="p">,</span><span class="n">arrow_size_reciprocal</span><span class="p">)</span>
            
            
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recieved invalid visualization type: </span><span class="si">{</span><span class="n">viz_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
        <span class="c1">#sets the limb branch dict specially  (uses overall one if none assigned)</span>

        <span class="c1">#print(f&quot;current_type = {current_type}&quot;)</span>
        
        <span class="c1">#handle if the limb_branch_dict is &quot;all&quot;</span>
        <span class="c1">#print(f&#39;configuration_dict[&quot;limb_branch_dict&quot;] = {configuration_dict[&quot;limb_branch_dict&quot;]}&#39;)</span>
        <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#print(&quot;limb_branch_dict was None&quot;)</span>
            <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_branch_dict</span>
        
        <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">()])</span>
            
        <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> 
            <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">()}</span>
        <span class="c1">#print(f&#39;configuration_dict[&quot;limb_branch_dict&quot;] = {configuration_dict[&quot;limb_branch_dict&quot;]}&#39;)</span>
            
        <span class="c1">#print(f&#39;configuration_dict[&quot;limb_branch_dict&quot;] = {configuration_dict[&quot;limb_branch_dict&quot;]}&#39;)</span>
        
        <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracting Dictionary = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="c1">#------------------------- Done with collecting the parameters ------------------------</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">configuration_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            
        <span class="c1">#get the list of items specific</span>
        <span class="n">limbs_to_plot</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">plot_items</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plot_items_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;limb&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">current_type</span> <span class="o">==</span> <span class="s2">&quot;mesh&quot;</span><span class="p">:</span>
                <span class="n">plot_items</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_mesh_from_branches</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">[</span><span class="n">li</span><span class="p">])</span> <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">limbs_to_plot</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">[</span><span class="n">li</span><span class="p">],</span><span class="n">current_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">limbs_to_plot</span><span class="p">]</span>
            <span class="n">plot_items_order</span> <span class="o">=</span> <span class="p">[[</span><span class="n">li</span><span class="p">]</span> <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">limbs_to_plot</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>
            
            <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">limbs_to_plot</span><span class="p">:</span>
                <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">li</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="s2">&quot;empty&quot;</span> <span class="ow">in</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">labels</span> <span class="ow">or</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                    
                <span class="c1">#handle if &quot;all&quot; is the key</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">][</span><span class="n">li</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="ow">or</span> 
                   <span class="p">(</span><span class="s2">&quot;all&quot;</span> <span class="ow">in</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">][</span><span class="n">li</span><span class="p">])):</span>
                    <span class="c1">#gather all of the branches: </span>
                    <span class="n">plot_items</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">],</span><span class="n">current_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
                    <span class="n">plot_items_order</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">li</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict&quot;</span><span class="p">][</span><span class="n">li</span><span class="p">]):</span>
                        <span class="n">plot_items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">],</span><span class="n">current_type</span><span class="p">))</span>
                        <span class="n">plot_items_order</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">li</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The resolution specified was neither branch nore limb&quot;</span><span class="p">)</span>
            
        
        <span class="c1">#getting the min and max of the plot items to set the zoom later (could be empty)</span>
        
        
        <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating Plot Items = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
       
        
<span class="c1">#         print(f&quot;plot_items_order= {plot_items_order}&quot;)</span>
<span class="c1">#         print(f&quot;plot_items= {plot_items}&quot;)</span>
        
     
        <span class="c1"># Now need to build the colors dictionary</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode:</span>
<span class="sd">        if color is a dictionary then that is perfect and what we want:</span>
<span class="sd">        </span>
<span class="sd">        -if color grouping or resolution at limb then this dictionary should be limb --&gt; color</span>
<span class="sd">        -if resolution adn color grouping aat branch should be limb --&gt; branch --&gt; color</span>
<span class="sd">        </span>
<span class="sd">        if not then generate a dictionary like that where </span>
<span class="sd">        a) if color is random: generate list of random colors for length needed and then store in dict</span>
<span class="sd">        b) if given one color or list of colors:</span>
<span class="sd">        - make sure it is a list of colors</span>
<span class="sd">        - convert all of the strings into rgb colors</span>
<span class="sd">        - for all the colors in the list that do not have an alpha value fill it in with the default alpha</span>
<span class="sd">        - repeat the list enough times to give every item a color</span>
<span class="sd">        - assign the colors to the limb or limb--&gt; branch dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#need to do preprocessing of colors if not a dictionary</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">color_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#if there was a dictionary given then compile a color list and fill everything not specified with mesh_fill_color</span>
            <span class="n">color_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dict_keys</span> <span class="ow">in</span> <span class="n">plot_items_order</span><span class="p">:</span>
                <span class="c1">#print(f&quot;dict_keys = {dict_keys}&quot;)</span>
                <span class="n">first_key</span> <span class="o">=</span> <span class="n">dict_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">first_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]:</span>
                    <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgb</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;fill_color&quot;</span><span class="p">]))</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgb</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">][</span><span class="n">first_key</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">second_key</span> <span class="o">=</span> <span class="n">dict_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">second_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">][</span><span class="n">first_key</span><span class="p">]:</span>
                        <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgb</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;fill_color&quot;</span><span class="p">]))</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">color_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgb</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">][</span><span class="n">first_key</span><span class="p">][</span><span class="n">second_key</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_items_order item is greater than size 2: </span><span class="si">{</span><span class="n">dict_keys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;color_list = </span><span class="si">{</span><span class="n">color_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            

            
        <span class="c1">#now go through and add the alpha levels to those that don&#39;t have it</span>
        <span class="n">color_list_alpha_fixed</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">color_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;color_alpha&quot;</span><span class="p">])</span>
        
        <span class="n">color_list_correct_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">user_colors</span><span class="o">=</span><span class="n">color_list_alpha_fixed</span><span class="p">,</span>
                                                                         <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">plot_items</span><span class="p">),</span>
                                                                        <span class="n">colors_to_omit</span><span class="o">=</span><span class="n">colors_to_omit</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;color_list_correct_size = </span><span class="si">{</span><span class="n">color_list_correct_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_items = </span><span class="si">{</span><span class="n">plot_items</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plot_items_order = </span><span class="si">{</span><span class="n">plot_items_order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            
        <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating Colors list = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#------at this point have a list of colors for all the things to plot -------</span>
        
        
        
        <span class="c1">#4) If soma is requested then get the some items</span>
        
        
        <span class="n">soma_names</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]):</span>
            <span class="n">soma_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]]</span>
            
        <span class="k">if</span> <span class="n">viz_type</span> <span class="o">==</span> <span class="s2">&quot;mesh&quot;</span><span class="p">:</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1">#add the vertices to plot to main_vertices list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">min_max_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>  <span class="n">plot_items</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">min_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">min_max_vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">max_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">min_max_vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">min_vertices</span><span class="p">,</span><span class="n">max_vertices</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Collecting vertices for mesh = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
            
            <span class="c1">#Can plot the meshes now</span>
            <span class="k">for</span> <span class="n">curr_mesh</span><span class="p">,</span><span class="n">curr_mesh_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plot_items</span><span class="p">,</span><span class="n">color_list_correct_size</span><span class="p">):</span>
                <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_mesh_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting mesh pieces= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
            <span class="c1">#Plot the soma if asked for it</span>
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Pseudocode: </span>
<span class="sd">                1) Get the soma meshes</span>
<span class="sd">                2) for the color specified: </span>
<span class="sd">                - if string --&gt; convert to rgba</span>
<span class="sd">                - if numpy array --&gt; </span>
<span class="sd">                </span>
<span class="sd">                configuration_dict.setdefault(&quot;soma&quot;,mesh_soma)</span>
<span class="sd">                configuration_dict.setdefault(&quot;soma_color&quot;,mesh_soma_color)</span>
<span class="sd">                configuration_dict.setdefault(&quot;soma_alpha&quot;,mesh_soma_alpha)</span>

<span class="sd">                &quot;&quot;&quot;</span>
                
                <span class="n">soma_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_names</span><span class="p">]</span>
                
                <span class="n">soma_colors_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma_color&quot;</span><span class="p">])</span>
                <span class="n">soma_colors_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">soma_colors_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma_alpha&quot;</span><span class="p">])</span>
                <span class="n">soma_colors_list_alpha_fixed_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">soma_colors_list_alpha</span><span class="p">,</span>
                                                                                          <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">))</span>
                <span class="n">soma_names</span><span class="p">,</span><span class="n">soma_colors_list_alpha_fixed_size</span>
                <span class="k">for</span> <span class="n">curr_soma_mesh</span><span class="p">,</span><span class="n">curr_soma_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">,</span><span class="n">soma_colors_list_alpha_fixed_size</span><span class="p">):</span>
                    <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_soma_mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_soma_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                    <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_soma_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;plotting mesh somas= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    
            <span class="c1">#will add the background mesh if requested</span>
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron&quot;</span><span class="p">]:</span>
                <span class="n">whole_neuron_colors_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_color&quot;</span><span class="p">])</span>
                <span class="n">whole_neuron_colors_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">whole_neuron_colors_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="n">subtract_glia</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">glia_faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">glia_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">whole_mesh</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">submesh</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)),</span>
                                                                                 <span class="n">current_neuron</span><span class="o">.</span><span class="n">glia_faces</span><span class="p">)],</span><span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">repair</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">whole_mesh</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">mesh</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">whole_mesh</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">mesh</span>
                    
                    
                <span class="c1"># Will do the erroring of the mesh</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">subtract_from_main_mesh</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plot_items</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)):</span>
                    <span class="n">main_mesh_to_plot</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">original_mesh</span><span class="o">=</span><span class="n">whole_mesh</span><span class="p">,</span>
                                              <span class="n">subtract_mesh</span><span class="o">=</span><span class="n">plot_items</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">main_mesh_to_plot</span> <span class="o">=</span> <span class="n">whole_mesh</span>
                    
                
        
                
                <span class="c1"># will do the plotting</span>
                <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">main_mesh_to_plot</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">whole_neuron_colors_list_alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">main_mesh_to_plot</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">main_mesh_to_plot</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
                
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting mesh whole neuron = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
                
            
<span class="c1">#             # plotting the boutons:</span>
<span class="c1">#             if configuration_dict[&quot;mesh_boutons&quot;]:</span>
<span class="c1">#                 bouton_meshes = []</span>
                
<span class="c1">#                 for limb_names in current_neuron.neuron_obj.get_limb_names():</span>
<span class="c1">#                     curr_limb_obj = current_neuron.concept_network.nodes[limb_names][&quot;data&quot;]</span>
<span class="c1">#                     for branch_name in curr_limb_obj.get_branch_names():</span>
<span class="c1">#                         if hasattr(curr_limb_obj[branch_name],boutons) and curr_limb_obj[branch_name].boutons is not None :</span>
<span class="c1">#                             bouton_meshes += curr_limb_obj[branch_name].boutons</span>
                
<span class="c1">#                 boutons_color_list = mu.process_non_dict_color_input(configuration_dict[&quot;mesh_boutons_color&quot;])</span>
<span class="c1">#                 boutons_color_list_alpha = mu.apply_alpha_to_color_list(boutons_color_list,alpha=configuration_dict[&quot;mesh_boutons_alpha&quot;])</span>
                
                
<span class="c1">#                 if len(boutons_color_list_alpha) == 1:</span>
<span class="c1">#                     combined_bouton_meshes = tu.combine_meshes(bouton_meshes)</span>
<span class="c1">#                     plot_ipv_mesh(combined_bouton_meshes,color=boutons_color_list_alpha[0],flip_y=flip_y)</span>
<span class="c1">#                     main_vertices.append(combined_bouton_meshes.vertices)</span>
                    
<span class="c1">#                 else:</span>
<span class="c1">#                     boutons_colors_list_alpha_fixed_size = mu.generate_color_list_no_alpha_change(boutons_color_list_alpha,</span>
<span class="c1">#                                                                                               n_colors=len(bouton_meshes))</span>


<span class="c1">#                     for curr_bouton_mesh,curr_bouton_color in zip(bouton_meshes,boutons_colors_list_alpha_fixed_size):</span>
<span class="c1">#                         plot_ipv_mesh(curr_bouton_mesh,color=curr_bouton_color,flip_y=flip_y)</span>
<span class="c1">#                         main_vertices.append(curr_bouton_mesh.vertices)</span>
<span class="c1">#                 if print_time:</span>
<span class="c1">#                     print(f&quot;Plotting mesh boutons= {time.time() - local_time}&quot;)</span>
<span class="c1">#                     local_time = time.time()</span>
                    
            <span class="c1"># -- 4/1 Addition:    </span>
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_boutons&quot;</span><span class="p">]:</span>
                <span class="n">bouton_verts</span> <span class="o">=</span> <span class="n">plot_branch_mesh_attribute</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                              <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;boutons&quot;</span><span class="p">,</span>
                              <span class="n">mesh_color</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_boutons_color&quot;</span><span class="p">],</span>
                              <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_boutons_alpha&quot;</span><span class="p">],</span>
                               <span class="n">return_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                               <span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">,</span>
                               <span class="n">plot_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">print_time</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bouton_verts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">main_vertices</span> <span class="o">+=</span> <span class="n">bouton_verts</span>
                    
            
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_web&quot;</span><span class="p">]:</span>
                <span class="n">web_verts</span> <span class="o">=</span> <span class="n">plot_branch_mesh_attribute</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                              <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;web&quot;</span><span class="p">,</span>
                              <span class="n">mesh_color</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_web_color&quot;</span><span class="p">],</span>
                              <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_web_alpha&quot;</span><span class="p">],</span>
                               <span class="n">return_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                               <span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">,</span>
                               <span class="n">plot_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="n">print_time</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">web_verts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">main_vertices</span> <span class="o">+=</span> <span class="n">web_verts</span>
                            
                
            <span class="c1">#plotting the spines</span>
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_spines&quot;</span><span class="p">]:</span>
                <span class="c1">#plotting the spines</span>
                <span class="n">spine_meshes</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="k">for</span> <span class="n">limb_names</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
                    <span class="c1">#iterate through all of the branches</span>
                    <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_names</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">branch_name</span> <span class="ow">in</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                        <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">spine_meshes</span> <span class="o">+=</span> <span class="n">curr_spines</span>
                
                <span class="n">spines_color_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_spines_color&quot;</span><span class="p">])</span>
                
                
                
                <span class="n">spines_color_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">spines_color_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;mesh_spines_alpha&quot;</span><span class="p">])</span>
                <span class="c1">#print(f&quot;spines_color_list_alpha = {spines_color_list_alpha}&quot;)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spines_color_list_alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1">#concatenate the meshes</span>
                    <span class="c1">#print(&quot;Inside spine meshes combined&quot;)</span>
                    <span class="n">combined_spine_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">)</span>
                    <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">combined_spine_meshes</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">spines_color_list_alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                    <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined_spine_meshes</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spines_colors_list_alpha_fixed_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">spines_color_list_alpha</span><span class="p">,</span>
                                                                                              <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">))</span>


                    <span class="k">for</span> <span class="n">curr_spine_mesh</span><span class="p">,</span><span class="n">curr_spine_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spine_meshes</span><span class="p">,</span><span class="n">spines_colors_list_alpha_fixed_size</span><span class="p">):</span>
                        <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_spine_mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_spine_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                        <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_spine_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting mesh spines= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
            
        <span class="k">elif</span> <span class="n">viz_type</span> <span class="o">==</span> <span class="s2">&quot;skeleton&quot;</span><span class="p">:</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1">#add the vertices to plot to main_vertices list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">reshaped_items</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">plot_items</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">min_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">reshaped_items</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">max_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">reshaped_items</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">min_vertices</span><span class="p">,</span><span class="n">max_vertices</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gathering vertices for skeleton= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1">#Can plot the meshes now</span>
            <span class="k">for</span> <span class="n">curr_skeleton</span><span class="p">,</span><span class="n">curr_skeleton_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plot_items</span><span class="p">,</span><span class="n">color_list_correct_size</span><span class="p">):</span>
                <span class="n">plot_ipv_skeleton</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_skeleton_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting skeleton pieces = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma&quot;</span><span class="p">]:</span>
                    
                <span class="n">soma_colors_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma_color&quot;</span><span class="p">])</span>
                <span class="n">soma_colors_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">soma_colors_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma_alpha&quot;</span><span class="p">])</span>
                <span class="n">soma_colors_list_alpha_fixed_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">soma_colors_list_alpha</span><span class="p">,</span>
                                                                                          <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_names</span><span class="p">))</span>
                <span class="c1">#get the somas associated with the neurons</span>
                <span class="n">soma_skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_soma_skeleton</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_names</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">curr_soma_sk</span><span class="p">,</span><span class="n">curr_soma_sk_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_skeletons</span><span class="p">,</span><span class="n">soma_colors_list_alpha_fixed_size</span><span class="p">):</span>
                    <span class="n">sk_vertices</span> <span class="o">=</span> <span class="n">plot_ipv_skeleton</span><span class="p">(</span><span class="n">curr_soma_sk</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_soma_sk_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                    <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk_vertices</span><span class="p">)</span> <span class="c1">#adding the vertices</span>
                
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting skeleton somas = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron&quot;</span><span class="p">]:</span>
                <span class="n">whole_neuron_colors_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_color&quot;</span><span class="p">])</span>
                <span class="n">whole_neuron_colors_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">whole_neuron_colors_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">])</span>
                
                <span class="c1">#graph</span>
                <span class="n">sk_vertices</span> <span class="o">=</span> <span class="n">plot_ipv_skeleton</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">whole_neuron_colors_list_alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sk_vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                      <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sk_vertices</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
                
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting skeleton whole neuron = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
                
        <span class="k">elif</span> <span class="n">viz_type</span> <span class="o">==</span> <span class="s2">&quot;network&quot;</span><span class="p">:</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Pseudocode: </span>
<span class="sd">            0) get the mesh_centers of all of the nodes in the concept_network sent and add to the main vertices</span>
<span class="sd">            1) get the current concept network (limb or branch) based on the resolution</span>
<span class="sd">            - if branch level then use the function that assembles</span>
<span class="sd">            2) get a list of all the nodes in the plot_items_order and assemble into a dictionary (have to fix the name)</span>
<span class="sd">            3) For all the somas to be added, add them to the dictionary of label to color (and add vertices to main vertices)</span>
<span class="sd">            4) Use that dictionary to send to the visualize_concept_map function and call the function</span>
<span class="sd">            with all the other parameters in the configuration dict</span>
<span class="sd">            </span>
<span class="sd">            5) get the mesh_centers of all of the nodes in the concept_network sent and add to the main vertices</span>
<span class="sd">            </span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            
            <span class="c1">#0) get the mesh_centers of all of the nodes in the concept_network sent and add to the main vertices</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">reshaped_items</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">plot_items</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">min_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">reshaped_items</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">max_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">reshaped_items</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">min_vertices</span><span class="p">,</span><span class="n">max_vertices</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gathering vertices for network = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                
            
            <span class="c1">#1) get the current concept network (limb or branch) based on the resolution</span>
            <span class="c1">#- if branch level then use the function that assembles</span>
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>

                <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">whole_neuron_branch_concept_network</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                                          <span class="n">directional</span><span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;network_directional&quot;</span><span class="p">],</span>
                                                         <span class="n">limb_soma_touch_dictionary</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;limb_to_starting_soma&quot;</span><span class="p">],</span>
                                                         <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

                    
                
                
                <span class="c1">#2) get a list of all the nodes in the plot_items_order and assemble into a dictionary for colors (have to fix the name)</span>
                <span class="n">item_to_color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">,</span><span class="n">color_list_correct_size</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#2) get a list of all the nodes in the plot_items_order and assemble into a dictionary for colors (have to fix the name)</span>
                <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span>
                <span class="n">item_to_color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">,</span><span class="n">color_list_correct_size</span><span class="p">)])</span>
                
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting whole concept network and colors = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            
            <span class="c1">#3) For all the somas to be added, add them to the dictionary of label to color</span>
            <span class="k">if</span> <span class="n">soma_names</span><span class="p">:</span>
                <span class="n">soma_colors_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma_color&quot;</span><span class="p">])</span>
                <span class="n">soma_colors_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">soma_colors_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;soma_alpha&quot;</span><span class="p">])</span>
                <span class="n">soma_colors_list_alpha_fixed_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">soma_colors_list_alpha</span><span class="p">,</span>
                                                                                          <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_names</span><span class="p">))</span>
                
                <span class="k">for</span> <span class="n">s_name</span><span class="p">,</span><span class="n">s_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_names</span><span class="p">,</span><span class="n">soma_colors_list_alpha_fixed_size</span><span class="p">):</span>
                    <span class="n">item_to_color_dict</span><span class="p">[</span><span class="n">s_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_color</span>
                    <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_neuron</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">s_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>
                    
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding soma items to network plotting = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    
            <span class="c1">#print(f&quot;plot_items_order = {plot_items_order}&quot;)</span>
            <span class="c1">#print(f&quot;item_to_color_dict = {item_to_color_dict}&quot;)</span>
                
            <span class="n">curr_concept_network_subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">item_to_color_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            
            
            
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting Subgraph of concept network = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1">#4) Use that dictionary to send to the visualize_concept_map function and call the function</span>
            <span class="c1">#with all the other parameters in the configuration dict</span>
            
            <span class="n">visualize_concept_map</span><span class="p">(</span><span class="n">curr_concept_network_subgraph</span><span class="p">,</span>
                            <span class="n">node_color</span><span class="o">=</span><span class="n">item_to_color_dict</span><span class="p">,</span>
                            <span class="n">edge_color</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;edge_color&quot;</span><span class="p">],</span>
                            <span class="n">node_size</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;node_size&quot;</span><span class="p">],</span>

                            <span class="n">starting_node</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">],</span>
                            <span class="n">starting_node_size</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node_size&quot;</span><span class="p">],</span>
                            <span class="n">starting_node_color</span><span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node_color&quot;</span><span class="p">],</span>
                            <span class="n">starting_node_alpha</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node_alpha&quot;</span><span class="p">],</span>

                            <span class="n">arrow_color</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_color&quot;</span><span class="p">]</span> <span class="p">,</span>
                            <span class="n">arrow_alpha</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_alpha&quot;</span><span class="p">],</span>
                            <span class="n">arrow_size</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_size&quot;</span><span class="p">],</span>

                            <span class="n">arrow_color_reciprocal</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_color_reciprocal&quot;</span><span class="p">]</span> <span class="p">,</span>
                            <span class="n">arrow_alpha_reciprocal</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_alpha_reciprocal&quot;</span><span class="p">],</span>
                            <span class="n">arrow_size_reciprocal</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_size_reciprocal&quot;</span><span class="p">],</span>
                          
                            <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Graphing concept network pieces = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
            <span class="c1"># plot the entire thing if asked for it</span>
            <span class="k">if</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron&quot;</span><span class="p">]:</span>
                <span class="c1">#compute the new color</span>
                <span class="n">whole_neuron_network_color</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_color&quot;</span><span class="p">],</span>
                                                             <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">])</span>
                
                <span class="n">whole_neuron_network_edge_color</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;edge_color&quot;</span><span class="p">],</span>
                                                             <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_alpha&quot;</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;whole_neuron_network_edge_color = </span><span class="si">{</span><span class="n">whole_neuron_network_edge_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="n">visualize_concept_map</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">,</span>
                            <span class="n">node_color</span><span class="o">=</span><span class="n">whole_neuron_network_color</span><span class="p">,</span>
                            <span class="n">edge_color</span><span class="o">=</span><span class="n">whole_neuron_network_edge_color</span><span class="p">,</span>
                            <span class="n">node_size</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;whole_neuron_node_size&quot;</span><span class="p">],</span>

                            <span class="n">starting_node</span><span class="o">=</span><span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node&quot;</span><span class="p">],</span>
                            <span class="n">starting_node_size</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node_size&quot;</span><span class="p">],</span>
                            <span class="n">starting_node_color</span><span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node_color&quot;</span><span class="p">],</span>
                            <span class="n">starting_node_alpha</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;starting_node_alpha&quot;</span><span class="p">],</span>

                            <span class="n">arrow_color</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_color&quot;</span><span class="p">]</span> <span class="p">,</span>
                            <span class="n">arrow_alpha</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_alpha&quot;</span><span class="p">],</span>
                            <span class="n">arrow_size</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_size&quot;</span><span class="p">],</span>

                            <span class="n">arrow_color_reciprocal</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_color_reciprocal&quot;</span><span class="p">]</span> <span class="p">,</span>
                            <span class="n">arrow_alpha_reciprocal</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_alpha_reciprocal&quot;</span><span class="p">],</span>
                            <span class="n">arrow_size_reciprocal</span> <span class="o">=</span> <span class="n">configuration_dict</span><span class="p">[</span><span class="s2">&quot;arrow_size_reciprocal&quot;</span><span class="p">],</span>
                          
                            <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Graphing whole neuron concept network = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid viz_type&quot;</span><span class="p">)</span>
        
        
    <span class="c1"># -------------- plotting the insignificant meshes, floating meshes and non-significant limbs ----- #</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: for [inside_piece,insignificant_limbs,non_soma_touching_meshes]</span>
<span class="sd">    </span>
<span class="sd">    1) get whether the argument was True/False or a list</span>
<span class="sd">    2) If True or list, assemble the color</span>
<span class="sd">    3) for each mesh plot it with the color</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">other_mesh_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">inside_pieces</span><span class="o">=</span><span class="n">inside_pieces</span><span class="p">,</span>
        <span class="n">inside_pieces_color</span><span class="o">=</span><span class="n">inside_pieces_color</span><span class="p">,</span>
        <span class="n">inside_pieces_alpha</span><span class="o">=</span><span class="n">inside_pieces_alpha</span><span class="p">,</span>
        
        <span class="n">insignificant_limbs</span><span class="o">=</span><span class="n">insignificant_limbs</span><span class="p">,</span>
        <span class="n">insignificant_limbs_color</span><span class="o">=</span><span class="n">insignificant_limbs_color</span><span class="p">,</span>
        <span class="n">insignificant_limbs_alpha</span><span class="o">=</span><span class="n">insignificant_limbs_alpha</span><span class="p">,</span>
        
        <span class="n">non_soma_touching_meshes</span><span class="o">=</span><span class="n">non_soma_touching_meshes</span><span class="p">,</span>
        <span class="n">non_soma_touching_meshes_color</span><span class="o">=</span><span class="n">non_soma_touching_meshes_color</span><span class="p">,</span>
        <span class="n">non_soma_touching_meshes_alpha</span><span class="o">=</span><span class="n">non_soma_touching_meshes_alpha</span>
    
    
    <span class="p">)</span>

    
    <span class="n">other_mesh_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;inside_pieces&quot;</span><span class="p">,</span><span class="s2">&quot;insignificant_limbs&quot;</span><span class="p">,</span><span class="s2">&quot;non_soma_touching_meshes&quot;</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">m_type</span> <span class="ow">in</span> <span class="n">other_mesh_types</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">other_mesh_dict</span><span class="p">[</span><span class="n">m_type</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other_mesh_dict</span><span class="p">[</span><span class="n">m_type</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
                <span class="n">current_mesh_list</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">m_type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;all&quot;</span> <span class="ow">in</span> <span class="n">other_mesh_dict</span><span class="p">[</span><span class="n">m_type</span><span class="p">]:</span>
                <span class="n">current_mesh_list</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">m_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">total_mesh_list</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">m_type</span><span class="p">)</span>
                <span class="n">current_mesh_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">total_mesh_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_mesh_dict</span><span class="p">[</span><span class="n">m_type</span><span class="p">]]</span>
                
            <span class="c1">#get the color</span>
            <span class="n">curr_mesh_colors_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">other_mesh_dict</span><span class="p">[</span><span class="n">m_type</span> <span class="o">+</span> <span class="s2">&quot;_color&quot;</span><span class="p">])</span>
            <span class="n">curr_mesh_colors_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">curr_mesh_colors_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">other_mesh_dict</span><span class="p">[</span><span class="n">m_type</span> <span class="o">+</span> <span class="s2">&quot;_alpha&quot;</span><span class="p">])</span>

            <span class="c1">#graph</span>
            <span class="k">for</span> <span class="n">curr_mesh</span> <span class="ow">in</span> <span class="n">current_mesh_list</span><span class="p">:</span>
                <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_mesh_colors_list_alpha</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting mesh pieces of </span><span class="si">{</span><span class="n">m_type</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c1"># ----- doing any extra scatter plotting you may need ---- #</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    scatters=[],</span>
<span class="sd">    scatters_colors=[],</span>
<span class="sd">    scatter_size=0.3,</span>
<span class="sd">    main_scatter_color=&quot;red&quot;</span>
<span class="sd">    </span>
<span class="sd">    soma_border_vertices</span>
<span class="sd">    soma_border_vertices_color</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">soma_border_vertices</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;working on soma border vertices&quot;</span><span class="p">)</span>
            <span class="n">unique_limb_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">plot_items_order</span><span class="p">])</span>
            <span class="n">all_soma_verts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;touching_soma_vertices&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> 
                                        <span class="n">input_neuron</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span> <span class="k">for</span> <span class="n">curr_limb_idx</span> <span class="ow">in</span> <span class="n">unique_limb_names</span><span class="p">]</span>

            
            <span class="n">new_borders</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">all_soma_verts</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">soma_border_vertices_color</span> <span class="o">!=</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                <span class="n">new_borders_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_border_vertices_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">new_borders</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_borders_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span><span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_borders</span><span class="p">),</span><span class="n">alpha_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">curr_scatter</span><span class="p">,</span><span class="n">curr_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_borders</span><span class="p">,</span><span class="n">new_borders_colors</span><span class="p">):</span>
                <span class="n">plot_ipv_scatter</span><span class="p">(</span><span class="n">curr_scatter</span><span class="p">,</span><span class="n">scatter_color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span>
                            <span class="n">scatter_size</span><span class="o">=</span><span class="n">soma_border_vertices_size</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
                <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_scatter</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">scatters_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">scatters_colors</span><span class="p">]</span>
        
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scatters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">scatters_colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_scatter_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">scatters</span><span class="p">)</span>

<span class="c1">#     print(f&quot;scatters = {scatters}&quot;)</span>
<span class="c1">#     print(f&quot;scatters_colors = {scatters_colors}&quot;)</span>
    
    
    <span class="k">for</span> <span class="n">curr_scatter</span><span class="p">,</span><span class="n">curr_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">scatters</span><span class="p">,</span><span class="n">scatters_colors</span><span class="p">):</span>
        
<span class="c1">#         print(f&quot;curr_scatter = {curr_scatter}&quot;)</span>
<span class="c1">#         print(f&quot;curr_color = {curr_color}&quot;)</span>
<span class="c1">#         print(f&quot;scatter_size= {scatter_size}&quot;)</span>
        
        <span class="n">plot_ipv_scatter</span><span class="p">(</span><span class="n">curr_scatter</span><span class="p">,</span><span class="n">scatter_color</span><span class="o">=</span><span class="n">curr_color</span><span class="p">,</span>
                    <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
        
        <span class="n">main_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_scatter</span><span class="p">)</span>   
        
        
        
    <span class="c1"># ---------- 6/9: Applying the Synapse Scatters -------#</span>
    

    <span class="n">syu</span><span class="o">.</span><span class="n">append_synapses_to_plot</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">,</span>
                               <span class="n">total_synapses</span> <span class="o">=</span> <span class="n">total_synapses</span><span class="p">,</span>
                                <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_dict_valid</span><span class="p">(</span><span class="n">input_neuron</span><span class="p">,</span>
                                                                              <span class="n">limb_branch_dict</span><span class="p">),</span>
                                <span class="n">total_synapses_size</span> <span class="o">=</span> <span class="n">total_synapses_size</span><span class="p">,</span>
                                <span class="n">limb_branch_synapses</span> <span class="o">=</span> <span class="n">limb_branch_synapses</span><span class="p">,</span>
                                <span class="n">limb_branch_synapse_type</span> <span class="o">=</span> <span class="n">limb_branch_synapse_type</span><span class="p">,</span>
                                <span class="n">distance_errored_synapses</span> <span class="o">=</span> <span class="n">distance_errored_synapses</span><span class="p">,</span>
                                <span class="n">mesh_errored_synapses</span> <span class="o">=</span> <span class="n">mesh_errored_synapses</span><span class="p">,</span>
                                <span class="n">soma_synapses</span> <span class="o">=</span> <span class="n">soma_synapses</span><span class="p">,</span>
                                <span class="n">limb_branch_size</span> <span class="o">=</span> <span class="n">limb_branch_size</span><span class="p">,</span>
                                <span class="n">distance_errored_size</span> <span class="o">=</span> <span class="n">distance_errored_size</span><span class="p">,</span>
                                <span class="n">mesh_errored_size</span> <span class="o">=</span> <span class="n">mesh_errored_size</span><span class="p">,</span>
                                <span class="n">soma_size</span> <span class="o">=</span> <span class="n">soma_size</span><span class="p">,)</span>
    

        
    <span class="c1">#To uncomment for full graphing</span>
    
    <span class="c1">#create the main mesh vertices for setting the bounding box</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No vertices plotted in the entire function&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">main_vertices</span> <span class="o">=</span> <span class="n">main_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#get rid of all empty ones</span>
        <span class="n">main_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">main_vertices</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">main_vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No vertices plotted in the entire function (after took out empty vertices)&quot;</span><span class="p">)</span>
    
    <span class="n">main_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">main_vertices</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">main_vertices</span> <span class="o">=</span> <span class="n">main_vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">main_vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">main_vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="n">volume_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">main_vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">volume_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">main_vertices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting volume min/max = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="c1">#setting the min/max of the plots</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">volume_max</span> <span class="o">-</span> <span class="n">volume_min</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
    <span class="n">min_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">max_index</span><span class="p">:</span>
            <span class="n">min_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">buffer</span>
            <span class="n">max_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">buffer</span> 
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">min_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span>  <span class="o">-</span> <span class="n">buffer</span>
            <span class="n">max_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">difference</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">buffer</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;calculating max limits = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">ipv</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">min_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">max_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ipv</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">min_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">max_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ipv</span><span class="o">.</span><span class="n">zlim</span><span class="p">(</span><span class="n">min_limits</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">max_limits</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;setting ipyvolume max limits = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">set_style_light</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">axis_box_off</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">axes_off</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">box_off</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">axes_on</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">box_on</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting axis and box on/off = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ipv.show= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">html_path</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">pylab</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">html_path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saving html = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
        


    
    <span class="k">if</span> <span class="n">return_color_dict</span><span class="p">:</span>
        <span class="c1">#build the color dictionary</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">color_list_correct_size</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No color dictionary to return because plot_items_order or color_list_correct_size empty&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for run = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">total_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">color_dict_to_return</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">,</span><span class="n">color_list_correct_size</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">color_dict_to_return</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plot_items_order</span><span class="p">,</span><span class="n">color_list_correct_size</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Length of first element in plot_items order is greater than 2 elements&quot;</span><span class="p">)</span>
        
        <span class="c1">#whether to add soma mappings to the list of colors:</span>
        <span class="c1">#soma_names, soma_colors_list_alpha_fixed_size</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="n">color_dict_to_return_soma</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_names</span><span class="p">,</span><span class="n">soma_colors_list_alpha_fixed_size</span><span class="p">)])</span>
            <span class="n">color_dict_to_return</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">color_dict_to_return_soma</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        
        <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing color dictionary = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for run = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">total_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">color_dict_to_return</span>
        
        
    <span class="k">if</span> <span class="n">zoom_coordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">set_zoom</span><span class="p">(</span><span class="n">zoom_coordinate</span><span class="p">,</span>
                          <span class="n">radius</span> <span class="o">=</span> <span class="n">zoom_radius</span><span class="p">,</span>
                          <span class="n">radius_xyz</span> <span class="o">=</span> <span class="n">zoom_radius_xyz</span><span class="p">)</span>
        
    
    <span class="n">ipvu</span><span class="o">.</span><span class="n">hide_legend_panel</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">print_time</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total time for run = </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">total_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="plot_spines"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_spines">[docs]</a><span class="k">def</span> <span class="nf">plot_spines</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                <span class="n">mesh_whole_neuron_alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                <span class="n">mesh_whole_neuron_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                <span class="n">mesh_spines_alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                <span class="n">spine_color</span><span class="o">=</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">visualize_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                          <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
                          <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">mesh_whole_neuron_alpha</span> <span class="o">=</span> <span class="n">mesh_whole_neuron_alpha</span><span class="p">,</span>
                            <span class="n">mesh_whole_neuron_color</span><span class="o">=</span><span class="n">mesh_whole_neuron_color</span><span class="p">,</span>
                        <span class="n">mesh_spines</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">mesh_spines_color</span> <span class="o">=</span> <span class="n">spine_color</span><span class="p">,</span>
                        <span class="n">mesh_spines_alpha</span> <span class="o">=</span> <span class="n">mesh_spines_alpha</span><span class="p">,</span>
                     <span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span>

                         <span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_boutons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_boutons">[docs]</a><span class="k">def</span> <span class="nf">plot_boutons</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                <span class="n">mesh_whole_neuron_alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                <span class="n">mesh_whole_neuron_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                <span class="n">boutons_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                <span class="n">mesh_boutons_alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">plot_web</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">web_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                 <span class="n">mesh_web_alpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">visualize_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                          <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
                          <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">mesh_whole_neuron_alpha</span> <span class="o">=</span> <span class="n">mesh_whole_neuron_alpha</span><span class="p">,</span>
                            <span class="n">mesh_whole_neuron_color</span><span class="o">=</span><span class="n">mesh_whole_neuron_color</span><span class="p">,</span>
                        <span class="n">mesh_boutons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">mesh_boutons_color</span> <span class="o">=</span> <span class="n">boutons_color</span><span class="p">,</span>
                        <span class="n">mesh_boutons_alpha</span> <span class="o">=</span> <span class="n">mesh_boutons_alpha</span><span class="p">,</span>
                         <span class="n">mesh_web</span> <span class="o">=</span> <span class="n">plot_web</span><span class="p">,</span>
                        <span class="n">mesh_web_color</span> <span class="o">=</span> <span class="n">web_color</span><span class="p">,</span>
                        <span class="n">mesh_web_alpha</span> <span class="o">=</span> <span class="n">mesh_web_alpha</span><span class="p">,</span>
                     <span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span>

                         <span class="p">)</span></div>
<span class="c1"># -------  9/24: Wrapper for the sk.graph function that is nicer to interface with ----#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">def graph_skeleton_and_mesh(main_mesh_verts=[],</span>
<span class="sd">                            main_mesh_faces=[],</span>
<span class="sd">                            unique_skeleton_verts_final=[],</span>
<span class="sd">                            edges_final=[],</span>
<span class="sd">                            edge_coordinates=[],</span>
<span class="sd">                            other_meshes=[],</span>
<span class="sd">                            other_meshes_colors =  [],</span>
<span class="sd">                            mesh_alpha=0.2,</span>
<span class="sd">                            other_meshes_face_components = [],</span>
<span class="sd">                            other_skeletons = [],</span>
<span class="sd">                            other_skeletons_colors =  [],</span>
<span class="sd">                            return_other_colors = False,</span>
<span class="sd">                            main_mesh_color = [0.,1.,0.,0.2],</span>
<span class="sd">                            main_skeleton_color = [0,0.,1,1],</span>
<span class="sd">                            main_mesh_face_coloring = [],</span>
<span class="sd">                            other_scatter=[],</span>
<span class="sd">                            scatter_size = 0.3,</span>
<span class="sd">                            other_scatter_colors=[],</span>
<span class="sd">                            main_scatter_color=[1.,0.,0.,0.5],</span>
<span class="sd">                            buffer=1000,</span>
<span class="sd">                           axis_box_off=True,</span>
<span class="sd">                           html_path=&quot;&quot;,</span>
<span class="sd">                           show_at_end=True,</span>
<span class="sd">                           append_figure=False):</span>
<span class="sd">                           </span>
<span class="sd">things that need to be changed:</span>
<span class="sd">1) main_mesh combined</span>
<span class="sd">2) edge_coordinates is just the main_skeleton</span>
<span class="sd">other_scatter --&gt; scatters</span>
<span class="sd">3) change all the other_[]_colors names</span>


<span class="sd">*if other inputs aren&#39;t list then make them list</span>
<span class="sd">                           </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def plot_objects(main_mesh=None,</span>
<span class="sd">                 main_skeleton=None,</span>
<span class="sd">                 main_mesh_color = [0.,1.,0.,0.2],</span>
<span class="sd">                 main_mesh_alpha = None,</span>
<span class="sd">                 </span>
<span class="sd">                main_skeleton_color = [0,0.,1,1],</span>
<span class="sd">                meshes=[],</span>
<span class="sd">                meshes_colors =  [],</span>
<span class="sd">                mesh_alpha=0.2,</span>
<span class="sd">                            </span>
<span class="sd">                skeletons = [],</span>
<span class="sd">                skeletons_colors =  [],</span>
<span class="sd">                            </span>
<span class="sd">                scatters=[],</span>
<span class="sd">                scatters_colors=[],</span>
<span class="sd">                scatter_size = 0.3,</span>
<span class="sd">                main_scatter_color=&quot;red&quot;,#[1.,0.,0.,0.5],</span>
<span class="sd">                scatter_with_widgets = True,</span>
<span class="sd">                 </span>
<span class="sd">                buffer=0,#1000,</span>
<span class="sd">                axis_box_off=True,</span>
<span class="sd">                html_path=&quot;&quot;,</span>
<span class="sd">                show_at_end=True,</span>
<span class="sd">                append_figure=False,</span>
<span class="sd">                flip_y=True,</span>
<span class="sd">                </span>
<span class="sd">                subtract_from_main_mesh=True,</span>
<span class="sd">                set_zoom = True, #used for the skeleton graph</span>
<span class="sd">                zoom_coordinate=None,</span>
<span class="sd">                zoom_radius = None,</span>
<span class="sd">                zoom_radius_xyz = None,</span>
<span class="sd">                adaptive_min_max_limits = True):</span>
<span class="sd">    #from neurd import neuron_visualizations as nviz</span>
<span class="sd">    #nviz = reload(nviz)</span>
<span class="sd">    </span>
<span class="sd">    if (main_mesh is None </span>
<span class="sd">        and main_skeleton is None </span>
<span class="sd">        and len(meshes) == 0</span>
<span class="sd">        and len(skeletons) == 0</span>
<span class="sd">        and len(scatters) == 0):</span>
<span class="sd">        print(&quot;Nothing to plot so returning&quot;)</span>
<span class="sd">        return </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    if main_skeleton is None:</span>
<span class="sd">        edge_coordinates = []</span>
<span class="sd">    else:</span>
<span class="sd">        edge_coordinates=main_skeleton</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    convert_to_list_vars = [meshes,meshes_colors,skeletons,</span>
<span class="sd">                            skeletons_colors,scatters,scatters_colors,scatter_size]</span>
<span class="sd">    </span>
<span class="sd">    def convert_to_list(curr_item):</span>
<span class="sd">        if type(curr_item) != list:</span>
<span class="sd">            if nu.is_array_like(curr_item):</span>
<span class="sd">                return list(curr_item)</span>
<span class="sd">            else:</span>
<span class="sd">                return [curr_item]</span>
<span class="sd">        else:</span>
<span class="sd">            return curr_item</span>
<span class="sd">    </span>
<span class="sd">    meshes =  convert_to_list(meshes)</span>
<span class="sd">    meshes_colors =  convert_to_list(meshes_colors)</span>
<span class="sd">    skeletons =  convert_to_list(skeletons)</span>
<span class="sd">    skeletons_colors =  convert_to_list(skeletons_colors)</span>
<span class="sd">    scatters =  convert_to_list(scatters)</span>
<span class="sd">    scatters_colors =  convert_to_list(scatters_colors)</span>
<span class="sd">    </span>
<span class="sd">    # --- 6/10: Making sure all scatters are numpy arrays ---</span>
<span class="sd">    scatters = [np.array(s).reshape(-1,3) for s in scatters]</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    if (subtract_from_main_mesh and (not main_mesh is None) and (len(meshes)&gt;0)):</span>
<span class="sd">        main_mesh = tu.subtract_mesh(original_mesh=main_mesh,</span>
<span class="sd">                                  subtract_mesh=meshes,exact_match=False)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    if main_mesh is None or nu.is_array_like(main_mesh):</span>
<span class="sd">        main_mesh_verts = []</span>
<span class="sd">        main_mesh_faces= []</span>
<span class="sd">    else:</span>
<span class="sd">        main_mesh_verts = main_mesh.vertices</span>
<span class="sd">        main_mesh_faces= main_mesh.faces</span>
<span class="sd">        </span>
<span class="sd">    if main_mesh_alpha is None:</span>
<span class="sd">        main_mesh_alpha = 0.2</span>
<span class="sd">    else: </span>
<span class="sd">        if nu.is_array_like(main_mesh_color):</span>
<span class="sd">            main_mesh_color = list(main_mesh_color)</span>
<span class="sd">            if len(main_mesh_color) == 4:</span>
<span class="sd">                main_mesh_color[3] = main_mesh_alpha</span>
<span class="sd">            else:</span>
<span class="sd">                main_mesh_color.append(main_mesh_alpha)</span>
<span class="sd">            </span>
<span class="sd">    </span>
<span class="sd">    if type(main_mesh_color) == str:</span>
<span class="sd">        main_mesh_color = mu.color_to_rgba(main_mesh_color,alpha=main_mesh_alpha)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    #print(f&quot;scatters = {scatters}&quot;)</span>
<span class="sd">    return_value = sk.graph_skeleton_and_mesh(main_mesh_verts=main_mesh_verts,</span>
<span class="sd">                           main_mesh_faces=main_mesh_faces,</span>
<span class="sd">                           edge_coordinates=edge_coordinates,</span>
<span class="sd">                           other_meshes=meshes,</span>
<span class="sd">                                      mesh_alpha=mesh_alpha,</span>
<span class="sd">                            other_meshes_colors=meshes_colors,</span>
<span class="sd">                            other_skeletons=skeletons,</span>
<span class="sd">                            other_skeletons_colors=skeletons_colors,</span>
<span class="sd">                            other_scatter=scatters,</span>
<span class="sd">                            other_scatter_colors=scatters_colors,</span>
<span class="sd">                            scatter_size=scatter_size,</span>
<span class="sd">                            main_scatter_color=main_scatter_color,</span>
<span class="sd">                            scatter_with_widgets=scatter_with_widgets,             </span>
<span class="sd">                                              </span>
<span class="sd">                            buffer=buffer,</span>
<span class="sd">                            axis_box_off=axis_box_off,</span>
<span class="sd">                            html_path=html_path,</span>
<span class="sd">                            show_at_end=show_at_end,</span>
<span class="sd">                            append_figure=append_figure,</span>
<span class="sd">                            flip_y=flip_y,</span>
<span class="sd">                                      main_mesh_color=main_mesh_color,</span>
<span class="sd">                                    main_skeleton_color = main_skeleton_color,</span>
<span class="sd">                                              </span>
<span class="sd">                            set_zoom=set_zoom,</span>
<span class="sd">                            adaptive_min_max_limits=adaptive_min_max_limits,</span>
<span class="sd">                           )</span>
<span class="sd">    #return </span>
<span class="sd">    </span>
<span class="sd">    if zoom_coordinate is not None:</span>
<span class="sd">        print(f&quot;Trying to set zoom&quot;)</span>
<span class="sd">        nviz.set_zoom(zoom_coordinate,</span>
<span class="sd">                          radius = zoom_radius,</span>
<span class="sd">                          radius_xyz = zoom_radius_xyz)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    return return_value</span>
<span class="sd">&#39;&#39;&#39;</span>
            
        
<div class="viewcode-block" id="plot_branch_spines"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_spines">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_spines</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">plot_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot a branch with certain spines</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_spines</span> <span class="o">=</span> <span class="p">[</span><span class="n">tu</span><span class="o">.</span><span class="n">empty_mesh</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_spines</span> <span class="o">=</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">spines</span>
        
    <span class="n">shaft_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">subtract_mesh</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="n">curr_spines</span><span class="p">,</span><span class="n">exact_match</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_skeletons</span><span class="p">:</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">shaft_mesh</span><span class="p">,</span>
                     <span class="n">meshes</span><span class="o">=</span><span class="n">curr_spines</span><span class="p">,</span>
                      <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
                      <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="plot_split_suggestions_per_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_split_suggestions_per_limb">[docs]</a><span class="k">def</span> <span class="nf">plot_split_suggestions_per_limb</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_results</span><span class="p">,</span>
    <span class="c1">#red_blue_splits=None,</span>
    <span class="n">scatter_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">scatter_alpha</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
    <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">add_components_colors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">component_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">path_cut_info</span> <span class="ow">in</span> <span class="n">limb_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">component_colors_cp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">component_colors</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">-------- Suggestions for Limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">------&quot;</span><span class="p">)</span>
        
        <span class="n">curr_scatters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path_i</span> <span class="ow">in</span> <span class="n">path_cut_info</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_i</span><span class="p">[</span><span class="s2">&quot;coordinate_suggestions&quot;</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">curr_scatters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">path_i</span><span class="p">[</span><span class="s2">&quot;coordinate_suggestions&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
                
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_scatters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> No suggested cuts for this limb!!&quot;</span><span class="p">)</span>
            
            <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">},</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                             <span class="n">skeleton_color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                             <span class="p">)</span>
            <span class="k">continue</span>
            
        <span class="n">curr_scatters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">curr_scatters</span><span class="p">)</span>
        <span class="n">scatter_color_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mu</span><span class="o">.</span><span class="n">color_to_rgba</span><span class="p">(</span><span class="n">scatter_color</span><span class="p">,</span><span class="n">scatter_alpha</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_scatters</span><span class="p">)</span>
        
        <span class="c1"># will create a dictionary that will show all of the disconnected components in different colors</span>
        <span class="k">if</span> <span class="n">add_components_colors</span><span class="p">:</span>
            <span class="n">curr_limb</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">cut_limb_network_by_suggestions</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]),</span>
                                                      <span class="n">path_cut_info</span><span class="p">)</span>
            <span class="n">limb_nx</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span>
            
<span class="c1">#             for cut in path_cut_info:</span>
<span class="c1">#                 limb_nx.remove_edges_from(cut[&quot;edges_to_cut&quot;])</span>
<span class="c1">#                 limb_nx.add_edges_from(cut[&quot;edges_to_add&quot;])</span>
            
            <span class="n">conn_comp</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">limb_nx</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">component_colors_cp</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
                <span class="n">component_colors_cp</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span><span class="n">n_colors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">component_colors_cp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">component_colors_cp</span> <span class="o">=</span> <span class="n">component_colors_cp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">component_colors_cp</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">component_colors_cp</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">)</span>

            <span class="n">color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">groud_ids</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">conn_comp</span><span class="p">,</span><span class="n">component_colors_cp</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">groud_ids</span><span class="p">:</span>
                    <span class="n">color_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                    
            <span class="n">mesh_component_colors</span> <span class="o">=</span> <span class="n">color_dict</span>
            <span class="n">skeleton_component_colors</span> <span class="o">=</span> <span class="n">color_dict</span>
            <span class="c1">#print(f&quot;skeleton_component_colors = {color_dict}&quot;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh_component_colors</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span>
            <span class="n">skeleton_component_colors</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
            
        <span class="c1">#at this point have all of the scatters we want</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">},</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">mesh_component_colors</span><span class="p">},</span>
                             <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_color_alpha</span><span class="p">,</span>
                             <span class="n">skeleton_color</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">skeleton_component_colors</span><span class="p">},</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">curr_scatters</span><span class="p">],</span>
                             <span class="n">scatters_colors</span><span class="o">=</span><span class="n">scatter_color_list</span><span class="p">,</span>
                             <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                              <span class="n">mesh_soma_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>
        

        
        
<div class="viewcode-block" id="visualize_neuron_path"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron_path">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron_path</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">limb_idx</span><span class="p">,</span>
                          <span class="n">path</span><span class="p">,</span>
                          <span class="n">path_mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                          <span class="n">path_skeleton_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                          <span class="n">mesh_fill_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                          <span class="n">skeleton_fill_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                         <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[],</span>
                         <span class="n">scatter_color_list</span><span class="o">=</span><span class="p">[],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">curr_limb_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_idx</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
    

    <span class="n">mesh_component_colors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">path_mesh_color</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
    <span class="n">skeleton_component_colors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">path_skeleton_color</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">])</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">},</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">mesh_component_colors</span><span class="p">},</span>
                              <span class="n">mesh_fill_color</span><span class="o">=</span><span class="n">mesh_fill_color</span><span class="p">,</span>
                          
                             <span class="n">skeleton_color</span><span class="o">=</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">skeleton_component_colors</span><span class="p">},</span>
                          <span class="n">skeleton_fill_color</span><span class="o">=</span><span class="n">skeleton_fill_color</span><span class="p">,</span>
                             <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
                             <span class="n">scatters_colors</span><span class="o">=</span><span class="n">scatter_color_list</span><span class="p">,</span>
                             <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="limb_correspondence_plottable"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.limb_correspondence_plottable">[docs]</a><span class="k">def</span> <span class="nf">limb_correspondence_plottable</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">,</span>
                                  <span class="n">mesh_name</span><span class="o">=</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">,</span>
                                 <span class="n">combine</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the meshes and skeleton parts from limb correspondence so can be plotted</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># then we have a limb correspondence with multiple objects</span>
        <span class="n">meshes</span><span class="o">=</span><span class="n">gu</span><span class="o">.</span><span class="n">combine_list_of_lists</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="n">mesh_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ki</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">skeletons</span><span class="o">=</span><span class="n">gu</span><span class="o">.</span><span class="n">combine_list_of_lists</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ki</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="n">mesh_name</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;branch_skeleton&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    
    <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">meshes</span><span class="p">)</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">stack_skeletons</span><span class="p">(</span><span class="n">skeletons</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">meshes</span><span class="p">,</span><span class="n">skeletons</span></div>

<div class="viewcode-block" id="plot_limb_correspondence"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_limb_correspondence">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_correspondence</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">,</span>
                            <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                            <span class="n">skeleton_colors</span><span class="o">=</span><span class="s2">&quot;random&quot;</span><span class="p">,</span>
                            <span class="n">mesh_name</span><span class="o">=</span><span class="s2">&quot;branch_mesh&quot;</span><span class="p">,</span>
                            <span class="n">scatters</span><span class="o">=</span><span class="p">[],</span>
                            <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">meshes</span><span class="p">,</span><span class="n">skeletons</span> <span class="o">=</span> <span class="n">limb_correspondence_plottable</span><span class="p">(</span><span class="n">limb_correspondence</span><span class="p">,</span><span class="n">mesh_name</span><span class="o">=</span><span class="n">mesh_name</span><span class="p">)</span>
        
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                      <span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
                     <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">skeleton_colors</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
        <span class="n">scatter_size</span> <span class="o">=</span> <span class="n">scatter_size</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
                     <span class="p">)</span></div>
    
    
<div class="viewcode-block" id="plot_limb_path"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_limb_path">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To highlight the nodes on a path</span>
<span class="sd">    with just given a limb object</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the entire limb mesh will be the main mesh</span>
<span class="sd">    2) Get the meshes corresponding to the path</span>
<span class="sd">    3) Get all of the skeletons</span>
<span class="sd">    4) plot</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                        <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span>
                      <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">path</span><span class="p">],</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
    
<span class="c1"># ----------- For plotting classifications ------------------ #</span>
<div class="viewcode-block" id="plot_labeled_limb_branch_dicts"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_labeled_limb_branch_dicts">[docs]</a><span class="k">def</span> <span class="nf">plot_labeled_limb_branch_dicts</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">labels</span><span class="p">,</span>
                           <span class="n">colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                          <span class="n">skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="n">print_color_map</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will plot the limb branches for certain labels</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nviz.plot_labeled_limb_branch_dicts(n_test,</span>
<span class="sd">                                   [&quot;apical&quot;,&quot;apical_shaft&quot;,&quot;axon&quot;],</span>
<span class="sd">                                   [&quot;blue&quot;,&quot;aqua&quot;,&quot;red&quot;],</span>
<span class="sd">                                   )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        
    <span class="n">limb_branch_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">],</span>
                             <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">skeleton</span><span class="p">:</span>
        <span class="n">visualize_type</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">visualize_type</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">]</span>
        
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict_multiple</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_branch_dicts</span><span class="p">,</span>
                                       <span class="n">color_list</span> <span class="o">=</span> <span class="n">colors</span><span class="p">,</span>
                                       <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                                       <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_color_map</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">colors</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_axon"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_axon">[docs]</a><span class="k">def</span> <span class="nf">plot_axon</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">],</span>
                             <span class="p">)</span>
    <span class="n">axon_skeleton</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_skeleton</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">skeleton_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                          <span class="n">total_synapses</span><span class="o">=</span><span class="n">plot_synapses</span><span class="p">,</span>
                         <span class="p">)</span></div>
<div class="viewcode-block" id="plot_dendrite_and_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_dendrite_and_synapses">[docs]</a><span class="k">def</span> <span class="nf">plot_dendrite_and_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">,</span>
                     <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span>
                     <span class="n">skeleton_color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                     <span class="n">limb_branch_synapses</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_axon_merge_errors"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_axon_merge_errors">[docs]</a><span class="k">def</span> <span class="nf">plot_axon_merge_errors</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="n">error_limb_branch_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon-like&quot;</span><span class="p">],</span>
                             <span class="n">not_matching_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon&quot;</span><span class="p">]</span>
                             <span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">error_limb_branch_dict</span><span class="p">,</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
    
    


<div class="viewcode-block" id="plot_branch_with_boutons_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_with_boutons_old">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_with_boutons_old</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                            <span class="n">bouton_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                            <span class="n">non_bouton_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                             <span class="n">main_mesh_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
                            <span class="n">non_bouton_size_filter</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
                            <span class="n">non_bouton_filtered_away_color</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To visualize a branch object with the bouton information </span>
<span class="sd">    plotted</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="s2">&quot;non_boutons&quot;</span><span class="p">):</span>
        <span class="n">non_bouton_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">non_bouton_flag</span> <span class="o">=</span> <span class="kc">False</span>
        
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="s2">&quot;boutons&quot;</span><span class="p">):</span>
        <span class="n">b_meshes</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">boutons</span>
        
        <span class="k">if</span> <span class="n">non_bouton_flag</span><span class="p">:</span>
            <span class="n">non_b_meshes</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">non_boutons</span>

            <span class="c1"># splitting the non significant non_bouton meshes</span>
            <span class="k">if</span> <span class="n">non_bouton_size_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">non_b_kept_idx</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">filter_meshes_by_size</span><span class="p">(</span><span class="n">non_b_meshes</span><span class="p">,</span>
                    <span class="n">size_threshold</span> <span class="o">=</span> <span class="n">non_bouton_size_filter</span><span class="p">,</span>
                    <span class="n">return_indices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">non_b_filtered_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_b_meshes</span><span class="p">)),</span><span class="n">non_b_kept_idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying filtering away:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;non_b_kept_idx = </span><span class="si">{</span><span class="n">non_b_kept_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;non_b_filtered_idx = </span><span class="si">{</span><span class="n">non_b_filtered_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">non_b_meshes_filtered</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">non_b_meshes</span><span class="p">)[</span><span class="n">non_b_filtered_idx</span><span class="p">])</span>
                <span class="n">non_b_meshes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">non_b_meshes</span><span class="p">)[</span><span class="n">non_b_kept_idx</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">non_b_kept_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_b_meshes</span><span class="p">))</span>
                <span class="n">non_b_meshes_filtered</span> <span class="o">=</span> <span class="p">[]</span>
        
  
        <span class="n">non_bouton_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="s2">&quot;non_bouton&quot;</span><span class="p">][</span><span class="n">non_b_kept_idx</span><span class="p">])</span>
        <span class="n">non_bouton_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">width_array</span><span class="p">[</span><span class="s2">&quot;non_bouton&quot;</span><span class="p">][</span><span class="n">non_b_kept_idx</span><span class="p">])</span>

        <span class="n">width_info_to_print</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">non_bouton_mean</span><span class="o">=</span><span class="n">non_bouton_mean</span><span class="p">,</span>
                                  <span class="n">non_bouton_median</span><span class="o">=</span><span class="n">non_bouton_median</span><span class="p">,</span>
                                  <span class="p">)</span>
        <span class="n">width_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;bouton_mean&quot;</span><span class="p">,</span>
          <span class="s2">&quot;bouton_median&quot;</span><span class="p">,</span>
          <span class="s2">&quot;non_bouton_mean&quot;</span><span class="p">,</span>
          <span class="s2">&quot;non_bouton_median&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;no_spine_median_mesh_center&quot;</span>
                      <span class="p">]</span>
        
        <span class="k">for</span> <span class="n">w_t</span> <span class="ow">in</span> <span class="n">width_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">w_t</span> <span class="ow">in</span> <span class="n">width_info_to_print</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">curr_width</span> <span class="o">=</span> <span class="n">width_info_to_print</span><span class="p">[</span><span class="n">w_t</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_width</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">w_t</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">w_t</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">curr_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">non_bouton_filtered_away_color</span> <span class="o">==</span> <span class="s2">&quot;random&quot;</span><span class="p">:</span>
            <span class="n">non_b_meshes_too_small_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_unique_random_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">non_b_meshes_filtered</span><span class="p">),</span>
                                        <span class="n">colors_to_omit</span><span class="o">=</span><span class="p">[</span><span class="n">bouton_color</span><span class="p">,</span><span class="n">non_bouton_color</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_b_meshes_too_small_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">non_bouton_filtered_away_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">non_b_meshes_filtered</span><span class="p">)</span>

        <span class="n">color_list</span> <span class="o">=</span> <span class="p">([</span><span class="n">bouton_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">b_meshes</span><span class="p">)</span> <span class="o">+</span> 
                      <span class="p">[</span><span class="n">non_bouton_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">non_b_meshes</span><span class="p">)</span> <span class="o">+</span> 
                      <span class="n">non_b_meshes_too_small_colors</span><span class="p">)</span>
                      
                      
        <span class="n">meshes_list</span> <span class="o">=</span> <span class="n">b_meshes</span> <span class="o">+</span> <span class="n">non_b_meshes</span> <span class="o">+</span> <span class="n">non_b_meshes_filtered</span>

        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">main_mesh_color</span><span class="o">=</span><span class="n">main_mesh_color</span><span class="p">,</span>
                          <span class="n">main_mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">meshes</span><span class="o">=</span><span class="n">meshes_list</span><span class="p">,</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No bouton processing done&quot;</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="plot_branches_with_mesh_attribute"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branches_with_mesh_attribute">[docs]</a><span class="k">def</span> <span class="nf">plot_branches_with_mesh_attribute</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span>
                                      <span class="n">mesh_attribute</span><span class="p">,</span>
                                      <span class="n">plot_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To plot the branch meshes and their spines</span>
<span class="sd">    with information about them</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">plot_skeletons</span><span class="p">:</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="n">total_mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">])</span>

    
    <span class="n">all_spine_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">and</span>  
            <span class="nb">getattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">all_spine_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">mesh_attribute</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_spine_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_spines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">all_spine_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s2"> to plot&quot;</span><span class="p">)</span>
        <span class="n">total_spines</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_branch</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">width_new</span><span class="si">}</span><span class="s2">, </span><span class="se">\n</span><span class="s2">n_</span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;n_</span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mesh_attribute</span> <span class="o">==</span> <span class="s2">&quot;spines&quot;</span><span class="p">:</span>
                  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; spine_density = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">spine_density</span><span class="si">}</span><span class="se">\n</span><span class="s2"> spine_volume_density = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">spine_volume_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeleton_length (in microns) = </span><span class="si">{</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;area = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">area</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_synapses = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">n_synapses</span><span class="si">}</span><span class="s2">, 85% width = </span><span class="si">{</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;ray_trace_percentile&#39;</span><span class="p">,</span><span class="mi">85</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_faces = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">total_mesh</span><span class="p">,</span>
                     <span class="n">meshes</span><span class="o">=</span><span class="n">total_spines</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                      <span class="n">mesh_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_branches_with_spines"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branches_with_spines">[docs]</a><span class="k">def</span> <span class="nf">plot_branches_with_spines</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="n">plot_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To plot the branch meshes and their spines</span>
<span class="sd">    with information about them</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plot_branches_with_mesh_attribute</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span>
                                      <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;spines&quot;</span><span class="p">,</span>
                                      <span class="n">plot_skeletons</span><span class="o">=</span><span class="n">plot_skeletons</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_branches_with_boutons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branches_with_boutons">[docs]</a><span class="k">def</span> <span class="nf">plot_branches_with_boutons</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="n">plot_skeletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To plot the branch meshes and their spines</span>
<span class="sd">    with information about them</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plot_branches_with_mesh_attribute</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span>
                                      <span class="n">mesh_attribute</span><span class="o">=</span><span class="s2">&quot;boutons&quot;</span><span class="p">,</span>
                                      <span class="n">plot_skeletons</span><span class="o">=</span><span class="n">plot_skeletons</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>
<span class="w">    </span>
<span class="sd">&#39;&#39;&#39;def plot_branches_with_spines(branches,plot_skeletons=True,</span>
<span class="sd">                             verbose=True):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    To plot the branch meshes and their spines</span>
<span class="sd">    with information about them</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    if not nu.is_array_like(branches):</span>
<span class="sd">        branches = [branches]</span>
<span class="sd">        </span>
<span class="sd">    if plot_skeletons:</span>
<span class="sd">        skeletons = [k.skeleton for k in branches]</span>
<span class="sd">    else:</span>
<span class="sd">        skeletons = []</span>
<span class="sd">        </span>
<span class="sd">    total_mesh = tu.combine_meshes([k.mesh for k in branches])</span>
<span class="sd">    </span>
<span class="sd">    all_spine_list = []</span>
<span class="sd">    for k in branches:</span>
<span class="sd">        if k.spines is not None and len(k.spines) &gt; 0:</span>
<span class="sd">            all_spine_list.append(k.spines)</span>
<span class="sd">    </span>
<span class="sd">    if len(all_spine_list) &gt; 0:</span>
<span class="sd">        total_spines = np.concatenate(all_spine_list)</span>
<span class="sd">    else:</span>
<span class="sd">        print(&quot;No spines to plot&quot;)</span>
<span class="sd">        total_spines = []</span>
<span class="sd">        </span>
<span class="sd">    if print_spine_info:</span>
<span class="sd">        for curr_branch in branches:</span>
<span class="sd">            print(f&quot;width = {curr_branch.width_new}, \nn_spines = {curr_branch.n_spines}, spine_density = {curr_branch.spine_density}\n spine_volume_density = {curr_branch.spine_volume_density}&quot;</span>
<span class="sd">                 f&quot;\nskeleton_length (in microns) = {sk.calculate_skeleton_distance(curr_branch.skeleton)/1000}\n&quot;</span>
<span class="sd">                 f&quot;area = {curr_branch.area}&quot;)</span>
<span class="sd">            </span>
<span class="sd">    nviz.plot_objects(total_mesh,</span>
<span class="sd">                     meshes=total_spines,</span>
<span class="sd">                     meshes_colors=&quot;red&quot;,</span>
<span class="sd">                      mesh_alpha=1,</span>
<span class="sd">                     skeletons=skeletons)&#39;&#39;&#39;</span>
<div class="viewcode-block" id="plot_branch_on_whole_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_on_whole_mesh">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_on_whole_mesh</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                             <span class="n">limb_idx</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will plot one branch with the background of whole neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">visualize_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visualize_type</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">]</span>
    <span class="n">limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
    <span class="n">ret_col</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="n">limb_name</span><span class="p">:[</span><span class="n">branch_idx</span><span class="p">]},</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                          <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                          <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                         <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="n">limb_branch_dict</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                          <span class="n">plot_random_color_map</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">dont_plot_if_empty</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    How to plot the color map along with: </span>
<span class="sd">    nviz.plot_limb_branch_dict(filt_neuron,</span>
<span class="sd">                          limb_branch_dict_to_cancel,</span>
<span class="sd">                          plot_random_color_map=True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dont_plot_if_empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_branch_dict empty &quot;</span><span class="p">)</span>
        <span class="k">return</span> 
    
    <span class="k">if</span> <span class="n">plot_random_color_map</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span>
        
    <span class="n">ret_col</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                          <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                          <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                         <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_random_color_map</span><span class="p">:</span>
        <span class="n">mu</span><span class="o">.</span><span class="n">plot_color_dict</span><span class="p">(</span><span class="n">ret_col</span><span class="p">)</span></div>
<span class="w">        </span>
<span class="sd">&quot;&quot;&quot;def plot_limb_branch_dicts(neuron_obj,</span>
<span class="sd">                           limb_branch_dicts,</span>
<span class="sd">                           colors = None,</span>
<span class="sd">                           visualize_type=[&quot;mesh&quot;],</span>
<span class="sd">                           alpha=1,</span>
<span class="sd">                           dont_plot_if_empty = True,</span>
<span class="sd">                           verbose = True,</span>
<span class="sd">                           **kwargs</span>
<span class="sd">                          ):</span>
<span class="sd">    if len(limb_branch_dicts) == 0 and dont_plot_if_empty:</span>
<span class="sd">        print(f&quot;limb_branch_dicts empty &quot;)</span>
<span class="sd">        return </span>
<span class="sd">    </span>
<span class="sd">    if colors is None:</span>
<span class="sd">        colors = mu.generate_non_randon_named_color_list(len(limb_branch_dicts))</span>
<span class="sd">    </span>
<span class="sd">    for j,(lb,lb_color) in enumerate(zip(limb_branch_dicts,colors)):</span>
<span class="sd">        if verbose:</span>
<span class="sd">            print(f&quot;limb branch {j} ({lb_color}): {lb}&quot;)</span>
<span class="sd">        </span>
<span class="sd">        show_at_end = False</span>
<span class="sd">        append_figure = True</span>
<span class="sd">        mesh_whole_neuron = False</span>
<span class="sd">        if j == 0:</span>
<span class="sd">            mesh_whole_neuron = True</span>
<span class="sd">            append_figure = False</span>
<span class="sd">        </span>
<span class="sd">        if j == len(limb_branch_dicts):</span>
<span class="sd">            show_at_end = True</span>
<span class="sd">            </span>

<span class="sd">        ret_col = nviz.visualize_neuron(neuron_obj,</span>
<span class="sd">                          visualize_type=visualize_type,</span>
<span class="sd">                         limb_branch_dict=lb,</span>
<span class="sd">                         mesh_color=lb_color,</span>
<span class="sd">                          skeleton_color=lb_color,</span>
<span class="sd">                          mesh_color_alpha=alpha,</span>
<span class="sd">                         mesh_whole_neuron=mesh_whole_neuron,</span>
<span class="sd">                        show_at_end = show_at_end,  </span>
<span class="sd">                        append_figure=append_figure,</span>
<span class="sd">                          return_color_dict=True,</span>
<span class="sd">                         **kwargs)&quot;&quot;&quot;</span>

    
<div class="viewcode-block" id="visualize_neuron_lite"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron_lite">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron_lite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                     <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    </div>

    
<div class="viewcode-block" id="visualize_neuron_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron_limbs">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limbs_to_plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">plot_soma_limb_network</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">limbs_to_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limbs_to_plot</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limbs_to_plot</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">limbs_to_plot</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">()</span>
        
    <span class="n">limb_branch</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="s2">&quot;all&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limbs_to_plot</span><span class="p">}</span>
    <span class="n">ret_col</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                      <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                     <span class="c1">#limb_branch_dict=&quot;all&quot;,</span>
                                    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch</span><span class="p">,</span>
                      <span class="n">mesh_resolution</span><span class="o">=</span><span class="s2">&quot;limb&quot;</span><span class="p">,</span>
                                <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">True</span>
                     <span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_soma_limb_network</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_soma_limb_concept_network</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">node_colors</span><span class="o">=</span><span class="n">ret_col</span><span class="p">)</span></div>
<div class="viewcode-block" id="visualize_subset_neuron_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_subset_neuron_limbs">[docs]</a><span class="k">def</span> <span class="nf">visualize_subset_neuron_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                 <span class="n">limbs_to_plot</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will just plot some of the limbs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron_limbs</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">limbs_to_plot</span><span class="p">,</span>
                               <span class="n">plot_soma_limb_network</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="visualize_neuron_specific_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron_specific_limb">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron_specific_limb</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                  <span class="p">):</span>
    <span class="k">if</span> <span class="n">limb_idx</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">or</span> <span class="n">limb_name</span> <span class="o">==</span> <span class="s2">&quot;axon&quot;</span><span class="p">:</span>
        <span class="n">limb_name</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_name</span>
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">limb_name</span> <span class="o">=</span> <span class="n">limb_idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limb_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">&quot;</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_name = </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">ret_col</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">limb_branch_dict</span><span class="o">=</span><span class="p">{</span><span class="n">limb_name</span><span class="p">:</span><span class="s2">&quot;all&quot;</span><span class="p">},</span>
                      <span class="n">return_color_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_color_alpha</span><span class="p">,</span>         
                     <span class="p">)</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_concept_network_2D</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">ret_col</span><span class="p">)</span></div>
    
<span class="n">plot_limb_idx</span> <span class="o">=</span> <span class="n">visualize_neuron_specific_limb</span>
<span class="n">plot_limb</span> <span class="o">=</span> <span class="n">visualize_neuron_specific_limb</span>

<div class="viewcode-block" id="plot_valid_error_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_valid_error_synapses">[docs]</a><span class="k">def</span> <span class="nf">plot_valid_error_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">synapse_dict</span><span class="p">,</span>
                             <span class="n">synapse_scatter_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                              <span class="n">valid_presyn_color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
                              <span class="n">valid_postsyn_color</span><span class="o">=</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                              <span class="n">error_presyn_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
                              <span class="n">error_postsyn_color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span>
                              <span class="n">error_presyn_non_axon_color</span> <span class="o">=</span> <span class="s2">&quot;brown&quot;</span><span class="p">,</span>
                             <span class="n">meshes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">meshes_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              
                              <span class="n">scatter_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">scatters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">scatters_colors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">plot_error_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              
                              <span class="n">mesh_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                              <span class="n">main_mesh_alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                              
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot Neuron along with the presyn and postsyn</span>
<span class="sd">    errored synapses</span>
<span class="sd">    </span>
<span class="sd">    synapse_dict must have the following keys:</span>
<span class="sd">    valid_syn_centers_presyn</span>
<span class="sd">    errored_syn_centers_presyn</span>
<span class="sd">    valid_syn_centers_postsyn</span>
<span class="sd">    errored_syn_centers_postsyn</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">False</span>
    
    
    <span class="n">filtered_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span> 
    <span class="n">synapse_center_coordinates</span> <span class="o">=</span> <span class="n">synapse_dict</span>
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;synapse_center_coordinates = </span><span class="si">{</span><span class="n">synapse_center_coordinates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">scatter_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_size</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">if</span> <span class="n">scatters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatters</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">if</span> <span class="n">scatters_colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    <span class="k">if</span> <span class="n">neuron_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">main_mesh</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">()):</span>
        <span class="n">main_mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span>
        <span class="k">if</span> <span class="n">meshes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meshes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">main_mesh</span><span class="o">=</span><span class="n">filtered_neuron</span><span class="o">.</span><span class="n">mesh_from_branches</span>
        <span class="n">meshes</span><span class="o">=</span><span class="n">filtered_neuron</span><span class="o">.</span><span class="n">get_soma_meshes</span><span class="p">()</span>
        <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]</span>
    
    
    <span class="n">synapse_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;valid_syn_centers_presyn&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;valid_syn_centers_postsyn&quot;</span><span class="p">]</span>
                   
    <span class="n">synapse_scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="n">valid_presyn_color</span><span class="p">,</span><span class="n">valid_postsyn_color</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">plot_error_synapses</span><span class="p">:</span>
        <span class="n">synapse_list</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;errored_syn_centers_presyn&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;errored_syn_centers_postsyn&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;errored_syn_centers_presyn_non_axon&quot;</span><span class="p">]</span>
        
        <span class="c1"># will not double plot the non axon centers</span>
        <span class="k">if</span> <span class="s2">&quot;errored_syn_centers_presyn_non_axon&quot;</span> <span class="ow">in</span> <span class="n">synapse_center_coordinates</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">synapse_center_coordinates</span><span class="p">[</span><span class="s2">&quot;errored_syn_centers_presyn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span>
                <span class="n">synapse_center_coordinates</span><span class="p">[</span><span class="s2">&quot;errored_syn_centers_presyn&quot;</span><span class="p">],</span>
                <span class="n">synapse_center_coordinates</span><span class="p">[</span><span class="s2">&quot;errored_syn_centers_presyn_non_axon&quot;</span><span class="p">]</span>
            <span class="p">)</span>
    
        <span class="n">synapse_scatters_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">error_presyn_color</span><span class="p">,</span><span class="n">error_postsyn_color</span><span class="p">]</span>
        
    
    <span class="n">synapse_scatters</span> <span class="o">=</span> <span class="p">[</span><span class="n">synapse_center_coordinates</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">synapse_list</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;synapse_scatters = </span><span class="si">{</span><span class="n">synapse_scatters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">synapse_scatter_size</span> <span class="p">):</span>
        <span class="n">synapse_scatter_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">synapse_scatter_size</span><span class="p">]</span>
        
    
    
    
    <span class="n">synapse_scatter_size</span> <span class="o">=</span> <span class="n">synapse_scatter_size</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">synapse_scatters</span><span class="p">)</span>
    
    
<span class="c1">#     synapse_scatters = [synapse_center_coordinates[&quot;valid_syn_centers_presyn&quot;],</span>
<span class="c1">#                                synapse_center_coordinates[&quot;errored_syn_centers_presyn&quot;],</span>
<span class="c1">#                       synapse_center_coordinates[&quot;valid_syn_centers_postsyn&quot;],</span>
<span class="c1">#                                synapse_center_coordinates[&quot;errored_syn_centers_postsyn&quot;],</span>
<span class="c1">#                      ]</span>
    
    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meshes</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mesh </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> with center: </span><span class="si">{</span><span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    
    <span class="n">scatter_size_to_use</span><span class="o">=</span><span class="n">scatter_size</span> <span class="o">+</span> <span class="n">synapse_scatter_size</span>
    
    
        
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">main_mesh</span><span class="p">,</span>
                  <span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                  <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                  <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
                      <span class="n">main_mesh_alpha</span><span class="o">=</span><span class="n">main_mesh_alpha</span><span class="p">,</span>
            <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="o">+</span><span class="n">synapse_scatters</span><span class="p">,</span>
             <span class="n">scatters_colors</span><span class="o">=</span><span class="n">scatters_colors</span><span class="o">+</span><span class="n">synapse_scatters_colors</span><span class="p">,</span>
                     <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size_to_use</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="visualize_limb_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_limb_obj">[docs]</a><span class="k">def</span> <span class="nf">visualize_limb_obj</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>                 
    <span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">skeletons_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span>
    <span class="n">plot_soma_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">soma_vertices_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="n">plot_starting_coordinate</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">starting_coordinate_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    purpose: To visualize just a limb object</span>


<span class="sd">    &quot;&quot;&quot;</span>
    


    <span class="n">all_scatters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_scatters_sizes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">plot_soma_vertices</span><span class="p">:</span>
        <span class="n">all_scatters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_touching_soma_vertices</span><span class="p">)</span>
        <span class="n">all_scatters_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">soma_vertices_size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_starting_coordinate</span><span class="p">:</span>
        <span class="n">all_scatters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_coordinate</span><span class="p">)</span>
        <span class="n">all_scatters_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_coordinate_size</span><span class="p">)</span>


    <span class="n">meshes</span><span class="p">,</span><span class="n">skeletons</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_correspondence_plottable</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">limb_correspondence</span><span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
                     <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">skeletons_colors</span><span class="p">,</span>
                     <span class="n">scatters</span><span class="o">=</span><span class="n">all_scatters</span><span class="p">,</span>
                     <span class="n">scatter_size</span><span class="o">=</span><span class="n">all_scatters_sizes</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="visualize_axon_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_axon_dendrite">[docs]</a><span class="k">def</span> <span class="nf">visualize_axon_dendrite</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">axon_color</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
                            <span class="n">dendrite_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                            <span class="n">plot_mesh</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To visualize the axon</span>
<span class="sd">    and dendrite of a neuron</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the axon and dendrite limb branches</span>
<span class="sd">    2) Construct an overall limb branch using the axon-dnedrite colors</span>
<span class="sd">    3) plot neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">visualize_type</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
        <span class="n">visualize_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mesh&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="n">visualize_type</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;skeleton&quot;</span><span class="p">)</span>

    <span class="c1">#construct overall limb branch dict</span>
    <span class="n">axon_limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span>
    <span class="n">dendrite_limb_branch_dict</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span>
    <span class="n">total_limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_union</span><span class="p">([</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span><span class="n">dendrite_limb_branch_dict</span><span class="p">])</span>

    <span class="c1">#construct the the color limb_brnach dict</span>
    <span class="n">color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">limb_dicts</span> <span class="o">=</span> <span class="p">[</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span><span class="n">dendrite_limb_branch_dict</span><span class="p">]</span>
    <span class="n">dict_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">axon_color</span><span class="p">,</span><span class="n">dendrite_color</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">l_dict</span><span class="p">,</span><span class="n">l_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">limb_dicts</span><span class="p">,</span><span class="n">dict_colors</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">l_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">color_dict</span><span class="p">:</span>
                <span class="n">color_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span><span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
                <span class="n">color_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_color</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                          <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">total_limb_branch_dict</span><span class="p">,</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                         <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="limb_branch_dicts_to_combined_color_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.limb_branch_dicts_to_combined_color_dict">[docs]</a><span class="k">def</span> <span class="nf">limb_branch_dicts_to_combined_color_dict</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">,</span>
                                            <span class="n">color_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will combine multiple limb branch dict lists into </span>
<span class="sd">    one color dictionary of limb_name --&gt; branch_name --&gt; color</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">limb_branch_dict</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">,</span><span class="n">color_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">limb_name</span><span class="p">,</span><span class="n">branch_list</span> <span class="ow">in</span> <span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">color_dict</span><span class="p">:</span>
                <span class="n">color_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">:</span>
                <span class="n">color_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">color_dict</span></div>


<div class="viewcode-block" id="visualize_neuron_axon_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron_axon_dendrite">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron_axon_dendrite</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
    <span class="n">axon_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
    <span class="n">dendrite_color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span>

    <span class="n">mesh_color_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

    <span class="n">mesh_soma_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">mesh_soma_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Fast way to visuzlize the axon and dendritic</span>
<span class="sd">    parts of a neuron</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">color_dict</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_branch_dicts_to_combined_color_dict</span><span class="p">([</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_branch_dict</span><span class="p">,</span>
                                             <span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">],</span>
                                            <span class="n">color_list</span><span class="o">=</span><span class="p">[</span><span class="n">axon_color</span><span class="p">,</span><span class="n">dendrite_color</span><span class="p">])</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                          <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                          <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_color_alpha</span><span class="p">,</span>
                          <span class="n">mesh_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                          <span class="n">mesh_soma_color</span><span class="o">=</span><span class="n">mesh_soma_color</span><span class="p">,</span>
                          <span class="n">mesh_soma_alpha</span><span class="o">=</span><span class="n">mesh_soma_alpha</span><span class="p">,</span>

                          <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span>
                         <span class="p">)</span>    </div>
    
<div class="viewcode-block" id="visualize_neuron_axon_merge_errors"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_neuron_axon_merge_errors">[docs]</a><span class="k">def</span> <span class="nf">visualize_neuron_axon_merge_errors</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
    <span class="n">axon_error_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>

    <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="n">mesh_color_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

    <span class="n">mesh_soma_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">mesh_soma_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Fast way to visuzlize the axon and dendritic</span>
<span class="sd">    parts of a neuron</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axon_errors</span> <span class="o">=</span>  <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">matching_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;axon-error&quot;</span><span class="p">])</span>
    <span class="n">non_error_limb_branch_dict</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_setdiff</span><span class="p">([</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span><span class="p">,</span>
                       <span class="n">axon_errors</span><span class="p">])</span>

    <span class="n">color_dict</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_branch_dicts_to_combined_color_dict</span><span class="p">([</span><span class="n">axon_errors</span><span class="p">,</span>
                                                                <span class="n">non_error_limb_branch_dict</span><span class="p">],</span>
                                            <span class="n">color_list</span><span class="o">=</span><span class="p">[</span><span class="n">axon_error_color</span><span class="p">,</span><span class="n">mesh_color</span><span class="p">])</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                          <span class="n">limb_branch_dict</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                          <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_color_alpha</span><span class="p">,</span>
                          <span class="n">mesh_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                          <span class="n">mesh_soma_color</span><span class="o">=</span><span class="n">mesh_soma_color</span><span class="p">,</span>
                          <span class="n">mesh_soma_alpha</span><span class="o">=</span><span class="n">mesh_soma_alpha</span><span class="p">,</span>

                          <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span>
                         <span class="p">)</span>    </div>
    
    
<div class="viewcode-block" id="plot_branch_mesh_attribute"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_mesh_attribute">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_mesh_attribute</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">mesh_attribute</span><span class="p">,</span>
                              <span class="n">mesh_color</span><span class="p">,</span>
                              <span class="n">mesh_alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                               <span class="n">return_vertices</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                               <span class="n">flip_y</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">plot_at_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To take a mesh attribute that is part of a branch object</span>
<span class="sd">    inside of a neuron and then to plot all of them</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    nviz.plot_branch_mesh_attribute(neuron_obj_high_fid_axon,</span>
<span class="sd">                              mesh_attribute=&quot;boutons&quot;,</span>
<span class="sd">                              mesh_color=&quot;aqua&quot;,</span>
<span class="sd">                              mesh_alpha=0.8,</span>
<span class="sd">                               return_vertices = True,</span>
<span class="sd">                                plot_at_end=False,</span>
<span class="sd">                                flip_y = True,</span>
<span class="sd">                              verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="n">current_neuron</span> <span class="o">=</span> <span class="n">neuron_obj</span>
    
    <span class="k">if</span> <span class="n">plot_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    
    <span class="n">bouton_meshes</span> <span class="o">=</span> <span class="p">[]</span>
                
    <span class="k">for</span> <span class="n">limb_names</span> <span class="ow">in</span> <span class="n">current_neuron</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">():</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">current_neuron</span><span class="p">[</span><span class="n">limb_names</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">branch_name</span> <span class="ow">in</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">[</span><span class="n">branch_name</span><span class="p">],</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">[</span><span class="n">branch_name</span><span class="p">],</span><span class="n">mesh_attribute</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
                <span class="n">curr_atr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">[</span><span class="n">branch_name</span><span class="p">],</span><span class="n">mesh_attribute</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">curr_atr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">bouton_meshes</span> <span class="o">+=</span> <span class="n">curr_atr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bouton_meshes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_atr</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of </span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s2"> meshes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">bouton_meshes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">boutons_color_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">process_non_dict_color_input</span><span class="p">(</span><span class="n">mesh_color</span><span class="p">)</span>
    <span class="n">boutons_color_list_alpha</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">apply_alpha_to_color_list</span><span class="p">(</span><span class="n">boutons_color_list</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">)</span>

    <span class="n">total_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boutons_color_list_alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">combined_bouton_meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">combine_meshes</span><span class="p">(</span><span class="n">bouton_meshes</span><span class="p">)</span>
        <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">combined_bouton_meshes</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">boutons_color_list_alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
        <span class="n">total_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined_bouton_meshes</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">boutons_colors_list_alpha_fixed_size</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list_no_alpha_change</span><span class="p">(</span><span class="n">boutons_color_list_alpha</span><span class="p">,</span>
                                                                                  <span class="n">n_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bouton_meshes</span><span class="p">))</span>


        <span class="k">for</span> <span class="n">curr_bouton_mesh</span><span class="p">,</span><span class="n">curr_bouton_color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bouton_meshes</span><span class="p">,</span><span class="n">boutons_colors_list_alpha_fixed_size</span><span class="p">):</span>
            <span class="n">plot_ipv_mesh</span><span class="p">(</span><span class="n">curr_bouton_mesh</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">curr_bouton_color</span><span class="p">,</span><span class="n">flip_y</span><span class="o">=</span><span class="n">flip_y</span><span class="p">)</span>
            <span class="n">total_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_bouton_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting mesh </span><span class="si">{</span><span class="n">mesh_attribute</span><span class="si">}</span><span class="s2">= </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">local_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">local_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">plot_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">return_vertices</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">total_vertices</span></div>
    
<div class="viewcode-block" id="plot_web_intersection"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_web_intersection">[docs]</a><span class="k">def</span> <span class="nf">plot_web_intersection</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">limb_idx</span><span class="p">,</span>
                         <span class="n">branch_idx</span><span class="p">,</span>
                          <span class="n">parent_color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
                          <span class="n">downstream_color</span> <span class="o">=</span> <span class="s2">&quot;pink&quot;</span><span class="p">,</span>
                          <span class="n">web_color</span> <span class="o">=</span> <span class="s2">&quot;purple&quot;</span><span class="p">,</span>
                          <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                          
                          <span class="n">print_web_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">plot_boutons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">plot_whole_limb</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                          <span class="n">whole_limb_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span><span class="p">,</span>
                          <span class="n">whole_limb_alpha</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                          
                    <span class="n">mesh_boutons_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To plot the webbing of a branch at it&#39;s intersection</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the downstream nodes of the branch</span>
<span class="sd">    2) Assemble the meshes of the parent and downstream branch</span>
<span class="sd">    3) If requested, get all of the bouton meshes</span>
<span class="sd">    4) Get the web mesh of parent node</span>
<span class="sd">    5) Plot</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting web intersection for limb_idx </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">, branch_idx </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
    <span class="n">parent_branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
    
    <span class="c1">#1) Get the downstream nodes of the branch</span>
    <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                              <span class="n">branch_idx</span><span class="p">)</span>
    
    <span class="c1">#2) Assemble the meshes of the parent and downstream branch</span>
    <span class="n">total_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
    
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">meshes_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent_color</span><span class="p">)</span>
    
    <span class="n">meshes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_branches</span><span class="p">]</span>
    <span class="n">meshes_colors</span><span class="o">+=</span> <span class="p">[</span><span class="n">downstream_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_boutons</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">total_nodes</span><span class="p">:</span>
            <span class="n">curr_boutons</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">boutons</span>
            <span class="k">if</span> <span class="n">curr_boutons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_boutons</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">meshes</span> <span class="o">+=</span> <span class="n">curr_boutons</span>
                <span class="n">meshes_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mesh_boutons_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_boutons</span><span class="p">)</span>
    
    <span class="c1">#4) Get the web mesh of parent node</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">web_mesh</span> <span class="o">=</span> <span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">web</span>
        <span class="n">web_cdf</span> <span class="o">=</span> <span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">web_cdf</span>
        
        <span class="n">meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">web_mesh</span><span class="p">)</span>
        <span class="n">meshes_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">web_color</span><span class="p">)</span>
    
        <span class="n">web_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No webbing for this branch!!&quot;</span><span class="p">)</span>
        <span class="n">web_flag</span> <span class="o">=</span> <span class="kc">False</span>
    
    
    
    
    <span class="k">if</span> <span class="n">print_web_info</span><span class="p">:</span>
        <span class="n">width_name</span> <span class="o">=</span> <span class="s2">&quot;no_bouton_median&quot;</span>
        <span class="n">backup_width</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span>
        
        <span class="k">if</span> <span class="n">web_flag</span><span class="p">:</span>
            <span class="n">web_bbox_rations</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">bbox_side_length_ratios</span><span class="p">(</span><span class="n">web_mesh</span><span class="p">)</span>
            <span class="n">web_volume_ratio</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_volume_ratio</span><span class="p">(</span><span class="n">web_mesh</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Web Mesh = </span><span class="si">{</span><span class="n">web_mesh</span><span class="si">}</span><span class="s2">, web_cdf = </span><span class="si">{</span><span class="n">web_cdf</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;web_bbox_rations = </span><span class="si">{</span><span class="n">web_bbox_rations</span><span class="si">}</span><span class="s2">, web_volume_ratio = </span><span class="si">{</span><span class="n">web_volume_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parent Node </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">, n_boutons = </span><span class="si">{</span><span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">n_boutons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parent_width (</span><span class="si">{</span><span class="n">width_name</span><span class="si">}</span><span class="s2">)= </span><span class="si">{</span><span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parent_width (</span><span class="si">{</span><span class="n">backup_width</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">backup_width</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parent_width (</span><span class="si">{</span><span class="n">backup_width</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">parent_branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">backup_width</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_branches</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Downstream Branch </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">, n_boutons = </span><span class="si">{</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">n_boutons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Downstream branch </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> width (</span><span class="si">{</span><span class="n">backup_width</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">backup_width</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downstream branch </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2"> width (</span><span class="si">{</span><span class="n">width_name</span><span class="si">}</span><span class="s2">)= </span><span class="si">{</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            
            
            <span class="n">child_angle</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_parent_child_skeleton_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                              <span class="n">d</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;child_angle = </span><span class="si">{</span><span class="n">child_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">sibling_angles</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                                   <span class="n">downstream_branches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sibling_angles = </span><span class="si">{</span><span class="n">sibling_angles</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> No downstream nodes to show&quot;</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="n">plot_whole_limb</span><span class="p">:</span>
        <span class="n">limb_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limb_mesh</span><span class="o">=</span> <span class="kc">None</span>
        
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span> <span class="o">=</span> <span class="n">limb_mesh</span><span class="p">,</span>
                     <span class="n">main_mesh_color</span><span class="o">=</span><span class="n">whole_limb_color</span><span class="p">,</span>
                      <span class="n">main_mesh_alpha</span><span class="o">=</span><span class="n">whole_limb_alpha</span><span class="p">,</span>
                     <span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                      <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span>
                     <span class="p">)</span></div>

    
<div class="viewcode-block" id="set_zoom"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.set_zoom">[docs]</a><span class="k">def</span> <span class="nf">set_zoom</span><span class="p">(</span><span class="n">center_coordinate</span><span class="p">,</span>
                       <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">radius_xyz</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">flip_y</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">turn_axis_on</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mi">5000</span>
    
    <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center_coordinate</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">flip_y</span><span class="p">:</span>
        <span class="n">coord</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coord</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">radius_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">radius_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">radius</span><span class="p">,</span><span class="n">radius</span><span class="p">,</span><span class="n">radius</span><span class="p">])</span>
    <span class="n">coord_radius</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">radius</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">radius_xyz</span><span class="p">]</span>
    <span class="n">ipv_function</span> <span class="o">=</span> <span class="p">[</span><span class="n">ipv</span><span class="o">.</span><span class="n">xlim</span><span class="p">,</span><span class="n">ipv</span><span class="o">.</span><span class="n">ylim</span><span class="p">,</span><span class="n">ipv</span><span class="o">.</span><span class="n">zlim</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">c_rad</span><span class="p">,</span><span class="n">ipvf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span><span class="n">coord_radius</span><span class="p">,</span><span class="n">ipv_function</span><span class="p">):</span>
        <span class="n">ipvf</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c_rad</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">c_rad</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">turn_axis_on</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">axes_on</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">box_on</span><span class="p">()</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">axes_on</span><span class="p">()</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">box_on</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">show_at_end</span><span class="p">:</span>
        <span class="n">ipv</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>    </div>
        
<div class="viewcode-block" id="plot_limb_correspondence_multiple"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_limb_correspondence_multiple">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_correspondence_multiple</span><span class="p">(</span><span class="n">limb_correspondence_list</span><span class="p">,</span>
                                      <span class="n">color_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">kwargs</span>
                                     <span class="p">):</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">limb_correspondence_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">limb_correspondence_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">limb_correspondence_list</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">if</span> <span class="n">color_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_correspondence_list</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colors generated: </span><span class="si">{</span><span class="n">color_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">total_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">total_skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    
    
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limb_correspondence_list</span><span class="p">:</span>
        <span class="n">mesh</span><span class="p">,</span><span class="n">skel</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_correspondence_plottable</span><span class="p">(</span>
            <span class="n">k</span><span class="p">,</span>
            <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">total_meshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">total_skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skel</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Color_list: </span><span class="si">{</span><span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="n">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">enumerate</span><span class="p">(</span><span class="n">color_list</span><span class="p">)]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">total_meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span> <span class="o">=</span> <span class="n">color_list</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="n">total_skeletons</span><span class="p">,</span>
                     <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="plot_limb_branch_dict_multiple"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_limb_branch_dict_multiple">[docs]</a><span class="k">def</span> <span class="nf">plot_limb_branch_dict_multiple</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict_list</span><span class="p">,</span>
                                   <span class="n">color_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                                  <span class="n">scatters_list</span><span class="o">=</span><span class="p">[],</span>
                                   <span class="n">scatters_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                                   <span class="n">mesh_color_alpha</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="n">mesh_whole_neuron</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to plot multiple limb branch dicts</span>
<span class="sd">    with scatter points associated with it</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">color_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color_list</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Colors generated: </span><span class="si">{</span><span class="n">color_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">limb_branch_total</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_union</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">)</span>
    <span class="n">color_finals</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_branch_dicts_to_combined_color_dict</span><span class="p">(</span><span class="n">limb_branch_dict_list</span><span class="p">,</span><span class="n">color_list</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">scatters_colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatters_colors</span> <span class="o">=</span> <span class="n">color_list</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                         <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_total</span><span class="p">,</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="n">color_finals</span><span class="p">,</span>
                          <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_color_alpha</span><span class="p">,</span>
                          <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color_finals</span><span class="p">,</span>
                         <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="n">mesh_whole_neuron</span><span class="p">,</span>
                          <span class="n">scatters</span><span class="o">=</span><span class="n">scatters_list</span><span class="p">,</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span>
                          <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
        

<div class="viewcode-block" id="visualize_branch_at_downstream_split"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.visualize_branch_at_downstream_split">[docs]</a><span class="k">def</span> <span class="nf">visualize_branch_at_downstream_split</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                         <span class="n">limb_idx</span><span class="p">,</span>
                                         <span class="n">branch_idx</span><span class="p">,</span>
                                        <span class="n">radius</span> <span class="o">=</span> <span class="mi">20000</span><span class="p">,</span>
                                         <span class="n">turn_axis_on</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">branch_color</span> <span class="o">=</span> <span class="s2">&quot;mediumblue&quot;</span><span class="p">,</span>
                                        <span class="n">downstream_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                        <span class="n">print_axon_border_info</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To zoom on the point at which a branch splits off</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    axon_limb_name = neuron_obj.axon_limb_name</span>
<span class="sd">    curr_idx = 1</span>
<span class="sd">    curr_border_idx = border_brnaches[curr_idx]</span>
<span class="sd">    nviz.visualize_branch_at_downstream_split(neuron_obj=neuron_obj,</span>
<span class="sd">                                             limb_idx=neuron_obj.axon_limb_name,</span>
<span class="sd">                                             branch_idx=curr_border_idx,</span>
<span class="sd">                                            radius = 20000,</span>
<span class="sd">                                            branch_color = &quot;mediumblue&quot;,</span>
<span class="sd">                                            downstream_color = &quot;red&quot;,</span>
<span class="sd">                                            print_border_info = True,</span>
<span class="sd">                                            verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_idx</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_label</span><span class="p">(</span><span class="n">limb_idx</span><span class="p">)</span>
    
    <span class="n">border_color</span> <span class="o">=</span> <span class="n">branch_color</span>
    <span class="n">axon_limb_name</span> <span class="o">=</span> <span class="n">limb_idx</span>
    <span class="n">curr_border_idx</span> <span class="o">=</span> <span class="n">branch_idx</span>


    <span class="n">shared_skeleton_pt</span><span class="p">,</span> <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_coordinate_connecting_to_downstream_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">axon_limb_name</span><span class="p">],</span>
                                                                    <span class="n">curr_border_idx</span><span class="p">,</span>
                                                                            <span class="n">return_downstream_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of downstream targets = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="c1"># plot the neuron at the current branching point</span>

    <span class="n">dict_list</span> <span class="o">=</span> <span class="p">[{</span><span class="n">axon_limb_name</span><span class="p">:[</span><span class="n">curr_border_idx</span><span class="p">]},</span>
                 <span class="p">{</span><span class="n">axon_limb_name</span><span class="p">:</span><span class="n">downstream_branches</span><span class="p">}]</span>
    <span class="n">color_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">border_color</span><span class="p">,</span><span class="n">downstream_color</span><span class="p">]</span>
    <span class="n">color_dict</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">limb_branch_dicts_to_combined_color_dict</span><span class="p">(</span><span class="n">dict_list</span><span class="p">,</span>
                                                 <span class="n">color_list</span><span class="p">)</span>

    <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                      <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                      <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">axon_limb_name</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">downstream_branches</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">curr_border_idx</span><span class="p">]},</span>
                      <span class="n">mesh_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                      <span class="n">skeleton_color</span><span class="o">=</span><span class="n">color_dict</span><span class="p">,</span>
                      <span class="n">mesh_boutons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">mesh_web</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span>
                                        <span class="p">)</span>


    <span class="k">if</span> <span class="n">print_axon_border_info</span><span class="p">:</span>

        <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_branching_attributes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                    <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_limb_idx</span><span class="p">,</span>
                                    <span class="n">curr_border_idx</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">attr_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">set_zoom</span><span class="p">(</span><span class="n">shared_skeleton_pt</span><span class="p">,</span>
                      <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                 <span class="n">turn_axis_on</span><span class="o">=</span><span class="n">turn_axis_on</span><span class="p">)</span></div>
        
        
<div class="viewcode-block" id="set_zoom_to_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.set_zoom_to_limb_branch">[docs]</a><span class="k">def</span> <span class="nf">set_zoom_to_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                           <span class="n">limb_idx</span><span class="p">,</span>
                           <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">radius</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                           <span class="n">turn_axis_on</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">shared_skeleton_pt</span><span class="p">,</span> <span class="n">downstream_branches</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_coordinate_connecting_to_downstream_branches</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">],</span>
                                                            <span class="n">branch_idx</span><span class="p">,</span>
                                                                            <span class="n">return_downstream_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">set_zoom</span><span class="p">(</span><span class="n">shared_skeleton_pt</span><span class="p">,</span>
                      <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                 <span class="n">turn_axis_on</span><span class="o">=</span><span class="n">turn_axis_on</span><span class="p">)</span></div>

<div class="viewcode-block" id="add_scatter_to_current_plot"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.add_scatter_to_current_plot">[docs]</a><span class="k">def</span> <span class="nf">add_scatter_to_current_plot</span><span class="p">(</span><span class="n">scatters</span><span class="p">,</span>
                               <span class="n">scatters_colors</span><span class="p">,</span>
                               <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
                      <span class="n">scatters_colors</span><span class="o">=</span><span class="n">scatters_colors</span><span class="p">,</span>
                      <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                      <span class="n">append_figure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">show_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">set_zoom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="c1">#zoom_coordinate=shared_skeleton_pt,</span>
                 <span class="c1">#zoom_radius=3000</span>
                 <span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_original_vs_proofread"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_original_vs_proofread">[docs]</a><span class="k">def</span> <span class="nf">plot_original_vs_proofread</span><span class="p">(</span><span class="n">original</span><span class="p">,</span>
    <span class="n">proofread</span><span class="p">,</span>
    <span class="n">original_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">proofread_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
    <span class="n">mesh_alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">plot_mesh</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To visualize the original version</span>
<span class="sd">    and proofread version of a neuron_obj</span>

<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Turn original neuron and the proofread neuron into meshes</span>
<span class="sd">    2) Plot both meshes</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nviz.plot_original_vs_proofread(original = neuron_obj,</span>
<span class="sd">        proofread = filtered_neuron,</span>
<span class="sd">        original_color = &quot;red&quot;,</span>
<span class="sd">        proofread_color = &quot;blue&quot;,</span>
<span class="sd">        mesh_alpha = 0.3,</span>
<span class="sd">        plot_mesh= True,</span>
<span class="sd">        plot_skeleton = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skeletons_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">plot_skeleton</span><span class="p">:</span>
        <span class="n">skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">skeletons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proofread</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>

        <span class="n">skeletons_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">original_color</span><span class="p">,</span><span class="n">proofread_color</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">(</span><span class="n">original</span><span class="p">):</span>
            <span class="n">original</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">mesh</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tu</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">(</span><span class="n">proofread</span><span class="p">):</span>
            <span class="n">proofread</span> <span class="o">=</span> <span class="n">proofread</span><span class="o">.</span><span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">original</span><span class="o">=</span> <span class="kc">None</span>
        <span class="n">proofread</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original = </span><span class="si">{</span><span class="n">original</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">original</span><span class="p">,</span>
                     <span class="n">main_mesh_color</span><span class="o">=</span><span class="n">original_color</span><span class="p">,</span>
                      <span class="n">main_mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">,</span>
                     <span class="n">meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">proofread</span><span class="p">],</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="p">[</span><span class="n">proofread_color</span><span class="p">],</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
                     <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">skeletons_colors</span><span class="p">,</span>
                     <span class="n">mesh_alpha</span><span class="o">=</span><span class="n">mesh_alpha</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="vector_to_scatter_line"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.vector_to_scatter_line">[docs]</a><span class="k">def</span> <span class="nf">vector_to_scatter_line</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span>
                          <span class="n">start_coordainte</span><span class="p">,</span>
                          <span class="n">distance_to_plot</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                        <span class="n">n_points</span> <span class="o">=</span> <span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will turn a vector into a sequence of scatter points to be graphed</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">distance_to_plot</span><span class="p">,</span><span class="n">n_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">normal_line</span> <span class="o">=</span> <span class="n">scaling</span><span class="o">*</span><span class="n">nu</span><span class="o">.</span><span class="n">repeat_vector_down_rows</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">scaling</span><span class="p">))</span> <span class="o">+</span> <span class="n">start_coordainte</span>
    <span class="k">return</span> <span class="n">normal_line</span></div>

<div class="viewcode-block" id="plot_intermediates"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_intermediates">[docs]</a><span class="k">def</span> <span class="nf">plot_intermediates</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branches</span><span class="p">,</span>
                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To graph the skeletons</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">curr_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;aqua&quot;</span><span class="p">,</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span><span class="s2">&quot;green&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;coordinate_branches = </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">branches</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span><span class="n">curr_colors</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">],</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">],</span>
                     <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">curr_colors</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_branch_groupings"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_groupings">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_groupings</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
<span class="n">groupings</span><span class="p">,</span>
<span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="n">plot_meshes</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="n">plot_skeletons</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="n">extra_group</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">extra_group_color</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">extra_group_color_name</span> <span class="o">=</span> <span class="s2">&quot;skipped&quot;</span><span class="p">,</span>
                         <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Plot branch objects all of a certain color</span>
<span class="sd">    that are in the same group, and the grouping</span>
<span class="sd">    is described with a graph</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all the connected components (if a graph is given for the groupings)</span>
<span class="sd">    2) Generate a color list for the groups</span>
<span class="sd">    3) Based on what attributes are set, compile plottable lists (and add the colors to it)</span>
<span class="sd">    4) Plot the branch objects</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    nviz.plot_branch_groupings(limb_obj = neuron_obj[0],</span>
<span class="sd">    groupings = G,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    plot_meshes = True,</span>
<span class="sd">    plot_skeletons = True)</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">xu</span><span class="o">.</span><span class="n">is_graph</span><span class="p">(</span><span class="n">groupings</span><span class="p">):</span>
        <span class="n">groupings</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">groupings</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;groupings = </span><span class="si">{</span><span class="n">groupings</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="k">if</span> <span class="n">extra_group</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">extra_group_color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">groupings_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groupings</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">extra_group_color</span> <span class="o">=</span> <span class="n">groupings_colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">groupings_colors</span> <span class="o">=</span> <span class="n">groupings_colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">groupings_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groupings</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">extra_group</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">groupings_colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">groupings_colors</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">extra_group_color</span><span class="p">]</span> 
        <span class="n">groupings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">groupings</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">extra_group</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Last group is </span><span class="si">{</span><span class="n">extra_group_color_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">skeletons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">color_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">gp</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">groupings</span><span class="p">,</span><span class="n">groupings_colors</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">gp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_meshes</span><span class="p">:</span>
            <span class="n">meshes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">plot_skeletons</span><span class="p">:</span>
            <span class="n">skeletons</span> <span class="o">+=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gp</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot_meshes</span> <span class="ow">or</span> <span class="n">plot_skeletons</span><span class="p">:</span>
            <span class="n">color_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>


    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="n">meshes</span><span class="p">,</span>
                      <span class="n">meshes_colors</span><span class="o">=</span> <span class="n">color_list</span><span class="p">,</span>
                     <span class="n">skeletons</span><span class="o">=</span><span class="n">skeletons</span><span class="p">,</span>
                      <span class="n">skeletons_colors</span><span class="o">=</span> <span class="n">color_list</span><span class="p">,)</span></div>

    
<div class="viewcode-block" id="plottable_from_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plottable_from_branches">[docs]</a><span class="k">def</span> <span class="nf">plottable_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branch_list</span><span class="p">):</span>
        <span class="n">branch_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_list</span><span class="p">]</span>
    
    <span class="n">singular</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">attributes</span><span class="p">):</span>
        <span class="n">singular</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="n">attributes</span><span class="p">]</span>
        
    <span class="n">return_attributes</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">singular</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_attributes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_attributes</span></div>
    
<div class="viewcode-block" id="plottable_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plottable_meshes">[docs]</a><span class="k">def</span> <span class="nf">plottable_meshes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">plottable_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">,</span><span class="s2">&quot;mesh&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="plottable_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plottable_skeletons">[docs]</a><span class="k">def</span> <span class="nf">plottable_skeletons</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">plottable_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="plottable_meshes_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plottable_meshes_skeletons">[docs]</a><span class="k">def</span> <span class="nf">plottable_meshes_skeletons</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">plottable_from_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">,[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="plot_branches_with_colors"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branches_with_colors">[docs]</a><span class="k">def</span> <span class="nf">plot_branches_with_colors</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">,</span><span class="n">colors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">meshes</span><span class="p">,</span><span class="n">skeletons</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">plottable_meshes_skeletons</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">b_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span><span class="n">branch_list</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b_idx</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span> <span class="n">colors</span><span class="p">,</span>
                     <span class="n">skeletons</span> <span class="o">=</span> <span class="n">skeletons</span><span class="p">,</span>
                     <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span></div>


<div class="viewcode-block" id="plot_branch_with_neighbors"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch_with_neighbors">[docs]</a><span class="k">def</span> <span class="nf">plot_branch_with_neighbors</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">neighbor_idxs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">branch_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                               <span class="n">neighbors_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                               <span class="n">scatters_colors</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
                               <span class="n">scatter_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                               <span class="n">visualize_type</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">,</span><span class="s2">&quot;skeleton&quot;</span><span class="p">],</span>
                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">main_skeleton</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">skeletons</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will plot a main branch and other branches around it</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nviz.plot_branch_with_neighbors(limb_obj,16,nru.downstream_nodes(limb_obj,16),</span>
<span class="sd">                                scatters=[nru.downstream_endpoint(limb_obj,16)],</span>
<span class="sd">                                verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">neighbor_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neighbor_idxs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">neighbor_idxs</span><span class="p">):</span>
        <span class="n">neighbor_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor_idxs</span><span class="p">]</span>
        
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">neighbor_idxs</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">branch_idx</span><span class="p">]</span>
    
    <span class="n">plot_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="s2">&quot;mesh&quot;</span> <span class="ow">in</span> <span class="n">visualize_type</span><span class="p">:</span>
        <span class="n">plot_dict</span><span class="p">[</span><span class="s2">&quot;main_mesh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">plot_dict</span><span class="p">[</span><span class="s2">&quot;meshes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">plottable_meshes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">neighbor_idxs</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="s2">&quot;skeleton&quot;</span> <span class="ow">in</span> <span class="n">visualize_type</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">main_skeleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_dict</span><span class="p">[</span><span class="s2">&quot;main_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plot_dict</span><span class="p">[</span><span class="s2">&quot;main_skeleton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">main_skeleton</span>
        
        <span class="k">if</span> <span class="n">skeletons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_dict</span><span class="p">[</span><span class="s2">&quot;skeletons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nviz</span><span class="o">.</span><span class="n">plottable_skeletons</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">neighbor_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plot_dict</span><span class="p">[</span><span class="s2">&quot;skeletons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">skeletons</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_idx (</span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">branch_color</span><span class="si">}</span><span class="se">\n</span><span class="s2"> neighbor nodes (</span><span class="si">{</span><span class="n">neighbor_idxs</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">neighbors_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">plot_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
                     <span class="n">main_mesh_color</span><span class="o">=</span><span class="n">branch_color</span><span class="p">,</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">neighbors_color</span><span class="p">,</span>
                      <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">neighbors_color</span><span class="p">,</span>
                     <span class="n">scatters_colors</span> <span class="o">=</span> <span class="n">scatters_colors</span><span class="p">,</span>
                     <span class="n">scatter_size</span><span class="o">=</span><span class="n">scatter_size</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">plot_dict</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_candidates"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_candidates">[docs]</a><span class="k">def</span> <span class="nf">plot_candidates</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                   <span class="n">candidates</span><span class="p">,</span>
                   <span class="n">color_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">visualize_type</span>  <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">dont_plot_if_no_candidates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">dont_plot_if_no_candidates</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not plotting because no candidates&quot;</span><span class="p">)</span>
        <span class="k">return</span> 
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting candidates&quot;</span><span class="p">)</span>
    
    <span class="n">candidate_lb</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict_multiple</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict_list</span><span class="o">=</span><span class="n">candidate_lb</span><span class="p">,</span>
                                       <span class="n">color_list</span><span class="o">=</span><span class="n">color_list</span><span class="p">,</span>
                                       <span class="n">visualize_type</span><span class="o">=</span><span class="n">visualize_type</span><span class="p">,</span>
                                        <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="n">mesh_color_alpha</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span>
                                       <span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_compartments"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_compartments">[docs]</a><span class="k">def</span> <span class="nf">plot_compartments</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">apical_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
                     <span class="n">apical_shaft_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
                     <span class="n">apical_tuft_color</span> <span class="o">=</span> <span class="s2">&quot;purple&quot;</span><span class="p">,</span>
                     <span class="n">basal_color</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
                     <span class="n">axon_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
                     <span class="n">oblique_color</span> <span class="o">=</span> <span class="s2">&quot;green&quot;</span>
                     <span class="p">):</span>
<span class="c1">#     nviz.plot_limb_branch_dict_multiple(neuron_obj,</span>
<span class="c1">#                               [neuron_obj.label_limb_branch_dict(&quot;apical&quot;),</span>
<span class="c1">#                               neuron_obj.label_limb_branch_dict(&quot;apical_shaft&quot;),</span>
<span class="c1">#                               neuron_obj.label_limb_branch_dict(&quot;apical_tuft&quot;),</span>
<span class="c1">#                               neuron_obj.label_limb_branch_dict(&quot;basal&quot;),</span>
<span class="c1">#                               neuron_obj.label_limb_branch_dict(&quot;axon&quot;),</span>
<span class="c1">#                               neuron_obj.label_limb_branch_dict(&quot;oblique&quot;)],</span>
<span class="c1">#                               [ apical_color,</span>
<span class="c1">#                                  apical_shaft_color,</span>
<span class="c1">#                                  apical_tuft_color,</span>
<span class="c1">#                                  basal_color,</span>
<span class="c1">#                                  axon_color,</span>
<span class="c1">#                                   oblique_color,</span>
                                  
<span class="c1">#                               ])</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_labeled_limb_branch_dicts</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="p">[</span><span class="s2">&quot;apical&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;apical_shaft&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;apical_tuft&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;basal&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;axon&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;oblique&quot;</span><span class="p">],</span>
                          <span class="p">[</span> <span class="n">apical_color</span><span class="p">,</span>
                             <span class="n">apical_shaft_color</span><span class="p">,</span>
                             <span class="n">apical_tuft_color</span><span class="p">,</span>
                             <span class="n">basal_color</span><span class="p">,</span>
                             <span class="n">axon_color</span><span class="p">,</span>
                              <span class="n">oblique_color</span><span class="p">,</span>

                          <span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unlabeled: transparent green&quot;</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="plot_mesh_face_idx"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_mesh_face_idx">[docs]</a><span class="k">def</span> <span class="nf">plot_mesh_face_idx</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">face_idx</span><span class="p">,</span><span class="n">meshes_colors</span> <span class="o">=</span> <span class="s2">&quot;random&quot;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To plot a mesh divided up by a face_mesh_idx</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nviz.plot_mesh_face_idx(neuron_obj[0][0].mesh,return_face_idx)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">split_mesh_into_face_groups</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                                  <span class="n">face_idx</span><span class="p">,</span>
                                  <span class="n">return_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">return_idx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">),</span>
                          <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_soma_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_soma_meshes">[docs]</a><span class="k">def</span> <span class="nf">plot_soma_meshes</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                     <span class="n">meshes_colors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">soma_node_names</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_soma_node_names</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">meshes_colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">meshes_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">soma_node_names</span><span class="p">))</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s_name</span><span class="p">,</span><span class="n">s_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soma_node_names</span><span class="p">,</span><span class="n">meshes_colors</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">s_col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">soma_node_names</span><span class="p">],</span>
                     <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="plot_meshes_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_meshes_skeletons">[docs]</a><span class="k">def</span> <span class="nf">plot_meshes_skeletons</span><span class="p">(</span><span class="n">meshes</span><span class="p">,</span><span class="n">skeletons</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_non_randon_named_color_list</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meshes</span><span class="p">))</span>
    <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
        <span class="n">meshes_colors</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
        <span class="n">skeletons</span> <span class="o">=</span> <span class="n">skeletons</span><span class="p">,</span>
        <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_soma_extraction_meshes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_soma_extraction_meshes">[docs]</a><span class="k">def</span> <span class="nf">plot_soma_extraction_meshes</span><span class="p">(</span>
    <span class="n">mesh</span><span class="p">,</span>
    <span class="n">soma_meshes</span><span class="p">,</span>
    <span class="n">glia_meshes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">soma_color</span> <span class="o">=</span> <span class="n">soma_color</span><span class="p">,</span>
    <span class="n">glia_color</span> <span class="o">=</span> <span class="n">glia_color</span><span class="p">,</span>
    <span class="n">nuclei_color</span> <span class="o">=</span> <span class="n">nuclei_color</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot the dataproducts from the</span>
<span class="sd">    soma extractio</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">total_soma_list</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">soma_meshes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">glia_meshes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">glia_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">glia_pieces</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">glia_meshes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nuclei_meshes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nuclei_meshes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nuclei_pieces</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">nuclei_meshes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of somas = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">total_soma_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of glia = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of nuclei = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">nuclei_pieces</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">meshes</span> <span class="o">=</span> <span class="n">total_soma_list</span> <span class="o">+</span> <span class="n">glia_pieces</span> <span class="o">+</span> <span class="n">nuclei_pieces</span>
    <span class="n">meshes_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">soma_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">total_soma_list</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">glia_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">glia_pieces</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nuclei_color</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">nuclei_pieces</span><span class="p">)</span>
    <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">mesh</span><span class="p">,</span>
        <span class="n">meshes</span> <span class="o">=</span> <span class="n">meshes</span><span class="p">,</span>
        <span class="n">meshes_colors</span><span class="o">=</span><span class="n">meshes_colors</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="plot_spines_head_neck"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_spines_head_neck">[docs]</a><span class="k">def</span> <span class="nf">plot_spines_head_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">spu</span><span class="o">.</span><span class="n">plot_spines_head_neck</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_synapses">[docs]</a><span class="k">def</span> <span class="nf">plot_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">syu</span><span class="o">.</span><span class="n">plot_synapses</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="plot_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_branch">[docs]</a><span class="k">def</span> <span class="nf">plot_branch</span><span class="p">(</span>
    <span class="n">branch_obj</span><span class="p">,</span>
    <span class="n">upstream_color</span> <span class="o">=</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
    <span class="n">downstream_color</span> <span class="o">=</span> <span class="s2">&quot;aqua&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_color = </span><span class="si">{</span><span class="n">upstream_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_color = </span><span class="si">{</span><span class="n">downstream_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">upstream</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoint_upstream</span>
    <span class="n">downstream</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">endpoint_downstream</span>
    
    <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">upstream</span><span class="p">,</span><span class="n">downstream</span><span class="p">],</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="n">upstream_color</span><span class="p">,</span><span class="n">downstream_color</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    

<div class="viewcode-block" id="plot_merge_filter_suggestions"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_visualizations.plot_merge_filter_suggestions">[docs]</a><span class="k">def</span> <span class="nf">plot_merge_filter_suggestions</span><span class="p">(</span>
    <span class="n">original_mesh</span><span class="p">,</span>
    <span class="n">merge_valid_error_suggestions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neuron_obj</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">merge_error_types</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_valid_error_coordinates</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">valid_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span><span class="p">,</span>
    <span class="n">error_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span>
    <span class="n">print_merge_color_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To plot the valid/error suggestions</span>
<span class="sd">    generated from</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scatters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">scatters_colors</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">if</span> <span class="n">merge_valid_error_suggestions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">merge_valid_error_suggestions</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">merge_filter_suggestions</span>

    <span class="k">if</span> <span class="n">merge_error_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">merge_error_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">merge_valid_error_suggestions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">merge_error_types</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">merge_error_types</span><span class="p">)</span>


    <span class="n">local_color_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">merge_type</span> <span class="ow">in</span> <span class="n">merge_error_types</span><span class="p">:</span>
        <span class="n">merge_info</span> <span class="o">=</span> <span class="n">merge_valid_error_suggestions</span><span class="p">[</span><span class="n">merge_type</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge_info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>


        <span class="n">merge_type</span> <span class="o">=</span> <span class="n">merge_type</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_red_blue_suggestions&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">pru</span><span class="o">.</span><span class="n">merge_type_to_color</span><span class="p">(</span><span class="n">merge_type</span><span class="p">)</span>
        <span class="n">local_color_map</span><span class="p">[</span><span class="n">merge_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">v_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">e_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">merge_point</span> <span class="ow">in</span> <span class="n">merge_info</span><span class="p">:</span>

            <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_point</span><span class="p">[</span><span class="s2">&quot;coordinate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">v_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_point</span><span class="p">[</span><span class="s2">&quot;valid_points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">e_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merge_point</span><span class="p">[</span><span class="s2">&quot;error_points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="n">scatters</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">scatters_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">color</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">plot_valid_error_coordinates</span><span class="p">:</span>
            <span class="n">scatters</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v_points</span><span class="p">,</span><span class="n">e_points</span><span class="p">]</span>
            <span class="n">scatters_colors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">valid_color</span><span class="p">,</span><span class="n">error_color</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">print_merge_color_map</span><span class="p">:</span>
        <span class="n">pru</span><span class="o">.</span><span class="n">print_merge_type_color_map</span><span class="p">(</span><span class="n">local_color_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_valid_error_coordinates</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For splitting&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">valid coordinates = </span><span class="si">{</span><span class="n">valid_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">error coordinates = </span><span class="si">{</span><span class="n">error_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span>
        <span class="n">original_mesh</span><span class="p">,</span>
        <span class="n">scatters</span><span class="o">=</span><span class="n">scatters</span><span class="p">,</span>
        <span class="n">scatters_colors</span><span class="o">=</span><span class="n">scatters_colors</span>
    <span class="p">)</span></div>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>

<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">spine_utils</span> <span class="k">as</span> <span class="n">spu</span>



<span class="n">plot_objects</span> <span class="o">=</span> <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
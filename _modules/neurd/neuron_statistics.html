

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.neuron_statistics &mdash; neurd  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.neuron_statistics</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.neuron_statistics</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span>

<span class="n">top_of_layer_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<div class="viewcode-block" id="neuron_path_analysis"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.neuron_path_analysis">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">neuron_path_analysis</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                        <span class="n">plot_paths</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="n">return_dj_inserts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all the errored branches</span>
<span class="sd">    For Each Limb:</span>
<span class="sd">    2) Remove the errored branches</span>
<span class="sd">    3) Find all branches that are N steps away from starting node (and get the paths)</span>
<span class="sd">    4) Filter away paths that do not have all degrees of 2 on directed network</span>
<span class="sd">    *** Those are the viable paths we would analyze***</span>
<span class="sd">    5) Extract the statistics</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 0) Compute the mesh center of the soma</span>
    <span class="n">curr_soma</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">curr_soma_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">curr_soma</span><span class="p">)</span>
    <span class="n">y_vector</span> <span class="o">=</span> <span class="n">top_of_layer_vector</span>

    <span class="c1"># 1) Getting all Errored Branches </span>
    <span class="n">error_branches</span> <span class="o">=</span> <span class="n">ed</span><span class="o">.</span><span class="n">error_branches_by_axons</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">visualize_errors_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># ----------- Loop that will iterate through all branches ----------- #</span>
    <span class="n">neuron_path_inserts_by_limb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>


    <span class="n">total_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">curr_limb_idx</span><span class="p">,</span><span class="n">curr_limb_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="n">l_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">l_name</span> <span class="ow">in</span> <span class="n">error_branches</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">curr_limb_error_branches</span> <span class="o">=</span> <span class="n">error_branches</span><span class="p">[</span><span class="n">l_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_limb_error_branches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># 2) Remove the errored branches</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one starting node for limb </span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">st_node</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">current_starting_node</span>
        <span class="n">st_coordinates</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">current_starting_coordinate</span>



        <span class="c1">#2-4: Getting the paths we want</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>

        <span class="n">target_to_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">st_node</span><span class="p">)</span><span class="c1">#, cutoff=N+1) </span>
        <span class="n">paths_of_certain_length</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">target_to_path</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of paths with </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">paths_of_certain_length</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#remove the paths with errors on</span>
        <span class="n">paths_of_certain_length_no_errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">paths_of_certain_length</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">curr_limb_error_branches</span><span class="p">,</span>
                                                                                                     <span class="n">v</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of paths with </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> nodes and no Errors = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">paths_of_certain_length_no_errors</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#need to filter away for high degree nodes along path</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1) Turn network into directional</span>
<span class="sd">        2) Find all of the upstream nodes</span>
<span class="sd">        3) Filter those paths away where existence of greater than 2 degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#1) Turn network into directional</span>
        <span class="n">G_directional</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">)</span>

        <span class="n">final_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ex_path</span> <span class="ow">in</span> <span class="n">paths_of_certain_length_no_errors</span><span class="p">:</span>
            <span class="n">path_degree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">downstream_edges_neighbors</span><span class="p">(</span><span class="n">G_directional</span><span class="p">,</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ex_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">path_degree</span><span class="o">!=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">final_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ex_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ignoring path because path degrees are </span><span class="si">{</span><span class="n">path_degree</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of paths after filtering away high degree nodes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">final_paths</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_paths</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_paths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curr_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">final_paths</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_nodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">total_paths</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">curr_limb_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">curr_nodes</span><span class="p">})</span>


        <span class="c1"># Step 5: Calculating the Statistics on the branches</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pseudocode: </span>
<span class="sd">        1) Get starting angle of branch</span>

<span class="sd">        For all branches not in the starting node</span>
<span class="sd">        a) Get the width (all of them)</span>
<span class="sd">        b) Get the number of spines, spines_volume, and spine density</span>


<span class="sd">        d) Skeletal distance (distance to next branch point)</span>
<span class="sd">        e) Angle between parent branch and current branch</span>
<span class="sd">        f) Angle between sibling branch and current</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#1) Get starting angle of branch</span>
        <span class="n">st_vector</span> <span class="o">=</span> <span class="n">st_coordinates</span> <span class="o">-</span> <span class="n">curr_soma_center</span>
        <span class="n">st_vector_norm</span> <span class="o">=</span> <span class="n">st_vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">st_vector</span><span class="p">)</span>
        <span class="n">angle_from_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">y_vector</span><span class="p">,</span><span class="n">st_vector_norm</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>



        <span class="n">limb_path_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">zz</span><span class="p">,</span><span class="n">curr_path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">final_paths</span><span class="p">):</span>

            <span class="n">local_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">soma_angle</span><span class="o">=</span><span class="n">angle_from_top</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">curr_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">curr_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;n</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">_&quot;</span>
                <span class="n">curr_node</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

                <span class="c1">#a) Get the width (all of them)</span>
                <span class="k">for</span> <span class="n">w_name</span><span class="p">,</span><span class="n">w_value</span> <span class="ow">in</span> <span class="n">curr_node</span><span class="o">.</span><span class="n">width_new</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">local_dict</span><span class="p">[</span><span class="n">curr_name</span> <span class="o">+</span><span class="s2">&quot;width_&quot;</span><span class="o">+</span> <span class="n">w_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">w_value</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1">#b) Get the number of spines, spines_volume, and spine density</span>
                <span class="n">attributes_to_export</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_spines&quot;</span><span class="p">,</span><span class="s2">&quot;total_spine_volume&quot;</span><span class="p">,</span><span class="s2">&quot;spine_volume_median&quot;</span><span class="p">,</span>
                                       <span class="s2">&quot;spine_volume_density&quot;</span><span class="p">,</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attributes_to_export</span><span class="p">:</span>
                    <span class="n">local_dict</span><span class="p">[</span><span class="n">curr_name</span> <span class="o">+</span> <span class="n">att</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">curr_node</span><span class="p">,</span><span class="n">att</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1">#e) Angle between parent branch and current branch</span>
                <span class="n">local_dict</span><span class="p">[</span><span class="n">curr_name</span> <span class="o">+</span> <span class="s2">&quot;parent_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_parent_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span><span class="n">child_node</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

                <span class="c1">#f) Angle between sibling branch and current</span>
                <span class="n">local_dict</span><span class="p">[</span><span class="n">curr_name</span> <span class="o">+</span> <span class="s2">&quot;sibling_angle&quot;</span><span class="p">]</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="p">,</span><span class="n">child_node</span><span class="o">=</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">limb_path_dict</span><span class="p">[</span><span class="n">zz</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_dict</span>


        <span class="n">neuron_path_inserts_by_limb</span><span class="p">[</span><span class="n">curr_limb_idx</span><span class="p">]</span> <span class="o">=</span>  <span class="n">limb_path_dict</span>

    <span class="k">if</span> <span class="n">plot_paths</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                          <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                          <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">total_paths</span><span class="p">,</span>
                         <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   

    <span class="k">if</span> <span class="n">return_dj_inserts</span><span class="p">:</span>
        <span class="c1"># Need to collapse this into a list of dictionaries to insert</span>
        <span class="n">dj_inserts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">limb_idx</span><span class="p">,</span><span class="n">limb_paths</span> <span class="ow">in</span> <span class="n">neuron_path_inserts_by_limb</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">path_idx</span><span class="p">,</span><span class="n">path_dict</span> <span class="ow">in</span> <span class="n">limb_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dj_inserts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">path_dict</span><span class="p">,</span><span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span><span class="n">path_idx</span><span class="o">=</span><span class="n">path_idx</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dj_inserts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neuron_path_inserts_by_limb</span></div>
    
    
<div class="viewcode-block" id="soma_starting_vector"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.soma_starting_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">soma_starting_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">neuron_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">soma_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">soma_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will find the angle between the vector pointing to the</span>
<span class="sd">    top of the volume and the angle from the soma center to the starting skeleton</span>
<span class="sd">    coordinate</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limb_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span>
        
    <span class="k">if</span> <span class="n">soma_group_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">starting_soma</span><span class="o">=</span><span class="n">soma_idx</span><span class="p">,</span>
                                                     <span class="n">soma_group_idx</span><span class="o">=</span><span class="n">soma_group_idx</span><span class="p">)</span>
        
    <span class="n">st_coordinates</span> <span class="o">=</span> <span class="n">curr_limb_obj</span><span class="o">.</span><span class="n">current_starting_coordinate</span>
    
    <span class="k">if</span> <span class="n">soma_center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_soma</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">soma_idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_center_vertex_average</span><span class="p">(</span><span class="n">curr_soma</span><span class="p">)</span>
    
    
    <span class="c1">#1) Get starting angle of branch</span>
    <span class="n">st_vector</span> <span class="o">=</span> <span class="n">st_coordinates</span> <span class="o">-</span> <span class="n">soma_center</span>
    <span class="n">st_vector_norm</span> <span class="o">=</span> <span class="n">st_vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">st_vector</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">st_vector_norm</span></div>

<div class="viewcode-block" id="soma_starting_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.soma_starting_angle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">soma_starting_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">neuron_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">limb_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">soma_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                        <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">soma_center</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">y_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])):</span>
    <span class="n">st_vector_norm</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">limb_obj</span><span class="p">,</span>
                        <span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
                        <span class="n">limb_idx</span><span class="o">=</span><span class="n">limb_idx</span><span class="p">,</span>
                        <span class="n">soma_idx</span> <span class="o">=</span> <span class="n">soma_idx</span><span class="p">,</span>
                        <span class="n">soma_group_idx</span> <span class="o">=</span> <span class="n">soma_group_idx</span><span class="p">,</span>
                        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">soma_center</span><span class="p">,)</span>
    <span class="n">angle_from_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">y_vector</span><span class="p">,</span><span class="n">st_vector_norm</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">angle_from_top</span></div>

<div class="viewcode-block" id="fork_divergence_from_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.fork_divergence_from_skeletons">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">fork_divergence_from_skeletons</span><span class="p">(</span><span class="n">upstream_skeleton</span><span class="p">,</span>
                    <span class="n">downstream_skeletons</span><span class="p">,</span>
                    <span class="n">downstream_starting_endpoint</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                    <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                    <span class="n">plot_restrictions</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">combining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute the number for the fork splitting</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find intersection point of all 3 branches</span>
<span class="sd">    2) for 2 downstream branch: </span>
<span class="sd">       - restrict the skeleton to a certain distance from the start</span>
<span class="sd">    3) discretize the skeeletons so have x pieces</span>
<span class="sd">    4) Measure distance between each indexed point</span>
<span class="sd">    5) Have one way of aggregating the distances (median, mean)</span>

<span class="sd">    Application: If below a certain value then can indicate incorrect branching</span>


<span class="sd">    Ex:</span>
<span class="sd">    from neurd import neuron_statistics as nst</span>
<span class="sd">    nst.fork_divergence(upstream_skeleton = upstream_sk,</span>
<span class="sd">                        downstream_skeletons = downstream_sk,</span>
<span class="sd">                        comparison_distance = 500,</span>
<span class="sd">                        skeletal_segment_size = 50,</span>
<span class="sd">                        plot_restrictions = True,</span>
<span class="sd">                        combining_function = np.mean)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">downstream_sk</span> <span class="o">=</span> <span class="n">downstream_skeletons</span>
    <span class="n">upstream_sk</span> <span class="o">=</span> <span class="n">upstream_skeleton</span>
    
    <span class="k">if</span> <span class="n">downstream_starting_endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">joining_endpoint_1</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_coordiantes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">downstream_sk</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">upstream_skeleton</span><span class="p">],</span>
                                 <span class="n">return_one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">joining_endpoint_1</span> <span class="o">=</span> <span class="n">downstream_starting_endpoint</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;joining_endpoint_1 = </span><span class="si">{</span><span class="n">joining_endpoint_1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># resize the skeletons</span>
    <span class="n">d_skeletons_resized</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">segment_width</span><span class="o">=</span><span class="n">skeletal_segment_size</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_skeletons</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
<span class="c1">#         print(f&quot;After resizing:\n{[sk.calculate_skeleton_segment_distances(k) for k in d_skeletons_resized]}&quot;)</span>
        <span class="k">pass</span>
        

    <span class="n">d_skeletons_restricted</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_to_distance_from_coordinate</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>
                                             <span class="n">coordinate</span> <span class="o">=</span> <span class="n">joining_endpoint_1</span><span class="p">,</span>
                                             <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span>
                              <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d_skeletons_resized</span><span class="p">]</span>
    <span class="n">d_skeletons_resized</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">segment_width</span><span class="o">=</span><span class="n">skeletal_segment_size</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d_skeletons_restricted</span><span class="p">]</span>
                           
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c1">#print(f&quot;After restricting:\n{[sk.calculate_skeleton_distance(k) for k in d_skeletons_restricted]}&quot;)</span>
        <span class="k">pass</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Segment sizes after restriction&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d_skeletons_resized</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>

    <span class="c1">#align the skeletons</span>

    <span class="k">if</span> <span class="n">plot_restrictions</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">skeletons</span> <span class="o">=</span> <span class="n">downstream_sk</span> <span class="o">+</span> <span class="n">d_skeletons_resized</span><span class="p">,</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;black&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">d_skeletons_resized</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">d_skeletons_restricted</span><span class="p">),</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">joining_endpoint_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="n">d_ordered_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">skeleton_coordinate_path_from_start</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">joining_endpoint_1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d_skeletons_restricted</span><span class="p">]</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="c1">#print(f&quot;Before skeleton path from start: {d_skeletons_restricted}&quot;)</span>
        <span class="c1">#print(f&quot;After skeleton path from start: {d_ordered_paths}&quot;)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d_ordered_paths</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_segment_distances</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">skelton_coordinate_path_to_skeleton</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span>
        
    <span class="n">min_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d_ordered_paths</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_length = </span><span class="si">{</span><span class="n">min_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">path_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d_ordered_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">min_length</span><span class="p">]</span><span class="o">-</span><span class="n">d_ordered_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">min_length</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">return_value</span> <span class="o">=</span> <span class="n">combining_function</span><span class="p">(</span><span class="n">path_distances</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="fork_divergence_from_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.fork_divergence_from_branch">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">fork_divergence_from_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branch_idx</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">error_not_2_downstream</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">total_downstream_skeleton_length_threshold</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
                                <span class="n">individual_branch_length_threshold</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
                                <span class="n">skip_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                                <span class="n">plot_fork_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">upstream_sk_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                                <span class="n">downstream_sk_colors</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                
                                <span class="c1">#arguments for the fork divergence measurement</span>
                                <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
                                <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
                                <span class="n">plot_restrictions</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                <span class="n">combining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span>
                               <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the branch where the error is</span>
<span class="sd">    2) Get all the upstream branch and all of the downstream branches of that</span>
<span class="sd">    3) Measure the sibling angles</span>
<span class="sd">    4) Collect together the skeletons in a list</span>
<span class="sd">    5) Run the fork splitting function</span>

<span class="sd">    Note: should only be done on 2 forks</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1">#2) Get all the upstream branch and all of the downstream branches of that</span>
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                                     <span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">skip_value</span>
    
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">upstream_node</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">error_not_2_downstream</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not exactly 2 downstream nodes: </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">upstream_sk</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span>
    <span class="n">downstream_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upstream Node = </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">, downstream nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">total_downstream_skeleton_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="n">individual_branch_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">d_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> 
                         <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">])</span>
        <span class="n">d_skeletal_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                <span class="n">d</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">])</span>
        <span class="n">below_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">d_skeletal_len</span><span class="o">&lt;</span><span class="n">total_downstream_skeleton_length_threshold</span><span class="p">)</span> <span class="o">|</span> 
                                   <span class="p">(</span><span class="n">d_len</span> <span class="o">&lt;</span> <span class="n">individual_branch_length_threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">below_threshold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping this intersection because some of downstream skeletal lengths too short (min </span><span class="si">{</span><span class="n">total_downstream_skeleton_length_threshold</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; or the individual branch length was too short (min </span><span class="si">{</span><span class="n">individual_branch_length_threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">d</span><span class="p">,</span><span class="n">d_len</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">,</span><span class="n">d_skeletal_len</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">below_threshold</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Brnach </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">: length </span><span class="si">{</span><span class="n">d_l</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">d_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">return_value</span> <span class="o">=</span> <span class="n">skip_value</span>


    <span class="k">if</span> <span class="n">return_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#3) Measure the sibling angles</span>
        <span class="n">sibling_angle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb_obj</span><span class="o">=</span><span class="n">limb_obj</span><span class="p">,</span>
                                             <span class="n">child_node</span><span class="o">=</span><span class="n">branch_idx</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sibling_angle = </span><span class="si">{</span><span class="n">sibling_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#4) Collect together the skeletons in a list</span>


        <span class="k">if</span> <span class="n">downstream_sk_colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">matplotlib_utils</span> <span class="k">as</span> <span class="n">mu</span>
            <span class="n">downstream_sk_colors</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">generate_color_list</span><span class="p">(</span><span class="n">n_colors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">),</span>
                                  <span class="n">colors_to_omit</span> <span class="o">=</span> <span class="p">[</span><span class="n">upstream_sk_color</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">plot_fork_skeleton</span><span class="p">:</span>
            <span class="n">downstream_meshes</span> <span class="o">=</span> <span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">]</span>
            <span class="n">upstream_mesh</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">main_mesh</span><span class="o">=</span><span class="n">upstream_mesh</span><span class="p">,</span>
                              <span class="n">main_mesh_color</span><span class="o">=</span><span class="n">upstream_sk_color</span><span class="p">,</span>
                                <span class="n">main_skeleton</span><span class="o">=</span><span class="n">upstream_sk</span><span class="p">,</span>
                              <span class="n">main_skeleton_color</span><span class="o">=</span><span class="n">upstream_sk_color</span><span class="p">,</span>
                              <span class="n">meshes</span><span class="o">=</span><span class="n">downstream_meshes</span><span class="p">,</span>
                              <span class="n">meshes_colors</span><span class="o">=</span><span class="n">downstream_sk_colors</span><span class="p">,</span>
                             <span class="n">skeletons</span><span class="o">=</span><span class="n">downstream_sk</span><span class="p">,</span>
                             <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">downstream_sk_colors</span><span class="p">)</span>

        
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">fork_divergence_from_skeletons</span><span class="p">(</span><span class="n">upstream_skeleton</span> <span class="o">=</span> <span class="n">upstream_sk</span><span class="p">,</span>
                            <span class="n">downstream_skeletons</span> <span class="o">=</span> <span class="n">downstream_sk</span><span class="p">,</span>
                            <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                            <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="n">skeletal_segment_size</span><span class="p">,</span>
                            <span class="n">plot_restrictions</span> <span class="o">=</span> <span class="n">plot_restrictions</span><span class="p">,</span>
                            <span class="n">combining_function</span> <span class="o">=</span> <span class="n">combining_function</span><span class="p">,</span>
                                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final Fork Divergence = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="n_small_children"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_small_children">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_small_children</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">width_maximum</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will measure the number</span>
<span class="sd">    of small width immediate downstream nodes</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Find the number of downstream nodes</span>
<span class="sd">    2) Find the width of the downstream nodes</span>
<span class="sd">    3) Count how many are below the threshold</span>
<span class="sd">    </span>
<span class="sd">    Ex:</span>
<span class="sd">    from neurd import neuron_statistics as nst</span>
<span class="sd">    nst.n_small_children(limb_obj = neuron_obj[6],</span>
<span class="sd">        branch_idx = 5,</span>
<span class="sd">        width_maximum = 80,</span>
<span class="sd">    verbose = False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">downstream_n</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                        <span class="n">branch_idx</span><span class="p">)</span>
    <span class="n">downstream_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_n</span><span class="p">])</span>

    <span class="n">n_small_downstream</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">downstream_width</span> <span class="o">&lt;</span> <span class="n">width_maximum</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_n = </span><span class="si">{</span><span class="n">downstream_n</span><span class="si">}</span><span class="s2">, downstream_width = </span><span class="si">{</span><span class="n">downstream_width</span><span class="si">}</span><span class="s2">,&quot;</span>
              <span class="sa">f</span><span class="s2">&quot; n_small_downstream = </span><span class="si">{</span><span class="n">n_small_downstream</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n_small_downstream</span></div>

<div class="viewcode-block" id="child_angles"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.child_angles">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">child_angles</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To measure all of the angles betweent he children nodes</span>

<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the downstream nodes --&gt; if none or one then return empty dictionary</span>

<span class="sd">    For all downstream nodes:</span>
<span class="sd">    2) choose one of the downstream nodes and send to nru.find_sibling_child_skeleton_angle</span>
<span class="sd">    3) create a dictionary with the nodes in a tuple as the key and the angle between </span>
<span class="sd">    them as the values</span>

<span class="sd">    will error if more than 2 children current</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.child_angles(limb_obj = neuron_obj[6],</span>
<span class="sd">    branch_idx = 22,</span>
<span class="sd">    verbose = False,</span>
<span class="sd">    )</span>

<span class="sd">    &quot;&quot;&quot;</span>




    <span class="c1">#1) Get the downstream nodes --&gt; if none or one then return empty dictionary</span>
    <span class="n">downstream_n</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_n</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not implemented for number of children more than 2 and currently there are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">downstream_n</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1">#2) choose one of the downstream nodes and send to nru.find_sibling_child_skeleton_angle</span>
    <span class="n">sibling_angles</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                         <span class="n">downstream_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                            <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">)</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{(</span><span class="n">downstream_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="p">):</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">sibling_angles</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_dict= </span><span class="si">{</span><span class="n">return_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">return_dict</span></div>


<div class="viewcode-block" id="angle_from_top"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.angle_from_top">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">angle_from_top</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span>
    <span class="n">vector_pointing_to_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will find the angle between</span>
<span class="sd">    a vector and the vector pointing towards the top</span>
<span class="sd">    of the volume</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vector</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">st_vector_norm</span> <span class="o">=</span> <span class="n">vector</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="n">angle_from_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nu</span><span class="o">.</span><span class="n">angle_between_vectors</span><span class="p">(</span><span class="n">vector_pointing_to_top</span><span class="p">,</span><span class="n">st_vector_norm</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">angle_from_top</span></div>


<div class="viewcode-block" id="children_skeletal_lengths"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.children_skeletal_lengths">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">children_skeletal_lengths</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">branch_idx</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To generate the downstream skeletal lengths of all children</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Find the downstream nodes</span>
<span class="sd">    2) Compute the downstream skeletal length for each</span>
<span class="sd">    3) return as dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">vals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                             <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span>
                                             <span class="n">include_branch_skeletal_length</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream values = </span><span class="si">{</span><span class="n">vals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="children_skeletal_lengths_min"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.children_skeletal_lengths_min">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">children_skeletal_lengths_min</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">branch_idx</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="n">return_sk_len</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">children_skeletal_lengths</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                        <span class="n">branch_idx</span><span class="p">,</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                        <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_sk_len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">return_sk_len</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="children_feature"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.children_feature">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">children_feature</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">feature_func</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To compute a feature over all of the children nodes of</span>
<span class="sd">    a traget branchn</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">feature_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                             <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">feature_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> values = </span><span class="si">{</span><span class="n">vals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="children_axon_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.children_axon_width">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">children_axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the axon width of all the children</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">feature_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">feature_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                <span class="p">))</span>
                  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Childrean Axon Width values = </span><span class="si">{</span><span class="n">vals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">vals</span></div>

<div class="viewcode-block" id="children_axon_width_max"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.children_axon_width_max">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">children_axon_width_max</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">children_widths</span> <span class="o">=</span> <span class="n">children_axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                       <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                       <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">children_widths</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="upstream_axon_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.upstream_axon_width">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">upstream_axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                        <span class="n">default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the widh of the upstream branch</span>
<span class="sd">    </span>
<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the upstream branch</span>
<span class="sd">    2) return the width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">up_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">up_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">up_node</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="upstream_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.upstream_skeletal_length">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">upstream_skeletal_length</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span>
                        <span class="n">default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the skeletal length of the upstream branch</span>
<span class="sd">    </span>
<span class="sd">    Psuedocode: </span>
<span class="sd">    1) Get the upstream branch</span>
<span class="sd">    2) return the width</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">up_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">up_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">up_node</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span></div>
    
    
<div class="viewcode-block" id="skeletal_length_along_path"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeletal_length_along_path">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeletal_length_along_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                              <span class="n">branch_path</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_path</span><span class="p">])</span></div>
<div class="viewcode-block" id="total_upstream_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.total_upstream_skeletal_length">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">total_upstream_skeletal_length</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                  <span class="n">branch_idx</span><span class="p">,</span>
                                   <span class="n">include_branch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get all of the skeleton length from current branch to </span>
<span class="sd">    starting branch</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(f&quot;include_branch = {include_branch}&quot;)</span>
    
    <span class="n">branch_path</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_start_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                             <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">include_branch_idx</span> <span class="o">=</span> <span class="n">include_branch</span><span class="p">,</span>
                            <span class="n">skeletal_length_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">skeletal_length_along_path</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_path</span><span class="p">)</span></div>

<span class="c1"># --------- 6/17: Functions for helping pair branches with each other ----------#</span>
<div class="viewcode-block" id="width_new"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_new">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_new</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">width_new_name</span><span class="o">=</span><span class="s2">&quot;no_spine_mean_mesh_center&quot;</span><span class="p">,</span>
              <span class="n">width_new_name_backup</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_new_name</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_new_name_backup</span><span class="p">]</span></div>


<div class="viewcode-block" id="width_diff_basic"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_diff_basic">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_diff_basic</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                 <span class="n">branch_1_idx</span><span class="p">,</span>
                 <span class="n">branch_2_idx</span><span class="p">,</span>
                 <span class="n">width_func</span> <span class="o">=</span> <span class="n">width_new</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_statistics as nst</span>
<span class="sd">    nst.width_diff_percentage_basic(n_obj_syn[0],1,2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">width_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_1_idx</span><span class="p">])</span> <span class="o">-</span> <span class="n">width_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_2_idx</span><span class="p">]))</span></div>


<div class="viewcode-block" id="width_diff"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_diff">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_diff</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                 <span class="n">branch_1_idx</span><span class="p">,</span>
                 <span class="n">branch_2_idx</span><span class="p">,</span>
                 <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">branch_1_direction</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                   <span class="n">branch_2_direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                  <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">return_individual_widths</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    
    <span class="n">branch_1_width</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">width_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                  <span class="n">branch_1_idx</span><span class="p">,</span>
                                                  <span class="n">direction</span><span class="o">=</span><span class="n">branch_1_direction</span><span class="p">,</span>
                                                  <span class="n">distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                  <span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">,</span>
                                                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
    
    <span class="n">branch_2_width</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">width_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                  <span class="n">branch_2_idx</span><span class="p">,</span>
                                                  <span class="n">direction</span><span class="o">=</span><span class="n">branch_2_direction</span><span class="p">,</span>
                                                  <span class="n">distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                  <span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">,</span>
                                                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_1_width = </span><span class="si">{</span><span class="n">branch_1_width</span><span class="si">}</span><span class="s2">, branch_2_width = </span><span class="si">{</span><span class="n">branch_2_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">width_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">branch_1_width</span> <span class="o">-</span> <span class="n">branch_2_width</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_individual_widths</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">width_d</span><span class="p">,</span><span class="n">branch_1_width</span><span class="p">,</span><span class="n">branch_1_width</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">width_d</span></div>

<div class="viewcode-block" id="width_max"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_max">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_max</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
             <span class="n">branches_idxs</span><span class="p">,</span>
             <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">width_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches_idxs</span><span class="p">])</span></div>

<div class="viewcode-block" id="width_diff_percentage_basic"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_diff_percentage_basic">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_diff_percentage_basic</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                 <span class="n">branch_1_idx</span><span class="p">,</span>
                 <span class="n">branch_2_idx</span><span class="p">,</span>
                 <span class="n">width_func</span> <span class="o">=</span> <span class="n">width_new</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_statistics as nst</span>
<span class="sd">    nst.width_diff_percentage_basic(n_obj_syn[0],1,2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_diff</span> <span class="o">=</span> <span class="n">width_diff</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_1_idx</span><span class="o">=</span><span class="n">branch_1_idx</span><span class="p">,</span>
                       <span class="n">branch_2_idx</span><span class="o">=</span><span class="n">branch_2_idx</span><span class="p">,</span>
                       <span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">)</span>
    <span class="n">max_width</span> <span class="o">=</span> <span class="n">width_max</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,[</span><span class="n">branch_1_idx</span><span class="p">,</span><span class="n">branch_2_idx</span><span class="p">],</span><span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w_diff_perc</span> <span class="o">=</span> <span class="n">w_diff</span><span class="o">/</span><span class="n">max_width</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_diff_perc</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;w_diff= </span><span class="si">{</span><span class="n">w_diff</span><span class="si">}</span><span class="s2">, max_width = </span><span class="si">{</span><span class="n">max_width</span><span class="si">}</span><span class="s2">, w_diff_perc = </span><span class="si">{</span><span class="n">w_diff_perc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w_diff_perc</span></div>

<div class="viewcode-block" id="width_diff_percentage"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_diff_percentage">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_diff_percentage</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                 <span class="n">branch_1_idx</span><span class="p">,</span>
                 <span class="n">branch_2_idx</span><span class="p">,</span>
                 <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">branch_1_direction</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                   <span class="n">branch_2_direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                  <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
                  
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    
    <span class="n">w_diff</span><span class="p">,</span> <span class="n">b1_w</span><span class="p">,</span> <span class="n">b2_w</span><span class="o">=</span> <span class="n">width_diff</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_1_idx</span><span class="o">=</span><span class="n">branch_1_idx</span><span class="p">,</span>
                       <span class="n">branch_2_idx</span><span class="o">=</span><span class="n">branch_2_idx</span><span class="p">,</span>
                       <span class="n">width_func</span><span class="o">=</span><span class="n">width_func</span><span class="p">,</span>
                       <span class="n">branch_1_direction</span> <span class="o">=</span> <span class="n">branch_1_direction</span><span class="p">,</span>
                   <span class="n">branch_2_direction</span> <span class="o">=</span> <span class="n">branch_2_direction</span><span class="p">,</span>
                  <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
              <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                       <span class="n">return_individual_widths</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    
    <span class="n">max_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">b1_w</span><span class="p">,</span> <span class="n">b2_w</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">max_width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">w_diff_perc</span> <span class="o">=</span> <span class="n">w_diff</span><span class="o">/</span><span class="n">max_width</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_diff_perc</span> <span class="o">=</span> <span class="mi">0</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;w_diff= </span><span class="si">{</span><span class="n">w_diff</span><span class="si">}</span><span class="s2">, max_width = </span><span class="si">{</span><span class="n">max_width</span><span class="si">}</span><span class="s2">, w_diff_perc = </span><span class="si">{</span><span class="n">w_diff_perc</span><span class="si">}</span><span class="s2">, for individual widths: </span><span class="si">{</span><span class="n">b1_w</span><span class="p">,</span><span class="n">b2_w</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w_diff_perc</span></div>



<div class="viewcode-block" id="parent_child_sk_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.parent_child_sk_angle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">parent_child_sk_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branch_1_idx</span><span class="p">,</span>
                                <span class="n">branch_2_idx</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">find_parent_child_skeleton_angle_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                        <span class="n">branch_1_idx</span><span class="p">,</span>
                                                        <span class="n">branch_2_idx</span><span class="p">,</span>
                                                        <span class="n">branch_1_type</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                                                        <span class="n">branch_2_type</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                                        <span class="n">use_upstream_skeleton_restriction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="sibling_sk_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.sibling_sk_angle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">sibling_sk_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branch_1_idx</span><span class="p">,</span>
                                <span class="n">branch_2_idx</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">find_parent_child_skeleton_angle_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                        <span class="n">branch_1_idx</span><span class="p">,</span>
                                                        <span class="n">branch_2_idx</span><span class="p">,</span>
                                                        <span class="n">branch_1_type</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                                        <span class="n">branch_2_type</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                                        <span class="n">use_upstream_skeleton_restriction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<span class="c1"># def none_to_some_synapses(limb_obj,</span>
<span class="c1">#                           branch_1_idx,</span>
<span class="c1">#                          branch_2_idx,</span>
<span class="c1">#                          synapse_type=None,):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Purpose: To indicate if there were no synapses and then some synapses</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     attr_name = &quot;synapses&quot;</span>
<span class="c1">#     if synapse_type is not None:</span>
<span class="c1">#         attr_name += f&quot;_{synapse_type}&quot;</span>
        
<span class="c1">#     n_syn_branch_1 = len(getattr(limb_obj[branch_1_idx],attr_name))</span>
<span class="c1">#     n_syn_branch_2 = len(getattr(limb_obj[branch_2_idx],attr_name))</span>
    
<span class="c1">#     if n_syn_branch_1 &gt; 0 and n_syn_branch_2 &gt; 0:</span>
<span class="c1">#         return False</span>
    
<span class="c1">#     if n_syn_branch_1 &gt; 0 or n_syn_branch_2 &gt; 0: </span>
<span class="c1">#         return True</span>
    
<span class="c1">#     return False</span>
    
<span class="c1"># def n_synapses_diff(limb_obj,</span>
<span class="c1">#                       branch_1_idx,</span>
<span class="c1">#                       branch_2_idx,</span>
<span class="c1">#                   synapse_type=None,</span>
<span class="c1">#                   verbose = False):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Purpose: Will return the different in number of synapses</span>
    
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     attr_name = &quot;synapses&quot;</span>
<span class="c1">#     if synapse_type is not None:</span>
<span class="c1">#         attr_name += f&quot;_{synapse_type}&quot;</span>
        
<span class="c1">#     n_syn_branch_1 = len(getattr(limb_obj[branch_1_idx],attr_name))</span>
<span class="c1">#     n_syn_branch_2 = len(getattr(limb_obj[branch_2_idx],attr_name))</span>
    
<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;Using {attr_name}&quot;)</span>
<span class="c1">#         print(f&quot;n_syn_branch_1 = {n_syn_branch_1}, n_syn_branch_2 = {n_syn_branch_2}&quot;)</span>
    
<span class="c1">#     return np.abs(n_syn_branch_1 - n_syn_branch_2)</span>

<div class="viewcode-block" id="n_synapses_diff"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_diff">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_diff</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">branch_1_idx</span><span class="p">,</span>
                      <span class="n">branch_2_idx</span><span class="p">,</span>
                    <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                    <span class="n">branch_1_direction</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                    <span class="n">branch_2_direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the different in number of synapses</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(f&quot;synapse_type inside nst = {synapse_type}&quot;)</span>
    <span class="n">n_syn_branch_1</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapses_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                            <span class="n">branch_1_idx</span><span class="p">,</span>
                                                             <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                                                            <span class="n">direction</span><span class="o">=</span><span class="n">branch_1_direction</span><span class="p">,</span>
                                                            <span class="n">distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
    <span class="n">n_syn_branch_2</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapses_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                            <span class="n">branch_2_idx</span><span class="p">,</span>
                                                             <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                                                            <span class="n">direction</span><span class="o">=</span><span class="n">branch_2_direction</span><span class="p">,</span>
                                                            <span class="n">distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        
    <span class="n">n_syn_branch_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_syn_branch_1</span><span class="p">)</span>
    <span class="n">n_syn_branch_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_syn_branch_2</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using </span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_syn_branch_1 = </span><span class="si">{</span><span class="n">n_syn_branch_1</span><span class="si">}</span><span class="s2">, n_syn_branch_2 = </span><span class="si">{</span><span class="n">n_syn_branch_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_syn_branch_1</span> <span class="o">-</span> <span class="n">n_syn_branch_2</span><span class="p">)</span></div>

<span class="c1"># def synapse_density_diff(limb_obj,</span>
<span class="c1">#                       branch_1_idx,</span>
<span class="c1">#                       branch_2_idx,</span>
<span class="c1">#                   synapse_type=None,</span>
<span class="c1">#                   verbose = False):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Purpose: Will return the different in number of synapses</span>
    
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     attr_name = &quot;synapse_density&quot;</span>
<span class="c1">#     if synapse_type is not None:</span>
<span class="c1">#         attr_name += f&quot;_{synapse_type}&quot;</span>
        
<span class="c1">#     n_syn_branch_1 = getattr(limb_obj[branch_1_idx],attr_name)</span>
<span class="c1">#     n_syn_branch_2 = getattr(limb_obj[branch_2_idx],attr_name)</span>
    
<span class="c1">#     if verbose:</span>
<span class="c1">#         print(f&quot;Using {attr_name}&quot;)</span>
<span class="c1">#         print(f&quot;n_syn_branch_1 = {n_syn_branch_1}, n_syn_branch_2 = {n_syn_branch_2}&quot;)</span>
    
<span class="c1">#     return np.abs(n_syn_branch_1 - n_syn_branch_2)</span>

<div class="viewcode-block" id="synapse_density_diff"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapse_density_diff">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapse_density_diff</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">branch_1_idx</span><span class="p">,</span>
                      <span class="n">branch_2_idx</span><span class="p">,</span>
                  <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapse_density&quot;</span><span class="p">,</span>
                    <span class="n">branch_1_direction</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                    <span class="n">branch_2_direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the different in number of synapses</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="n">n_syn_branch_1</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapse_density_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                            <span class="n">branch_1_idx</span><span class="p">,</span>
                                                             <span class="n">synapse_density_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                                                            <span class="n">direction</span><span class="o">=</span><span class="n">branch_1_direction</span><span class="p">,</span>
                                                            <span class="n">distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
    <span class="n">n_syn_branch_2</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapse_density_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                            <span class="n">branch_2_idx</span><span class="p">,</span>
                                                             <span class="n">synapse_density_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                                                            <span class="n">direction</span><span class="o">=</span><span class="n">branch_2_direction</span><span class="p">,</span>
                                                            <span class="n">distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using </span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;syn_density_branch_1 = </span><span class="si">{</span><span class="n">n_syn_branch_1</span><span class="si">}</span><span class="s2">, syn_density_branch_2 = </span><span class="si">{</span><span class="n">n_syn_branch_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_syn_branch_1</span> <span class="o">-</span> <span class="n">n_syn_branch_2</span><span class="p">)</span></div>


<div class="viewcode-block" id="compute_edge_attributes_locally"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.compute_edge_attributes_locally">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">compute_edge_attributes_locally</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                          <span class="n">limb_obj</span><span class="p">,</span>
                                         <span class="n">nodes_to_compute</span><span class="p">,</span>
                                         <span class="n">edge_functions</span><span class="p">,</span>
                                         <span class="n">arguments_for_all_edge_functions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">directional</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                         <span class="n">set_default_at_end</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="n">default_value_at_end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To iterate over graph edges and compute</span>
<span class="sd">    edge properties and store</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    For each nodes to compute:</span>
<span class="sd">        get all of the edges for that node</span>
<span class="sd">        For each downstream partner:</span>
<span class="sd">            For each function:</span>
<span class="sd">                compute the value and store it in the edge</span>
<span class="sd">    Ex: </span>
<span class="sd">    G = complete_graph_from_node_ids(all_branch_idx)</span>

<span class="sd">    nodes_to_compute = [upstream_branch]</span>
<span class="sd">    edge_functions = dict(sk_angle=nst.parent_child_sk_angle,</span>
<span class="sd">                         width_diff = nst.width_diff,</span>
<span class="sd">                          width_diff_percentage = nst.width_diff_percentage)</span>

<span class="sd">    compute_edge_attributes_between_nodes(G,</span>
<span class="sd">                                             nodes_to_compute,</span>
<span class="sd">                                             edge_functions,</span>
<span class="sd">                                             verbose=True,</span>
<span class="sd">                                             directional = False)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">directional</span><span class="p">:</span>
        <span class="n">neighbors_func</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">neighbors_func</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">get_neighbors</span>

    <span class="n">func_value_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_compute</span><span class="p">:</span>
        <span class="n">func_value_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">down_nodes</span> <span class="o">=</span> <span class="n">neighbors_func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">down_nodes</span><span class="p">:</span>
            <span class="n">func_value_dict</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Neighbor </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span><span class="n">func_info</span> <span class="ow">in</span> <span class="n">edge_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func_info</span><span class="p">):</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="s2">&quot;arguments&quot;</span> <span class="ow">in</span> <span class="n">func_info</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">args</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;arguments&quot;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">func_info</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                    
                <span class="k">if</span> <span class="n">arguments_for_all_edge_functions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">func_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arguments_for_all_edge_functions</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">func_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
                <span class="n">func_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                
                <span class="n">func_value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
            
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">func_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">func_value_dict</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">d</span><span class="p">][</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_value</span>
    
    <span class="n">xu</span><span class="o">.</span><span class="n">apply_edge_attribute_dict_to_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">func_value_dict</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">set_default_at_end</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span><span class="n">func_info</span> <span class="ow">in</span> <span class="n">edge_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">d_value</span> <span class="o">=</span> <span class="n">default_value_at_end</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;default_value&quot;</span> <span class="ow">in</span> <span class="n">func_info</span><span class="p">:</span>
                    <span class="n">d_value</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;defualt_value&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">set_edge_attribute_defualt</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">func_name</span><span class="p">,</span><span class="n">d_value</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="compute_edge_attributes_locally_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.compute_edge_attributes_locally_upstream_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">compute_edge_attributes_locally_upstream_downstream</span><span class="p">(</span>
            <span class="n">limb_obj</span><span class="p">,</span>
            <span class="n">upstream_branch</span><span class="p">,</span>
            <span class="n">downstream_branches</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
            <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
            <span class="n">plot_extracted_skeletons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">concept_network_comparison_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
            <span class="n">synapse_density_diff_type</span> <span class="o">=</span> <span class="s2">&quot;synapse_density_pre&quot;</span><span class="p">,</span>
            <span class="n">n_synapses_diff_type</span> <span class="o">=</span> <span class="s2">&quot;synapses_pre&quot;</span><span class="p">,</span>
            
    
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To compute a graph storing the values for the</span>
<span class="sd">    edges between the nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_branch_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">downstream_branches</span><span class="p">,[</span><span class="n">upstream_branch</span><span class="p">]])</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">complete_graph_from_node_ids</span><span class="p">(</span><span class="n">all_branch_idx</span><span class="p">)</span>
    
    <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="p">[</span><span class="n">upstream_branch</span><span class="p">]</span>
    
    <span class="n">arguments_for_all_edge_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                                        <span class="c1">#nodes_to_exclude=nodes_to_exclude,</span>
                                           <span class="n">branch_1_direction</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                                            <span class="n">branch_2_direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                           <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">concept_network_comparison_distance</span><span class="p">)</span>
    
    <span class="n">edge_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sk_angle</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">parent_child_sk_angle</span><span class="p">,</span>
                                        <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                      <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                      <span class="n">plot_extracted_skeletons</span><span class="o">=</span><span class="n">plot_extracted_skeletons</span><span class="p">)),</span>
                         <span class="n">width_diff</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_diff</span><span class="p">,</span>
                          <span class="n">width_diff_percentage</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_diff_percentage</span><span class="p">,</span>
                         <span class="n">synapse_density_diff</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">synapse_density_diff</span><span class="p">,</span>
                                               <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">synapse_type</span> <span class="o">=</span> <span class="n">synapse_density_diff_type</span><span class="p">)),</span>
                          <span class="n">n_synapses_diff</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_diff</span><span class="p">,</span>
                                                 <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">=</span><span class="n">n_synapses_diff_type</span><span class="p">)),</span>
                          <span class="c1">#none_to_some_synapses = nst.none_to_some_synapses</span>
                         <span class="p">)</span>

    <span class="n">G_e_1</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">compute_edge_attributes_locally</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                              <span class="n">limb_obj</span><span class="p">,</span>
                                             <span class="n">nodes_to_compute</span><span class="p">,</span>
                                             <span class="n">edge_functions</span><span class="p">,</span>
                                                <span class="n">arguments_for_all_edge_functions</span><span class="o">=</span><span class="n">arguments_for_all_edge_functions</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">directional</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">downstream_branches</span>
    
    <span class="n">arguments_for_all_edge_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                                        <span class="c1">#nodes_to_exclude=nodes_to_exclude,</span>
                                           <span class="n">branch_1_direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                            <span class="n">branch_2_direction</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                           <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">concept_network_comparison_distance</span><span class="p">)</span>
    
    <span class="n">edge_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                          <span class="n">sk_angle</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">sibling_sk_angle</span><span class="p">,</span>
                                        <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                      <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                <span class="n">plot_extracted_skeletons</span><span class="o">=</span><span class="n">plot_extracted_skeletons</span><span class="p">)),</span>
                         <span class="n">width_diff</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_diff</span><span class="p">,</span>
                          <span class="n">width_diff_percentage</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_diff_percentage</span><span class="p">,</span>
                         <span class="n">synapse_density_diff</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">synapse_density_diff</span><span class="p">,</span>
                                               <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">synapse_type</span> <span class="o">=</span> <span class="n">synapse_density_diff_type</span><span class="p">)),</span>
                          <span class="n">n_synapses_diff</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_diff</span><span class="p">,</span>
                                                 <span class="n">arguments</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">=</span><span class="n">n_synapses_diff_type</span><span class="p">)),</span>
                         <span class="c1">#none_to_some_synapses = nst.none_to_some_synapses</span>
    <span class="p">)</span>

    <span class="n">G_e_2</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">compute_edge_attributes_locally</span><span class="p">(</span><span class="n">G_e_1</span><span class="p">,</span>
                                              <span class="n">limb_obj</span><span class="p">,</span>
                                             <span class="n">nodes_to_compute</span><span class="p">,</span>
                                             <span class="n">edge_functions</span><span class="p">,</span>
                                                <span class="n">arguments_for_all_edge_functions</span><span class="o">=</span><span class="n">arguments_for_all_edge_functions</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">directional</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G_e_2</span></div>
                
                
<span class="c1"># --------- For the global deleteion functions ------------</span>

<div class="viewcode-block" id="compute_edge_attributes_globally"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.compute_edge_attributes_globally">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">compute_edge_attributes_globally</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                     <span class="n">edge_functions</span><span class="p">,</span>
                                     <span class="n">edges_to_compute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">arguments_for_all_edge_functions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="n">set_default_at_end</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="n">default_value_at_end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to compute edge attributes</span>
<span class="sd">    that need the whole graph to be computed</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">edges_to_compute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges_to_compute</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="n">other_edges_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_to_compute</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   Working on Edge </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span><span class="n">func_info</span> <span class="ow">in</span> <span class="n">edge_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func_info</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;arguments&quot;</span> <span class="ow">in</span> <span class="n">func_info</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;arguments&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">func_info</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
                
            <span class="k">if</span> <span class="n">arguments_for_all_edge_functions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">func_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arguments_for_all_edge_functions</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">func_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                
            <span class="n">global_edge_dict</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">global_edge_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="n">xu</span><span class="o">.</span><span class="n">apply_edge_attribute_dict_to_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">global_edge_dict</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">func_name</span><span class="p">)</span>
            
            
    <span class="k">if</span> <span class="n">set_default_at_end</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span><span class="n">func_info</span> <span class="ow">in</span> <span class="n">edge_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">d_value</span> <span class="o">=</span> <span class="n">default_value_at_end</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;default_value&quot;</span> <span class="ow">in</span> <span class="n">func_info</span><span class="p">:</span>
                    <span class="n">d_value</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;defualt_value&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">set_edge_attribute_defualt</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">func_name</span><span class="p">,</span><span class="n">d_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
            
<div class="viewcode-block" id="edges_to_delete_from_threshold_and_buffer"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.edges_to_delete_from_threshold_and_buffer">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">edges_to_delete_from_threshold_and_buffer</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                              <span class="n">u</span><span class="p">,</span>
                                              <span class="n">v</span><span class="p">,</span>
                                        <span class="n">edge_attribute</span><span class="o">=</span><span class="s2">&quot;sk_angle&quot;</span><span class="p">,</span>
                                        <span class="n">threshold</span> <span class="o">=</span> <span class="mi">45</span><span class="p">,</span>
                                        <span class="n">buffer</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    4) Create definite pairs by looking for edges that meet:</span>
<span class="sd">    - match threshold</span>
<span class="sd">    - have buffer better than other edges</span>
<span class="sd">    ** for those edges, eliminate all edges on those</span>
<span class="sd">    2 nodes except that edge</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    Iterate through each edge:</span>
<span class="sd">    a) get the current weight of this edge</span>
<span class="sd">    b) get all the other edges that are touching the two nodes and their weights</span>
<span class="sd">    c) Run the following test on the edge:</span>
<span class="sd">       i) Is it in the match limit</span>
<span class="sd">       ii) is it less than other edge weightbs by the buffer size</span>
<span class="sd">    d) If pass the tests then delete all of the other edges from the graph</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    edges_to_delete = edges_to_delete_from_threshold_and_buffer(G,</span>
<span class="sd">                                                            225,</span>
<span class="sd">                                                            226,</span>
<span class="sd">                                          threshold=100,</span>
<span class="sd">                                          buffer= 13,</span>
<span class="sd">                                         verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#verbose = True</span>
    <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span>
    
    <span class="n">edges_to_delete_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--Working on edge </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">-- (attribute = </span><span class="si">{</span><span class="n">edge_attribute</span><span class="si">}</span><span class="s2">, buffer = </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">, threshold= </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="c1">#e_weight = xu.get_edge_weight(G,e)</span>
    <span class="n">e_weight</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">edge_attribute</span><span class="p">]</span>
    <span class="n">all_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">node_to_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_to_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


    <span class="c1">#b) get all the other edges that are touching the two nodes and their weights</span>
    <span class="n">other_edges</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">setdiff2d</span><span class="p">(</span><span class="n">all_edges</span><span class="p">,</span><span class="n">e</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">other_edge_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_edge_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="p">[</span><span class="n">edg</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">edg</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">edge_attribute</span><span class="p">]</span> <span class="k">for</span> <span class="n">edg</span> <span class="ow">in</span> <span class="n">other_edges</span><span class="p">]</span>
        <span class="n">other_edge_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">other_edge_weights</span><span class="p">)</span>

    <span class="n">edge_buffer</span> <span class="o">=</span> <span class="n">other_edge_min</span> <span class="o">-</span> <span class="n">e_weight</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edge_buffer = </span><span class="si">{</span><span class="n">edge_buffer</span><span class="si">}</span><span class="s2"> (other_edge_min = </span><span class="si">{</span><span class="n">other_edge_min</span><span class="si">}</span><span class="s2">, e_weight = </span><span class="si">{</span><span class="n">e_weight</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">e_weight</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="ow">and</span> <span class="n">edge_buffer</span> <span class="o">&gt;</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2"> is matches definite match threshold with: &quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edge Buffer of </span><span class="si">{</span><span class="n">edge_buffer</span><span class="si">}</span><span class="s2"> (buffer = </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">)&quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edge distane of </span><span class="si">{</span><span class="n">e_weight</span><span class="si">}</span><span class="s2"> (threshold = </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;other_edges = </span><span class="si">{</span><span class="n">other_edges</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="n">edges_to_delete_dict</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_attribute_dict_from_edges</span><span class="p">(</span><span class="n">other_edges</span><span class="p">)</span>
        <span class="n">edges_to_keep_dict</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_attribute_dict_from_edges</span><span class="p">([</span><span class="n">e</span><span class="p">],</span><span class="n">value_to_store</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">edges_to_delete_dict</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">combine_edge_attributes</span><span class="p">([</span><span class="n">edges_to_delete_dict</span><span class="p">,</span><span class="n">edges_to_keep_dict</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_delete_dict = </span><span class="si">{</span><span class="n">edges_to_delete_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">edges_to_delete_dict</span></div>



<span class="c1"># -------------- For node level edge attributes ------------- 3</span>
<div class="viewcode-block" id="compute_edge_attributes_around_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.compute_edge_attributes_around_node">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">compute_edge_attributes_around_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                        <span class="n">edge_functions</span><span class="p">,</span>
                                        <span class="n">edge_functions_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span>
                                        <span class="n">nodes_to_compute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">arguments_for_all_edge_functions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="c1">#directional = False,</span>
                                         <span class="n">set_default_at_end</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                         <span class="n">default_value_at_end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To use all the edges around a node </span>
<span class="sd">    to compute edge features</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">nodes_to_compute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">nodes_to_compute</span><span class="p">):</span>
        <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes_to_compute</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_compute = </span><span class="si">{</span><span class="n">nodes_to_compute</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_compute</span><span class="p">:</span>
        <span class="n">node_edges</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">node_to_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span><span class="n">func_info</span> <span class="ow">in</span> <span class="n">edge_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func_info</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;arguments&quot;</span> <span class="ow">in</span> <span class="n">func_info</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;arguments&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">func_info</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                
            <span class="k">if</span> <span class="n">arguments_for_all_edge_functions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">func_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arguments_for_all_edge_functions</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="n">func_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                
            <span class="n">node_edge_dict</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_edges</span><span class="p">,</span><span class="o">**</span><span class="n">func_args</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;      </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">node_edge_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="n">xu</span><span class="o">.</span><span class="n">apply_edge_attribute_dict_to_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_edge_dict</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">func_name</span><span class="p">)</span>
            
            
    <span class="k">if</span> <span class="n">set_default_at_end</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span><span class="n">func_info</span> <span class="ow">in</span> <span class="n">edge_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">d_value</span> <span class="o">=</span> <span class="n">default_value_at_end</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;default_value&quot;</span> <span class="ow">in</span> <span class="n">func_info</span><span class="p">:</span>
                    <span class="n">d_value</span> <span class="o">=</span> <span class="n">func_info</span><span class="p">[</span><span class="s2">&quot;defualt_value&quot;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">xu</span><span class="o">.</span><span class="n">set_edge_attribute_defualt</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">func_name</span><span class="p">,</span><span class="n">d_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>
            
<div class="viewcode-block" id="edges_to_delete_on_node_above_threshold_if_one_below"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.edges_to_delete_on_node_above_threshold_if_one_below">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">edges_to_delete_on_node_above_threshold_if_one_below</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                                  <span class="n">node_edges</span><span class="p">,</span>
                                                   <span class="n">threshold</span><span class="p">,</span>
                                                   <span class="n">edge_attribute</span><span class="o">=</span><span class="s2">&quot;sk_angle&quot;</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To mark edges that should</span>
<span class="sd">    be deleted if there is another node</span>
<span class="sd">    that is already below the threshold</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode:</span>
<span class="sd">    1) Get the values of the attribute for all of the edges</span>
<span class="sd">    2) Get the number of these values below the threshold</span>
<span class="sd">    3) If at least one value below, then get the edges that are above </span>
<span class="sd">    the threshold, turn them into an edge_attribute dict and return</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">edge_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">edge_attribute</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">node_edges</span><span class="p">])</span>
    <span class="n">under_threshold_mask</span> <span class="o">=</span> <span class="n">edge_values</span><span class="o">&lt;=</span><span class="n">threshold</span>
    <span class="n">n_below_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">under_threshold_mask</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;for edge_values = </span><span class="si">{</span><span class="n">edge_values</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">n_below_match = </span><span class="si">{</span><span class="n">n_below_match</span><span class="si">}</span><span class="s2"> (with threshold = </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">n_below_match</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">node_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_edges</span><span class="p">)</span>
    <span class="n">edges_to_delete</span> <span class="o">=</span> <span class="n">node_edges</span><span class="p">[</span><span class="n">edge_values</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;edges_to_delete = </span><span class="si">{</span><span class="n">edges_to_delete</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xu</span><span class="o">.</span><span class="n">edge_attribute_dict_from_edges</span><span class="p">(</span><span class="n">edges_to_delete</span><span class="p">)</span></div>



<div class="viewcode-block" id="find_parent_child_skeleton_angle_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.find_parent_child_skeleton_angle_upstream_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">find_parent_child_skeleton_angle_upstream_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                         <span class="n">branch_1_idx</span><span class="p">,</span>
                                                         <span class="n">branch_2_idx</span><span class="p">,</span>
                                                         <span class="n">branch_1_type</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                                                         <span class="n">branch_2_type</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                        <span class="n">offset</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
                                                        <span class="n">min_comparison_distance</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                                                        <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
                                                         <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                                        <span class="n">plot_extracted_skeletons</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                         <span class="n">use_upstream_skeleton_restriction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="n">use_downstream_skeleton_restriction</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                                         <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                         <span class="o">**</span><span class="n">kwargs</span>
                                                        <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to find the skeleton angle between a designated</span>
<span class="sd">    upstream and downstream branch</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nru.find_parent_child_skeleton_angle_upstream_downstream(</span>
<span class="sd">        limb_obj = neuron_obj[0],</span>
<span class="sd">    branch_1_idx = 223,</span>
<span class="sd">    branch_2_idx = 224,</span>
<span class="sd">        plot_extracted_skeletons = True</span>
<span class="sd">    )</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    branch_idx = 140</span>
<span class="sd">    nru.find_parent_child_skeleton_angle_upstream_downstream(limb_obj,</span>
<span class="sd">                                                            nru.upstream_node(limb_obj,branch_idx),branch_idx,</span>
<span class="sd">                                                            verbose = True,</span>
<span class="sd">                                                            plot_extracted_skeletons=True,</span>
<span class="sd">                                                            comparison_distance=40000,</span>
<span class="sd">                                                            use_upstream_skeleton_restriction=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_sk</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b_idx</span><span class="p">,</span><span class="n">b_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">branch_1_idx</span><span class="p">,</span><span class="n">branch_2_idx</span><span class="p">],</span>
                            <span class="p">[</span><span class="n">branch_1_type</span><span class="p">,</span><span class="n">branch_2_type</span><span class="p">]):</span>
        
        <span class="n">upstream_func</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">b_type</span> <span class="o">==</span> <span class="s2">&quot;downstream&quot;</span><span class="p">:</span>
            <span class="n">b_endpt</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">b_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_downstream_skeleton_restriction</span><span class="p">:</span>
                <span class="n">downstream_func</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">b_endpt</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                 <span class="n">b_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_upstream_skeleton_restriction</span><span class="p">:</span>
                <span class="n">upstream_func</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">if</span> <span class="n">upstream_func</span><span class="p">:</span>
            <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset_upstream</span><span class="p">(</span>
                                                                <span class="n">limb_obj</span><span class="p">,</span>
                                                                <span class="n">b_idx</span><span class="p">,</span>
                                                                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                                <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">,</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                <span class="n">start_coordinate</span><span class="o">=</span><span class="n">b_endpt</span><span class="p">,</span>
                                                                <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="n">skeleton_resolution</span><span class="p">,</span>
                                                                <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">downstream_func</span><span class="p">:</span>
            <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset_downstream</span><span class="p">(</span>
                                                                <span class="n">limb_obj</span><span class="p">,</span>
                                                                <span class="n">b_idx</span><span class="p">,</span>
                                                                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                                <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">,</span>
                                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                                <span class="n">start_coordinate</span><span class="o">=</span><span class="n">b_endpt</span><span class="p">,</span>
                                                                <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="n">skeleton_resolution</span><span class="p">,</span>
                                                                <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                                   <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                                    <span class="n">min_comparison_distance</span><span class="o">=</span><span class="n">min_comparison_distance</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                 <span class="n">start_coordinate</span><span class="o">=</span><span class="n">b_endpt</span><span class="p">,</span>
                                                                  <span class="n">skeleton_resolution</span> <span class="o">=</span> <span class="n">skeleton_resolution</span>
                                                   <span class="p">)</span>
        <span class="n">output_sk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_sk</span><span class="p">)</span>
        <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_endpt</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b_type</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">b_idx</span><span class="si">}</span><span class="s2"> endpoint: </span><span class="si">{</span><span class="n">b_endpt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">up_sk</span> <span class="o">=</span> <span class="n">output_sk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">d_sk</span> <span class="o">=</span> <span class="n">output_sk</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
<span class="c1">#     sk.restrict_skeleton_from_start_plus_offset(limb_obj[branch_1_idx].skeleton,</span>
<span class="c1">#                                                    offset=offset,</span>
<span class="c1">#                                                 comparison_distance=comparison_distance,</span>
<span class="c1">#                                                     min_comparison_distance=min_comparison_distance,</span>
<span class="c1">#                                                 verbose=verbose,</span>
<span class="c1">#                                                  start_coordinate=b_1_endpt,</span>
<span class="c1">#                                                    )</span>

<span class="c1">#     d_sk = sk.restrict_skeleton_from_start_plus_offset(limb_obj[branch_2_idx].skeleton,</span>
<span class="c1">#                                                    offset=offset,</span>
<span class="c1">#                                                 comparison_distance=comparison_distance,</span>
<span class="c1">#                                                     min_comparison_distance=min_comparison_distance,</span>
<span class="c1">#                                                 verbose=verbose,</span>
<span class="c1">#                                                  start_coordinate=b_2_endpt,</span>
<span class="c1">#                                                    )</span>

    <span class="n">curr_angle</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">parent_child_skeletal_angle</span><span class="p">(</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_angle = </span><span class="si">{</span><span class="n">curr_angle</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">plot_extracted_skeletons</span><span class="p">:</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_1_idx</span><span class="p">,</span><span class="n">branch_2_idx</span><span class="p">]</span>
        <span class="n">parent_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">child_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parent (</span><span class="si">{</span><span class="n">branch_1_idx</span><span class="si">}</span><span class="s2">):</span><span class="si">{</span><span class="n">parent_color</span><span class="si">}</span><span class="s2">, child (</span><span class="si">{</span><span class="n">branch_2_idx</span><span class="si">}</span><span class="s2">):</span><span class="si">{</span><span class="n">child_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">parent_color</span><span class="p">,</span><span class="n">child_color</span><span class="p">]</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bs</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                         <span class="n">skeletons</span> <span class="o">=</span><span class="p">[</span><span class="n">up_sk</span><span class="p">,</span><span class="n">d_sk</span><span class="p">],</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="n">endpoints</span><span class="p">,</span>
                         <span class="n">scatters_colors</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">curr_angle</span></div>

    
<div class="viewcode-block" id="ray_trace_perc"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.ray_trace_perc">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">ray_trace_perc</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="n">percentile</span><span class="o">=</span><span class="mi">85</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_size</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span><span class="s1">&#39;ray_trace_percentile&#39;</span><span class="p">,</span><span class="n">percentile</span><span class="p">)</span></div>

<div class="viewcode-block" id="parent_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.parent_width">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">parent_width</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">width_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span>
    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="k">return</span> <span class="n">width_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">])</span></div>

<div class="viewcode-block" id="min_synapse_dist_to_branch_point"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.min_synapse_dist_to_branch_point">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">min_synapse_dist_to_branch_point</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">downstream_branches</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downstream_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">default_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="n">plot_closest_synapse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">synapse_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1">#either pre or post</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To check if any of the synapses on the </span>
<span class="sd">    branch or downstream branches has a synapse</span>
<span class="sd">    close to the branching point</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    2) Get all of the downstream synapses (not including the current branch)</span>
<span class="sd">    3) Get all of the distances upstream</span>
<span class="sd">    4) Get the synapses for the current branch</span>
<span class="sd">    5) Get all fo the distances dowsntream </span>
<span class="sd">    6) Concatenate the distances</span>
<span class="sd">    7) Find the minimum distance (if none then make inf)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_statistics as nst</span>
<span class="sd">    nst.min_synapse_dist_to_branch_point(limb_obj,</span>
<span class="sd">        branch_idx = 16,</span>
<span class="sd">        downstream_distance = 0,</span>
<span class="sd">        default_value = np.inf,</span>
<span class="sd">        plot_closest_synapse = True,</span>
<span class="sd">        verbose = True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#2) Get all of the downstream synapses (not including the current branch)</span>
    
    <span class="k">if</span> <span class="n">downstream_branches</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">down_syn</span><span class="p">,</span><span class="n">down_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                                   <span class="n">distance</span> <span class="o">=</span> <span class="n">downstream_distance</span><span class="p">,</span> 
                                   <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="n">include_branch_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                   <span class="n">plot_synapses</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">return_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">down_nodes</span> <span class="o">=</span> <span class="n">downstream_branches</span>
        <span class="n">down_syn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">synapses</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_branches</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;down_syn = </span><span class="si">{</span><span class="n">down_syn</span><span class="si">}</span><span class="s2">, down_nodes = </span><span class="si">{</span><span class="n">down_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">synapse_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;pre&quot;</span> <span class="ow">in</span> <span class="n">synapse_type</span><span class="p">:</span>
            <span class="n">synapse_type</span> <span class="o">=</span> <span class="s2">&quot;pre&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;post&quot;</span> <span class="ow">in</span> <span class="n">synapse_type</span><span class="p">:</span>
            <span class="n">synapse_type</span> <span class="o">=</span> <span class="s2">&quot;post&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downstream synapses before synapse_type: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">down_syn</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">down_syn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">syu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;synapses_</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="nb">list</span><span class="p">(</span><span class="n">down_syn</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Downstream synapses AFTER synapse_type: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">down_syn</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        

    <span class="c1">#3) Get all of the distances upstream</span>
    <span class="n">upstream_dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">upstream_dist</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">down_syn</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_dist from downstreams = </span><span class="si">{</span><span class="n">upstream_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#4) Get the synapses for the current branch</span>
    <span class="n">curr_syn</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                     <span class="n">branch_idx</span><span class="p">,</span>
                                     <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="n">nodes_to_exclude</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">synapse_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upstream synapses before synapse_type: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_syn</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">curr_syn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">syu</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;synapses_</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_syn</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upstream synapses AFTER synapse_type: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_syn</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">downstream_dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">downstream_dist</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_syn</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_dist from current node = </span><span class="si">{</span><span class="n">downstream_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">all_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">upstream_dist</span><span class="p">,</span><span class="n">downstream_dist</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">min_distance_from_branch_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_dist</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_distance_from_branch_point</span> <span class="o">=</span> <span class="n">default_value</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All distances: </span><span class="si">{</span><span class="n">all_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_distance_from_branch_point: </span><span class="si">{</span><span class="n">min_distance_from_branch_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_closest_synapse</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No synapses to plot&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">branch_point</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
            <span class="n">closest_coordinate</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">coordinate</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">curr_syn</span><span class="p">,</span><span class="n">down_syn</span><span class="p">])</span>
                                         <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">upstream_dist</span> <span class="o">==</span> <span class="n">min_distance_from_branch_point</span> 
                                             <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">downstream_dist</span> <span class="o">==</span> <span class="n">min_distance_from_branch_point</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_branch_with_neighbors</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">down_nodes</span><span class="p">,</span>
                                        <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">branch_point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">closest_coordinate</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)],</span>
                                            <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;yellow&quot;</span><span class="p">],</span>
                                        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">min_distance_from_branch_point</span></div>



<span class="c1"># ---------------- Getting Attributes Using the concept network walking ----------- #</span>

<div class="viewcode-block" id="skeleton_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="skeletal_length_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeletal_length_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeletal_length_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeletal_length_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeletal_length_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeletal_length_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeletal_length_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_downstream_total"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeletal_length_downstream_total">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeletal_length_downstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeletal_length_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                            <span class="n">include_branch_in_dist</span><span class="o">=</span><span class="n">include_branch_in_dist</span><span class="p">,</span>
                            <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_length_upstream_total"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeletal_length_upstream_total">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeletal_length_upstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">include_branch_in_dist</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeletal_length_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                            <span class="n">include_branch_in_dist</span><span class="o">=</span><span class="n">include_branch_in_dist</span><span class="p">,</span>
                            <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="width_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">width_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="width_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">width_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapses_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapses_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                            <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<div class="viewcode-block" id="n_synapses_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="n_synapses_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>
<div class="viewcode-block" id="synapses_downstream_total"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_downstream_total">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_downstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                                   <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                   <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<div class="viewcode-block" id="synapses_upstream_total"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_upstream_total">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_upstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                             <span class="n">distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapses_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                                   <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                   <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<div class="viewcode-block" id="n_synapses_upstream_total"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_upstream_total">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_upstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">synapses_upstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="n_synapses_downstream_total"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_downstream_total">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_downstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                       <span class="n">branch_idx</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">synapses_downstream_total</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<div class="viewcode-block" id="synapses_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_downstream_within_dist">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                                    
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    purpose: to find thenumber of downstream</span>
<span class="sd">    postsyns within a certain downstream distance</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">post_syns</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">synapses_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                           <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">branch_idx</span><span class="p">,</span>
                           <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">only_non_branching</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">include_branch_in_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">include_branch_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="n">synapse_type</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span>
                           <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of postsyns = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">post_syns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_synapses</span><span class="p">:</span>
        <span class="n">syn_coords</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_to_coordinates</span><span class="p">(</span><span class="n">post_syns</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">meshes</span><span class="o">=</span><span class="p">[</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">],</span>
                         <span class="n">meshes_colors</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">syn_coords</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">post_syns</span></div>

<div class="viewcode-block" id="synapses_post_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_post_downstream_within_dist">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_post_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
    <span class="k">return</span> <span class="n">synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses_post&quot;</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,)</span></div>

<div class="viewcode-block" id="synapses_pre_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapses_pre_downstream_within_dist">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapses_pre_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
    <span class="k">return</span> <span class="n">synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses_pre&quot;</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,)</span></div>

<div class="viewcode-block" id="n_synapses_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_downstream_within_dist">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses&quot;</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,))</span></div>

<div class="viewcode-block" id="n_synapses_post_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_post_downstream_within_dist">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_post_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses_post&quot;</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,))</span></div>

<div class="viewcode-block" id="n_synapses_pre_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_pre_downstream_within_dist">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_pre_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">synapses_downstream_within_dist</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">branch_idx</span><span class="p">,</span>
                            <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;synapses_pre&quot;</span><span class="p">,</span>
                            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">,</span>
                            <span class="n">plot_synapses</span> <span class="o">=</span> <span class="n">plot_synapses</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,))</span></div>



<div class="viewcode-block" id="fork_divergence"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.fork_divergence">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">fork_divergence</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">downstream_idxs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="c1">#arguments for skeletons</span>
    <span class="n">skeleton_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>

    <span class="n">error_not_2_downstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="c1">#arguments for enforcing skipping rule for fork check</span>
    <span class="n">total_downstream_skeleton_length_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="c1">#3000#4000</span>
    <span class="n">individual_branch_length_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span><span class="c1">#3000</span>
    <span class="n">skip_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>

    <span class="c1"># for visualizing the current plot</span>
    <span class="n">plot_fork_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>

    <span class="c1">#arguments for the fork divergence measurement</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
    <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="n">plot_restrictions</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">combining_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                    
                <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To run the fork divergence the children</span>
<span class="sd">    of an upstream node</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get downstream nodes</span>
<span class="sd">    2) Apply skeletal length restrictions if any</span>
<span class="sd">    3) compute the fork divergence from the skeletons</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">branch_idx</span>

    <span class="k">if</span> <span class="n">downstream_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">downstream_idxs</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">upstream_sk</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span>
    <span class="n">downstream_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="n">skeleton_distance</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">]</span>


    <span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">if</span> <span class="n">error_not_2_downstream</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not exactly 2 downstream nodes: </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">total_downstream_skeleton_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="n">individual_branch_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">d_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> 
                         <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">])</span>
        <span class="n">d_skeletal_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                <span class="n">d</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal length = </span><span class="si">{</span><span class="n">d_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream skeletal length = </span><span class="si">{</span><span class="n">d_skeletal_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">below_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">d_skeletal_len</span><span class="o">&lt;</span><span class="n">total_downstream_skeleton_length_threshold</span><span class="p">)</span> <span class="o">|</span> 
                                   <span class="p">(</span><span class="n">d_len</span> <span class="o">&lt;</span> <span class="n">individual_branch_length_threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">below_threshold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping this intersection because some of downstream skeletal lengths too short (min </span><span class="si">{</span><span class="n">total_downstream_skeleton_length_threshold</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; or the individual branch length was too short (min </span><span class="si">{</span><span class="n">individual_branch_length_threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">d</span><span class="p">,</span><span class="n">d_len</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">,</span><span class="n">d_skeletal_len</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">below_threshold</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Brnach </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">: length </span><span class="si">{</span><span class="n">d_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">return_value</span> <span class="o">=</span> <span class="n">skip_value</span>


    <span class="k">if</span> <span class="n">plot_fork_skeleton</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_branch_with_neighbors</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="n">main_skeleton</span> <span class="o">=</span> <span class="n">upstream_sk</span><span class="p">,</span>
                                       <span class="n">skeletons</span><span class="o">=</span><span class="n">downstream_sk</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">fork_divergence_from_skeletons</span><span class="p">(</span><span class="n">upstream_skeleton</span> <span class="o">=</span> <span class="n">upstream_sk</span><span class="p">,</span>
                                <span class="n">downstream_skeletons</span> <span class="o">=</span> <span class="n">downstream_sk</span><span class="p">,</span>
                                <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="n">skeletal_segment_size</span><span class="p">,</span>
                                <span class="n">plot_restrictions</span> <span class="o">=</span> <span class="n">plot_restrictions</span><span class="p">,</span>
                                <span class="n">combining_function</span> <span class="o">=</span> <span class="n">combining_function</span><span class="p">,</span>
                                                             <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_value = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="compute_node_attributes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.compute_node_attributes">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">compute_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                            <span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">node_functions</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To Compute node attributes given:</span>
<span class="sd">    - function</span>
<span class="sd">    - arguments for function</span>
<span class="sd">    - nodes to compute for (so can explicitely do for upstream and downstream)</span>

<span class="sd">    Each of this will be stored in a list of dictionaries</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">G_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">att_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">G_nodes</span><span class="p">])</span>
    
    <span class="k">for</span> <span class="n">f_info</span>  <span class="ow">in</span> <span class="n">node_functions</span><span class="p">:</span>
        <span class="n">f_name</span> <span class="o">=</span> <span class="n">f_info</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">f_info</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
        <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">f_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nodes_to_compute&quot;</span><span class="p">,</span><span class="n">G_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">nodes_to_compute</span><span class="p">):</span>
            <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes_to_compute</span><span class="p">]</span>
        
        <span class="n">args</span> <span class="o">=</span> <span class="n">f_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;arguments&quot;</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">f_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{</span><span class="n">f_name</span><span class="si">}</span><span class="s2"> with args = </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">nodes_not_compute</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">G_nodes</span><span class="p">,</span><span class="n">nodes_to_compute</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_to_compute</span><span class="p">:</span>
            <span class="n">att_dict</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">f_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">limb_obj</span><span class="p">,</span>
                                       <span class="n">branch_idx</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_not_compute</span><span class="p">:</span>
                <span class="n">att_dict</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">f_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>

    <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">att_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="node_functions_default"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.node_functions_default">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">node_functions_default</span><span class="p">(</span><span class="n">upstream_branch</span><span class="p">,</span>
                   <span class="n">downstream_branches</span><span class="p">,</span>
                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To create the defautl node attributes</span>
<span class="sd">    wanting to compute</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;skeletal_length_downstream&quot;</span><span class="p">,</span>
     <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_downstream</span><span class="p">,</span>
     <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">),</span>

    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;skeletal_length_downstream_total&quot;</span><span class="p">,</span>
     <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_downstream_total</span><span class="p">,</span>
     <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">,),</span>
        
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;skeletal_length_upstream_total&quot;</span><span class="p">,</span>
     <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_upstream_total</span><span class="p">,</span>
     <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="p">,),</span>
        
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;skeletal_length_upstream&quot;</span><span class="p">,</span>
     <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeletal_length_upstream</span><span class="p">,</span>
     <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="p">,),</span>
    
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;width_downstream&quot;</span><span class="p">,</span>
     <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_downstream</span><span class="p">,</span>
     <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">,),</span>
    
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;width_upstream&quot;</span><span class="p">,</span>
     <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_upstream</span><span class="p">,</span>
     <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="p">,),</span> 
    
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;n_synapses_upstream&quot;</span><span class="p">,</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_upstream</span><span class="p">,</span>
        <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">upstream_branch</span><span class="p">),</span>
    
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;n_synapses_downstream&quot;</span><span class="p">,</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_downstream</span><span class="p">,</span>
        <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">),</span>
    
    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;n_synapses_downstream_total&quot;</span><span class="p">,</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_downstream_total</span><span class="p">,</span>
        <span class="n">nodes_to_compute</span> <span class="o">=</span> <span class="n">downstream_branches</span><span class="p">),</span>
    
    <span class="p">]</span></div>

<div class="viewcode-block" id="compute_node_attributes_upstream_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.compute_node_attributes_upstream_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">compute_node_attributes_upstream_downstream</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                                                <span class="n">limb_obj</span><span class="p">,</span>
                                               <span class="n">upstream_branch</span><span class="p">,</span>
                                               <span class="n">downstream_branches</span><span class="p">,</span>
                                                <span class="n">node_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To attach node properties to a graph</span>
<span class="sd">    that references branches on a limb</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node_functions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">node_functions</span> <span class="o">=</span> <span class="n">node_functions_default</span><span class="p">(</span><span class="n">upstream_branch</span><span class="o">=</span><span class="n">upstream_branch</span><span class="p">,</span>
                            <span class="n">downstream_branches</span><span class="o">=</span><span class="n">downstream_branches</span><span class="p">)</span>
        
    <span class="n">node_type_dict</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">merge_dicts</span><span class="p">([{</span><span class="n">upstream_branch</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="n">node_type</span><span class="o">=</span><span class="s2">&quot;upstream&quot;</span><span class="p">)},</span>
                        <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="n">node_type</span><span class="o">=</span><span class="s2">&quot;downstream&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_branches</span><span class="p">}])</span>
    
    <span class="n">xu</span><span class="o">.</span><span class="n">set_node_attributes_dict</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">node_type_dict</span><span class="p">)</span>

    <span class="n">nst</span><span class="o">.</span><span class="n">compute_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
                           <span class="n">limb_obj</span><span class="p">,</span>
                            <span class="n">node_functions</span><span class="o">=</span><span class="n">node_functions</span><span class="p">,</span>
                           <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">node_df</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="synapse_closer_to_downstream_endpoint_than_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapse_closer_to_downstream_endpoint_than_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapse_closer_to_downstream_endpoint_than_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will indicate if there is a synapse that is closer to the downstream endpoint than upstream endpoint</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">syn</span> <span class="ow">in</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">syn</span><span class="o">.</span><span class="n">downstream_dist</span> <span class="o">&lt;</span> <span class="n">syn</span><span class="o">.</span><span class="n">upstream_dist</span><span class="p">:</span>
            <span class="n">return_value</span> <span class="o">=</span> <span class="kc">True</span>
    
    <span class="k">return</span> <span class="n">return_value</span></div>


    

<div class="viewcode-block" id="downstream_upstream_diff_of_most_downstream_syn"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.downstream_upstream_diff_of_most_downstream_syn">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">downstream_upstream_diff_of_most_downstream_syn</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                   <span class="n">default_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Determine the difference between </span>
<span class="sd">    the closest downstream dist and </span>
<span class="sd">    the farthest upstream dist</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get the synapse with min of downstream dist</span>
<span class="sd">    2) Get the difference between downstream dist and upstream dist</span>
<span class="sd">    3) Return the difference</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="n">default_value</span>
    <span class="n">syns</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">synapses</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">downstream_dist</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">syns</span><span class="p">])</span>
        <span class="n">syn_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d_dists</span><span class="p">)</span>
        <span class="n">d_min</span> <span class="o">=</span> <span class="n">d_dists</span><span class="p">[</span><span class="n">syn_idx</span><span class="p">]</span>
        <span class="n">u_max</span> <span class="o">=</span> <span class="n">syns</span><span class="p">[</span><span class="n">syn_idx</span><span class="p">]</span><span class="o">.</span><span class="n">upstream_dist</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">d_min</span> <span class="o">-</span> <span class="n">u_max</span>
    <span class="k">return</span> <span class="n">return_value</span></div>


<span class="c1"># ------------ New Filter: 7/8 ----------</span>
<div class="viewcode-block" id="fork_min_skeletal_distance_from_skeletons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.fork_min_skeletal_distance_from_skeletons">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">fork_min_skeletal_distance_from_skeletons</span><span class="p">(</span><span class="n">downstream_skeletons</span><span class="p">,</span>
                                             <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">,</span>
                                             <span class="n">offset</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span>
                                              <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
                                             <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                             <span class="n">plot_skeleton_restriction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">plot_min_pair</span> <span class="o">=</span> <span class="kc">False</span>
                                             <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the min distance from two diverging</span>
<span class="sd">    skeletons with an offset</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">joining_endpoint_1</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">shared_coordiantes</span><span class="p">(</span><span class="n">downstream_skeletons</span><span class="p">,</span>
                                 <span class="n">return_one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">d_skeletons_resized</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">resize_skeleton_branch</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">segment_width</span><span class="o">=</span><span class="n">skeletal_segment_size</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_skeletons</span><span class="p">]</span>

    <span class="n">new_sks</span> <span class="o">=</span> <span class="p">[</span><span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_from_start_plus_offset</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>
                                               <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span>
                                               <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                                <span class="n">start_coordinate</span> <span class="o">=</span> <span class="n">joining_endpoint_1</span><span class="p">,</span>
                                               <span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d_skeletons_resized</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">plot_skeleton_restriction</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">skeletons</span><span class="o">=</span><span class="n">new_sks</span><span class="p">,</span> <span class="c1"># + d_skeletons_resized,</span>
                         <span class="n">skeletons_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;blue&quot;</span><span class="p">],</span><span class="c1">#,&quot;yellow&quot;,&quot;yellow&quot;],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">joining_endpoint_1</span><span class="p">])</span>

    <span class="n">distances_between_skeletons</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">closest_distances_from_skeleton_vertices_to_base_skeleton</span><span class="p">(</span><span class="n">new_sks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">new_sks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                              <span class="n">verbose</span><span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                              <span class="n">plot_min_pair</span><span class="o">=</span><span class="n">plot_min_pair</span><span class="p">)</span>
    <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distances_between_skeletons</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_dist= </span><span class="si">{</span><span class="n">min_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;distances_between_skeletons = </span><span class="si">{</span><span class="n">distances_between_skeletons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">min_dist</span></div>

<div class="viewcode-block" id="fork_min_skeletal_distance"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.fork_min_skeletal_distance">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">fork_min_skeletal_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">downstream_idxs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>

    <span class="c1">#arguments for skeletons</span>
    <span class="n">skeleton_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>

    <span class="n">error_not_2_downstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>

    <span class="c1">#arguments for enforcing skipping rule for fork check</span>
    <span class="n">total_downstream_skeleton_length_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="c1">#3000#4000</span>
    <span class="n">individual_branch_length_threshold</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span><span class="c1">#3000</span>
    <span class="n">skip_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>

    <span class="c1">#arguments for the fork divergence measurement</span>
    <span class="n">comparison_distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">700</span><span class="p">,</span><span class="c1">#2000,#700,</span>
    <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="n">plot_skeleton_restriction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  
    <span class="n">plot_min_pair</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To run the fork divergence the children</span>
<span class="sd">    of an upstream node</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get downstream nodes</span>
<span class="sd">    2) Apply skeletal length restrictions if any</span>
<span class="sd">    3) compute the fork skeleton min distance</span>

<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_statistics as nst</span>

<span class="sd">    upstream_branch = 68</span>
<span class="sd">    downstream_branches = [55,64]</span>
<span class="sd">    verbose = False</span>
<span class="sd">    div = nst.fork_min_skeletal_distance(limb_obj,upstream_branch,</span>
<span class="sd">                                      downstream_idxs = downstream_branches,</span>
<span class="sd">                                  total_downstream_skeleton_length_threshold=0,</span>
<span class="sd">                                  individual_branch_length_threshold = 0,</span>
<span class="sd">                       plot_skeleton_restriction = False,</span>
<span class="sd">                       verbose = verbose)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">branch_idx</span>

    <span class="k">if</span> <span class="n">downstream_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">downstream_idxs</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_nodes = </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">upstream_sk</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span>
    <span class="n">downstream_sk</span> <span class="o">=</span> <span class="p">[</span><span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">distance</span><span class="o">=</span><span class="n">skeleton_distance</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">]</span>


    <span class="n">return_value</span> <span class="o">=</span> <span class="kc">None</span>


    <span class="k">if</span> <span class="n">error_not_2_downstream</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not exactly 2 downstream nodes: </span><span class="si">{</span><span class="n">downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">total_downstream_skeleton_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="n">individual_branch_length_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">d_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> 
                         <span class="n">k</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">])</span>
        <span class="n">d_skeletal_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                <span class="n">d</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downstream_nodes</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skeletal length = </span><span class="si">{</span><span class="n">d_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream skeletal length = </span><span class="si">{</span><span class="n">d_skeletal_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">below_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">d_skeletal_len</span><span class="o">&lt;</span><span class="n">total_downstream_skeleton_length_threshold</span><span class="p">)</span> <span class="o">|</span> 
                                   <span class="p">(</span><span class="n">d_len</span> <span class="o">&lt;</span> <span class="n">individual_branch_length_threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">below_threshold</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping this intersection because some of downstream skeletal lengths too short (min </span><span class="si">{</span><span class="n">total_downstream_skeleton_length_threshold</span><span class="si">}</span><span class="s2">):&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; or the individual branch length was too short (min </span><span class="si">{</span><span class="n">individual_branch_length_threshold</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,(</span><span class="n">d</span><span class="p">,</span><span class="n">d_len</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">downstream_nodes</span><span class="p">,</span><span class="n">d_skeletal_len</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">below_threshold</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Brnach </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s2">: length </span><span class="si">{</span><span class="n">d_len</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">return_value</span> <span class="o">=</span> <span class="n">skip_value</span>


    <span class="k">if</span> <span class="n">return_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">fork_min_skeletal_distance_from_skeletons</span><span class="p">(</span>
                                <span class="n">downstream_skeletons</span> <span class="o">=</span> <span class="n">downstream_sk</span><span class="p">,</span>
                                <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance</span><span class="p">,</span>
                                <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                <span class="n">skeletal_segment_size</span> <span class="o">=</span> <span class="n">skeletal_segment_size</span><span class="p">,</span>
                                <span class="n">plot_skeleton_restriction</span> <span class="o">=</span> <span class="n">plot_skeleton_restriction</span><span class="p">,</span>
                                <span class="n">plot_min_pair</span><span class="o">=</span><span class="n">plot_min_pair</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_value = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>


<div class="viewcode-block" id="shortest_distance_from_soma_multi_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.shortest_distance_from_soma_multi_soma">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">shortest_distance_from_soma_multi_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">branches</span><span class="p">,</span>
                      <span class="n">somas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">include_node_skeleton_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span>
                      <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the distance of a branch from the soma </span>
<span class="sd">    (if there are multiple somas it will check for shortest distance between all of them)</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.shortest_distance_from_soma_multi_soma(neuron_obj_exc_syn_sp[0],190)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branches</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span><span class="p">]</span>
        <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="n">return_d</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_distance_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                  <span class="n">branches</span><span class="o">=</span><span class="n">branches</span><span class="p">,</span>
                    <span class="n">somas</span> <span class="o">=</span> <span class="n">somas</span><span class="p">,</span>
                    <span class="n">error_if_all_nodes_not_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="n">include_node_skeleton_dist</span><span class="p">,</span>
                    <span class="n">print_flag</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">return_d</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">return_d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">singular_flag</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">return_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="distance_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.distance_from_soma">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">distance_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                      <span class="n">branch_idx</span><span class="p">,</span>
                      <span class="n">include_node_skeleton_dist</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the distance away from the soma</span>
<span class="sd">    for a given set of branches</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.distance_from_soma(limb_obj,190)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">):</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
        <span class="n">singular_flag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="n">branch_idx</span>
        
    <span class="n">branch_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">branch_path_to_start_node</span><span class="p">(</span>
                    <span class="n">limb_obj</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">include_branch_idx</span><span class="o">=</span><span class="n">include_node_skeleton_dist</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">]</span>
    
    <span class="n">return_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">k</span><span class="p">,</span>
                                                 <span class="n">feature_name</span> <span class="o">=</span> <span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">branch_paths</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_paths = </span><span class="si">{</span><span class="n">branch_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Path lengths = </span><span class="si">{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    <span class="k">if</span> <span class="n">singular_flag</span><span class="p">:</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">return_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">return_value</span></div>

<div class="viewcode-block" id="distance_from_soma_euclidean"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.distance_from_soma_euclidean">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">distance_from_soma_euclidean</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branch_idx</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return the euclidean distance of the upstream endpoint</span>
<span class="sd">    to the starting coordinate of the limb</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    branch_idx = 0</span>
<span class="sd">    limb_obj = neuron_obj_proof[0]</span>
<span class="sd">    nst.distance_from_soma_euclidean(limb_obj,branch_idx)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">upstream_endpoint</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">return_endpoint_index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">current_starting_coordinate</span> <span class="o">-</span> <span class="n">upstream_endpoint</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance_from_soma_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.distance_from_soma_candidate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">distance_from_soma_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">candidate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the distance of a candidate</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">candidate</span> 
    <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="s2">&quot;limb_idx&quot;</span><span class="p">]]</span>
    <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s2">&quot;start_node&quot;</span><span class="p">]</span>
    <span class="n">downstream_nodes</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s2">&quot;branches&quot;</span><span class="p">]</span>
    <span class="k">return</span>  <span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="width_basic"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_basic">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_basic</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">width</span></div>
                            
    
<div class="viewcode-block" id="farthest_dendrite_branch_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.farthest_dendrite_branch_from_soma">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">farthest_dendrite_branch_from_soma</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">neurd</span><span class="w"> </span><span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
    <span class="n">dist_from_soma_df</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">],</span>
                   <span class="n">query</span><span class="o">=</span><span class="s2">&quot;distance_from_soma &gt; -1&quot;</span><span class="p">,</span>
                   <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">dendrite_limb_branch_dict</span><span class="p">)</span>
    <span class="n">max_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dist_from_soma_df</span><span class="p">[</span><span class="s2">&quot;distance_from_soma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">dist_from_soma_df</span><span class="p">[</span><span class="n">dist_from_soma_df</span><span class="p">[</span><span class="s2">&quot;distance_from_soma&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_distance</span><span class="p">]</span></div>

<div class="viewcode-block" id="trajectory_angle_from_start_branch_and_subtree"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.trajectory_angle_from_start_branch_and_subtree">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">trajectory_angle_from_start_branch_and_subtree</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                  <span class="n">subtree_branches</span><span class="p">,</span>
                                                   <span class="n">start_branch_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                  <span class="n">nodes_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                   <span class="n">downstream_distance</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                                <span class="n">plot_skeleton_before_restriction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">plot_skeleton_after_restriction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">plot_skeleton_endpoints</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">return_max_min</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">return_n_angles</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To figure out the </span>
<span class="sd">    initial trajectory of a subtree</span>
<span class="sd">    of branches if given the initial </span>
<span class="sd">    branch of the subtree and all</span>
<span class="sd">    the branches of the subtree</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all branches that are within a certain distance of the starting branch</span>
<span class="sd">    2) Get the upstream coordinate of start branch</span>
<span class="sd">    3) Restrict the skeleton to the downstream distance</span>
<span class="sd">    4) Find all endpoints of the restricted skeleton</span>
<span class="sd">    5) Calculate the vectors and angle from the top of the start coordinate and all the endpoints</span>

<span class="sd">    Ex: </span>
<span class="sd">    nst.trajectory_angle_from_start_branch_and_subtree(</span>
<span class="sd">    limb_obj = neuron_obj_exc_syn_sp[limb_idx],</span>
<span class="sd">    start_branch_idx = 31,</span>
<span class="sd">    subtree_branches = [31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,</span>
<span class="sd">                        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101],</span>
<span class="sd">    nodes_to_exclude = nodes_to_exclude,</span>
<span class="sd">    plot_skeleton_endpoints = plot_skeleton_endpoints,</span>
<span class="sd">    return_max_min=True,</span>
<span class="sd">    return_n_angles=True</span>
<span class="sd">)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start_branch_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">concept_network_directional</span>
        <span class="n">G_subtree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">subtree_branches</span><span class="p">)</span>
        <span class="n">start_branch_idx</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">starting_node_from_DiG</span><span class="p">(</span><span class="n">G_subtree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start_branch computed as </span><span class="si">{</span><span class="n">start_branch_idx</span><span class="si">}</span><span class="s2"> (because original set to None)&quot;</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nodes_to_exclude = </span><span class="si">{</span><span class="n">nodes_to_exclude</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">downstream_skeleton</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">skeleton_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                 <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">start_branch_idx</span><span class="p">,</span>
                                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">downstream_distance</span><span class="p">,</span>
                                                 <span class="n">only_non_branching</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">nodes_to_exclude</span><span class="o">=</span><span class="n">nodes_to_exclude</span>
                                                 <span class="p">)</span>
    <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">start_branch_idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_skeleton_before_restriction</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">downstream_skeleton</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">restricted_sk</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">restrict_skeleton_to_distance_from_coordinate</span><span class="p">(</span><span class="n">downstream_skeleton</span><span class="p">,</span>
                                                    <span class="n">coordinate</span><span class="o">=</span><span class="n">starting_coordinate</span><span class="p">,</span>
                                                    <span class="n">distance_threshold</span><span class="o">=</span><span class="n">downstream_distance</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_skeleton_after_restriction</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">restricted_sk</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">endpoints</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">find_skeleton_endpoint_coordinates</span><span class="p">(</span><span class="n">restricted_sk</span><span class="p">,</span><span class="n">coordinates_to_exclude</span> <span class="o">=</span> <span class="n">starting_coordinate</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoints = </span><span class="si">{</span><span class="n">endpoints</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot_skeleton_endpoints</span><span class="p">:</span>
        <span class="n">start_color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
        <span class="n">endpoint_color</span> <span class="o">=</span> <span class="s2">&quot;blue&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting point = </span><span class="si">{</span><span class="n">start_color</span><span class="si">}</span><span class="s2">, endpoints = </span><span class="si">{</span><span class="n">endpoint_color</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
                         <span class="n">skeletons</span><span class="o">=</span><span class="p">[</span><span class="n">restricted_sk</span><span class="p">],</span>
                         <span class="n">scatters</span><span class="o">=</span><span class="p">[</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="n">endpoints</span><span class="p">],</span>
                          <span class="n">scatters_colors</span><span class="o">=</span><span class="p">[</span><span class="n">start_color</span><span class="p">,</span><span class="n">endpoint_color</span><span class="p">],</span>
                         <span class="n">scatter_size</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="n">subtree_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">nu</span><span class="o">.</span><span class="n">vector_from_endpoints</span><span class="p">(</span><span class="n">starting_coordinate</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">]</span> 
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subtree_vectors = </span><span class="si">{</span><span class="n">subtree_vectors</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">subtree_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">nst</span><span class="o">.</span><span class="n">angle_from_top</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">subtree_vectors</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subtree_angles = </span><span class="si">{</span><span class="n">subtree_angles</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_max_min</span><span class="p">:</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">subtree_angles</span><span class="p">)</span>
        <span class="n">min_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">subtree_angles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_n_angles</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">max_angle</span><span class="p">,</span><span class="n">min_angle</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">subtree_angles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">max_angle</span><span class="p">,</span><span class="n">min_angle</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">subtree_angles</span></div>
    

<span class="c1"># ------- 7/26: To help identify axons  -----------</span>
<span class="n">distance_away_from_endpoint</span><span class="o">=</span> <span class="mi">6_000</span>
<span class="c1">#distance_away_from_endpoint= 10_000</span>
<div class="viewcode-block" id="synapse_density_post_near_endpoint_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapse_density_post_near_endpoint_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapse_density_post_near_endpoint_downstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span>
                                                 <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get the synapse density near the downstream endpoint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_post_within_distance_of_endpoint_downstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                          <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_spine_within_distance_of_endpoint_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_spine_within_distance_of_endpoint_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_spine_within_distance_of_endpoint_downstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span>
                                                           <span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_spine_within_distance_of_endpoint_downstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                          <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                          <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density_post_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapse_density_post_offset_endpoint_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapse_density_post_offset_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span>
                                                 <span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_post_offset_distance_of_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                    <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span></div>

<div class="viewcode-block" id="synapse_density_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.synapse_density_offset_endpoint_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">synapse_density_offset_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span>
                                                 <span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_offset_distance_of_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                    <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span></div>

<div class="viewcode-block" id="n_synapses_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_offset_endpoint_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_offset_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                   <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span>
                                                 <span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_offset_distance_of_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                    <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span></div>

<div class="viewcode-block" id="n_synapses_spine_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_spine_offset_endpoint_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_spine_offset_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span>
                                                 <span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_spine_offset_distance_of_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                    <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span></div>

<div class="viewcode-block" id="n_synapses_pre_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.n_synapses_pre_offset_endpoint_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">n_synapses_pre_offset_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                 <span class="n">distance</span> <span class="o">=</span> <span class="n">distance_away_from_endpoint</span><span class="p">,</span>
                                                  <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span>
                                                 <span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre_offset_distance_of_endpoint_upstream</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span>
                                                                    <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span></div>



<span class="c1"># ------------- 7/28: for apical -----------------</span>
<div class="viewcode-block" id="filter_limbs_by_soma_starting_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.filter_limbs_by_soma_starting_angle">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">filter_limbs_by_soma_starting_angle</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">soma_angle</span><span class="p">,</span>
                                        <span class="n">angle_less_than</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                       <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                       <span class="n">return_int_names</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will return the limb names that satisfy the</span>
<span class="sd">    soma angle requirement</span>
<span class="sd">    </span>
<span class="sd">    Ex: nst.filter_limbs_by_soma_starting_angle(neuron_obj,60,verbose=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">angle_less_than</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;soma_starting_angle&lt;=</span><span class="si">{</span><span class="n">soma_angle</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;soma_starting_angle&gt;=</span><span class="si">{</span><span class="n">soma_angle</span><span class="si">}</span><span class="s2">&quot;</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Restricting limbs to </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">soma_center</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
    
    <span class="n">possible_apical_limbs_dict</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                    <span class="n">query</span><span class="o">=</span><span class="n">query</span><span class="p">,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">],</span>
                   <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">soma_center</span><span class="o">=</span><span class="n">soma_center</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

    <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">possible_apical_limbs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="n">return_int_names</span><span class="p">:</span>
        <span class="n">possible_apical_limbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_int_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">possible_apical_limbs</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">possible_apical_limbs</span></div>



<div class="viewcode-block" id="skeleton_perc_dist_match_ref_vector"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_perc_dist_match_ref_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_perc_dist_match_ref_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reference_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
    <span class="n">skeleton_resize_distance</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
    <span class="n">plot_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: </span>
<span class="sd">    To find the percentage of skeleton that is</span>
<span class="sd">    within a certain angle of a comparison vector</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Resize the branch skeleton and order the skeleton</span>
<span class="sd">    2) For each segments of the skeleton:</span>
<span class="sd">    - extract the vector from the skeleton</span>
<span class="sd">    - find the angle betweeen the reference bector and the segment vector</span>
<span class="sd">    - if angle is below the threshold then count it as a match</span>
<span class="sd">    3) return the percentage of the matches</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">plot_branch</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_branches_with_spines</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,)</span>

    <span class="c1">#branch_obj</span>
    <span class="c1">#1) Resize the branch skeleton and order the skeleton</span>

    <span class="n">perc_match</span><span class="p">,</span><span class="n">dist_match</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">percentage_skeleton_match_to_ref_vector</span><span class="p">(</span><span class="n">branch_obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
                                              <span class="n">reference_vector</span><span class="o">=</span><span class="n">reference_vector</span><span class="p">,</span>
                                               <span class="n">max_angle</span><span class="o">=</span><span class="n">max_angle</span><span class="p">,</span>
                                                <span class="n">min_angle</span><span class="o">=</span><span class="n">min_angle</span><span class="p">,</span>
                                              <span class="n">start_endpoint_coordinate</span><span class="o">=</span><span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">),</span>
                                            <span class="n">segment_width</span><span class="o">=</span><span class="n">skeleton_resize_distance</span><span class="p">,</span>
                                             <span class="n">plot_skeleton</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                              <span class="n">return_match_length</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_match = </span><span class="si">{</span><span class="n">perc_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dist_match = </span><span class="si">{</span><span class="n">dist_match</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">perc_match</span><span class="p">,</span><span class="n">dist_match</span></div>

<div class="viewcode-block" id="skeleton_dist_match_ref_vector"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_dist_match_ref_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_dist_match_ref_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reference_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
    <span class="n">skeleton_resize_distance</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
    <span class="n">plot_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the amount of skeletal distance that matches</span>
<span class="sd">    a comparison vector</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.skeleton_dist_match_ref_vector(neuron_obj[0],</span>
<span class="sd">                                       11,</span>
<span class="sd">                                       verbose = True)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">perc_match</span><span class="p">,</span><span class="n">dist_match</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_perc_dist_match_ref_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="n">max_angle</span><span class="p">,</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="n">min_angle</span><span class="p">,</span>
    <span class="n">reference_vector</span> <span class="o">=</span> <span class="n">reference_vector</span><span class="p">,</span>
    <span class="n">skeleton_resize_distance</span> <span class="o">=</span> <span class="n">skeleton_resize_distance</span><span class="p">,</span>
    <span class="n">plot_branch</span> <span class="o">=</span> <span class="n">plot_branch</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span>
    
    <span class="k">return</span> <span class="n">dist_match</span></div>

<div class="viewcode-block" id="skeleton_perc_match_ref_vector"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_perc_match_ref_vector">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_perc_match_ref_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reference_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
    <span class="n">skeleton_resize_distance</span> <span class="o">=</span> <span class="mi">8000</span><span class="p">,</span>
    <span class="n">plot_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the percentage of skeletal distance that matches</span>
<span class="sd">    a comparison vector</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">perc_match</span><span class="p">,</span><span class="n">dist_match</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_perc_dist_match_ref_vector</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">max_angle</span> <span class="o">=</span> <span class="n">max_angle</span><span class="p">,</span>
    <span class="n">min_angle</span> <span class="o">=</span> <span class="n">min_angle</span><span class="p">,</span>
    <span class="n">reference_vector</span> <span class="o">=</span> <span class="n">reference_vector</span><span class="p">,</span>
    <span class="n">skeleton_resize_distance</span> <span class="o">=</span> <span class="n">skeleton_resize_distance</span><span class="p">,</span>
    <span class="n">plot_branch</span> <span class="o">=</span> <span class="n">plot_branch</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,)</span>
    
    <span class="k">return</span> <span class="n">perc_match</span></div>

<div class="viewcode-block" id="get_stat"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.get_stat">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_stat</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">stat</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will either run the function 0n the  object</span>
<span class="sd">    of get the property of the function if it is a string</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.get_stat(limb_obj[0],syu.n_synapses_pre)</span>
<span class="sd">    nst.get_stat(limb_obj[0],&quot;skeletal_length&quot;)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">stat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stat</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
    
<span class="c1"># --------- Statisitcs for canddidates --------------</span>
<div class="viewcode-block" id="skeletal_length_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeletal_length_over_candidate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeletal_length_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">candidate</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">sk_len</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_limb_branch</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">nru</span><span class="o">.</span><span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_from_candidate</span><span class="p">(</span><span class="n">candidate</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sk_len</span></div>

<div class="viewcode-block" id="width_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_over_candidate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_over_candidate</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">candidate</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_weighted_over_branches</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="s1">&#39;limb_idx&#39;</span><span class="p">]],</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="s1">&#39;branches&#39;</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="max_layer_height_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.max_layer_height_over_candidate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">max_layer_height_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">candidate</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To determine the maximum height in the</span>
<span class="sd">    layer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cand_sk</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mcu</span><span class="o">.</span><span class="n">coordinates_to_layer_height</span><span class="p">(</span><span class="n">cand_sk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span></div>

<div class="viewcode-block" id="max_layer_distance_above_soma_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.max_layer_distance_above_soma_over_candidate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">max_layer_distance_above_soma_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">candidate</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">soma_max_height</span> <span class="o">=</span> <span class="n">mcu</span><span class="o">.</span><span class="n">coordinates_to_layer_height</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span><span class="p">)</span>
    <span class="n">cand_height</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">max_layer_height_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cand_height</span> <span class="o">-</span> <span class="n">soma_max_height</span></div>


<div class="viewcode-block" id="downstream_dist_match_ref_vector_over_candidate"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.downstream_dist_match_ref_vector_over_candidate">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">downstream_dist_match_ref_vector_over_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                    <span class="n">candidate</span><span class="p">,</span>
                                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
                                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Measure the amount of downstream branch</span>
<span class="sd">    length that is at a certain angle</span>

<span class="sd">    1) Get all of the nodes that are downstream</span>
<span class="sd">    of all of the branches</span>
<span class="sd">    2) Add up the amount of distance on each</span>
<span class="sd">    branch that matches the angle specified</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.downstream_dist_match_ref_vector_over_candidate(neuron_obj,</span>
<span class="sd">                                               candidate = winning_candidates[0],max_angle=65)</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">all_downstream_branches</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">all_downstream_branches_from_candidate</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                                        <span class="n">candidate</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_downstream_branches = </span><span class="si">{</span><span class="n">all_downstream_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_downstream_branches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">angle_match_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">nst</span><span class="o">.</span><span class="n">skeleton_dist_match_ref_vector</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="n">candidate</span><span class="p">[</span><span class="s1">&#39;limb_idx&#39;</span><span class="p">]],</span>
                                                  <span class="n">branch_idx</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span>
                                                  <span class="n">max_angle</span><span class="o">=</span><span class="n">max_angle</span><span class="p">,</span>
                                                 <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_downstream_branches</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">angle_match_dist</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;angle_match_dist = </span><span class="si">{</span><span class="n">angle_match_dist</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">angle_match_dist</span></div>


<span class="c1"># ------- help with searching for labels -------------- #</span>
<div class="viewcode-block" id="upstream_node_is_apical_shaft"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.upstream_node_is_apical_shaft">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">upstream_node_is_apical_shaft</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node_has_label</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>
<div class="viewcode-block" id="upstream_node_is_apical"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.upstream_node_is_apical">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">upstream_node_is_apical</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_node_has_label</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;apical&quot;</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="is_label_in_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.is_label_in_downstream_branches">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">is_label_in_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">label</span><span class="p">,</span>
                                    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To test if a label is in the downstream </span>
<span class="sd">    nodes </span>

<span class="sd">    1) Get all the downstream labels</span>
<span class="sd">    2) return the test if a certain label is in downstream labels</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.is_label_in_downstream_branches(neuron_obj[1],5,&quot;apical_shaft&quot;,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
        
    <span class="n">downstream_labels</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">downstream_labels</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">,</span>
                          <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="n">all_downstream_nodes</span><span class="p">,</span>
                         <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
    
    <span class="n">common_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">downstream_labels</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;common_labels= </span><span class="si">{</span><span class="n">common_labels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="is_apical_shaft_in_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.is_apical_shaft_in_downstream_branches">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">is_apical_shaft_in_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.is_apical_shaft_in_downstream_branches(neuron_obj[1],4,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_label_in_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;apical_shaft&quot;</span><span class="p">,</span>
                                    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="n">all_downstream_nodes</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                   <span class="p">)</span></div>

<div class="viewcode-block" id="is_axon_in_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.is_axon_in_downstream_branches">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">is_axon_in_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.is_apical_shaft_in_downstream_branches(neuron_obj[1],4,verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_label_in_downstream_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                    <span class="n">branch_idx</span><span class="p">,</span>
                                    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
                                    <span class="n">all_downstream_nodes</span> <span class="o">=</span> <span class="n">all_downstream_nodes</span><span class="p">,</span>
                                     <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                   <span class="p">)</span></div>


<span class="c1"># ---------- Functions over upstream and downstream branches ----------- #</span>
<div class="viewcode-block" id="width_weighted_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_weighted_over_branches">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_weighted_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branches</span><span class="p">,</span>
                                 <span class="n">width_func</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find weighted width over branches</span>

<span class="sd">    Ex: </span>
<span class="sd">    nst.width_weighted_over_branches(n_obj_2[6],</span>
<span class="sd">                                branches = [24,2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">width_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width_func</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">width_new</span>
        
    <span class="n">weight_width</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">weighted_feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branches</span> <span class="o">=</span><span class="n">branches</span><span class="p">,</span>
                               <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                               <span class="n">feature_function</span><span class="o">=</span><span class="n">width_func</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">weight_width</span></div>


<div class="viewcode-block" id="skeleton_dist_match_ref_vector_sum_over_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_dist_match_ref_vector_sum_over_branches">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_dist_match_ref_vector_sum_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="p">,</span>
                                                    <span class="n">max_angle</span><span class="p">,</span>
                                                    <span class="n">min_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                     <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find the amount of upstream skeletal distance</span>
<span class="sd">    that matches a certain angle</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sk_dist</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">sum_feature_over_branches</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">,</span>
                                <span class="n">branches</span> <span class="o">=</span><span class="n">branches</span><span class="p">,</span>
                               <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                               <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                               <span class="n">feature_function</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">skeleton_dist_match_ref_vector</span><span class="p">,</span>
                                  <span class="n">use_limb_obj_and_branch_idx</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">max_angle</span><span class="o">=</span><span class="n">max_angle</span><span class="p">,</span>
                                  <span class="n">min_angle</span> <span class="o">=</span> <span class="n">min_angle</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">sk_dist</span></div>

<div class="viewcode-block" id="skeleton_dist_match_ref_vector_sum_over_branches_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_dist_match_ref_vector_sum_over_branches_upstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_dist_match_ref_vector_sum_over_branches_upstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="p">,</span>
                                                    <span class="n">max_angle</span><span class="p">,</span>
                                                    <span class="n">min_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">skeleton_dist_match_ref_vector_sum_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="p">,</span>
                                                    <span class="n">max_angle</span><span class="p">,</span>
                                                    <span class="n">min_angle</span><span class="o">=</span><span class="n">min_angle</span><span class="p">,</span>
                                                     <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;upstream&quot;</span><span class="p">,</span>
                                                     <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<div class="viewcode-block" id="skeleton_dist_match_ref_vector_sum_over_branches_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_dist_match_ref_vector_sum_over_branches_downstream">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_dist_match_ref_vector_sum_over_branches_downstream</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="p">,</span>
                                                    <span class="n">max_angle</span><span class="p">,</span>
                                                    <span class="n">min_angle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                     <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To find the skeletal length of the downstream </span>
<span class="sd">    branch portions that match a certain angle</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    nst.skeleton_dist_match_ref_vector_sum_over_branches_downstream(</span>
<span class="sd">    limb_obj = n_obj_2[6],</span>
<span class="sd">    branches = [23,14,27],</span>
<span class="sd">    max_angle = 10000,</span>
<span class="sd">    min_angle = 40,</span>
<span class="sd">    verbose = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">skeleton_dist_match_ref_vector_sum_over_branches</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span>
                                                    <span class="n">branches</span><span class="p">,</span>
                                                    <span class="n">max_angle</span><span class="p">,</span>
                                                    <span class="n">min_angle</span><span class="o">=</span><span class="n">min_angle</span><span class="p">,</span>
                                                     <span class="n">direction</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
                                                     <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="stats_dict_over_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.stats_dict_over_limb_branch">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">stats_dict_over_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
   <span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
   <span class="n">stats_to_compute</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span><span class="s2">&quot;area&quot;</span><span class="p">,</span><span class="s2">&quot;mesh_volume&quot;</span><span class="p">,</span><span class="s2">&quot;n_branches&quot;</span><span class="p">),</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To get a statistics </span>
<span class="sd">    over a limb branch dict</span>

<span class="sd">    Stats to retrieve:</span>
<span class="sd">    1) skeletal length</span>
<span class="sd">    2) surface area</span>
<span class="sd">    3) volume</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_statistics as nst</span>
<span class="sd">    nst.stats_dict_over_limb_branch(</span>
<span class="sd">        neuron_obj = neuron_obj_proof,</span>
<span class="sd">        limb_branch_dict = apu.apical_limb_branch_dict(neuron_obj_proof))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict</span><span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>
    
    <span class="n">s_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">nru</span><span class="o">.</span><span class="n">sum_feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                   <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                   <span class="n">feature</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">stats_to_compute</span><span class="p">}</span>


    <span class="k">return</span> <span class="n">s_dict</span></div>

<div class="viewcode-block" id="features_from_neuron_skeleton_and_soma_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.features_from_neuron_skeleton_and_soma_center">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">features_from_neuron_skeleton_and_soma_center</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neuron_obj_aligned</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
    
    <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_limb_branch_dict</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">limb_branch_dict</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeleton</span>
        
    <span class="k">if</span> <span class="n">neuron_obj_aligned</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">limb_branch_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeleton_over_limb_branch_dict</span><span class="p">(</span>
                <span class="n">neuron_obj_aligned</span><span class="p">,</span>
                <span class="n">limb_branch_dict</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="n">neuron_obj_aligned</span><span class="o">.</span><span class="n">skeleton</span>
            
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">neuron_obj_aligned</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="kc">None</span> 
        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>
    
        
    
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">features_from_skeleton_and_soma_center</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">soma_center</span> <span class="o">=</span> <span class="n">soma_center</span><span class="p">,</span><span class="c1">#neuron_obj[&quot;S0&quot;].mesh_center,</span>
    <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="n">skeleton_aligned</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
    
<div class="viewcode-block" id="features_from_skeleton_and_soma_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.features_from_skeleton_and_soma_center">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">features_from_skeleton_and_soma_center</span><span class="p">(</span>
    <span class="n">skeleton</span><span class="p">,</span>
    <span class="n">soma_center</span><span class="p">,</span>
    <span class="n">short_threshold</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">,</span>
    <span class="n">long_threshold</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">,</span>
    <span class="n">volume_divisor</span> <span class="o">=</span> <span class="mi">1_000_000_000_000_000</span><span class="p">,</span><span class="c1">#(10**14),</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">name_prefix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">features_to_exclude</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skeleton_aligned</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">in_um</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To calculate features about a skeleton</span>
<span class="sd">    representing a subset of the neuron (</span>
<span class="sd">    features specifically in relation to soma)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axon_dict</span> <span class="o">=</span>  <span class="nb">dict</span><span class="p">(</span>

                    <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">branch_length_median</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">branch_length_mean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

                    <span class="n">n_branches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">n_short_branches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">n_long_branches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">n_medium_branches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

                    <span class="n">bbox_volume</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_x_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_y_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_z_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_x_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_y_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_z_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                    <span class="n">bbox_x_min_soma_relative</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_y_min_soma_relative</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_z_min_soma_relative</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_x_max_soma_relative</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_y_max_soma_relative</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">bbox_z_max_soma_relative</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>

                    <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Calculating the boudning box</span>
        <span class="n">sk_branches</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">decompose_skeleton_to_branches</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>

        <span class="n">sk_branches_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sk_branches</span><span class="p">])</span>

        <span class="n">n_branches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sk_branches</span><span class="p">)</span>
        <span class="n">n_short_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sk_branches_dist</span><span class="o">&lt;</span><span class="n">short_threshold</span><span class="p">)</span>
        <span class="n">n_long_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sk_branches_dist</span><span class="o">&gt;</span><span class="n">long_threshold</span><span class="p">)</span>
        <span class="n">n_medium_branches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sk_branches_dist</span><span class="o">&lt;=</span><span class="n">long_threshold</span><span class="p">)</span> <span class="o">&amp;</span> 
                                  <span class="p">(</span><span class="n">sk_branches_dist</span><span class="o">&gt;=</span><span class="n">short_threshold</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Number of Branches = </span><span class="si">{</span><span class="p">(</span><span class="n">n_branches</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_short_branches = </span><span class="si">{</span><span class="n">n_short_branches</span><span class="si">}</span><span class="s2">, n_medium_branches = </span><span class="si">{</span><span class="n">n_medium_branches</span><span class="si">}</span><span class="s2">, n_long_branches = </span><span class="si">{</span><span class="n">n_long_branches</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># calculating the skeletal lengths</span>
        <span class="k">if</span> <span class="n">in_um</span><span class="p">:</span>
            <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">axon_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sk_branches_dist</span><span class="p">)</span><span class="o">/</span><span class="n">divisor</span>
        <span class="n">axon_branch_length_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sk_branches_dist</span><span class="p">)</span><span class="o">/</span><span class="n">divisor</span>
        <span class="n">axon_branch_length_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk_branches_dist</span><span class="p">)</span><span class="o">/</span><span class="n">divisor</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axon_length = </span><span class="si">{</span><span class="n">axon_length</span><span class="si">}</span><span class="s2">, axon_branch_length_median = </span><span class="si">{</span><span class="n">axon_branch_length_median</span><span class="si">}</span><span class="s2">, axon_branch_length_mean = </span><span class="si">{</span><span class="n">axon_branch_length_mean</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">bbox_volume</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">bbox_volume</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span><span class="o">/</span><span class="n">volume_divisor</span>
        <span class="n">bbox_corners</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">bbox_corners_soma_relative</span> <span class="o">=</span> <span class="n">bbox_corners</span> <span class="o">-</span> <span class="n">soma_center</span>
        <span class="k">if</span> <span class="n">skeleton_aligned</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using skeleton aligned&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Previous bbox_corners_soma_relative = </span><span class="si">{</span><span class="n">bbox_corners_soma_relative</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">bbox_corners_aligned</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">bounding_box_corners</span><span class="p">(</span><span class="n">skeleton_aligned</span><span class="p">)</span>
            <span class="n">bbox_corners_soma_relative</span> <span class="o">=</span> <span class="n">bbox_corners_aligned</span> <span class="o">-</span> <span class="n">soma_center</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NEW ALIGNED bbox_corners_soma_relative = </span><span class="si">{</span><span class="n">bbox_corners_soma_relative</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bbox_volume = </span><span class="si">{</span><span class="n">bbox_volume</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bbox_corners = </span><span class="si">{</span><span class="n">bbox_corners</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;bbox_corners_soma_relative = </span><span class="si">{</span><span class="n">bbox_corners_soma_relative</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="n">axon_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>

                        <span class="n">length</span> <span class="o">=</span> <span class="n">axon_length</span><span class="p">,</span>
                        <span class="n">branch_length_median</span> <span class="o">=</span> <span class="n">axon_branch_length_median</span><span class="p">,</span>
                        <span class="n">branch_length_mean</span> <span class="o">=</span> <span class="n">axon_branch_length_mean</span><span class="p">,</span>

                        <span class="n">n_branches</span> <span class="o">=</span> <span class="n">n_branches</span><span class="p">,</span>
                        <span class="n">n_short_branches</span> <span class="o">=</span> <span class="n">n_short_branches</span><span class="p">,</span>
                        <span class="n">n_long_branches</span> <span class="o">=</span> <span class="n">n_long_branches</span><span class="p">,</span>
                        <span class="n">n_medium_branches</span> <span class="o">=</span> <span class="n">n_medium_branches</span><span class="p">,</span>

                        <span class="n">bbox_volume</span><span class="o">=</span><span class="n">bbox_volume</span><span class="p">,</span>
                        <span class="n">bbox_x_min</span><span class="o">=</span><span class="n">bbox_corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">bbox_y_min</span><span class="o">=</span><span class="n">bbox_corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">bbox_z_min</span><span class="o">=</span><span class="n">bbox_corners</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">bbox_x_max</span><span class="o">=</span><span class="n">bbox_corners</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">bbox_y_max</span><span class="o">=</span><span class="n">bbox_corners</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">bbox_z_max</span><span class="o">=</span><span class="n">bbox_corners</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>

                        <span class="n">bbox_x_min_soma_relative</span><span class="o">=</span><span class="n">bbox_corners_soma_relative</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">bbox_y_min_soma_relative</span><span class="o">=</span><span class="n">bbox_corners_soma_relative</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">bbox_z_min_soma_relative</span><span class="o">=</span><span class="n">bbox_corners_soma_relative</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">bbox_x_max_soma_relative</span><span class="o">=</span><span class="n">bbox_corners_soma_relative</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">bbox_y_max_soma_relative</span><span class="o">=</span><span class="n">bbox_corners_soma_relative</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">bbox_z_max_soma_relative</span><span class="o">=</span><span class="n">bbox_corners_soma_relative</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>

                        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">features_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">axon_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">features_to_exclude</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">name_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axon_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prefix</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">axon_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        
    
    
    <span class="k">return</span> <span class="n">axon_dict</span></div>






<div class="viewcode-block" id="branch_stats_over_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.branch_stats_over_limb_branch">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">branch_stats_over_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">limb_branch_dict</span><span class="p">,</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span>
               <span class="s2">&quot;width_with_spines&quot;</span><span class="p">,</span>
               <span class="s2">&quot;width_no_spines&quot;</span><span class="p">),</span>
    <span class="n">stats_to_compute</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span><span class="s2">&quot;median&quot;</span><span class="p">,</span><span class="s2">&quot;percentile_70&quot;</span><span class="p">),</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: to compute some stats over a limb branch</span>

<span class="sd">    Things want to find out about dendrites: </span>

<span class="sd">    - widths</span>
<span class="sd">    - lengths</span>

<span class="sd">    and then summary statistics about it</span>
<span class="sd">    - mean/median</span>
<span class="sd">    - 70th percentile</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">branch_lengths</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                     <span class="n">feature</span><span class="o">=</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">)</span>

    <span class="n">branch_widths_with_spine</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                     <span class="n">feature_from_fuction</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">width_new</span><span class="p">,</span>
                                                    <span class="n">feature_from_fuction_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width_new_name</span> <span class="o">=</span> <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">))</span>
    <span class="n">branch_widths_no_spine</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">feature_over_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                     <span class="n">limb_branch_dict</span><span class="p">,</span>
                                                     <span class="n">feature_from_fuction</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">width_new</span><span class="p">,</span>
                                                    <span class="n">feature_from_fuction_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width_new_name</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">))</span>
    <span class="n">branch_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">skeletal_length</span> <span class="o">=</span> <span class="n">branch_lengths</span><span class="p">,</span>
        <span class="n">width_with_spines</span> <span class="o">=</span> <span class="n">branch_widths_with_spine</span><span class="p">,</span>
        <span class="n">width_no_spines</span> <span class="o">=</span> <span class="n">branch_widths_no_spine</span><span class="p">)</span>

    <span class="c1"># if verbose:</span>
    <span class="c1">#     print(f&quot;branch_widths_with_spine = {branch_widths_with_spine}&quot;)</span>
    <span class="c1">#     print(f&quot;branch_widths_no_spine = {branch_widths_no_spine}&quot;)</span>

    <span class="n">branch_data_stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">branch_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="n">continues</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats_to_compute</span><span class="p">:</span>
            <span class="n">s_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">if</span> <span class="s2">&quot;percentile&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">stat_name</span><span class="p">,</span><span class="n">percentile</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="n">s_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">percentile</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stat_name</span> <span class="o">=</span> <span class="n">s</span>

            <span class="n">branch_data_stats</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">stat_name</span><span class="p">)(</span><span class="n">v</span><span class="p">,</span><span class="o">**</span><span class="n">s_kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">branch_data_stats</span></div>
    
    
    
<span class="c1">#-------------- 12/9 Developed for work with cell typing -----------------</span>
<div class="viewcode-block" id="soma_distance_branch_set"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.soma_distance_branch_set">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">soma_distance_branch_set</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">attr_name</span><span class="p">,</span>
                                     <span class="n">attr_func</span><span class="p">,</span>
                                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will set the skeletal distance to soma</span>
<span class="sd">    on each branch</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) iterate through all of the limbs and branches</span>
<span class="sd">    2) Find the distnace from soma and store</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="n">s_dist</span> <span class="o">=</span> <span class="n">attr_func</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">],</span><span class="n">attr_name</span><span class="p">,</span><span class="n">s_dist</span><span class="p">)</span></div>
            
            
<div class="viewcode-block" id="soma_distance_skeletal_branch_set"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.soma_distance_skeletal_branch_set">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">soma_distance_skeletal_branch_set</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;soma_distance_skeletal&quot;</span><span class="p">,):</span>
    <span class="n">nst</span><span class="o">.</span><span class="n">soma_distance_branch_set</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="n">attr_name</span><span class="p">,</span>
                             <span class="n">attr_func</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">,</span>
                            <span class="p">)</span></div>
    
<div class="viewcode-block" id="soma_distance_euclidean_branch_set"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.soma_distance_euclidean_branch_set">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">soma_distance_euclidean_branch_set</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                     <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;soma_distance_euclidean&quot;</span><span class="p">,):</span>
    <span class="n">nst</span><span class="o">.</span><span class="n">soma_distance_branch_set</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="n">attr_name</span><span class="p">,</span>
                             <span class="n">attr_func</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma_euclidean</span><span class="p">,</span>
                            <span class="p">)</span></div>
<div class="viewcode-block" id="upstream_endpoint_branch_set"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.upstream_endpoint_branch_set">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">upstream_endpoint_branch_set</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;upstream_endpoint&quot;</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_node_names</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="n">starting_coordinate</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">upstream_endpoint</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">],</span><span class="n">attr_name</span><span class="p">,</span><span class="n">starting_coordinate</span><span class="p">)</span></div>
            
<div class="viewcode-block" id="centroid_stats_from_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.centroid_stats_from_neuron_obj">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">centroid_stats_from_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">include_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">voxel_adjustment_vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="n">voxel_to_nm_scaling</span>
        
    <span class="n">soma_x_nm</span><span class="p">,</span><span class="n">soma_y_nm</span><span class="p">,</span><span class="n">soma_z_nm</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">soma_centers</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                       <span class="n">soma_name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                       <span class="n">voxel_adjustment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">return_int_form</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">soma_x</span><span class="p">,</span><span class="n">soma_y</span><span class="p">,</span><span class="n">soma_z</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">soma_centers</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                           <span class="n">soma_name</span><span class="o">=</span><span class="s2">&quot;S0&quot;</span><span class="p">,</span>
                                            <span class="n">voxel_adjustment</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                           <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="n">voxel_adjustment_vector</span><span class="p">,</span>
                                           <span class="n">return_int_form</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">centroid_x_nm</span><span class="o">=</span><span class="n">soma_x_nm</span><span class="p">,</span>
        <span class="n">centroid_y_nm</span><span class="o">=</span><span class="n">soma_y_nm</span><span class="p">,</span>
        <span class="n">centroid_z_nm</span><span class="o">=</span><span class="n">soma_z_nm</span><span class="p">,</span>
        <span class="n">centroid_x</span><span class="o">=</span><span class="n">soma_x</span><span class="p">,</span>
        <span class="n">centroid_y</span><span class="o">=</span><span class="n">soma_y</span><span class="p">,</span>
        <span class="n">centroid_z</span><span class="o">=</span><span class="n">soma_z</span> 
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">include_volume</span><span class="p">:</span>
        <span class="n">return_dict</span><span class="p">[</span><span class="s2">&quot;centroid_volume&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span>
        
    <span class="k">return</span> <span class="n">return_dict</span></div>
    

<div class="viewcode-block" id="skeleton_stats_from_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_stats_from_neuron_obj">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_stats_from_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">include_centroids</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                  <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                   <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                   <span class="n">neuron_obj_aligned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute all the statistics for a neurons skeleton (should have only one soma)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">voxel_adjustment_vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="n">voxel_to_nm_scaling</span>
    
    <span class="n">sk_dict</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">stats_dict_over_limb_branch</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
        <span class="n">stats_to_compute</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">,</span><span class="s2">&quot;n_branches&quot;</span><span class="p">])</span>

    <span class="n">sk_dict_2</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">features_from_neuron_skeleton_and_soma_center</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict</span><span class="p">,</span>
        <span class="n">features_to_exclude</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span><span class="s2">&quot;n_branches&quot;</span><span class="p">),</span>
        <span class="n">neuron_obj_aligned</span><span class="o">=</span><span class="n">neuron_obj_aligned</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">sk_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sk_dict_2</span><span class="p">)</span>
    <span class="n">sk_dict</span><span class="p">[</span><span class="s2">&quot;n_limbs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_limbs</span>
    
    <span class="k">if</span> <span class="n">include_centroids</span><span class="p">:</span>
        <span class="n">cent_stats</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">centroid_stats_from_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                       <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="n">voxel_adjustment_vector</span><span class="p">)</span>
        <span class="n">sk_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cent_stats</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sk_dict</span></div>

<div class="viewcode-block" id="skeleton_stats_compartment"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_stats_compartment">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_stats_compartment</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">compartment</span><span class="p">,</span>
    <span class="n">include_compartmnet_prefix</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">include_centroids</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compartment</span><span class="si">}</span><span class="s2">_limb_branch_dict&quot;</span><span class="p">)</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_stats_from_neuron_obj</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">,</span>
        <span class="n">include_centroids</span><span class="o">=</span><span class="n">include_centroids</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">include_compartmnet_prefix</span><span class="p">:</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">compartment</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">return_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        
    <span class="k">return</span> <span class="n">return_dict</span></div>
        
<div class="viewcode-block" id="skeleton_stats_dendrite"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_stats_dendrite">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_stats_dendrite</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_stats_compartment</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;dendrite&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
<div class="viewcode-block" id="skeleton_stats_axon"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.skeleton_stats_axon">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">skeleton_stats_axon</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">skeleton_stats_compartment</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">compartment</span><span class="o">=</span><span class="s2">&quot;axon&quot;</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="width_near_branch_endpoint"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.width_near_branch_endpoint">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">width_near_branch_endpoint</span><span class="p">(</span>
    <span class="n">limb_obj</span><span class="p">,</span>
    <span class="n">branch_idx</span><span class="p">,</span>
    <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># if None then will select most upstream endpoint of branch</span>

    <span class="c1">#parameters for the restriction</span>
    <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">comparison_distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
    <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To compute the width of a branch</span>
<span class="sd">    around a comparison distance and offset of an endpoint</span>
<span class="sd">    on it&#39;s skeleton</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">endpoint</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">closest_branch_endpoint_to_limb_starting_coordinate</span><span class="p">(</span>
            <span class="n">limb_obj</span><span class="o">=</span><span class="n">limb_obj</span><span class="p">,</span>
            <span class="n">branches</span><span class="o">=</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;endpoint = </span><span class="si">{</span><span class="n">endpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="p">(</span><span class="n">base_final_skeleton</span><span class="p">,</span>
    <span class="n">base_final_widths</span><span class="p">,</span>
    <span class="n">base_final_seg_lengths</span><span class="p">)</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_and_restrict_branch</span><span class="p">(</span><span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">],</span>
                              <span class="n">common_endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span>
                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                             <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                             <span class="n">skeleton_segment_size</span><span class="o">=</span><span class="n">skeleton_segment_size</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="p">)</span>


    <span class="n">branch_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">base_final_widths</span><span class="p">)</span>
    <span class="n">overall_ais_width</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;base_final_widths = </span><span class="si">{</span><span class="n">base_final_widths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;overall_branch_width = </span><span class="si">{</span><span class="n">overall_ais_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_width = </span><span class="si">{</span><span class="n">branch_width</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">branch_width</span></div>

<span class="c1"># --------------s / 9 ---------------</span>
<div class="viewcode-block" id="farthest_distance_from_skeleton_to_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.farthest_distance_from_skeleton_to_mesh">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">farthest_distance_from_skeleton_to_mesh</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purposee: find the coordinate</span>
<span class="sd">    of the skeleton that has the </span>
<span class="sd">    longest closest distance to the mesh</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    farthest_distance_from_skeleton_to_mesh(</span>
<span class="sd">    branch_obj,</span>
<span class="sd">    verbose = True,</span>
<span class="sd">    plot = True</span>
<span class="sd">    )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tu</span><span class="o">.</span><span class="n">farthest_coordinate_to_faces</span><span class="p">(</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span>
        <span class="n">return_distance</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="limb_branch_from_stats_df"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.limb_branch_from_stats_df">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">limb_branch_from_stats_df</span><span class="p">(</span>
    <span class="n">df</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To convert a dataframe to a limb branch dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_branch_pairings</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;limb&quot;</span><span class="p">,</span><span class="s2">&quot;node&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="c1">#gets a dictionary where key is the limb and value is a list of all the branches that were in the filtered dataframe</span>
    <span class="n">limb_to_branch</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">limb_branch_pairings</span><span class="p">[:,</span><span class="mi">1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">limb_branch_pairings</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span> 
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">limb_branch_pairings</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])])</span>
    <span class="k">return</span> <span class="n">limb_to_branch</span></div>

<div class="viewcode-block" id="coordinates_function_list"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.coordinates_function_list">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">coordinates_function_list</span><span class="p">(</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
    <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;mesh_center&quot;</span><span class="p">,</span>
               <span class="s2">&quot;endpoint_downstream&quot;</span><span class="p">,</span>
              <span class="s2">&quot;endpoint_upstream&quot;</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
        <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">coordinates</span>
    <span class="p">])</span></div>

<div class="viewcode-block" id="coordinates_stats_df"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.coordinates_stats_df">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">coordinates_stats_df</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To create a dataframe of centers </span>
<span class="sd">    for a limb branch</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">functions_list</span><span class="o">=</span><span class="n">nst</span><span class="o">.</span><span class="n">coordinates_function_list</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="s2">&quot;endpoint&quot;</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">functions_list</span><span class="p">])):</span>
        <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>


    <span class="n">coordinates_df</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">stats_df</span><span class="p">(</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">functions_list</span><span class="o">=</span><span class="n">functions_list</span><span class="p">,</span>
        <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">coordinates_df</span></div>

<div class="viewcode-block" id="stats_df"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.stats_df">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">stats_df</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">functions_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">query</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">function_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">include_coordinates</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">check_nans</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To return the stats on neuron branches </span>
<span class="sd">    that is used by the neuron searching to filter down</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_statistics as nst</span>

<span class="sd">    limb_obj = neuron_obj[6]</span>

<span class="sd">    s_df = nst.stats_df(</span>
<span class="sd">        neuron_obj,</span>
<span class="sd">        functions_list = [ns.width_new,</span>
<span class="sd">        ns.skeletal_length,</span>
<span class="sd">        ns.n_synapses_post_downstream],</span>
<span class="sd">        limb_branch_dict_restriction=dict(L6=limb_obj.get_branch_names())</span>
<span class="sd">            )</span>
<span class="sd">    s_df</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">functions_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">functions_list</span><span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">functions_list</span> <span class="o">+=</span> <span class="n">ns</span><span class="o">.</span><span class="n">functions_list_from_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">include_coordinates</span><span class="p">:</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
        <span class="n">functions_list</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">coordinates_function_list</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                <span class="n">functions_list</span><span class="o">=</span><span class="n">functions_list</span><span class="p">,</span>
                <span class="n">function_kwargs</span> <span class="o">=</span> <span class="n">function_kwargs</span><span class="p">,</span>       
                <span class="n">return_dataframe_before_filtering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
               <span class="n">query</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">check_nans</span><span class="o">=</span><span class="n">check_nans</span><span class="p">)</span></div>
    
    
        


<div class="viewcode-block" id="neuron_stats"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.neuron_stats">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">neuron_stats</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">stats_to_ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_centroids</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">voxel_adjustment_vector</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cell_type_mode</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will compute a wide range of statistics </span>
<span class="sd">    on a neurons object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">cell_type_mode</span><span class="p">:</span>
        <span class="n">stats_to_ignore</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;n_not_processed_soma_containing_meshes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_error_limbs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_same_soma_multi_touching_limbs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_multi_soma_touching_limbs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;n_somas&quot;</span><span class="p">,</span>
            <span class="s2">&quot;spine_density&quot;</span>
            <span class="p">]</span>
        <span class="n">include_skeletal_stats</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">include_centroids</span><span class="o">=</span> <span class="kc">True</span>


    <span class="n">stats_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">n_vertices</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_vertices</span><span class="p">,</span>
                    <span class="n">n_faces</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_faces</span><span class="p">,</span>

                    <span class="n">axon_length</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_length</span><span class="p">,</span>
                    <span class="n">axon_area</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">axon_area</span><span class="p">,</span>

                    <span class="n">max_soma_volume</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">max_soma_volume</span><span class="p">,</span>
                    <span class="n">max_soma_n_faces</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">max_soma_n_faces</span><span class="p">,</span>
                    <span class="n">max_soma_area</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">max_soma_area</span><span class="p">,</span>


                    <span class="n">n_not_processed_soma_containing_meshes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">not_processed_soma_containing_meshes</span><span class="p">),</span>
                    <span class="n">n_error_limbs</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_error_limbs</span><span class="p">,</span>
                    <span class="n">n_same_soma_multi_touching_limbs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">same_soma_multi_touching_limbs</span><span class="p">),</span>
                    <span class="n">n_multi_soma_touching_limbs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">multi_soma_touching_limbs</span><span class="p">),</span>
                    <span class="n">n_somas</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_somas</span><span class="p">,</span>
                    <span class="n">n_limbs</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_limbs</span><span class="p">,</span>
                    <span class="n">n_branches</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_branches</span><span class="p">,</span>
                    <span class="n">max_limb_n_branches</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">max_limb_n_branches</span><span class="p">,</span>

                    <span class="n">skeletal_length</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length</span><span class="p">,</span>
                    <span class="n">max_limb_skeletal_length</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">max_limb_skeletal_length</span><span class="p">,</span>
                    <span class="n">median_branch_length</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">median_branch_length</span><span class="p">,</span>

                    <span class="n">width_median</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">width_median</span><span class="p">,</span> <span class="c1">#median width from mesh center without spines removed</span>
                    <span class="n">width_no_spine_median</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">width_no_spine_median</span><span class="p">,</span> <span class="c1">#median width from mesh center with spines removed</span>
                    <span class="n">width_90_perc</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">width_90_perc</span><span class="p">,</span> <span class="c1"># 90th percentile for width without spines removed</span>
                    <span class="n">width_no_spine_90_perc</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">width_no_spine_90_perc</span><span class="p">,</span>  <span class="c1"># 90th percentile for width with spines removed</span>

                    <span class="n">n_spines</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spines</span><span class="p">,</span>
                    <span class="n">n_boutons</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">,</span>

                    <span class="n">spine_density</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_density</span><span class="p">,</span> <span class="c1"># n_spines/ skeletal_length</span>
                    <span class="n">spines_per_branch</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_per_branch</span><span class="p">,</span>

                    <span class="n">skeletal_length_eligible</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">skeletal_length_eligible</span><span class="p">,</span> <span class="c1"># the skeletal length for all branches searched for spines</span>
                    <span class="n">n_spine_eligible_branches</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">n_spine_eligible_branches</span><span class="p">,</span>
                    <span class="n">spine_density_eligible</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_density_eligible</span><span class="p">,</span>
                    <span class="n">spines_per_branch_eligible</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spines_per_branch_eligible</span><span class="p">,</span>

                    <span class="n">total_spine_volume</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">total_spine_volume</span><span class="p">,</span> <span class="c1"># the sum of all spine volume</span>
                    <span class="n">spine_volume_median</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_volume_median</span><span class="p">,</span>
                    <span class="n">spine_volume_density</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_volume_density</span><span class="p">,</span> <span class="c1">#total_spine_volume/skeletal_length</span>
                    <span class="n">spine_volume_density_eligible</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_volume_density_eligible</span><span class="p">,</span> <span class="c1">#total_spine_volume/skeletal_length_eligible</span>
                    <span class="n">spine_volume_per_branch_eligible</span><span class="o">=</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">spine_volume_per_branch_eligible</span><span class="p">,</span> <span class="c1">#total_spine_volume/n_spine_eligible_branche</span>



    <span class="p">)</span>

    <span class="k">if</span> <span class="n">stats_to_ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stats_to_ignore</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">stats_dict</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">include_skeletal_stats</span><span class="p">:</span>
        <span class="n">sk_dict</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">features_from_neuron_skeleton_and_soma_center</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                              <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                              <span class="n">features_to_exclude</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">,</span><span class="s2">&quot;n_branches&quot;</span><span class="p">),</span>
                                             <span class="p">)</span>
        <span class="n">stats_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sk_dict</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">include_centroids</span><span class="p">:</span>
        <span class="n">cent_stats</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">centroid_stats_from_neuron_obj</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                       <span class="n">voxel_adjustment_vector</span><span class="o">=</span><span class="n">voxel_adjustment_vector</span><span class="p">)</span>
        <span class="n">stats_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cent_stats</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">stats_dict</span></div>

<div class="viewcode-block" id="branch_stats_dict_from_df"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.branch_stats_dict_from_df">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">branch_stats_dict_from_df</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">limb_name</span><span class="p">,</span><span class="n">branch_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ex: limb_df = nst.stats_df(neuron_obj,</span>
<span class="sd">        functions_list=[eval(f&quot;lu.{k}_{ns.limb_function_append_name}&quot;) </span>
<span class="sd">                        for k in ctcu.branch_attrs_limb_based_for_G])</span>

<span class="sd">    limb_name = &quot;L0&quot;</span>
<span class="sd">    branch_name = 4</span>
<span class="sd">    nst.branch_stats_dict_from_df(limb_df,limb_name,branch_name)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">limb_name</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">limb_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pu</span><span class="o">.</span><span class="n">df_to_dicts</span><span class="p">(</span><span class="n">pu</span><span class="o">.</span><span class="n">delete_columns</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(limb==&#39;</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">&#39;) and (node == </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">),[</span><span class="s2">&quot;limb&quot;</span><span class="p">,</span><span class="s2">&quot;node&quot;</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="euclidean_distance_from_soma_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.euclidean_distance_from_soma_limb_branch">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">euclidean_distance_from_soma_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">less_than</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">endpoint_type</span> <span class="o">=</span> <span class="s2">&quot;downstream&quot;</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Find limb branch dict within or</span>
<span class="sd">    farther than a certain euclidean distance</span>
<span class="sd">    from all the soma pieces</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) get the upstream endpoints of all</span>
<span class="sd">    &quot;&quot;&quot;</span>
   
    

    <span class="n">bu</span><span class="o">.</span><span class="n">set_branches_endpoints_upstream_downstream_idx</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">)</span>
    <span class="n">soma_kd</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">mesh_to_kdtree</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>



    <span class="n">lb_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">limb_idx</span> <span class="ow">in</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">get_limb_names</span><span class="p">():</span>
        <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">limb_obj</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
            <span class="n">branch_obj</span> <span class="o">=</span> <span class="n">limb_obj</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span>
            <span class="n">dist</span><span class="p">,</span><span class="n">__</span> <span class="o">=</span> <span class="n">soma_kd</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">branch_obj</span><span class="p">,</span><span class="sa">f</span><span class="s2">&quot;endpoint_</span><span class="si">{</span><span class="n">endpoint_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">less_than</span><span class="p">:</span>
                <span class="n">add_flag</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance_threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">add_flag</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">distance_threshold</span>

            <span class="k">if</span> <span class="n">add_flag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">limb_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lb_dict</span><span class="p">:</span>
                    <span class="n">lb_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">lb_dict</span><span class="p">[</span><span class="n">limb_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">branch_idx</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">limb_idx</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">branch_idx</span><span class="si">}</span><span class="s2"> because dist </span><span class="si">{</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">lb_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">lb_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">lb_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">lb_dict</span></div>

<div class="viewcode-block" id="euclidean_distance_close_to_soma_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.euclidean_distance_close_to_soma_limb_branch">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">euclidean_distance_close_to_soma_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">euclidean_distance_from_soma_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">less_than</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="euclidean_distance_farther_than_soma_limb_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_statistics.euclidean_distance_farther_than_soma_limb_branch">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">euclidean_distance_farther_than_soma_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">euclidean_distance_from_soma_limb_branch</span><span class="p">(</span>
    <span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">less_than</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">distance_threshold</span> <span class="o">=</span> <span class="n">distance_threshold</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
    <span class="p">)</span></div>

<span class="c1"># ----------------- Parameters ------------------------</span>


<span class="n">global_parameters_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
<span class="p">)</span>

<span class="n">attributes_dict_default</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">voxel_to_nm_scaling</span> <span class="o">=</span> <span class="n">mvu</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span>
<span class="p">)</span>    

<span class="n">global_parameters_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">attributes_dict_microns</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">global_parameters_dict_h01</span> <span class="o">=</span> <span class="p">{}</span>


<span class="n">attributes_dict_h01</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">voxel_to_nm_scaling</span> <span class="o">=</span> <span class="n">hvu</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span>
<span class="p">)</span>

<span class="c1"># data_type = &quot;default&quot;</span>
<span class="c1"># algorithms = None</span>


<span class="c1"># modules_to_set = [nst]</span>

<span class="c1"># def set_global_parameters_and_attributes_by_data_type(dt,</span>
<span class="c1">#                                                      algorithms_list = None,</span>
<span class="c1">#                                                       modules = None,</span>
<span class="c1">#                                                      set_default_first = True,</span>
<span class="c1">#                                                       verbose=False):</span>
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     modu.set_global_parameters_and_attributes_by_data_type(modules,dt,</span>
<span class="c1">#                                                           algorithms=algorithms_list,</span>
<span class="c1">#                                                           set_default_first = set_default_first,</span>
<span class="c1">#                                                           verbose = verbose)</span>
    
<span class="c1"># set_global_parameters_and_attributes_by_data_type(data_type,</span>
<span class="c1">#                                                    algorithms)</span>

<span class="c1"># def output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#     modules = None,</span>
<span class="c1">#     algorithms = None,</span>
<span class="c1">#     verbose = True,</span>
<span class="c1">#     lowercase = True,</span>
<span class="c1">#     output_types = (&quot;global_parameters&quot;),</span>
<span class="c1">#     include_default = True,</span>
<span class="c1">#     algorithms_only = False,</span>
<span class="c1">#     **kwargs):</span>
    
<span class="c1">#     if modules is None:</span>
<span class="c1">#         modules = modules_to_set</span>
    
<span class="c1">#     return modu.output_global_parameters_and_attributes_from_current_data_type(</span>
<span class="c1">#         modules,</span>
<span class="c1">#         algorithms = algorithms,</span>
<span class="c1">#         verbose = verbose,</span>
<span class="c1">#         lowercase = lowercase,</span>
<span class="c1">#         output_types = output_types,</span>
<span class="c1">#         include_default = include_default,</span>
<span class="c1">#         algorithms_only = algorithms_only,</span>
<span class="c1">#         **kwargs,</span>
<span class="c1">#         )</span>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">branch_utils</span> <span class="k">as</span> <span class="n">bu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">error_detection</span> <span class="k">as</span> <span class="n">ed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">h01_volume_utils</span> <span class="k">as</span> <span class="n">hvu</span> 
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mcu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">microns_volume_utils</span> <span class="k">as</span> <span class="n">mvu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mesh_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mesh_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">general_utils</span> <span class="k">as</span> <span class="n">gu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">module_utils</span> <span class="k">as</span> <span class="n">modu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datasci_tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
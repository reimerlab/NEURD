<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.neuron_searching &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.neuron_searching</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.neuron_searching</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>



<span class="sd">Purpose: Module provides tools for helping to find the interesting branches</span>
<span class="sd">and limbs according to the query and functions that you define</span>

<span class="sd">** To create a limb function **</span>
<span class="sd">Have it return either one singular value or a dictionary mapping the </span>
<span class="sd">branch idx to a </span>




<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">comparison_distance_global</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">limb_function_append_name</span> <span class="o">=</span> <span class="s2">&quot;limb_ns&quot;</span>

<div class="viewcode-block" id="convert_neuron_to_branches_dataframe"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.convert_neuron_to_branches_dataframe">[docs]</a><span class="k">def</span> <span class="nf">convert_neuron_to_branches_dataframe</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                        <span class="n">limbs_to_process</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;axon_segment</span>
<span class="sd">    Purpose: </span>
<span class="sd">    How to turn a concept map into a pandas table with only the limb_idx and node_idx</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    neuron_df = convert_neuron_to_branches_dataframe(current_neuron = recovered_neuron)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">return_concept_network</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">limbs_to_process</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_idxs</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_names_from_concept_network</span><span class="p">(</span><span class="n">curr_concept_network</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limb_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limbs_to_process</span><span class="p">]</span>
    
    
    <span class="n">limb_node_idx_dicts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">limb_idxs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_node_idx_dicts</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">limb</span><span class="o">=</span><span class="n">l</span><span class="p">,</span><span class="n">node</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> 
                                <span class="n">curr_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">limb_branch_dict_restriction</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">limb_node_idx_dicts</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">limb</span><span class="o">=</span><span class="n">l</span><span class="p">,</span><span class="n">node</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> 
                                    <span class="n">limb_branch_dict_restriction</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">limb_node_idx_dicts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>

<span class="c1">#wrapper to help with classifying funciton uses</span>
<div class="viewcode-block" id="run_options"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.run_options">[docs]</a><span class="k">class</span> <span class="nc">run_options</span><span class="p">:</span>
<div class="viewcode-block" id="run_options.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.run_options.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_type</span> <span class="o">=</span> <span class="n">run_type</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="n">f</span><span class="o">.</span><span class="n">run_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_type</span>
        <span class="k">return</span> <span class="n">f</span></div>

<span class="c1">#------------------------------- Branch Functions ------------------------------------#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Want to have functions that just operate off of branch characteristics or limb characteristics</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#Branch Functions</span>

<div class="viewcode-block" id="n_faces_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_faces_branch">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_faces_branch</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span></div>

<div class="viewcode-block" id="width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.width">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="width_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.width_neuron">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">width_neuron</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="axon_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_width">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">axon_width</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">width_name</span><span class="o">=</span><span class="s2">&quot;no_bouton_median&quot;</span><span class="p">,</span>
               <span class="n">width_name_backup</span><span class="o">=</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
               <span class="n">width_name_backup_2</span> <span class="o">=</span> <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">au</span><span class="o">.</span><span class="n">axon_width</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                         <span class="n">width_name</span><span class="o">=</span><span class="n">width_name</span><span class="p">,</span>
               <span class="n">width_name_backup</span><span class="o">=</span><span class="n">width_name_backup</span><span class="p">,</span>
               <span class="n">width_name_backup_2</span> <span class="o">=</span> <span class="n">width_name_backup_2</span><span class="p">,</span>
                        <span class="p">)</span></div>
    

<div class="viewcode-block" id="skeleton_distance_branch"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeleton_distance_branch">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeleton_distance_branch</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#print(f&quot;curr_branch.skeleton = {curr_branch.skeleton.shape}&quot;)</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_branch.skeleton = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeletal_length">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeletal_length</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#print(f&quot;curr_branch.skeleton = {curr_branch.skeleton.shape}&quot;)</span>
        <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_branch.skeleton = </span><span class="si">{</span><span class="n">curr_branch</span><span class="o">.</span><span class="n">skeleton</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="n_spines"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_spines">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_spines</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">branch</span><span class="o">.</span><span class="n">spines</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">n_spines</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="width_new"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.width_new">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">width_new</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">width_new_name</span><span class="o">=</span><span class="s2">&quot;no_spine_mean_mesh_center&quot;</span><span class="p">,</span>
              <span class="n">width_new_name_backup</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_new_name</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_new_name_backup</span><span class="p">]</span></div>


<div class="viewcode-block" id="n_boutons"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_boutons">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_boutons</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">n_boutons</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span></div>


<div class="viewcode-block" id="n_boutons_above_thresholds"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_boutons_above_thresholds">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_boutons_above_thresholds</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">boutons_above_thresholds</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span>
                                          <span class="n">return_idx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>
    

<span class="c1"># ---------- new possible widths ----------------- #</span>
<div class="viewcode-block" id="mean_mesh_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.mean_mesh_center">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mean_mesh_center</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;mean_mesh_center&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="median_mesh_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.median_mesh_center">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">median_mesh_center</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="no_spine_mean_mesh_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.no_spine_mean_mesh_center">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_spine_mean_mesh_center</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_mean_mesh_center&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="no_spine_median_mesh_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.no_spine_median_mesh_center">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_spine_median_mesh_center</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">]</span></div>

<span class="c1"># ---------- new possible widths ----------------- #</span>




<div class="viewcode-block" id="no_spine_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.no_spine_width">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_spine_width</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_average&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="no_spine_average_mesh_center"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.no_spine_average_mesh_center">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">no_spine_average_mesh_center</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;no_spine_average_mesh_center&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="spines_per_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.spines_per_skeletal_length">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spines_per_skeletal_length</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">curr_n_spines</span> <span class="o">=</span> <span class="n">n_spines</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span>
    <span class="n">curr_skeleton_distance</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">curr_n_spines</span><span class="o">/</span><span class="n">curr_skeleton_distance</span></div>

<span class="c1"># --------- spine densities ---------------- #</span>
<div class="viewcode-block" id="spine_density"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.spine_density">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">spine_density</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">spine_density</span></div>


<span class="c1"># ----------- working with different labels -----------------#</span>
<div class="viewcode-block" id="matching_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.matching_label">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matching_label</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">poss_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span>
    <span class="n">match_flag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">poss_labels</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">branch</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="n">match_flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">match_flag</span></div>

<div class="viewcode-block" id="labels_restriction"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.labels_restriction">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">labels_restriction</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">poss_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;matching_labels&quot;</span><span class="p">,[])</span>
    <span class="n">not_possible_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;not_matching_labels&quot;</span><span class="p">,[])</span>
    <span class="n">match_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;match_type&quot;</span><span class="p">,</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
<span class="c1">#     print(f&quot;poss_labels = {poss_labels}&quot;)</span>
<span class="c1">#     print(f&quot;not_possible_labels = {not_possible_labels}&quot;)</span>
<span class="c1">#     print(f&quot;np.intersect1d(branch.labels,poss_labels) = {np.intersect1d(branch.labels,poss_labels)}&quot;)</span>
   
    <span class="k">if</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_labels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span><span class="n">poss_labels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span><span class="n">not_possible_labels</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">match_type</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span><span class="n">not_possible_labels</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">branch</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span><span class="n">poss_labels</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown match type: </span><span class="si">{</span><span class="n">match_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
            

<div class="viewcode-block" id="labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.labels">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">branch</span><span class="o">.</span><span class="n">labels</span></div>

<div class="viewcode-block" id="axon_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_label">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">axon_label</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">branch</span><span class="o">.</span><span class="n">labels</span></div>

<div class="viewcode-block" id="is_axon"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.is_axon">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_axon</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;axon&quot;</span> <span class="ow">in</span> <span class="n">branch</span><span class="o">.</span><span class="n">labels</span></div>


<span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_axon_like</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;axon-like&quot;</span> <span class="ow">in</span> <span class="n">branch</span><span class="o">.</span><span class="n">labels</span>

<div class="viewcode-block" id="is_axon_like"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.is_axon_like">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_axon_like</span><span class="p">(</span><span class="n">branch</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;axon-like&quot;</span> <span class="ow">in</span> <span class="n">branch</span><span class="o">.</span><span class="n">labels</span></div>




<div class="viewcode-block" id="query_neuron_by_labels"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.query_neuron_by_labels">[docs]</a><span class="k">def</span> <span class="nf">query_neuron_by_labels</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
    <span class="n">matching_labels</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">not_matching_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">match_type</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">not_matching_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">not_matching_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
               <span class="n">query</span><span class="o">=</span><span class="s2">&quot;labels_restriction == True&quot;</span><span class="p">,</span>
               <span class="n">functions_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;labels_restriction&quot;</span><span class="p">],</span>
               <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">matching_labels</span><span class="o">=</span><span class="n">matching_labels</span><span class="p">,</span>
                                    <span class="n">not_matching_labels</span><span class="o">=</span><span class="n">not_matching_labels</span><span class="p">,</span>
                                    <span class="n">match_type</span><span class="o">=</span><span class="n">match_type</span>

                                   <span class="p">))</span></div>
        


<span class="c1">#------------------------------- Limb Functions ------------------------------------#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Rule: For the limb functions will either return</span>
<span class="sd">1) 1 number</span>
<span class="sd">2) 1 True/False Value</span>
<span class="sd">3) Array of 1 or 2 that matches the number of branches</span>
<span class="sd">4) a list of nodes that it applies to</span>

<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="convert_limb_function_return_to_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.convert_limb_function_return_to_dict">[docs]</a><span class="k">def</span> <span class="nf">convert_limb_function_return_to_dict</span><span class="p">(</span><span class="n">function_return</span><span class="p">,</span>
                                        <span class="n">curr_limb_concept_network</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    purpose: to take the returned</span>
<span class="sd">    value of a limb function and convert it to </span>
<span class="sd">    a dictionary that maps all of the nodes to a certain value</span>
<span class="sd">    - capable of handling both a dictionary and a scalar value</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#curr_limb_concept_network = curr_neuron_concept_network.nodes[limb_name][&quot;data&quot;].concept_network</span>
    <span class="n">function_mapping_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">function_return</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">function_mapping_dict</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_return</span>
    <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">function_return</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
        <span class="n">function_mapping_dict</span> <span class="o">=</span> <span class="n">function_return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The value returned from limb function was not a scalar nor did it match the keys of the limb branches&quot;</span><span class="p">)</span>  
    
    <span class="k">return</span> <span class="n">function_mapping_dict</span></div>

<div class="viewcode-block" id="convert_limb_function_return_to_limb_branch_dict"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.convert_limb_function_return_to_limb_branch_dict">[docs]</a><span class="k">def</span> <span class="nf">convert_limb_function_return_to_limb_branch_dict</span><span class="p">(</span><span class="n">function_return</span><span class="p">,</span>
                                        <span class="n">curr_limb_concept_network</span><span class="p">,</span>
                                                    <span class="n">limb_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: returns a dictionary that maps limb to valid branches</span>
<span class="sd">    according to a function return that is True or False</span>
<span class="sd">    (only includes the branches that are true from the function_return)</span>
<span class="sd">    </span>
<span class="sd">    Result: retursn a dictionary like dict(L1=[3,5,8,9,10])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_dict</span> <span class="o">=</span> <span class="n">convert_limb_function_return_to_dict</span><span class="p">(</span><span class="n">function_return</span><span class="p">,</span>
                                        <span class="n">curr_limb_concept_network</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">limb_name</span><span class="p">:[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">new_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]}</span></div>
    


<div class="viewcode-block" id="skeleton_distance_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeleton_distance_limb">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeleton_distance_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">curr_skeleton</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_skeleton</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_skeleton</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_faces_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_faces_limb">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_faces_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span></div>

<div class="viewcode-block" id="merge_limbs"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.merge_limbs">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">merge_limbs</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;MergeError&quot;</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">labels</span></div>

<div class="viewcode-block" id="limb_error_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.limb_error_branches">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">limb_error_branches</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">error_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">classify_endpoint_error_branches_from_limb_concept_network</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="p">)</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">error_nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">])</span></div>

<div class="viewcode-block" id="average_branch_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.average_branch_length">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">average_branch_length</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">sk</span><span class="o">.</span><span class="n">calculate_skeleton_distance</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeleton</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">()])</span></div>

<div class="viewcode-block" id="test_limb"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.test_limb">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_limb</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">5</span></div>


<div class="viewcode-block" id="skeletal_distance_from_soma_excluding_node"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeletal_distance_from_soma_excluding_node">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">skeletal_distance_from_soma_excluding_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                    <span class="n">limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">error_if_all_nodes_not_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                            
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_distance_from_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                    <span class="n">limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">error_if_all_nodes_not_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="skeletal_distance_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeletal_distance_from_soma">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeletal_distance_from_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                    <span class="n">limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">error_if_all_nodes_not_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                            
    <span class="p">):</span>
    
    <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_distance_from_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                    <span class="n">limb_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">somas</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">error_if_all_nodes_not_return</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">include_node_skeleton_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">print_flag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>





<div class="viewcode-block" id="axon_width_like_query"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_width_like_query">[docs]</a><span class="k">def</span> <span class="nf">axon_width_like_query</span><span class="p">(</span><span class="n">width_to_use</span><span class="p">):</span>
    <span class="n">axon_width_like_query</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="c1">#f&quot;(n_spines &lt; 4 and {width_to_use} and skeleton_distance_branch &lt;= 15000)&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(n_spines &lt; 4 and </span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2"> and skeleton_distance_branch &lt;= 25000)&quot;</span>
                    <span class="c1">#f&quot; or (skeleton_distance_branch &gt; 15000 and {width_to_use} and spines_per_skeletal_length &lt; 0.00023)&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; or (skeleton_distance_branch &gt; 25000 and </span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2"> and spines_per_skeletal_length &lt; 0.00015)&quot;</span>
                            
                            <span class="p">)</span>
    <span class="k">return</span> <span class="n">axon_width_like_query</span></div>

<div class="viewcode-block" id="axon_merge_error_width_like_query"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_merge_error_width_like_query">[docs]</a><span class="k">def</span> <span class="nf">axon_merge_error_width_like_query</span><span class="p">(</span><span class="n">width_to_use</span><span class="p">):</span>
   

    <span class="n">axon_width_like_query</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;((n_spines &lt; 2) and ((n_spines &lt; 3 and </span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2"> and skeleton_distance_branch &lt;= 25000)&quot;</span>
    <span class="c1">#f&quot; or (skeleton_distance_branch &gt; 15000 and {width_to_use} and spines_per_skeletal_length &lt; 0.00023)&quot;</span>
    <span class="sa">f</span><span class="s2">&quot; or (skeleton_distance_branch &gt; 25000 and </span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2"> and spines_per_skeletal_length &lt; 0.00015)))&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">axon_width_like_query</span></div>
    

<span class="n">axon_width_like_functions_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;width&quot;</span><span class="p">,</span>
    <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
    <span class="s2">&quot;n_spines&quot;</span><span class="p">,</span>
    <span class="s2">&quot;n_faces_branch&quot;</span><span class="p">,</span>
    <span class="s2">&quot;skeleton_distance_branch&quot;</span><span class="p">,</span>
    <span class="s2">&quot;spines_per_skeletal_length&quot;</span><span class="p">,</span>
    <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="axon_width_like_segments_old"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_width_like_segments_old">[docs]</a><span class="k">def</span> <span class="nf">axon_width_like_segments_old</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                      <span class="n">current_query</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">current_functions_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">include_ais</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">axon_merge_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">width_to_use</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will get all of</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">current_functions_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">current_functions_list</span> <span class="o">=</span> <span class="n">axon_width_like_functions_list</span>
    <span class="k">if</span> <span class="n">current_query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">width_to_use</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width_expression</span>  <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(median_mesh_center &lt; </span><span class="si">{</span><span class="n">width_to_use</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_ais</span><span class="p">:</span>
                <span class="n">width_expression</span> <span class="o">=</span> <span class="n">ais_axon_width_like_requirement</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">width_expression</span> <span class="o">=</span> <span class="n">axon_width_like_requirement</span>
        <span class="n">current_query</span> <span class="o">=</span> <span class="n">axon_width_like_query</span><span class="p">(</span><span class="n">width_expression</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">axon_merge_error</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_expression = </span><span class="si">{</span><span class="n">width_expression</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">current_query</span> <span class="o">=</span> <span class="n">axon_merge_error_width_like_query</span><span class="p">(</span><span class="n">width_expression</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;current_query = </span><span class="si">{</span><span class="n">current_query</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">limb_branch_dict</span> <span class="o">=</span> <span class="n">query_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                       <span class="c1">#query=&quot;n_spines &lt; 4 and no_spine_average_mesh_center &lt; 400&quot;,</span>
                                       <span class="n">query</span><span class="o">=</span><span class="n">current_query</span><span class="p">,</span>
                                       <span class="c1">#return_dataframe=True,</span>
                   <span class="n">functions_list</span><span class="o">=</span><span class="n">current_functions_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">limb_branch_dict</span></div>

<span class="c1"># ------------- 1//22: Addition that accounts for newer higher fidelity spining --------- #</span>




<div class="viewcode-block" id="axon_segments_after_checks"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_segments_after_checks">[docs]</a><span class="k">def</span> <span class="nf">axon_segments_after_checks</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                               <span class="n">include_ais</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span>
                                <span class="n">width_match_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                               <span class="n">plot_axon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    
    <span class="n">axon_like_limb_branch_dict</span> <span class="o">=</span> <span class="n">axon_width_like_segments</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                         <span class="n">include_ais</span><span class="o">=</span><span class="n">include_ais</span><span class="p">,</span>
                                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">current_functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;axon_segment&quot;</span><span class="p">]</span>
    <span class="n">final_axon_like_classification</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>

                                       <span class="n">query</span><span class="o">=</span><span class="s2">&quot;axon_segment==True&quot;</span><span class="p">,</span>
                                       <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">limb_branch_dict</span> <span class="o">=</span><span class="n">axon_like_limb_branch_dict</span><span class="p">,</span>
                                                            <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="n">downstream_face_threshold</span><span class="p">,</span>
                                                            <span class="n">width_match_threshold</span><span class="o">=</span><span class="n">width_match_threshold</span><span class="p">,</span>
                                                           <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                       <span class="n">functions_list</span><span class="o">=</span><span class="n">current_functions_list</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_axon</span><span class="p">:</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">visualize_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                              <span class="n">visualize_type</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mesh&quot;</span><span class="p">],</span>
                             <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">final_axon_like_classification</span><span class="p">,</span>
                             <span class="n">mesh_color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
                              <span class="n">mesh_color_alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">mesh_whole_neuron</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_axon_like_classification</span></div>




<div class="viewcode-block" id="axon_segment"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_segment">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">axon_segment</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 
                 <span class="c1">#the parameters for the axon_segment_downstream_dendrites function</span>
                 <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                 <span class="n">downstream_non_axon_percentage_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                 <span class="n">max_skeletal_length_can_flip</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
                 <span class="n">distance_for_downstream_check</span><span class="o">=</span><span class="mi">40000</span><span class="p">,</span>
                 <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 
                 
                 <span class="c1">#the parameters for the axon_segment_clean_false_positives function</span>
                 <span class="n">width_match_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
               <span class="n">width_type</span> <span class="o">=</span> <span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
               <span class="n">must_have_spine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that will go through and hopefully label all of the axon pieces on a limb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network</span>
    <span class="c1">#print(f&quot;limb_branch_dict BEFORE = {limb_branch_dict}&quot;)</span>
    <span class="n">downstream_filtered_limb_branch_dict</span> <span class="o">=</span> <span class="n">axon_segment_downstream_dendrites</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
             <span class="n">downstream_face_threshold</span><span class="o">=</span><span class="n">downstream_face_threshold</span><span class="p">,</span>
             <span class="n">downstream_non_axon_percentage_threshold</span><span class="o">=</span><span class="n">downstream_non_axon_percentage_threshold</span><span class="p">,</span>                
            <span class="n">max_skeletal_length_can_flip</span><span class="o">=</span><span class="n">max_skeletal_length_can_flip</span><span class="p">,</span>                      
            <span class="n">distance_for_downstream_check</span><span class="o">=</span><span class="n">distance_for_downstream_check</span><span class="p">,</span>
             <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Old way of doing before condensed</span>
<span class="sd">    #print(f&quot;limb_branch_dict AFTER = {limb_branch_dict}&quot;)</span>
<span class="sd">    #unravel the output back into a dictionary mapping every node to a value</span>
<span class="sd">    #print(f&quot;downstream_filtered_limb_branch_dict BEFORE= {downstream_filtered_limb_branch_dict}&quot;)</span>
<span class="sd">    downstream_filtered_limb_branch_dict =  convert_limb_function_return_to_dict(downstream_filtered_limb_branch_dict,</span>
<span class="sd">                                                curr_limb_concept_network)</span>
<span class="sd">    #print(f&quot;downstream_filtered_limb_branch_dict AFTER= {downstream_filtered_limb_branch_dict}&quot;)</span>
<span class="sd">    #convert the dictionary mapping to a new limb_branch_dict just for that limb</span>
<span class="sd">    limb_branch_dict_downstream_filtered = {limb_name:[k for k,v in downstream_filtered_limb_branch_dict.items() if v == True]}</span>
<span class="sd">    #print(f&quot;limb_branch_dict_downstream_filtered = {limb_branch_dict_downstream_filtered}&quot;)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">limb_branch_dict_downstream_filtered</span> <span class="o">=</span> <span class="n">convert_limb_function_return_to_limb_branch_dict</span><span class="p">(</span><span class="n">downstream_filtered_limb_branch_dict</span><span class="p">,</span>
                                                                                           <span class="n">curr_limb_concept_network</span><span class="p">,</span>
                                                                                           <span class="n">limb_name</span><span class="p">)</span>
    
    
    
    <span class="n">clean_false_positives_dict</span> <span class="o">=</span> <span class="n">axon_segment_clean_false_positives</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict</span><span class="o">=</span><span class="n">limb_branch_dict_downstream_filtered</span><span class="p">,</span>
                                       <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                                    <span class="n">width_match_threshold</span><span class="o">=</span><span class="n">width_match_threshold</span><span class="p">,</span>
                                   <span class="n">width_type</span> <span class="o">=</span> <span class="n">width_type</span><span class="p">,</span>
                                   <span class="n">must_have_spine</span><span class="o">=</span><span class="n">must_have_spine</span><span class="p">,</span>
                                 <span class="n">print_flag</span><span class="o">=</span><span class="n">print_flag</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">limb_branch_dict_downstream_filtered</span> <span class="o">=</span> <span class="n">convert_limb_function_return_to_limb_branch_dict</span><span class="p">(</span><span class="n">clean_false_positives_dict</span><span class="p">,</span>
                                                                                           <span class="n">curr_limb_concept_network</span><span class="p">,</span>
                                                                                           <span class="n">limb_name</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;limb_branch_dict_downstream_filtered before dendrite to axon flipping = {limb_branch_dict_downstream_filtered}&quot;)</span>
    
    <span class="n">dendrit_to_axon_flip_branch_dict</span> <span class="o">=</span> <span class="n">flip_dendrite_to_axon</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_branch_dict_downstream_filtered</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    
    
    <span class="n">limb_branch_dict_downstream_filtered</span> <span class="o">=</span> <span class="n">convert_limb_function_return_to_limb_branch_dict</span><span class="p">(</span><span class="n">dendrit_to_axon_flip_branch_dict</span><span class="p">,</span>
                                                                                           <span class="n">curr_limb_concept_network</span><span class="p">,</span>
                                                                                           <span class="n">limb_name</span><span class="p">)</span>
    
    <span class="c1">#print(f&quot;limb_branch_dict_downstream_filtered AFTER dendrite to axon flipping = {limb_branch_dict_downstream_filtered}&quot;)</span>
    
    <span class="k">return</span> <span class="n">dendrit_to_axon_flip_branch_dict</span></div>

<div class="viewcode-block" id="axon_segment_downstream_dendrites"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_segment_downstream_dendrites">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">axon_segment_downstream_dendrites</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">downstream_face_threshold</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
                                      <span class="n">downstream_non_axon_percentage_threshold</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                                      <span class="n">max_skeletal_length_can_flip</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span>
                                      <span class="n">distance_for_downstream_check</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span>
                 <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">limb_starting_angle_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">limb_starting_angle_threshold</span> <span class="o">=</span> <span class="mi">155</span><span class="p">,</span>
                 <span class="c1">#return_limb_branch_dict=False,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To filter the aoxn-like segments (so that does not mistake dendritic branches)</span>
<span class="sd">    based on the criteria that an axon segment should not have many non-axon upstream branches</span>
<span class="sd">    </span>
<span class="sd">    Example on how to run: </span>
<span class="sd">    </span>
<span class="sd">    curr_limb_name = &quot;L1&quot;</span>
<span class="sd">    curr_limb = uncompressed_neuron.concept_network.nodes[curr_limb_name][&quot;data&quot;]</span>
<span class="sd">    ns = reload(ns)</span>

<span class="sd">    return_value = ns.axon_segment(curr_limb,limb_branch_dict=limb_branch_dict,</span>
<span class="sd">                 limb_name=curr_limb_name,downstream_face_threshold=5000,</span>
<span class="sd">                     print_flag=False)</span>
<span class="sd">    return_value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
   
    
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_face_threshold= </span><span class="si">{</span><span class="n">downstream_face_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_non_axon_percentage_threshold = </span><span class="si">{</span><span class="n">downstream_non_axon_percentage_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_skeletal_length_can_flip = </span><span class="si">{</span><span class="n">max_skeletal_length_can_flip</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;distance_for_downstream_check = </span><span class="si">{</span><span class="n">distance_for_downstream_check</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#print(f&quot;limb_branch_dict= {limb_branch_dict}&quot;)</span>
        
    <span class="c1">#curr_limb_branch_dict = kwargs[&quot;function_kwargs&quot;][&quot;limb_branch_dict&quot;]</span>
    
    <span class="n">curr_limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict</span>
    
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="n">curr_axon_nodes</span> <span class="o">=</span> <span class="n">curr_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
    
<span class="c1">#     if print_flag:</span>
<span class="c1">#         print(f&quot;curr_axon_nodes = {curr_axon_nodes}&quot;)</span>
    
    <span class="n">curr_limb_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span> <span class="c1">#deepcopying so don&#39;t change anything</span>
    
    <span class="n">non_axon_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#1) Get all of the concept maps (by first getting all of the somas)</span>
    <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
    <span class="c1">#2) For each of the concept maps: </span>
    <span class="k">for</span> <span class="n">sm_start</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
        <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">sm_start</span><span class="p">)</span>
        <span class="n">curr_directional_network</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network_directional</span>
        
        <span class="c1">#- For each node: </span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">:</span>
            
            <span class="c1"># ----------- 1/28: Only want to go downstream for a certain extent, and only want to flip back to dendrite if small segments</span>
            <span class="k">if</span> <span class="n">curr_limb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="o">&gt;</span> <span class="n">max_skeletal_length_can_flip</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping a possible flip because the length is too long for threshold (</span><span class="si">{</span><span class="n">max_skeletal_length_can_flip</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1">#a. Get all of the downstream nodes</span>
            
            <span class="n">curr_downstream_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_within_skeletal_distance</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="p">,</span>
                            <span class="n">start_branch</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span>
                            <span class="n">max_distance_from_start</span> <span class="o">=</span> <span class="n">distance_for_downstream_check</span><span class="p">,</span>
                            <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">include_start_branch_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">include_node_branch_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">only_consider_downstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            
            <span class="c1">#curr_downstream_nodes = xu.downstream_edges(curr_directional_network,n)</span>
            
            <span class="c1"># if there are any downstream nodes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_downstream_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#curr_downstream_nodes = np.concatenate(curr_downstream_nodes)</span>
                <span class="c1">#b. Get the total number of faces for all upstream non-axon nodes</span>
                <span class="n">curr_non_axon_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_downstream_nodes</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">])</span>
                <span class="n">downstream_axon_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_downstream_nodes</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">])</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_non_axon_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
                    <span class="n">non_axon_face_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_non_axon_nodes</span><span class="p">])</span>
                    <span class="n">axon_face_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span>  <span class="ow">in</span> <span class="n">downstream_axon_nodes</span><span class="p">])</span>
                    <span class="n">perc_non_axon</span> <span class="o">=</span> <span class="n">non_axon_face_count</span> <span class="o">/</span> <span class="p">(</span><span class="n">non_axon_face_count</span> <span class="o">+</span> <span class="n">axon_face_count</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2">, limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">, node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="n">non_axon_face_count</span><span class="si">}</span><span class="s2"> non-axon downstream faces, </span><span class="si">{</span><span class="n">axon_face_count</span><span class="si">}</span><span class="s2"> axon downstream for a percentage of </span><span class="si">{</span><span class="n">perc_non_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  
                    <span class="c1">#if non_axon_face_count &gt; downstream_face_threshold:</span>
                    
                    <span class="c1"># ----------- 1/20 addition: That factors in percentages and not just raw face count ------- #</span>
                    <span class="k">if</span> <span class="n">downstream_non_axon_percentage_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_non_axon for limb_</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">_node_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">,  = </span><span class="si">{</span><span class="n">perc_non_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">reverse_label</span> <span class="o">=</span> <span class="n">perc_non_axon</span> <span class="o">&gt;</span> <span class="n">downstream_non_axon_percentage_threshold</span> <span class="ow">and</span> <span class="n">non_axon_face_count</span> <span class="o">&gt;</span> <span class="n">downstream_face_threshold</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reverse_label</span> <span class="o">=</span> <span class="n">non_axon_face_count</span> <span class="o">&gt;</span> <span class="n">downstream_face_threshold</span>
                    
                    <span class="k">if</span> <span class="n">reverse_label</span><span class="p">:</span>
                        <span class="n">non_axon_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     Added </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> to non-axon list&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2">, limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">, node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> did not hae any NON-AXON downstream targets&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2">, limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">, node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> did not hae any downstream targets&quot;</span><span class="p">)</span>
    
    <span class="c1">#compile all of the non-axon nodes</span>
    <span class="n">total_non_axon_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">non_axon_nodes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_non_axon_nodes = </span><span class="si">{</span><span class="n">total_non_axon_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#make a return dictionary that shows the filtered down axons</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">total_non_axon_nodes</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">return</span> <span class="n">return_dict</span></div>


<span class="c1"># ------- 2/3: Will help flip dendrites back to axons (to help with axon identification) --------------- #</span>

<div class="viewcode-block" id="flip_dendrite_to_axon"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.flip_dendrite_to_axon">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flip_dendrite_to_axon</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_branch_dict</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_skeletal_length_can_flip_dendrite</span> <span class="o">=</span> <span class="mi">70000</span><span class="p">,</span>
    <span class="n">downstream_axon_percentage_threshold</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span>
    <span class="n">distance_for_downstream_check_dendrite</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span>
    <span class="n">downstream_face_threshold_dendrite</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>

    <span class="n">axon_spine_density_max</span> <span class="o">=</span> <span class="mf">0.00015</span><span class="p">,</span>
    <span class="n">axon_width_max</span> <span class="o">=</span> <span class="mi">600</span><span class="p">,</span>

    <span class="n">significant_dendrite_downstream_density</span> <span class="o">=</span> <span class="mf">0.0002</span><span class="p">,</span>
    <span class="n">significant_dendrite_downstream_length</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>

    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudoode: </span>
<span class="sd">    1) Flip the axon banch list into a dendrite list</span>
<span class="sd">    2) Iterate through all the dendrite nodes: </span>

<span class="sd">    a. Run the following checks to exclude dendrite from being flipped:</span>
<span class="sd">    - max size</span>
<span class="sd">    - spine density</span>
<span class="sd">    - width</span>

<span class="sd">    b. Get all of the downstream nodes and if there are an downstream nodes:</span>
<span class="sd">        i) Get the # of axons and non axons downsream</span>
<span class="sd">        ii) If no axons then skip</span>
<span class="sd">        iii) Iterate through all the downstream nodes:</span>
<span class="sd">            Check for a significant spiny cell and if detect then skip</span>
<span class="sd">        iv) get the downstream axon percentage and total numbers</span>
<span class="sd">        v) if pass the percentage and total number threshold --&gt; add to the list</span>

<span class="sd">    3) Generate a new limb branch dict</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    from neurd import neuron_searching as ns  </span>
<span class="sd">    curr_limb_idx = 3</span>
<span class="sd">    curr_limb = test_neuron[curr_limb_idx]</span>
<span class="sd">    limb_name = f&quot;L{curr_limb_idx}&quot;</span>
<span class="sd">    try:</span>
<span class="sd">        limb_branch_dict = {limb_name:current_axon_limb_branch_dict[limb_name]}</span>
<span class="sd">    except:</span>
<span class="sd">        limb_branch_dict = {limb_name:[]}</span>

<span class="sd">    ns.flip_dendrite_to_axon(curr_limb,limb_branch_dict,limb_name)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_face_threshold_dendrite= </span><span class="si">{</span><span class="n">downstream_face_threshold_dendrite</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;downstream_axon_percentage_threshold = </span><span class="si">{</span><span class="n">downstream_axon_percentage_threshold</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max_skeletal_length_can_flip_dendrite = </span><span class="si">{</span><span class="n">max_skeletal_length_can_flip_dendrite</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;distance_for_downstream_check_dendrite = </span><span class="si">{</span><span class="n">distance_for_downstream_check_dendrite</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">curr_limb_branch_dict</span> <span class="o">=</span> <span class="n">limb_branch_dict</span>

    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">curr_limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">curr_axon_nodes</span> <span class="o">=</span> <span class="n">curr_limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
    <span class="n">curr_dendrite_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">(),</span><span class="n">curr_axon_nodes</span><span class="p">)</span>
    <span class="n">curr_dendrite_nodes</span>

    <span class="n">curr_limb_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span>
    <span class="n">non_dendrite_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#1) Get all of the concept maps (by first getting all of the somas)</span>
    <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
    <span class="c1">#2) For each of the concept maps: </span>
    <span class="k">for</span> <span class="n">sm_start</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
        <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">sm_start</span><span class="p">)</span>
        <span class="n">curr_directional_network</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network_directional</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_dendrite_nodes</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            a. Run the following checks to exclude dendrite from being flipped:</span>
<span class="sd">            - max size</span>
<span class="sd">            - spine density</span>
<span class="sd">            - width</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">branch_obj</span> <span class="o">=</span><span class="n">curr_limb_copy</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">curr_density</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">spine_density</span>
            <span class="n">curr_width</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="s2">&quot;median_mesh_center&quot;</span><span class="p">]</span>
            <span class="n">curr_length</span> <span class="o">=</span> <span class="n">branch_obj</span><span class="o">.</span><span class="n">skeletal_length</span>  

            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">curr_density</span><span class="o">&lt;</span><span class="n">axon_spine_density_max</span><span class="p">)</span> <span class="ow">and</span> 
                   <span class="p">(</span><span class="n">curr_length</span><span class="o">&lt;</span> <span class="n">max_skeletal_length_can_flip_dendrite</span><span class="p">)</span> <span class="ow">and</span>
                   <span class="p">(</span><span class="n">curr_width</span><span class="o">&lt;</span><span class="n">axon_width_max</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping dendrite candidate </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> because failed the attribute filter with: </span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;curr_density = </span><span class="si">{</span><span class="n">curr_density</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;curr_width = </span><span class="si">{</span><span class="n">curr_width</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;curr_length = </span><span class="si">{</span><span class="n">curr_length</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            b. Get all of the downstream nodes and if there are an downstream nodes:</span>
<span class="sd">            i) Get the # of axons and non axons downsream</span>
<span class="sd">            ii) If no axons then skip</span>
<span class="sd">            iii) Iterate through all the downstream nodes:</span>
<span class="sd">                Check for a significant spiny cell and if detect then skip</span>
<span class="sd">            iv) get the downstream axon percentage and total numbers</span>
<span class="sd">            v) if pass the percentage and total number threshold --&gt; add to the list</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1">#i) Get the # of axons and non axons downsream</span>
            <span class="n">curr_downstream_nodes</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">branches_within_skeletal_distance</span><span class="p">(</span><span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="p">,</span>
                                    <span class="n">start_branch</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span>
                                    <span class="n">max_distance_from_start</span> <span class="o">=</span> <span class="n">distance_for_downstream_check_dendrite</span><span class="p">,</span>
                                    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">include_start_branch_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">include_node_branch_length</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                    <span class="n">only_consider_downstream</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;curr_downstream_nodes = </span><span class="si">{</span><span class="n">curr_downstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_downstream_nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1">#i) Get the # of axons and non axons downsream</span>
                <span class="n">curr_non_axon_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_downstream_nodes</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">])</span>
                <span class="n">downstream_axon_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_downstream_nodes</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">])</span>

                <span class="c1">#ii) If no axons then skip</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">downstream_axon_nodes</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping dendrite candidate </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> because no downstream axons&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="n">continue_from_donwstream_dendrite_flag</span> <span class="o">=</span> <span class="kc">False</span>


                <span class="c1">#iii) Iterate through all the downstream nodes:</span>
                <span class="c1">#Check for a significant spiny cell and if detect then skip</span>

                <span class="k">for</span> <span class="n">dn</span> <span class="ow">in</span> <span class="n">curr_non_axon_nodes</span><span class="p">:</span>
                    <span class="n">branch_d</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="p">[</span><span class="n">dn</span><span class="p">]</span>

                    <span class="n">curr_density</span> <span class="o">=</span> <span class="n">branch_d</span><span class="o">.</span><span class="n">spine_density</span>
                    <span class="n">curr_length</span> <span class="o">=</span> <span class="n">branch_d</span><span class="o">.</span><span class="n">skeletal_length</span>

                    <span class="k">if</span> <span class="p">((</span><span class="n">curr_density</span> <span class="o">&gt;</span> <span class="n">significant_dendrite_downstream_density</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">curr_length</span> <span class="o">&gt;</span> <span class="n">significant_dendrite_downstream_length</span><span class="p">)):</span>

                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping dendrite candidate </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> because found downstream dendrite with </span><span class="se">\n</span><span class="s2">&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;curr_density = </span><span class="si">{</span><span class="n">curr_density</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;curr_length = </span><span class="si">{</span><span class="n">curr_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                        <span class="n">continue_from_donwstream_dendrite_flag</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">continue_from_donwstream_dendrite_flag</span><span class="p">:</span>
                    <span class="k">continue</span>


                <span class="c1">#iv) get the downstream axon percentage and total numbers</span>
                <span class="n">non_axon_face_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_non_axon_nodes</span><span class="p">])</span>
                <span class="n">axon_face_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span>  <span class="ow">in</span> <span class="n">downstream_axon_nodes</span><span class="p">])</span>
                <span class="n">perc_axon</span> <span class="o">=</span> <span class="n">axon_face_count</span> <span class="o">/</span> <span class="p">(</span><span class="n">non_axon_face_count</span> <span class="o">+</span> <span class="n">axon_face_count</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Soma </span><span class="si">{</span><span class="n">sm_start</span><span class="si">}</span><span class="s2">, limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">, node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> had </span><span class="si">{</span><span class="n">non_axon_face_count</span><span class="si">}</span><span class="s2"> non-axon downstream faces, </span><span class="si">{</span><span class="n">axon_face_count</span><span class="si">}</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot; axon downstream for a percentage of </span><span class="si">{</span><span class="n">perc_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  


                <span class="c1"># ----------- 1/20 addition: That factors in percentages and not just raw face count ------- #</span>
                <span class="k">if</span> <span class="n">downstream_axon_percentage_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;perc_axon for limb_</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2">_node_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">,  = </span><span class="si">{</span><span class="n">perc_axon</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">reverse_label</span> <span class="o">=</span> <span class="n">perc_axon</span> <span class="o">&gt;</span> <span class="n">downstream_axon_percentage_threshold</span> <span class="ow">and</span> <span class="n">axon_face_count</span> <span class="o">&gt;</span> <span class="n">downstream_face_threshold_dendrite</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reverse_label</span> <span class="o">=</span> <span class="n">axon_face_count</span> <span class="o">&gt;</span> <span class="n">downstream_face_threshold_dendrite</span>

                <span class="k">if</span> <span class="n">reverse_label</span><span class="p">:</span>
                    <span class="n">non_dendrite_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     Added </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> to non-dendrite list&quot;</span><span class="p">)</span>


    <span class="c1">#compile all of the non-axon nodes</span>
    <span class="n">total_non_dendrite_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">non_dendrite_nodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_non_dendrite_nodes = </span><span class="si">{</span><span class="n">total_non_dendrite_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#make a return dictionary that shows the filtered down axons</span>

    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span> <span class="ow">or</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">total_non_dendrite_nodes</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">return_dict</span></div>
    

<div class="viewcode-block" id="axon_segment_clean_false_positives"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.axon_segment_clean_false_positives">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">axon_segment_clean_false_positives</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                       <span class="n">limb_branch_dict</span><span class="p">,</span>
                                       <span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">width_match_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                                   <span class="n">width_type</span> <span class="o">=</span> <span class="s2">&quot;no_spine_average_mesh_center&quot;</span><span class="p">,</span>
                                   <span class="n">must_have_spine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">interest_nodes</span><span class="o">=</span><span class="p">[],</span>
                                    <span class="c1">#return_limb_branch_dict=False,</span>
                                       <span class="n">false_positive_max_skeletal_length</span> <span class="o">=</span> <span class="mi">35000</span><span class="p">,</span>
                                 <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To help prevent the false positives</span>
<span class="sd">    where small end dendritic segments are mistaken for axon pieces</span>
<span class="sd">    by checking if the mesh transition in width is very constant between an upstream </span>
<span class="sd">    node (that is a non-axonal piece) and the downstream node that is an axonal piece</span>
<span class="sd">    then this will change the axonal piece to a non-axonal piece label: </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Idea: Can look for where width transitions are pretty constant with preceeding dendrite and axon</span>
<span class="sd">    and if very similar then keep as non-dendrite</span>

<span class="sd">    *** only apply to those with 1 or more spines</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) given all of the axons</span>

<span class="sd">    For each axon node:</span>
<span class="sd">    For each of the directional concept networks</span>
<span class="sd">    1) If has an upstream node that is not an axon --&gt; if not then continue</span>
<span class="sd">    1b) (optional) Has to have at least one spine or continues</span>
<span class="sd">    2) get the upstream nodes no_spine_average_mesh_center width array</span>
<span class="sd">    2b) find the endpoints of the current node</span>
<span class="sd">    3) Find which endpoints match from the node and the upstream node</span>
<span class="sd">    4) get the tangent part of the no_spine_average_mesh_center width array from the endpoints matching</span>
<span class="sd">    (this is either the 2nd and 3rd from front or last depending on touching AND that it is long enough)</span>

<span class="sd">    5) get the tangent part of the node based on touching</span>

<span class="sd">    6) if the average of these is greater than upstream - 50</span>

<span class="sd">    return an updated dictionary</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_branch_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> not in curr_limb_branch_dict.keys so returning False&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="n">curr_axon_nodes</span> <span class="o">=</span> <span class="n">limb_branch_dict</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span>
    
    <span class="n">curr_limb_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">)</span>
    
    <span class="n">non_axon_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#a) Get all of the concept maps (by first getting all of the somas)</span>
    <span class="n">touching_somas</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="s2">&quot;starting_soma&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">all_concept_network_data</span><span class="p">]</span>
    
    <span class="c1">#b) For each of the concept maps: </span>
    <span class="k">for</span> <span class="n">sm_start</span> <span class="ow">in</span> <span class="n">touching_somas</span><span class="p">:</span>
        <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">set_concept_network_directional</span><span class="p">(</span><span class="n">sm_start</span><span class="p">)</span>
        <span class="n">curr_directional_network</span> <span class="o">=</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network_directional</span>
        
        <span class="c1">#- For each node: </span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">:</span>
            
            <span class="c1">#if already added to the non-axons nodes then don&#39;t need to check anymore</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">non_axon_nodes</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1">#1) If has an upstream node that is not an axon --&gt; if not then continue</span>
            <span class="n">curr_upstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_edges_neighbors</span><span class="p">(</span><span class="n">curr_directional_network</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_upstream_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_upstream_nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one upstream node for node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">curr_upstream_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">curr_upstream_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">, upstream_node= </span><span class="si">{</span><span class="n">upstream_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Skipping because the upstream node is not a non-axon piece&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
                
            <span class="k">if</span> <span class="p">(</span><span class="n">false_positive_max_skeletal_length</span> <span class="o">&lt;</span> 
                <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">skeletal_length</span> <span class="o">&gt;</span> 
                        <span class="n">false_positive_max_skeletal_length</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping because the pice was larger than false_positive_max_skeletal_length = </span><span class="si">{</span><span class="n">false_positive_max_skeletal_length</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
                <span class="k">continue</span>
                    
        
            <span class="c1">#1b) (optional) Has to have at least one spine or continues</span>
            <span class="k">if</span> <span class="n">must_have_spine</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">n_spines</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not processing node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> because there were no spines and  must_have_spine set to </span><span class="si">{</span><span class="n">must_have_spine</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not processing node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> because spines were NONE and must_have_spine set to </span><span class="si">{</span><span class="n">must_have_spine</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span> <span class="c1">#if spines were None</span>
                    
            
            <span class="c1">#2- 5) get the tangent touching parts of the mesh</span>
            <span class="n">width_array_1</span><span class="p">,</span><span class="n">width_array_2</span> <span class="o">=</span> <span class="n">wu</span><span class="o">.</span><span class="n">find_mesh_width_array_border</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb_copy</span><span class="p">,</span>
                                 <span class="n">node_1</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span>
                                 <span class="n">node_2</span> <span class="o">=</span> <span class="n">upstream_node</span><span class="p">,</span>
                                <span class="n">width_name</span><span class="o">=</span><span class="n">width_type</span><span class="p">,</span>
                                <span class="n">segment_start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="n">segment_end</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
                                <span class="n">skeleton_segment_size</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
                                <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span>
                                <span class="p">)</span>
            
            <span class="c1">#6) if the average of these is greater than upstream - 50 then add to the list of non axons</span>
            <span class="c1">#interest_nodes = [56,71]`x</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">interest_nodes</span> <span class="ow">or</span> <span class="n">upstream_node</span> <span class="ow">in</span> <span class="n">interest_nodes</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_array_1 = </span><span class="si">{</span><span class="n">width_array_1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;width_array_2 = </span><span class="si">{</span><span class="n">width_array_2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.mean(width_array_1) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">width_array_1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.mean(width_array_2) = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">width_array_2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">width_array_1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">width_array_2</span><span class="p">)</span><span class="o">-</span><span class="n">width_match_threshold</span><span class="p">):</span>
                
                <span class="n">non_axon_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding node </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> to non_axon list with threshold </span><span class="si">{</span><span class="n">width_match_threshold</span><span class="si">}</span><span class="s2"> because </span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;   np.mean(width_array_1)  = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">width_array_1</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;   np.mean(width_array_2)  = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">width_array_2</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                 
    <span class="c1">#after checking all nodes and concept networks</span>
    <span class="c1">#compile all of the non-axon nodes</span>
    <span class="n">total_non_axon_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">non_axon_nodes</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total_non_axon_nodes = </span><span class="si">{</span><span class="n">total_non_axon_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1">#make a return dictionary that shows the filtered down axons</span>
    <span class="n">return_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_limb_copy</span><span class="o">.</span><span class="n">concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">curr_axon_nodes</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">total_non_axon_nodes</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">return</span> <span class="n">return_dict</span></div>
            
    
<span class="c1"># --------- 1/15: Additions to help find axon -----------------#</span>

<div class="viewcode-block" id="soma_starting_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.soma_starting_angle">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">soma_starting_angle</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    will compute the angle in degrees from the vector pointing</span>
<span class="sd">    straight to the volume and the vector pointing from </span>
<span class="sd">    the middle of the soma to the starting coordinate of the limb</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">print_flag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">curr_soma_angle</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">soma_starting_angle</span><span class="p">(</span><span class="n">limb_obj</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                        <span class="n">soma_center</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;soma_center&quot;</span><span class="p">],</span>
                        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Limb </span><span class="si">{</span><span class="n">limb_name</span><span class="si">}</span><span class="s2"> soma angle: </span><span class="si">{</span><span class="n">curr_soma_angle</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">curr_soma_angle</span></div>
    


<span class="c1">#------------------------------- Creating the Data tables from the neuron and functions------------------------------</span>
<div class="viewcode-block" id="get_run_type"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.get_run_type">[docs]</a><span class="k">def</span> <span class="nf">get_run_type</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To decide whether a function is a limb or branch</span>
<span class="sd">    function</span>

<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Try and get the runtype</span>
<span class="sd">    2) Extract the name of the first parameter of the function</span>
<span class="sd">    3a) if &quot;branch&quot; in then branch, elif &quot;limb&quot; in then limb</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">curr_run_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s2">&quot;run_type&quot;</span><span class="p">,)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">first_arg_name</span> <span class="o">=</span> <span class="n">fcu</span><span class="o">.</span><span class="n">arg_names</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="s2">&quot;branch&quot;</span> <span class="ow">in</span> <span class="n">first_arg_name</span><span class="p">:</span>
                <span class="n">curr_run_type</span> <span class="o">=</span> <span class="s2">&quot;Branch&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;limb&quot;</span> <span class="ow">in</span> <span class="n">first_arg_name</span><span class="p">:</span>
                <span class="n">curr_run_type</span> <span class="o">=</span> <span class="s2">&quot;Limb&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No branch argument&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">curr_run_type</span> <span class="o">=</span> <span class="s2">&quot;Branch&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="k">return</span> <span class="n">curr_run_type</span></div>
    
    
<div class="viewcode-block" id="apply_function_to_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.apply_function_to_neuron">[docs]</a><span class="k">def</span> <span class="nf">apply_function_to_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">current_function</span><span class="p">,</span><span class="n">function_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To retrieve a dictionary mapping every branch on every node</span>
<span class="sd">    to a certain value as defined by the function passed</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    curr_function = ns.width</span>
<span class="sd">    curr_function_mapping = ns.apply_function_to_neuron(recovered_neuron,curr_function)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">function_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">function_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    
    <span class="n">curr_neuron_concept_network</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">return_concept_network</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="s2">&quot;limbs_to_process&quot;</span> <span class="ow">in</span> <span class="n">function_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">curr_limb_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">function_kwargs</span><span class="p">[</span><span class="s2">&quot;limbs_to_process&quot;</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_limb_names</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">get_limb_names_from_concept_network</span><span class="p">(</span><span class="n">curr_neuron_concept_network</span><span class="p">)</span>
        
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span>  <span class="n">function_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict_restriction&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">neuron_limb_branch_dict</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using the limb_branch_dict_restriction = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    
    
    <span class="n">function_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">limb_name</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span> <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">curr_limb_names</span> <span class="k">if</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">limb_branch_dict_restriction</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="c1">#curr_run_type = getattr(current_function,&quot;run_type&quot;,&quot;Branch&quot;)</span>
    <span class="n">curr_run_type</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get_run_type</span><span class="p">(</span><span class="n">current_function</span><span class="p">)</span>
    <span class="c1">#if it was a branch function that was passed</span>
    <span class="k">if</span> <span class="n">curr_run_type</span><span class="o">==</span><span class="s2">&quot;Branch&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">function_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">curr_neuron_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span>
            <span class="k">for</span> <span class="n">branch_idx</span> <span class="ow">in</span> <span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                
                <span class="c1"># -- 1/29 Addition: Will only look at nodes in the limb branch dict restriction -- #</span>
                <span class="k">if</span> <span class="n">branch_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict_restriction</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]:</span>
                    <span class="k">continue</span>
                    
<span class="c1">#                 if limb_name == &quot;L0&quot; and branch_idx == 73:</span>
<span class="c1">#                     print(f&quot;Computing {current_function} for !!!!!&quot;)</span>
                    
                <span class="k">if</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">current_function</span><span class="p">)):</span>
                    <span class="n">function_mapping</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">],</span>
                                                                     <span class="n">current_function</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">function_mapping</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="n">branch_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_function</span><span class="p">(</span><span class="n">curr_limb_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">branch_idx</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">],</span><span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="n">branch_idx</span><span class="p">,</span><span class="o">**</span><span class="n">function_kwargs</span><span class="p">)</span>
                
    <span class="k">elif</span> <span class="n">curr_run_type</span><span class="o">==</span><span class="s2">&quot;Limb&quot;</span><span class="p">:</span>
        <span class="c1">#if it was a limb function that was passed</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        - for each limb:</span>
<span class="sd">          i) run the function and recieve the returned result</span>
<span class="sd">          2) If only a single value is returned --&gt; make dict[limb_idx][node_idx] = value all with the same value</span>
<span class="sd">          3) if dictionary of values: </span>
<span class="sd">             a. check that keys match the node_names</span>
<span class="sd">             b. make dict[limb_idx][node_idx] = value for all nodes using the dictionary</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">limb_name</span> <span class="ow">in</span> <span class="n">function_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">function_return</span> <span class="o">=</span> <span class="n">current_function</span><span class="p">(</span><span class="n">curr_neuron_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">],</span><span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                                               <span class="o">**</span><span class="n">function_kwargs</span><span class="p">)</span>
            <span class="n">curr_limb_concept_network</span> <span class="o">=</span> <span class="n">curr_neuron_concept_network</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">limb_name</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">concept_network</span>
            
            <span class="n">function_mapping</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]</span> <span class="o">=</span>  <span class="n">convert_limb_function_return_to_dict</span><span class="p">(</span><span class="n">function_return</span><span class="p">,</span>
                                                        <span class="n">curr_limb_concept_network</span><span class="p">)</span>
<span class="w">            </span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Older way of doing this before functionality was moved out to function</span>
<span class="sd">            if np.isscalar(function_return):</span>
<span class="sd">                for branch_idx in curr_limb_concept_network.nodes():</span>
<span class="sd">                    function_mapping[limb_name][branch_idx] = function_return</span>
<span class="sd">            elif set(list(function_return.keys())) == set(list(curr_limb_concept_network.nodes())):</span>
<span class="sd">                function_mapping[limb_name] = function_return</span>
<span class="sd">            else:</span>
<span class="sd">                raise Exception(&quot;The value returned from limb function was not a scalar nor did it match the keys of the limb branches&quot;)</span>
<span class="sd">            &quot;&quot;&quot;</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Function recieved was neither a Branch nor a Limb&quot;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">function_mapping</span></div>


<div class="viewcode-block" id="map_new_limb_node_value"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.map_new_limb_node_value">[docs]</a><span class="k">def</span> <span class="nf">map_new_limb_node_value</span><span class="p">(</span><span class="n">current_df</span><span class="p">,</span><span class="n">mapping_dict</span><span class="p">,</span><span class="n">value_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To apply a dictionary to a neuron dataframe table</span>
<span class="sd">    </span>
<span class="sd">    mapping_dict = dict()</span>
<span class="sd">    for x,y in zip(neuron_df[&quot;limb&quot;].to_numpy(),neuron_df[&quot;node&quot;].to_numpy()):</span>
<span class="sd">        if x not in mapping_dict.keys():</span>
<span class="sd">            mapping_dict[x]=dict()</span>
<span class="sd">        mapping_dict[x][y] = np.random.randint(10)</span>
<span class="sd">        </span>
<span class="sd">    map_new_limb_node_value(neuron_df,mapping_dict,value_name=&quot;random_number&quot;)</span>
<span class="sd">    neuron_df</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current_df</span><span class="p">[</span><span class="n">value_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mapping_dict</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;limb&quot;</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;node&quot;</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">current_df</span></div>

<div class="viewcode-block" id="generate_neuron_dataframe"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.generate_neuron_dataframe">[docs]</a><span class="k">def</span> <span class="nf">generate_neuron_dataframe</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                              <span class="n">functions_list</span><span class="p">,</span>
                              <span class="n">check_nans</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: With a neuron and a specified set of functions generate a dataframe</span>
<span class="sd">    with the values computed</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">    current_neuron: Either a neuron object or the concept network of a neuron</span>
<span class="sd">    functions_list: List of functions to process the limbs and branches of the concept network</span>
<span class="sd">    check_nans : whether to check and raise an Exception if any nans in run</span>
<span class="sd">    </span>
<span class="sd">    Application: We will then later restrict using df.eval()</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) convert the functions_list to a list</span>
<span class="sd">    2) Create a dataframe for the neuron</span>
<span class="sd">    3) For each function:</span>
<span class="sd">    a. get the dictionary mapping of limbs/branches to values</span>
<span class="sd">    b. apply the values to the dataframe</span>
<span class="sd">    4) return the dataframe</span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    returned_df = ns.generate_neuron_dataframe(recovered_neuron,functions_list=[</span>
<span class="sd">    ns.n_faces_branch,</span>
<span class="sd">    ns.width,</span>
<span class="sd">    ns.skeleton_distance_branch,</span>
<span class="sd">    ns.skeleton_distance_limb,</span>
<span class="sd">    ns.n_faces_limb,</span>
<span class="sd">    ns.merge_limbs,</span>
<span class="sd">    ns.limb_error_branches</span>
<span class="sd">    ])</span>

<span class="sd">    returned_df[returned_df[&quot;merge_limbs&quot;] == True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">functions_list</span><span class="p">):</span>
        <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions_list</span><span class="p">]</span>
        
    <span class="c1">#print(f&quot;functions_list = {functions_list}&quot;)</span>
    
    
    <span class="n">limbs_to_process</span> <span class="o">=</span> <span class="n">function_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;limbs_to_process&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">function_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;limb_branch_dict_restriction&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    
    <span class="c1">#2) Create a dataframe for the neuron</span>
    <span class="n">curr_df</span> <span class="o">=</span> <span class="n">convert_neuron_to_branches_dataframe</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span>
                                                  <span class="n">limbs_to_process</span><span class="o">=</span><span class="n">limbs_to_process</span><span class="p">,</span>
                                                  <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3) For each function:</span>
<span class="sd">    a. get the dictionary mapping of limbs/branches to values</span>
<span class="sd">    b. apply the values to the dataframe</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">curr_function</span> <span class="ow">in</span> <span class="n">functions_list</span><span class="p">:</span>
        <span class="n">curr_function_mapping</span> <span class="o">=</span> <span class="n">apply_function_to_neuron</span><span class="p">(</span><span class="n">current_neuron</span><span class="p">,</span><span class="n">curr_function</span><span class="p">,</span><span class="n">function_kwargs</span><span class="p">)</span>
        <span class="n">curr_function_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">curr_function</span><span class="p">,</span><span class="s2">&quot;__name__&quot;</span><span class="p">,</span><span class="n">curr_function</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_function_name</span><span class="p">[</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_function_append_name</span><span class="p">):]</span> <span class="o">==</span> <span class="n">limb_function_append_name</span><span class="p">:</span>
            <span class="n">curr_function_name</span> <span class="o">=</span> <span class="n">curr_function_name</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">limb_function_append_name</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">map_new_limb_node_value</span><span class="p">(</span><span class="n">curr_df</span><span class="p">,</span><span class="n">curr_function_mapping</span><span class="p">,</span><span class="n">value_name</span><span class="o">=</span><span class="n">curr_function_name</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">check_nans</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pu</span><span class="o">.</span><span class="n">n_nans_total</span><span class="p">(</span><span class="n">curr_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of nans = </span><span class="si">{</span><span class="n">pu</span><span class="o">.</span><span class="n">n_nans_per_column</span><span class="p">(</span><span class="n">curr_df</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">su</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">curr_df</span><span class="p">,</span><span class="s2">&quot;curr_df&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Some fo the data in the dataframe were incomplete&quot;</span><span class="p">)</span>
            
    
    <span class="c1">#4) return the dataframe</span>
    <span class="k">return</span> <span class="n">curr_df</span></div>



<span class="c1"># -------------------- Function that does full querying of neuron -------------------------- #</span>


<span class="n">current_module</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>


<div class="viewcode-block" id="functions_list_from_query"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.functions_list_from_query">[docs]</a><span class="k">def</span> <span class="nf">functions_list_from_query</span><span class="p">(</span>
    <span class="n">query</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To turn a query into a list of functions</span>
<span class="sd">    </span>
<span class="sd">    Ex: </span>
<span class="sd">    ns.functions_list_from_query(query = </span>
<span class="sd">    &quot;(n_synapses_pre &gt;= 1) and (synapse_pre_perc &gt;= 0.6) and (axon_width &lt;= 270) and (n_spines &lt;= 10) and (n_synapses_post_spine &lt;= 3) and (skeletal_length &gt; 2500) and (area &gt; 1) and (closest_mesh_skeleton_dist &lt; 500)&quot;,</span>
<span class="sd">      verbose = True                  )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\((.*?)[ =&lt;&gt; ]+(.*?)\)&#39;</span><span class="p">)</span>
    <span class="n">curr_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">r_obj</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">query</span><span class="p">))</span>
    <span class="n">found_functions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">curr_list</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;# of found functions = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">found_functions</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">found_functions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">found_functions</span></div>


<div class="viewcode-block" id="query_neuron"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.query_neuron">[docs]</a><span class="k">def</span> <span class="nf">query_neuron</span><span class="p">(</span>
    <span class="n">concept_network</span><span class="p">,</span>           
    <span class="n">query</span><span class="p">,</span>
    <span class="n">functions_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">function_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">query_variables_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">return_dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_dataframe_before_filtering</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_limbs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_limb_grouped_branches</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">print_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">limbs_to_process</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">plot_limb_branch_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">check_nans</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *** to specify &quot;limbs_to_process&quot; to process just put in the function kwargs</span>
<span class="sd">    </span>
<span class="sd">    Purpose: Recieve a neuron object or concept map </span>
<span class="sd">    representing a neuron and apply the query</span>
<span class="sd">    to find the releveant limbs, branches</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Possible Ouptuts: </span>
<span class="sd">    1) filtered dataframe</span>
<span class="sd">    2) A list of the [(limb_idx,branches)] ** default</span>
<span class="sd">    3) A dictionary that makes limb_idx to the branches that apply (so just grouping them)</span>
<span class="sd">    4) Just a list of the limbs</span>
<span class="sd">    </span>
<span class="sd">    Arguments</span>
<span class="sd">    concept_network,</span>
<span class="sd">    feature_functios, #the list of str/functions that specify what metrics want computed (so can use in query)</span>
<span class="sd">    query, #df.query string that specifies how to filter for the desired branches/limbs</span>
<span class="sd">    local_dict=dict(), #if any variables in the query string whose values can be loaded into query (variables need to start with @)</span>
<span class="sd">    return_dataframe=False, #if just want the filtered dataframe</span>
<span class="sd">    return_limbs=False, #just want limbs in query returned</span>
<span class="sd">    return_limb_grouped_branches=True, #if want dictionary with keys as limbs and values as list of branches in the query</span>
<span class="sd">    print_flag=True,</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example: </span>
<span class="sd">    from os import sys</span>
<span class="sd">    sys.path.append(&quot;../../neurd_packages/meshAfterParty/meshAfterParty/&quot;)</span>
<span class="sd">    from importlib import reload</span>
<span class="sd">    </span>
<span class="sd">    from datasci_tools import pandas_utils as pu</span>
<span class="sd">    import pandas as pd</span>
<span class="sd">    from pathlib import Path</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    compressed_neuron_path = Path(&quot;../test_neurons/test_objects/12345_2_soma_practice_decompress&quot;)</span>

<span class="sd">    from neurd import neuron_utils as nru</span>
<span class="sd">    nru = reload(nru)</span>
<span class="sd">    from neurd import neuron</span>
<span class="sd">    neuron=reload(neuron)</span>

<span class="sd">    from datasci_tools import system_utils as su</span>

<span class="sd">    with su.suppress_stdout_stderr():</span>
<span class="sd">        recovered_neuron = nru.decompress_neuron(filepath=compressed_neuron_path,</span>
<span class="sd">                          original_mesh=compressed_neuron_path)</span>

<span class="sd">    recovered_neuron</span>
<span class="sd">    </span>
<span class="sd">    ns = reload(ns)</span>
<span class="sd">    nru = reload(nru)</span>

<span class="sd">    list_of_faces = [1038,5763,7063,11405]</span>
<span class="sd">    branch_threshold = 31000</span>
<span class="sd">    current_query = &quot;n_faces_branch in @list_of_faces or skeleton_distance_branch &gt; @branch_threshold&quot;</span>
<span class="sd">    local_dict=dict(list_of_faces=list_of_faces,branch_threshold=branch_threshold)</span>


<span class="sd">    functions_list=[</span>
<span class="sd">    ns.n_faces_branch,</span>
<span class="sd">    &quot;width&quot;,</span>
<span class="sd">    ns.skeleton_distance_branch,</span>
<span class="sd">    ns.skeleton_distance_limb,</span>
<span class="sd">    &quot;n_faces_limb&quot;,</span>
<span class="sd">    ns.merge_limbs,</span>
<span class="sd">    ns.limb_error_branches</span>
<span class="sd">    ]</span>

<span class="sd">    returned_output = ns.query_neuron(recovered_neuron,</span>
<span class="sd">                             functions_list,</span>
<span class="sd">                              current_query,</span>
<span class="sd">                              local_dict=local_dict,</span>
<span class="sd">                              return_dataframe=False,</span>
<span class="sd">                              return_limbs=False,</span>
<span class="sd">                              return_limb_grouped_branches=True,</span>
<span class="sd">                             print_flag=False)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Example 2:  How to use the local dictionary with a list</span>
<span class="sd">    </span>
<span class="sd">    ns = reload(ns)</span>

<span class="sd">    current_functions_list = [</span>
<span class="sd">        &quot;skeletal_distance_from_soma&quot;,</span>
<span class="sd">        &quot;no_spine_average_mesh_center&quot;,</span>
<span class="sd">        &quot;n_spines&quot;,</span>
<span class="sd">        &quot;n_faces_branch&quot;,</span>

<span class="sd">    ]</span>

<span class="sd">    function_kwargs=dict(somas=[0],print_flag=False)</span>
<span class="sd">    query=&quot;skeletal_distance_from_soma &gt; -1 and (limb in @limb_list)&quot;</span>
<span class="sd">    query_variables_dict = dict(limb_list=[&#39;L1&#39;,&#39;L2&#39;,&quot;L3&quot;])</span>

<span class="sd">    limb_branch_dict_df = ns.query_neuron(uncompressed_neuron,</span>
<span class="sd">                                       query=query,</span>
<span class="sd">                                          function_kwargs=function_kwargs,</span>
<span class="sd">                                          query_variables_dict=query_variables_dict,</span>
<span class="sd">                   functions_list=current_functions_list,</span>
<span class="sd">                                      return_dataframe=True)</span>

<span class="sd">    limb_branch_dict = ns.query_neuron(uncompressed_neuron,</span>
<span class="sd">                                       query=query,</span>
<span class="sd">                   functions_list=current_functions_list,</span>
<span class="sd">                                       query_variables_dict=query_variables_dict,</span>
<span class="sd">                                       function_kwargs=function_kwargs,</span>
<span class="sd">                                      return_dataframe=False)</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">functions_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">functions_list</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">functions_list_from_query</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">function_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">function_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">query_variables_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">query_variables_dict</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">limbs_to_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limbs_to_process</span> <span class="o">=</span> <span class="p">[</span><span class="n">nru</span><span class="o">.</span><span class="n">get_limb_string_name</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">limbs_to_process</span><span class="p">]</span>
        <span class="n">function_kwargs</span><span class="p">[</span><span class="s2">&quot;limbs_to_process&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limbs_to_process</span>
    
    <span class="n">local_dict</span> <span class="o">=</span> <span class="n">query_variables_dict</span>
    <span class="n">concept_network_old</span> <span class="o">=</span> <span class="n">concept_network</span>
    <span class="c1">#any preprocessing work</span>
    <span class="k">if</span> <span class="n">concept_network</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Neuron&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extracting concept network from neuron object&quot;</span><span class="p">)</span>
        <span class="n">concept_network</span> <span class="o">=</span> <span class="n">concept_network</span><span class="o">.</span><span class="n">concept_network</span>
        
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;functions_list = </span><span class="si">{</span><span class="n">functions_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="n">final_feature_functions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;str&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">curr_feature</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">current_module</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
                <span class="c1">#curr_feature = 0</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The funciton </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> specified by string was not a pre-made funciton in neuron_searching module&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">curr_feature</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function item </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2"> was not a string or callable function&quot;</span><span class="p">)</span>
        
        <span class="n">final_feature_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_feature</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">print_flag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;final_feature_functions = </span><span class="si">{</span><span class="n">final_feature_functions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        
    
    <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">function_kwargs</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict_restriction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limb_branch_dict_restriction</span>
        
    <span class="c1">#0) Generate a pandas table that originally has the limb index and node index</span>
    <span class="n">returned_df</span> <span class="o">=</span> <span class="n">generate_neuron_dataframe</span><span class="p">(</span><span class="n">concept_network</span><span class="p">,</span><span class="n">functions_list</span><span class="o">=</span><span class="n">final_feature_functions</span><span class="p">,</span>
                                           <span class="n">function_kwargs</span><span class="o">=</span><span class="n">function_kwargs</span><span class="p">,</span>
                                           <span class="n">check_nans</span><span class="o">=</span><span class="n">check_nans</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_dataframe_before_filtering</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">returned_df</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">returned_df</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">filtered_returned_df</span> <span class="o">=</span> <span class="n">returned_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="p">,</span>
                      <span class="n">local_dict</span><span class="o">=</span><span class="n">local_dict</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filtered_returned_df</span> <span class="o">=</span> <span class="n">returned_df</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preparing output for returning</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">return_dataframe</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filtered_returned_df</span>
    
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_returned_df</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; -- old method --</span>
<span class="sd">        limb_branch_pairings = filtered_returned_df[[&quot;limb&quot;,&quot;node&quot;]].to_numpy()</span>

<span class="sd">        #gets a dictionary where key is the limb and value is a list of all the branches that were in the filtered dataframe</span>
<span class="sd">        limb_to_branch = dict([(k,np.sort(limb_branch_pairings[:,1][np.where(limb_branch_pairings[:,0]==k)[0]]).astype(&quot;int&quot;)) </span>
<span class="sd">                               for k in np.unique(limb_branch_pairings[:,0])])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">limb_to_branch</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">limb_branch_from_stats_df</span><span class="p">(</span><span class="n">filtered_returned_df</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plot_limb_branch_dict</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plotting limb_to_branch = </span><span class="si">{</span><span class="n">limb_to_branch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">concept_network_old</span><span class="p">,</span><span class="n">limb_to_branch</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limb_to_branch</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">limb_branch_intersection</span><span class="p">([</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span><span class="n">limb_to_branch</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">return_limbs</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">limb_to_branch</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">return_limb_grouped_branches</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">limb_to_branch</span>

        <span class="k">return</span> <span class="n">limb_branch_pairings</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">plot_limb_branch_dict</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No limb branch to plot&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_limbs</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">return_limb_grouped_branches</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">return_limb_grouped_branches</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span></div>
        
        

<div class="viewcode-block" id="n_downstream_nodes"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_downstream_nodes">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_downstream_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">curr_downstream_nodes</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">downstream_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodes_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_downstream_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">curr_downstream_nodes</span><span class="p">,</span><span class="n">nodes_to_exclude</span><span class="p">)</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_downstream_nodes</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="n_downstream_nodes_with_skip"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_downstream_nodes_with_skip">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_downstream_nodes_with_skip</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">curr_downstream_nodes</span> <span class="o">=</span> <span class="n">cnu</span><span class="o">.</span><span class="n">endnode_branches_of_branches_within_distance_downtream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                                                           <span class="n">b</span><span class="p">,</span>
                                                                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curr_downstream_nodes</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>





<span class="c1"># ----- 4/19 ---------------</span>


    

<div class="viewcode-block" id="width_jump"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.width_jump">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">width_jump</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">width_name</span><span class="o">=</span><span class="s2">&quot;no_bouton_median&quot;</span><span class="p">,</span>
               <span class="n">width_name_backup</span><span class="o">=</span><span class="s2">&quot;no_spine_median_mesh_center&quot;</span><span class="p">,</span>
               <span class="n">width_name_backup_2</span> <span class="o">=</span> <span class="s2">&quot;median_mesh_center&quot;</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To measure the width jump from the upstream node</span>
<span class="sd">    to the current node</span>
<span class="sd">    </span>
<span class="sd">    Effect: For axon, just seemed to pick up on the short segments and ones that had boutons</span>
<span class="sd">    that were missed</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        
        <span class="n">upstream_node</span> <span class="o">=</span> <span class="n">xu</span><span class="o">.</span><span class="n">upstream_node</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">upstream_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">width_jump</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">width_jump</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name_backup</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name_backup</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">width_jump</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr_limb</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name_backup_2</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">curr_limb</span><span class="p">[</span><span class="n">upstream_node</span><span class="p">]</span><span class="o">.</span><span class="n">width_new</span><span class="p">[</span><span class="n">width_name_backup_2</span><span class="p">])</span>
            <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">width_jump</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>




<span class="c1">#raise Exception(&quot;Need to fix all of the relational skeletal angles&quot;)</span>

<div class="viewcode-block" id="parent_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.parent_angle">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">parent_angle</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">comparison_distance</span> <span class="o">=</span> <span class="n">comparison_distance_global</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will return the angle between the current node and the parent</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">neurd</span> <span class="kn">import</span> <span class="n">limb_utils</span> <span class="k">as</span> <span class="n">lu</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
<span class="c1">#             parent_angle = nru.find_parent_child_skeleton_angle(curr_limb,</span>
<span class="c1">#                                             b,comparison_distance=comparison_distance,</span>
<span class="c1">#                                                                **kwargs)</span>
            <span class="n">parent_angle</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">parent_skeletal_angle</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">default_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">parent_angle</span> <span class="o">=</span> <span class="mi">0</span>
            
        
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_angle</span>
            
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="sibling_angle_min"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.sibling_angle_min">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sibling_angle_min</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance_global</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sibling_angles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                                   <span class="n">b</span><span class="p">,</span>
                                                                <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                         <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">min_sib_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sibling_angles</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">min_sib_angle</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_sib_angle</span>
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="sibling_angle_max"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.sibling_angle_max">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sibling_angle_max</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance_global</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sibling_angles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">find_sibling_child_skeleton_angle</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                                   <span class="n">b</span><span class="p">,</span>
                                                                        <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">,</span>
                                         <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">min_sib_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sibling_angles</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">min_sib_angle</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_sib_angle</span>
    <span class="k">return</span> <span class="n">output_dict</span></div>

<span class="c1"># @run_options(run_type=&quot;Limb&quot;)</span>
<span class="c1"># def n_downstream_nodes(curr_limb,limb_name=None,</span>
<span class="c1">#                **kwargs):</span>
<span class="c1">#     output_dict = dict()</span>
<span class="c1">#     for b in curr_limb.get_branch_names():</span>
<span class="c1">#         downstream_nodes = xu.downstream_nodes(curr_limb.concept_network_directional,b)</span>
<span class="c1">#         output_dict[b] = len(downstream_nodes)</span>
        
<span class="c1">#     return output_dict</span>

<div class="viewcode-block" id="n_siblings"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_siblings">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_siblings</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xu</span><span class="o">.</span><span class="n">sibling_nodes</span><span class="p">(</span><span class="n">curr_limb</span><span class="o">.</span><span class="n">concept_network_directional</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="n_small_children"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_small_children">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_small_children</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">width_maximum</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_small_children</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">width_maximum</span><span class="o">=</span><span class="n">width_maximum</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="children_skeletal_lengths_min"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.children_skeletal_lengths_min">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">children_skeletal_lengths_min</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">width_maximum</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">children_skeletal_lengths_min</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="two_children_angle"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.two_children_angle">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">two_children_angle</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance_global</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;limb_branch_dict_restriction&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict_restriction</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]:</span>
                <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">child_angles</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">comparison_distance</span><span class="o">=</span><span class="n">comparison_distance</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">output_dict</span></div>



<div class="viewcode-block" id="skeletal_length_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeletal_length_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeletal_length_downstream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="n">curr_value</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">skeletal_length_over_downstream_branches</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span>
                                                <span class="n">b</span><span class="p">,</span>
                                                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">curr_value</span>
    <span class="k">return</span> <span class="n">output_dict</span></div>



<div class="viewcode-block" id="fork_divergence"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.fork_divergence">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fork_divergence</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The winning threshold appears to be 165</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict_restriction</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]:</span>
                <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>
        <span class="c1">#print(f&quot;b = {b}&quot;)</span>
        <span class="n">div</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">fork_divergence_from_branch</span><span class="p">(</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span>
                <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">plot_fork_skeleton</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">div</span>
    <span class="k">return</span> <span class="n">output_dict</span></div>



<div class="viewcode-block" id="run_limb_function"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.run_limb_function">[docs]</a><span class="k">def</span> <span class="nf">run_limb_function</span><span class="p">(</span><span class="n">limb_func</span><span class="p">,</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will run a generic limb function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(f&quot;limb_name = {limb_name},kwargs = {kwargs}&quot;)</span>
    <span class="n">output_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">curr_limb</span><span class="o">.</span><span class="n">get_branch_names</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">limb_branch_dict_restriction</span><span class="p">[</span><span class="n">limb_name</span><span class="p">]:</span>
                <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>
        <span class="c1">#print(f&quot;b = {b}&quot;)</span>
        <span class="n">div</span> <span class="o">=</span> <span class="n">limb_func</span><span class="p">(</span><span class="n">branch_idx</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span>
                <span class="n">limb_obj</span> <span class="o">=</span> <span class="n">curr_limb</span><span class="p">,</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">output_dict</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">div</span>
    <span class="k">return</span> <span class="n">output_dict</span></div>

<div class="viewcode-block" id="upstream_axon_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.upstream_axon_width">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">upstream_axon_width</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">upstream_axon_width</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>


<div class="viewcode-block" id="children_axon_width_max"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.children_axon_width_max">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">children_axon_width_max</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">children_axon_width_max</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="upstream_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.upstream_skeletal_length">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">upstream_skeletal_length</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">upstream_skeletal_length</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="total_upstream_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.total_upstream_skeletal_length">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">total_upstream_skeletal_length</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">total_upstream_skeletal_length</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<span class="c1"># ------------- 5/26: For Width and Double Back Errors ----------</span>

<div class="viewcode-block" id="width_jump_from_upstream_min"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.width_jump_from_upstream_min">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">width_jump_from_upstream_min</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">ed</span><span class="o">.</span><span class="n">width_jump_from_upstream_min</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="restrict_by_branch_and_upstream_skeletal_length"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.restrict_by_branch_and_upstream_skeletal_length">[docs]</a><span class="k">def</span> <span class="nf">restrict_by_branch_and_upstream_skeletal_length</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                   <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                   <span class="n">plot_initial_limb_branch_restriction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">branch_skeletal_length_min</span> <span class="o">=</span> <span class="mi">6000</span><span class="p">,</span>
                                                <span class="n">plot_branch_skeletal_length_min</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">upstream_skeletal_length_min</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
                                                <span class="n">plot_upstream_skeletal_length_min</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">include_branch</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: Will restrict a neuron by the skeletal </span>
<span class="sd">    length of individual branches and the amount of </span>
<span class="sd">    skeleton upstream</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">limb_branch_dict_restriction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">limb_branch_dict</span>
    
    <span class="k">if</span> <span class="n">plot_initial_limb_branch_restriction</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial limb branch restriction&quot;</span><span class="p">)</span>
        <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                  <span class="n">limb_branch_dict_restriction</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">branch_skeletal_length_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                      <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;skeletal_length&quot;</span><span class="p">],</span>
                                <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;skeletal_length &gt; </span><span class="si">{</span><span class="n">branch_skeletal_length_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_branch_skeletal_length_min</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;branch_skeletal_length_min = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict_restriction</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">upstream_skeletal_length_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">limb_branch_dict_restriction</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">query_neuron</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                                      <span class="n">functions_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;total_upstream_skeletal_length&quot;</span><span class="p">],</span>
                                <span class="n">query</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;total_upstream_skeletal_length &gt; </span><span class="si">{</span><span class="n">upstream_skeletal_length_min</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                                       <span class="n">function_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">include_branch</span><span class="o">=</span><span class="n">include_branch</span><span class="p">),</span>
                                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_upstream_skeletal_length_min</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;upstream_skeletal_length_min = </span><span class="si">{</span><span class="n">limb_branch_dict_restriction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nviz</span><span class="o">.</span><span class="n">plot_limb_branch_dict</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span>
                                      <span class="n">limb_branch_dict_restriction</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">limb_branch_dict_restriction</span></div>


<span class="c1"># ---------- 6/9: Synapse Features --------------#</span>

<div class="viewcode-block" id="n_synapses"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_density">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_density</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_pre"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_pre">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_pre</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_post"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_post">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_post</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density_pre"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_density_pre">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_density_pre</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_pre</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density_post"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_density_post">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_density_post</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_density_post</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>


<span class="c1"># ----------- 6/21: v6 statistics -----------</span>
<div class="viewcode-block" id="downstream_nodes_mesh_connected"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.downstream_nodes_mesh_connected">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">downstream_nodes_mesh_connected</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">cnu</span><span class="o">.</span><span class="n">downstream_nodes_mesh_connected</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="parent_width"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.parent_width">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">parent_width</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">parent_width</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="min_synapse_dist_to_branch_point"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.min_synapse_dist_to_branch_point">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">min_synapse_dist_to_branch_point</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">min_synapse_dist_to_branch_point</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="ray_trace_perc"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.ray_trace_perc">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ray_trace_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="s2">&quot;percentile&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">ray_trace_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;percentile&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">ray_trace_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="synapse_closer_to_downstream_endpoint_than_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_closer_to_downstream_endpoint_than_upstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_closer_to_downstream_endpoint_than_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapse_closer_to_downstream_endpoint_than_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="downstream_upstream_diff_of_most_downstream_syn"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.downstream_upstream_diff_of_most_downstream_syn">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">downstream_upstream_diff_of_most_downstream_syn</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">downstream_upstream_diff_of_most_downstream_syn</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>


<span class="c1">#-------- 7/17: For new axon finder --------- #</span>
<div class="viewcode-block" id="n_synapses_post_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_post_downstream_within_dist">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_post_downstream_within_dist</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_post_downstream_within_dist</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>
<div class="viewcode-block" id="n_synapses_downstream_within_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_downstream_within_dist">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_downstream_within_dist</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_downstream_within_dist</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>


<span class="c1"># --------- 7/19: Helping with the new E/I classification --------</span>
<div class="viewcode-block" id="synapse_post_perc"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_post_perc">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_post_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_post_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="distance_from_soma"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.distance_from_soma">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">distance_from_soma</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">distance_from_soma</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<span class="c1"># --------- 7/20: for the axon error segments ----- #</span>
<div class="viewcode-block" id="synapse_pre_perc"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_pre_perc">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_pre_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_pre_perc</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_pre_perc_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_pre_perc_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_pre_perc_downstream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">syu</span><span class="o">.</span><span class="n">synapse_pre_perc_downstream</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="synapse_post_perc_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_post_perc_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_post_perc_downstream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">syu</span><span class="o">.</span><span class="n">synapse_post_perc_downstream</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_post_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_post_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_post_downstream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post_downstream</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_pre_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_pre_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_pre_downstream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_pre_downstream</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_downstream</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_downstream</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_spine"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_spine">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_spine</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_spine</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_post_head"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_post_head">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_post_head</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post_head</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_post_spine"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_post_spine">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_post_spine</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">n_synapses_post_spine</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>


<div class="viewcode-block" id="synapse_density_post_near_endpoint_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_density_post_near_endpoint_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_density_post_near_endpoint_downstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapse_density_post_near_endpoint_downstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_spine_within_distance_of_endpoint_downstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_spine_within_distance_of_endpoint_downstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_spine_within_distance_of_endpoint_downstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_spine_within_distance_of_endpoint_downstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density_post_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_density_post_offset_endpoint_upstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_density_post_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapse_density_post_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="synapse_density_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.synapse_density_offset_endpoint_upstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">synapse_density_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">synapse_density_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="c1"># @run_options(run_type=&quot;Branch&quot;)</span>
<span class="c1"># def labels(curr_branch,name=None,branch_name=None,**kwargs):</span>
<span class="c1">#     return set(curr_branch.labels)</span>

<div class="viewcode-block" id="n_synapses_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_offset_endpoint_upstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_pre_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_pre_offset_endpoint_upstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_pre_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_pre_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="n_synapses_spine_offset_endpoint_upstream"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.n_synapses_spine_offset_endpoint_upstream">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">n_synapses_spine_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">n_synapses_spine_offset_endpoint_upstream</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<span class="c1"># ------- functions for apical classification ---------#</span>
<div class="viewcode-block" id="skeleton_dist_match_ref_vector"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeleton_dist_match_ref_vector">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeleton_dist_match_ref_vector</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">skeleton_dist_match_ref_vector</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="skeleton_perc_match_ref_vector"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.skeleton_perc_match_ref_vector">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">skeleton_perc_match_ref_vector</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">skeleton_perc_match_ref_vector</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="upstream_node_has_label"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.upstream_node_has_label">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">upstream_node_has_label</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">upstream_node_has_label</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>


<div class="viewcode-block" id="upstream_node_is_apical_shaft"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.upstream_node_is_apical_shaft">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">upstream_node_is_apical_shaft</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">upstream_node_is_apical_shaft</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="is_apical_shaft_in_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.is_apical_shaft_in_downstream_branches">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_apical_shaft_in_downstream_branches</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">is_apical_shaft_in_downstream_branches</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="is_axon_in_downstream_branches"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.is_axon_in_downstream_branches">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_axon_in_downstream_branches</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nst</span><span class="o">.</span><span class="n">is_axon_in_downstream_branches</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>



<span class="c1"># ------------------ 2/9 autoproofredaing of human ---------</span>
<div class="viewcode-block" id="farthest_distance_from_skeleton_to_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.farthest_distance_from_skeleton_to_mesh">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">farthest_distance_from_skeleton_to_mesh</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">nst</span><span class="o">.</span><span class="n">farthest_distance_from_skeleton_to_mesh</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span>
                                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_branch_mesh_connected_to_neighborhood</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">is_branch_mesh_connected_to_neighborhood</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span>
<div class="viewcode-block" id="closest_mesh_skeleton_dist"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.closest_mesh_skeleton_dist">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">closest_mesh_skeleton_dist</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bu</span><span class="o">.</span><span class="n">closest_mesh_skeleton_dist</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">)</span></div>

<div class="viewcode-block" id="area"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.area">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Branch&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">curr_branch</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">branch_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">curr_branch</span><span class="o">.</span><span class="n">area</span></div>

<span class="c1"># ------------- skeletal angles -------------</span>
<div class="viewcode-block" id="is_branch_mesh_connected_to_neighborhood"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.is_branch_mesh_connected_to_neighborhood">[docs]</a><span class="nd">@run_options</span><span class="p">(</span><span class="n">run_type</span><span class="o">=</span><span class="s2">&quot;Limb&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_branch_mesh_connected_to_neighborhood</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">run_limb_function</span><span class="p">(</span><span class="n">nru</span><span class="o">.</span><span class="n">is_branch_mesh_connected_to_neighborhood</span><span class="p">,</span>
                            <span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                             <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                             <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span>
                            <span class="p">)</span></div>


<div class="viewcode-block" id="set_limb_functions_for_search"><a class="viewcode-back" href="../../neurd.html#neurd.neuron_searching.set_limb_functions_for_search">[docs]</a><span class="k">def</span> <span class="nf">set_limb_functions_for_search</span><span class="p">(</span>
    <span class="n">module</span><span class="p">,</span>
    <span class="n">functions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">append_name</span> <span class="o">=</span> <span class="n">limb_function_append_name</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Purpose: To add wrappers for all the functions</span>
<span class="sd">    so can operate in generating a neurons dataframe</span>
<span class="sd">    </span>
<span class="sd">    Pseudocode: </span>
<span class="sd">    1) Get all of the functions in the module</span>
<span class="sd">    2) Filter the functions for only those that have limb in the first arg</span>
<span class="sd">    </span>
<span class="sd">    For all functions</span>
<span class="sd">    3) Send each of the functions through the wrapper</span>
<span class="sd">    4) Set the function in module with new name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">functions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_func_names</span> <span class="o">=</span> <span class="n">fcu</span><span class="o">.</span><span class="n">all_functions_from_module</span><span class="p">(</span><span class="n">module</span><span class="p">,</span><span class="n">return_only_names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_func_names</span> <span class="o">=</span> <span class="n">functions</span>
        
    <span class="n">limb_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_func_names</span> <span class="k">if</span> <span class="s2">&quot;limb&quot;</span> <span class="ow">in</span> <span class="n">fcu</span><span class="o">.</span><span class="n">arg_names</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span><span class="n">k</span><span class="p">))[</span><span class="mi">0</span><span class="p">]]</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;all_func_name = </span><span class="si">{</span><span class="n">all_func_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;limb_funcs = </span><span class="si">{</span><span class="n">limb_funcs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="n">newname</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">newname</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">return</span> <span class="n">decorator</span>
        
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">limb_funcs</span><span class="p">:</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">append_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating new function: </span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">f_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">make_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="nd">@rename</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">dummy_func</span><span class="p">(</span><span class="n">curr_limb</span><span class="p">,</span><span class="n">limb_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ns</span><span class="o">.</span><span class="n">run_limb_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">curr_limb</span><span class="o">=</span><span class="n">curr_limb</span><span class="p">,</span>
                                 <span class="n">limb_name</span><span class="o">=</span><span class="n">limb_name</span><span class="p">,</span>
                                 <span class="n">limb_branch_dict_restriction</span><span class="o">=</span><span class="n">limb_branch_dict_restriction</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dummy_func</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span><span class="n">new_name</span><span class="p">,</span><span class="n">make_func</span><span class="p">(</span><span class="n">f_func</span><span class="p">))</span></div>


<span class="c1">#--- from neurd_packages ---</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">axon_utils</span> <span class="k">as</span> <span class="n">au</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">branch_utils</span> <span class="k">as</span> <span class="n">bu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">classification_utils</span> <span class="k">as</span> <span class="n">clu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">concept_network_utils</span> <span class="k">as</span> <span class="n">cnu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">error_detection</span> <span class="k">as</span> <span class="n">ed</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_statistics</span> <span class="k">as</span> <span class="n">nst</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">width_utils</span> <span class="k">as</span> <span class="n">wu</span>

<span class="n">axon_width_like_requirement</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_width_like_requirement</span>
<span class="n">ais_axon_width_like_requirement</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">ais_axon_width_like_requirement</span>
<span class="n">axon_width_like_query_revised</span><span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_width_like_query_revised</span>
<span class="n">axon_width_like_segments</span> <span class="o">=</span> <span class="n">clu</span><span class="o">.</span><span class="n">axon_width_like_segments</span>

<span class="c1">#--- from mesh_tools ---</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">skeleton_utils</span> <span class="k">as</span> <span class="n">sk</span>
<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="c1">#--- from datasci_tools ---</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">function_utils</span> <span class="k">as</span> <span class="n">fcu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">networkx_utils</span> <span class="k">as</span> <span class="n">xu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_dep</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">system_utils</span> <span class="k">as</span> <span class="n">su</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_searching</span> <span class="k">as</span> <span class="n">ns</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
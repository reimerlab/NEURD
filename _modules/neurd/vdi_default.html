<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neurd.vdi_default &mdash; neurd  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            neurd
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">neurd</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">neurd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../neurd.html">neurd</a></li>
      <li class="breadcrumb-item active">neurd.vdi_default</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for neurd.vdi_default</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ABC</span><span class="p">,</span><span class="n">abstractmethod</span><span class="p">,)</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">trimesh</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span><span class="n">Union</span>
<span class="kn">from</span> <span class="nn">.neuron</span> <span class="kn">import</span> <span class="n">Neuron</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="c1"># --- for parameters</span>
<span class="n">parameters_config_filename</span> <span class="o">=</span> <span class="s2">&quot;parameters_config_default.py&quot;</span>
<span class="n">config_filepath</span> <span class="o">=</span> <span class="nb">str</span><span class="p">((</span>
    <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parameter_configs/</span><span class="si">{</span><span class="n">parameters_config_filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
<span class="p">)</span>


<span class="n">default_settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">parameters_config_filepath_default</span> <span class="o">=</span> <span class="n">config_filepath</span><span class="p">,</span>
    
    <span class="c1"># --- mesh locations ---</span>
    <span class="n">meshes_directory</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span>
    <span class="n">meshes_undecimated_directory</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span>
    
    <span class="n">neuron_obj_directory</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span>
    <span class="n">neuron_obj_auto_proof_directory</span> <span class="o">=</span> <span class="s2">&quot;./&quot;</span><span class="p">,</span>
    <span class="n">neuron_obj_auto_proof_suffix</span> <span class="o">=</span> <span class="s2">&quot;_auto_proof&quot;</span><span class="p">,</span>
    <span class="c1"># --- synapse locations ---</span>
    <span class="n">synapse_filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<div class="viewcode-block" id="neuron_obj_func"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.neuron_obj_func">[docs]</a><span class="k">def</span> <span class="nf">neuron_obj_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">new_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span><span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only implemented for neuron_obj input (not segment_id yet)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">new_func</span></div>
        

<div class="viewcode-block" id="DataInterfaceBoilerplate"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate">[docs]</a><span class="k">class</span> <span class="nc">DataInterfaceBoilerplate</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="n">proof_version</span> <span class="o">=</span> <span class="mi">7</span>
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">default_settings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parameters_obj</span><span class="p">()</span></div>
        

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vdi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
        
<div class="viewcode-block" id="DataInterfaceBoilerplate.set_parameters_obj"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.set_parameters_obj">[docs]</a>    <span class="k">def</span> <span class="nf">set_parameters_obj</span><span class="p">(</span>
        <span class="bp">self</span>
        <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To set the parameters obj using the</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="n">parameters_config_filepath_default</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="s2">&quot;parameters_config_filepath_default&quot;</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">)</span>
        
        <span class="n">filepaths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">parameters_config_filepath_default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parameters_config_filepath_default</span><span class="p">)</span>
            
            
        <span class="n">override_filepaths</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;parameters_config_filepaths&quot;</span><span class="p">,[])</span>
        <span class="n">override_filepaths</span> <span class="o">=</span> <span class="n">nu</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">override_filepaths</span><span class="p">)</span>
        
        <span class="n">filepaths</span> <span class="o">+=</span> <span class="n">override_filepaths</span>
        
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filepaths</span><span class="p">:</span>
            <span class="c1">#print(f&quot;Setting parameters from {f}&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_parameters_obj_from_filepath</span><span class="p">(</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">f</span>
            <span class="p">)</span></div>
        
<div class="viewcode-block" id="DataInterfaceBoilerplate.set_parameters_obj_from_filepath"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.set_parameters_obj_from_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">set_parameters_obj_from_filepath</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">set_module_parameters</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;parameters_obj&quot;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;parameters_obj&quot;</span><span class="p">,</span><span class="n">paru</span><span class="o">.</span><span class="n">PackageParameters</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters_config_filepath</span>
            
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> 
        
        
        <span class="n">parameters_obj_curr</span> <span class="o">=</span> <span class="n">paru</span><span class="o">.</span><span class="n">parameters_from_filepath</span><span class="p">(</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">parameters_obj_curr</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">set_module_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_parameters_for_directory_modules</span><span class="p">()</span></div>
            
<div class="viewcode-block" id="DataInterfaceBoilerplate.set_parameters_for_directory_modules"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.set_parameters_for_directory_modules">[docs]</a>    <span class="k">def</span> <span class="nf">set_parameters_for_directory_modules</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        
        <span class="n">paru</span><span class="o">.</span><span class="n">set_parameters_for_directory_modules_from_obj</span><span class="p">(</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span><span class="p">,</span>
            <span class="n">verbose_loop</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
        
    <span class="c1"># --------------------------</span>
<div class="viewcode-block" id="DataInterfaceBoilerplate.align_array"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.align_array">[docs]</a>    <span class="k">def</span> <span class="nf">align_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">array</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#print(f&quot;inside vdi align array&quot;)</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="n">align_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataInterfaceBoilerplate.align_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.align_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">align_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#print(f&quot;inside vdi align mesh&quot;)</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">align_matrix</span><span class="o">=</span><span class="n">align_matrix</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataInterfaceBoilerplate.align_skeleton"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.align_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">align_skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">skeleton</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#print(f&quot;inside vdi align skeleton&quot;)</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_skeleton</span><span class="p">(</span><span class="n">skeleton</span><span class="o">=</span><span class="n">skeleton</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="n">align_matrix</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.align_neuron_obj_from_align_matrix"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.align_neuron_obj_from_align_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">align_neuron_obj_from_align_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">align_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">align_neuron_obj_from_align_matrix</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">align_matrix</span><span class="o">=</span><span class="n">align_matrix</span><span class="p">,</span>
            <span class="n">align_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_array</span><span class="p">,</span>
            <span class="n">align_mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_mesh</span><span class="p">,</span>
            <span class="n">align_skeleton</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">align_skeleton</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.unalign_neuron_obj_from_align_matrix"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.unalign_neuron_obj_from_align_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">unalign_neuron_obj_from_align_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">align_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">unalign_neuron_obj_from_align_matrix</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">align_matrix</span><span class="o">=</span><span class="n">align_matrix</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="DataInterfaceBoilerplate.align_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.align_neuron_obj">[docs]</a>    <span class="k">def</span> <span class="nf">align_neuron_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep the body of function as &quot;pass&quot; unless the neuron obj needs to be rotated so axon is pointing down</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">align_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">align_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_align_matrix</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">align_neuron_obj_from_align_matrix</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">align_matrix</span> <span class="o">=</span> <span class="n">align_matrix</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DataInterfaceBoilerplate.unalign_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.unalign_neuron_obj">[docs]</a>    <span class="k">def</span> <span class="nf">unalign_neuron_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">neuron_obj</span><span class="p">,</span><span class="n">align_matrix</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep the body of function as &quot;pass&quot; unless the neuron obj needs to be rotated so axon is pointing down</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">align_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">align_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_align_matrix</span><span class="p">(</span><span class="n">neuron_obj</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unalign_neuron_obj_from_align_matrix</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">align_matrix</span> <span class="o">=</span> <span class="n">align_matrix</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
    
    <span class="c1"># -------- save and load for neuron obj</span>
<div class="viewcode-block" id="DataInterfaceBoilerplate.save_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.save_neuron_obj">[docs]</a>    <span class="k">def</span> <span class="nf">save_neuron_obj</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">neuron_obj</span><span class="p">,</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        neuron_obj : _type_</span>
<span class="sd">            </span>
<span class="sd">        directory : _type_, optional</span>
<span class="sd">            by default None</span>
<span class="sd">        filename : _type_, optional</span>
<span class="sd">            by default None</span>
<span class="sd">        suffix : str, optional</span>
<span class="sd">            by default &#39;&#39;</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_obj_directory</span>
        
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">neuron_obj</span><span class="o">.</span><span class="n">segment_id</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
            
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">nru</span><span class="o">.</span><span class="n">save_compressed_neuron</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">output_folder</span> <span class="o">=</span> <span class="n">directory</span><span class="p">,</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">filename</span><span class="p">,</span>
            <span class="n">return_file_path</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saved neuron filepath = </span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.pbz2&quot;</span></div>
    
        
<div class="viewcode-block" id="DataInterfaceBoilerplate.load_neuron_obj"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.load_neuron_obj">[docs]</a>    <span class="k">def</span> <span class="nf">load_neuron_obj</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mesh_decimated</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mesh_filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">meshes_directory</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">mesh_decimated</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mesh_decimated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_segment_id_mesh</span><span class="p">(</span>
                <span class="n">segment_id</span><span class="p">,</span>
                <span class="n">meshes_directory</span> <span class="o">=</span> <span class="n">meshes_directory</span><span class="p">,</span>
                <span class="n">mesh_filepath</span><span class="o">=</span><span class="n">mesh_filepath</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_obj_directory</span>
            
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">segment_id</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">nru</span><span class="o">.</span><span class="n">decompress_neuron</span><span class="p">(</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span><span class="p">,</span>
            <span class="n">original_mesh</span> <span class="o">=</span> <span class="n">mesh_decimated</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> </div>
        
        
    <span class="c1"># ---------- used by autoproofreading --------------</span>
<div class="viewcode-block" id="DataInterfaceBoilerplate.multiplicity"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.multiplicity">[docs]</a>    <span class="k">def</span> <span class="nf">multiplicity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">neuron_obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For those who don&#39;t store the output of each stage in the neuron obj</span>
<span class="sd">        this function could be redefined to pull from a database</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">multiplicity</span></div>
        
<div class="viewcode-block" id="DataInterfaceBoilerplate.nucleus_id"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.nucleus_id">[docs]</a>    <span class="k">def</span> <span class="nf">nucleus_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">nucleus_id</span></div>
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.cell_type"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.cell_type">[docs]</a>    <span class="k">def</span> <span class="nf">cell_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">neuron_obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">nucleus_id</span></div>
    
    
    <span class="c1"># ---- used by proximities</span>
<div class="viewcode-block" id="DataInterfaceBoilerplate.segment_id_and_split_index"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.segment_id_and_split_index">[docs]</a>    <span class="k">def</span> <span class="nf">segment_id_and_split_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">,</span>
        <span class="n">split_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">return_dict</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        
        
        <span class="n">single_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">segment_id</span><span class="p">):</span>
            <span class="n">segment_id</span><span class="o">=</span><span class="p">[</span><span class="n">segment_id</span><span class="p">]</span>
            <span class="n">split_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_index</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>
            <span class="n">single_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nu</span><span class="o">.</span><span class="n">is_array_like</span><span class="p">(</span><span class="n">split_index</span><span class="p">):</span>
                <span class="n">split_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">split_index</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">segment_id</span><span class="p">)</span>
        
        <span class="n">seg_ids_final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sp_idxs_final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg_id</span><span class="p">,</span><span class="n">sp_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span><span class="n">split_index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sp_idx</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sp_idx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;_&quot;</span> <span class="ow">in</span> <span class="n">seg_id</span><span class="p">:</span>
                    <span class="n">seg_id</span><span class="p">,</span><span class="n">sp_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id_and_split_index_from_node_name</span><span class="p">(</span><span class="n">seg_id</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            
            <span class="n">seg_ids_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_id</span><span class="p">)</span>
            <span class="n">sp_idxs_final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp_idx</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">single_flag</span><span class="p">:</span>
            <span class="n">seg_ids_final</span> <span class="o">=</span> <span class="n">seg_ids_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sp_idxs_final</span> <span class="o">=</span> <span class="n">sp_idxs_final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seg_ids_final</span><span class="p">,</span><span class="n">sp_idxs_final</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">single_flag</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">segment_id</span><span class="o">=</span><span class="n">seg_ids_final</span><span class="p">,</span><span class="n">split_index</span> <span class="o">=</span> <span class="n">sp_idxs_final</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">segment_id</span><span class="o">=</span><span class="n">k</span><span class="p">,</span><span class="n">split_index</span> <span class="o">=</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">seg_ids_final</span><span class="p">,</span><span class="n">sp_idxs_final</span><span class="p">)]</span></div>
    
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.add_nm_to_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.add_nm_to_synapse_df">[docs]</a>    <span class="k">def</span> <span class="nf">add_nm_to_synapse_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">df</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">syu</span><span class="o">.</span><span class="n">add_nm_to_synapse_df</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">scaling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span><span class="p">,</span>
        <span class="p">)</span></div>
<div class="viewcode-block" id="DataInterfaceBoilerplate.segment_id_to_synapse_dict"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.segment_id_to_synapse_dict">[docs]</a>    <span class="k">def</span> <span class="nf">segment_id_to_synapse_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Purpose: return a dictionary containing the presyn and postsyn information for a certain segment from the backend datasource implmeneted for the data. The structure of the returned dictionary should in the following format where all coordinates and sizes ARE SCALED TO NM ALREADY</span>
<span class="sd">        </span>
<span class="sd">        syn_dict = dict(</span>
<span class="sd">            presyn = dict(</span>
<span class="sd">                synapse_ids= np.array (N),</span>
<span class="sd">                synapse_coordinates = np.array (Nx3),</span>
<span class="sd">                synapse_sizes = np.array (N),</span>
<span class="sd">            ),</span>
<span class="sd">            postsyn = dict(</span>
<span class="sd">                synapse_ids= np.array (N),</span>
<span class="sd">                synapse_coordinates = np.array (Nx3),</span>
<span class="sd">                synapse_sizes = np.array (N),</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        The default implementation assumes there is a local synapse csv file (whose path needs to be passed as an argument or set with as an object attribute) with the following columns</span>
<span class="sd">        </span>
<span class="sd">        segment_id,</span>
<span class="sd">        segment_id_secondary,</span>
<span class="sd">        synapse_id,</span>
<span class="sd">        prepost, # presyn or postsyn</span>
<span class="sd">        synapse_x, # in voxel coordinates</span>
<span class="sd">        synapse_y, # in voxel coordinates</span>
<span class="sd">        synapse_z, # in voxel coordinates</span>
<span class="sd">        synapse_size, # in voxel coordinates</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Example Implementation</span>
<span class="sd">        ----------------------</span>
<span class="sd">        cave_client_utils.synapse_df_from_seg_id</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="n">syn_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id_to_synapse_df</span><span class="p">(</span>
            <span class="n">segment_id</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nm_to_synapse_df</span><span class="p">(</span><span class="n">syn_df</span><span class="p">)</span>
        
        <span class="n">syn_dict</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_dict_from_synapse_df</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">coordinates_nm</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">syn_dict</span></div>
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.segment_id_to_synapse_table_optimized"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.segment_id_to_synapse_table_optimized">[docs]</a>    <span class="k">def</span> <span class="nf">segment_id_to_synapse_table_optimized</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">,</span>
        <span class="n">synapse_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_away_self_synapses</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">coordinates_nm</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">synapse_filepath</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: Given a segment id (or neuron obj)</span>
<span class="sd">        will retrieve the synapses from a backend synapse implementation renamed in a particular manner</span>
<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : int or neuron.Neuron</span>
<span class="sd">            </span>
<span class="sd">        synapse_type : _type_, optional</span>
<span class="sd">            by default None</span>
<span class="sd">        filter_away_self_synapses : bool, optional</span>
<span class="sd">            by default True</span>
<span class="sd">        coordinates_nm : bool, optional</span>
<span class="sd">            by default True</span>
<span class="sd">        synapse_filepath : _type_, optional</span>
<span class="sd">            by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            </span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Exception</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span><span class="n">neuron</span><span class="o">.</span><span class="n">Neuron</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">synapse_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">synapse_filepath</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                    <span class="n">segment_id</span><span class="p">,</span><span class="s2">&quot;synapse_filepath&quot;</span><span class="p">,</span><span class="kc">None</span>
                <span class="p">)</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span><span class="o">.</span><span class="n">segment_id</span>
            
        <span class="n">return_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id_to_synapse_df</span><span class="p">(</span>
            <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span><span class="p">,</span>
            <span class="n">synapse_filepath</span> <span class="o">=</span> <span class="n">synapse_filepath</span><span class="p">,</span>
            <span class="n">coordinates_nm</span><span class="o">=</span><span class="n">coordinates_nm</span><span class="p">,</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">coordinates_nm</span><span class="p">:</span>
            <span class="n">return_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_nm_to_synapse_df</span><span class="p">(</span><span class="n">return_df</span><span class="p">)</span>
        
        <span class="c1"># if synapse_filepath is None:</span>
        <span class="c1">#     if self.synapse_filepath is None:</span>
        <span class="c1">#         raise Exception(&quot;No synapse filepath set&quot;)</span>
        <span class="c1">#     synapse_filepath = self.synapse_filepath</span>
        
        <span class="c1"># return_df = syu.synapse_df_from_csv(</span>
        <span class="c1">#     synapse_filepath=synapse_filepath,</span>
        <span class="c1">#     segment_id=segment_id,</span>
        <span class="c1">#     coordinates_nm=coordinates_nm,</span>
        <span class="c1">#     **kwargs</span>
        <span class="c1"># )</span>
        
        <span class="n">return_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">rename_columns</span><span class="p">(</span>
            <span class="n">return_df</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">segment_id</span> <span class="o">=</span> <span class="s1">&#39;primary_seg_id&#39;</span><span class="p">,</span>
                <span class="n">segment_id_secondary</span> <span class="o">=</span> <span class="s2">&quot;secondary_seg_id&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">synapse_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_df</span> <span class="o">=</span> <span class="n">return_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;prepost == &#39;</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">return_df</span></div>
    
<div class="viewcode-block" id="DataInterfaceBoilerplate.pre_post_synapse_ids_coords_from_connectome"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceBoilerplate.pre_post_synapse_ids_coords_from_connectome">[docs]</a>    <span class="nd">@neuron_obj_func</span>
    <span class="k">def</span> <span class="nf">pre_post_synapse_ids_coords_from_connectome</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id_pre</span><span class="p">,</span>
        <span class="n">segment_id_post</span><span class="p">,</span>
        <span class="n">split_index_pre</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">split_index_post</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">synapse_pre_df</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">):</span>
        
        <span class="k">if</span> <span class="n">synapse_pre_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">synapse_pre_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id_to_synapse_table_optimized_proofread</span><span class="p">(</span>
                <span class="n">segment_id_pre</span><span class="p">,</span>
                <span class="n">split_index</span> <span class="o">=</span> <span class="n">split_index_pre</span><span class="p">,</span>
                <span class="n">synapse_type</span><span class="o">=</span><span class="s2">&quot;presyn&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">synapse_coordinates_from_df</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;synapse_x_nm&quot;</span><span class="p">,</span><span class="s2">&quot;synapse_y_nm&quot;</span><span class="p">,</span><span class="s2">&quot;synapse_z_nm&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

        <span class="c1"># gets the pre and post synapses</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">synapse_pre_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">syn_ids</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_df</span><span class="p">(</span><span class="n">segment_id_post</span><span class="o">.</span><span class="n">synapses_valid</span><span class="p">)[</span><span class="s2">&quot;syn_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

            
            <span class="n">synapse_pre_post_df</span> <span class="o">=</span> <span class="n">synapse_pre_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;(secondary_seg_id == </span><span class="si">{</span><span class="n">segment_id_post</span><span class="o">.</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
            <span class="n">synapse_pre_post_df</span> <span class="o">=</span> <span class="n">synapse_pre_post_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;(synapse_id in </span><span class="si">{</span><span class="n">syn_ids</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>


            <span class="n">synapse_pre_post_coords</span> <span class="o">=</span> <span class="n">synapse_coordinates_from_df</span><span class="p">(</span><span class="n">synapse_pre_post_df</span><span class="p">)</span>
            <span class="n">synapse_pre_post_ids</span> <span class="o">=</span> <span class="n">synapse_pre_post_df</span><span class="p">[</span><span class="s2">&quot;synapse_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">synapse_pre_post_coords</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">synapse_pre_post_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;synapse_pre_post_coords = </span><span class="si">{</span><span class="n">synapse_pre_post_coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;synapse_pre_post_ids = </span><span class="si">{</span><span class="n">synapse_pre_post_ids</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">synapse_pre_post_ids</span><span class="p">,</span><span class="n">synapse_pre_post_coords</span></div></div>
    
    
<div class="viewcode-block" id="DataInterfaceDefault"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault">[docs]</a><span class="k">class</span> <span class="nc">DataInterfaceDefault</span><span class="p">(</span><span class="n">DataInterfaceBoilerplate</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to outline what functions to overload in implement a volume data interface that will work with NEURD. All methods exposed fall under the following categories</span>
<span class="sd">    </span>
<span class="sd">    1) required abstract method</span>
<span class="sd">    2) data fetchers/setters</span>
<span class="sd">    3) autoproofreading filter settings</span>
<span class="sd">    </span>
<span class="sd">    All fetchers and setters have a default implementation where data is stored locally in csv (for synapses) or locally in the neuron object. If exporting data to non-local source (ex: database) override these functions to pull from other these sources</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DataInterfaceDefault.__init__"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
        
    <span class="nd">@property</span>    
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">voxel_to_nm_scaling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ***REQUIRED OVERRIDE***</span>
<span class="sd">        </span>
<span class="sd">        Purpose: Provide a 1x3 numpy matrix representing the scaling of voxel units to nm units. If the data is already in nm format then just assign a ones matrix</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scaling_vector : np.array</span>
<span class="sd">            vector that can convert a matrix or vector of 3D voxel coordinates to 3D nm coordinates (default: np.array([1,1,1]))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    
<div class="viewcode-block" id="DataInterfaceDefault.get_align_matrix"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.get_align_matrix">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_align_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ***REQUIRED OVERRIDE***</span>
<span class="sd">        </span>
<span class="sd">        Purpose: a transformation matrix (call A, 3x3) that when applied to a matrix of 3D coordinates (call B, Nx3) as a matrix multiplication of C = BA will produce a new matrix of rotated coordinates (call C, Nx3) so that all coordinates or a mesh or skeleton are rotated to ensure that the apical of the neuron is generally direted in the positive z direction.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="DataInterfaceDefault.segment_id_to_synapse_df"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.segment_id_to_synapse_df">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">segment_id_to_synapse_df</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ***REQUIRED OVERRIDE***</span>
<span class="sd">        </span>
<span class="sd">        Purpose: return a dataframe with the presyn</span>
<span class="sd">        and postsyn information for a certain segment from the backend data source. The structure of the dataframe should return the following columns</span>
<span class="sd">        </span>
<span class="sd">        segment_id,</span>
<span class="sd">        segment_id_secondary,</span>
<span class="sd">        synapse_id,</span>
<span class="sd">        prepost, # presyn or postsyn</span>
<span class="sd">        synapse_x, # in voxel coordinates</span>
<span class="sd">        synapse_y, # in voxel coordinates</span>
<span class="sd">        synapse_z, # in voxel coordinates</span>
<span class="sd">        synapse_size, # in voxel coordinates</span>
<span class="sd">        </span>
<span class="sd">        The default implementation assumes there is a local synapse csv file (whose path needs to be passed as an argument or set with as an object attribute)</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        </span>
<span class="sd">        segment_id: int</span>
<span class="sd">        coordinates_nm: bool</span>
<span class="sd">            Whether to scale the coordinate to nm units</span>
<span class="sd">        scaling: np.array</span>
<span class="sd">            The scaling factor to use</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            dataframe with all of the relevant synapse information for one segment id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scaling</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">voxel_to_nm_scaling</span>
            
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;synapse_filepath&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No synapse filepath set&quot;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;synapse_filepath&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_filepath</span>
        
        <span class="n">df</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapse_df_from_csv</span><span class="p">(</span>
            <span class="n">synapse_filepath</span><span class="p">,</span>
            <span class="n">segment_id</span> <span class="o">=</span> <span class="n">segment_id</span><span class="p">,</span>
            <span class="n">coordinates_nm</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        
        <span class="k">return</span> <span class="n">df</span></div>
    
    <span class="c1"># ---- Data Fetching and Savinig Functions</span>
<div class="viewcode-block" id="DataInterfaceDefault.fetch_segment_id_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.fetch_segment_id_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_segment_id_mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">meshes_directory</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mesh_filepath</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ext</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;off&quot;</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: retrieve a decimated segment id mesh. Current implementation assumes a local filepath storing all meshes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : int, optional</span>
<span class="sd">            neuron segment id, by default None</span>
<span class="sd">        meshes_directory : str, optional</span>
<span class="sd">            location of decimated mesh files, by default None</span>
<span class="sd">        mesh_filepath : str, optional</span>
<span class="sd">            complete path of location and filename for neuron , by default None</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            by default False</span>
<span class="sd">        ext : str, optional</span>
<span class="sd">            the file extension for mesh storage, by default &quot;off&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trimesh.Trimesh</span>
<span class="sd">            decimated mesh for segment id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">mesh_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">meshes_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">meshes_directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes_directory</span>
            
            <span class="n">mesh_filepath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">meshes_directory</span><span class="p">)</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">segment_id</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">tu</span><span class="o">.</span><span class="n">load_mesh_no_processing</span><span class="p">(</span><span class="n">mesh_filepath</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">mesh</span></div>
    
<div class="viewcode-block" id="DataInterfaceDefault.fetch_undecimated_segment_id_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.fetch_undecimated_segment_id_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_undecimated_segment_id_mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">meshes_directory</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ext</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;off&quot;</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : int</span>
<span class="sd">            </span>
<span class="sd">        meshes_directory : str, optional</span>
<span class="sd">            by default None</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            by default False</span>
<span class="sd">        ext : str, optional</span>
<span class="sd">            by default &quot;off&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trimesh.Trimesh</span>
<span class="sd">            undecimated mesh for segment id</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">meshes_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meshes_directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes_undecimated_directory</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_segment_id_mesh</span><span class="p">(</span>
            <span class="n">segment_id</span><span class="p">,</span>
            <span class="n">meshes_directory</span> <span class="o">=</span> <span class="n">meshes_directory</span><span class="p">,</span>
            <span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span><span class="p">,</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="DataInterfaceDefault.set_synapse_filepath"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.set_synapse_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">set_synapse_filepath</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">synapse_filepath</span><span class="p">:</span><span class="nb">str</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sets the location and filename of the synapse csv for the default implementation that loads synapses from a local csv file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        synapse_filepath : str</span>
<span class="sd">            complete folder path and filename for synapse csv</span>
<span class="sd">        &quot;&quot;&quot;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_filepath</span> <span class="o">=</span> <span class="n">synapse_filepath</span></div>

<div class="viewcode-block" id="DataInterfaceDefault.nuclei_from_segment_id"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.nuclei_from_segment_id">[docs]</a>    <span class="k">def</span> <span class="nf">nuclei_from_segment_id</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">return_centers</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_nm</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        retrieves the nuclei id (and possibly the </span>
<span class="sd">        nuclei centers) from an external database. No external database currently set so currently set to None returns. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : int</span>
<span class="sd">            </span>
<span class="sd">        return_centers : bool, optional</span>
<span class="sd">            whether to return the nuclei center coordinates along with the ids, by default True</span>
<span class="sd">        return_nm : bool, optional</span>
<span class="sd">            whether to return nuclei center coordinates in nm units, by default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nuclei_ids: np.array (N,)</span>
<span class="sd">            nuclei ids corresponding to segment_id</span>
<span class="sd">        nuclei_centers: np.array (N,3), optional</span>
<span class="sd">            center locations for the corresponding nuclei</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nuclues_ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nucleus_centers</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="n">return_centers</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nuclues_ids</span><span class="p">,</span><span class="n">nucleus_centers</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nucleus_ids</span></div>
           
<div class="viewcode-block" id="DataInterfaceDefault.nuclei_classification_info_from_nucleus_id"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.nuclei_classification_info_from_nucleus_id">[docs]</a>    <span class="k">def</span> <span class="nf">nuclei_classification_info_from_nucleus_id</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nuclei</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span><span class="o">-&gt;</span><span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: To return a dictionary of cell type</span>
<span class="sd">        information (same structure as from the allen institute of brain science CAVE client return) from an external database. No external database currently set up so None filled dictionary returned.   </span>
<span class="sd">    </span>

<span class="sd">        Example Returns: </span>
<span class="sd">        </span>
<span class="sd">        {</span>
<span class="sd">            &#39;external_cell_type&#39;: &#39;excitatory&#39;,</span>
<span class="sd">            &#39;external_cell_type_n_nuc&#39;: 1,</span>
<span class="sd">            &#39;external_cell_type_fine&#39;: &#39;23P&#39;,</span>
<span class="sd">            &#39;external_cell_type_fine_n_nuc&#39;: 1,</span>
<span class="sd">            &#39;external_cell_type_fine_e_i&#39;: &#39;excitatory&#39;</span>
<span class="sd">        }</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nuclei : int</span>
<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            nuclei info about classification (fine and coarse)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;external_cell_type&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;external_cell_type_n_nuc&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;external_cell_type_fine&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;external_cell_type_fine_n_nuc&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;external_cell_type_fine_e_i&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span></div>
    
        
<div class="viewcode-block" id="DataInterfaceDefault.save_neuron_obj_auto_proof"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.save_neuron_obj_auto_proof">[docs]</a>    <span class="k">def</span> <span class="nf">save_neuron_obj_auto_proof</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">neuron_obj</span><span class="p">:</span><span class="n">Neuron</span><span class="p">,</span>
        <span class="n">directory</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">suffix</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a neuron object in the autoproofreading directory (using the default pbz2 compressed method that does not save the mesh along with it). Typical  This is the current local implementation, should be overriden if the proofreading neuron objects are to be saved in an external store </span>
<span class="sd">        </span>
<span class="sd">        Default filename: {segment_id}.pbz2 </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        neuron_obj : Neuron</span>
<span class="sd">            </span>
<span class="sd">        directory : str, optional</span>
<span class="sd">            location for storing .pbz2 files, by default None</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            a custom name for compressed neuron file to replace the default name, by default None</span>
<span class="sd">        suffix : str, optional</span>
<span class="sd">            change filename to {segment_id}{suffix}.pbz2 , by default None</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            filepath of saved neuron file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_obj_auto_proof_directory</span>
            
        <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_obj_auto_proof_suffix</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_neuron_obj</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="o">=</span><span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span><span class="p">,</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">,</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span>
        <span class="p">)</span></div>
        
<div class="viewcode-block" id="DataInterfaceDefault.load_neuron_obj_auto_proof"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.load_neuron_obj_auto_proof">[docs]</a>    <span class="k">def</span> <span class="nf">load_neuron_obj_auto_proof</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">mesh_decimated</span><span class="p">:</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">directory</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Neuron</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loading an external neuron file into a python object. Current implementation assumes the default .pbz2 method of compression that does not store the mesh information, which is why the mesh object needs to be passed as an argument</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : str</span>
<span class="sd">            </span>
<span class="sd">        mesh_decimated : trimesh.Trimesh, optional</span>
<span class="sd">            the original decimated mesh before any proofreaidng, by default None</span>
<span class="sd">        directory : str, optional</span>
<span class="sd">            filepath location of saved .pbz2 file, by default self.neuron_obj_auto_proof_directory</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Neuron</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_obj_auto_proof_directory</span>
            
        <span class="k">if</span> <span class="s2">&quot;suffix&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;suffix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_obj_auto_proof_suffix</span>
            
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_neuron_obj</span><span class="p">(</span>
            <span class="n">segment_id</span><span class="p">,</span>
            <span class="n">mesh_decimated</span> <span class="o">=</span> <span class="n">mesh_decimated</span><span class="p">,</span>
            <span class="n">directory</span><span class="o">=</span><span class="n">directory</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
        
        
        
    <span class="c1"># --------- functions for setting autoproofreading ---</span>
<div class="viewcode-block" id="DataInterfaceDefault.exc_filters_auto_proof"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.exc_filters_auto_proof">[docs]</a>    <span class="k">def</span> <span class="nf">exc_filters_auto_proof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All autoproofreading filters (referenced in proofreading_utils.py) that will be used for excitatory cells</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[filter objects]</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">v7_exc_filters</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>
        
<div class="viewcode-block" id="DataInterfaceDefault.inh_filters_auto_proof"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.inh_filters_auto_proof">[docs]</a>    <span class="k">def</span> <span class="nf">inh_filters_auto_proof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All autoproofreading filters (referenced in proofreading_utils.py) that will be used for inhibitory cells</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[filter functions]</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pru</span><span class="o">.</span><span class="n">v7_inh_filters</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_low_degree_graph_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The graph filters to be using the &#39;exc_low_degree_branching_filter&#39; for autoproofreading that inspects axon branches with exactly 2 downstream nodes and classifies as an error based on if one fo the following graph filters has a successful match. Overriding this function could be simply excluding some filters that are not applicable/work for your volume even with parameters tuned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[graph filter functions]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">axon_webbing_filter</span><span class="p">,</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">thick_t_filter</span><span class="p">,</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">axon_double_back_filter</span><span class="p">,</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">fork_divergence_filter</span><span class="p">,</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">fork_min_skeletal_distance_filter</span><span class="p">,</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">axon_spine_at_intersection_filter</span><span class="p">,</span>
            <span class="n">gf</span><span class="o">.</span><span class="n">min_synapse_dist_to_branch_point_filter</span><span class="p">,</span>
        <span class="p">]</span>
        
        
    <span class="c1"># --- Fetching functions of data (default to searching neuron obj because no default database set up)</span>
<div class="viewcode-block" id="DataInterfaceDefault.fetch_proofread_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.fetch_proofread_mesh">[docs]</a>    <span class="nd">@neuron_obj_func</span>
    <span class="k">def</span> <span class="nf">fetch_proofread_mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="n">Neuron</span><span class="p">],</span>
        <span class="n">split_index</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">plot_mesh</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span><span class="o">-&gt;</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve mesh after autoproofreading filtering. Default implementation uses a local solution of extracting the mesh from the neuron object, but the proofreading mesh could be stored in an external database with only the segment id and split index needed to retrieve. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : Union[int,Neuron]</span>
<span class="sd">            proofread neuron object from which the mesh can be extracted or an int representing the segment id for external database implementation where saved products indexed by unique segment_id and split index</span>
<span class="sd">        split_index : int, optional</span>
<span class="sd">            for external database implementation where saved products indexed by unique segment_id and split index, by default 0</span>
<span class="sd">        plot_mesh : bool, optional</span>
<span class="sd">            by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trimesh.Trimesh</span>
<span class="sd">            auto proofread mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">segment_id</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">mesh_from_branches</span>
        
        <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">mesh</span></div>
    
<div class="viewcode-block" id="DataInterfaceDefault.fetch_soma_mesh"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.fetch_soma_mesh">[docs]</a>    <span class="nd">@neuron_obj_func</span>
    <span class="k">def</span> <span class="nf">fetch_soma_mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="n">Neuron</span><span class="p">],</span>
        <span class="n">split_index</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">plot_mesh</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        
        <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve soma mesh. Default implementation uses a local solution of extracting the soma mesh from the neuron object, but the soma mesh could be stored in an external database with only the segment id and split index needed to retrieve. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : Union[int,Neuron]</span>
<span class="sd">            neuron object from which the mesh can be extracted or an int representing the segment id for external database implementation where saved products indexed by unique segment_id and split index</span>
<span class="sd">        split_index : int, optional</span>
<span class="sd">            for external database implementation where saved products indexed by unique segment_id and split index, by default 0</span>
<span class="sd">        plot_mesh : bool, optional</span>
<span class="sd">            by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trimesh.Trimesh</span>
<span class="sd">            auto proofread mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">segment_id</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
        
        <span class="k">if</span> <span class="n">plot_mesh</span><span class="p">:</span>
            <span class="n">ipvu</span><span class="o">.</span><span class="n">plot_objects</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">mesh</span></div>
    
<div class="viewcode-block" id="DataInterfaceDefault.segment_id_to_synapse_table_optimized_connectome"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.segment_id_to_synapse_table_optimized_connectome">[docs]</a>    <span class="k">def</span> <span class="nf">segment_id_to_synapse_table_optimized_connectome</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="n">Neuron</span><span class="p">],</span>
        <span class="n">split_index</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">synapse_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coordinates_nm</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: to return a dataframe</span>
<span class="sd">        of the connections before proofreading with</span>
<span class="sd">        the constraint of one segment_id/split_index as a presyn or postsyn. Not implemented for local storage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
    
<div class="viewcode-block" id="DataInterfaceDefault.segment_id_to_synapse_table_optimized_proofread"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.segment_id_to_synapse_table_optimized_proofread">[docs]</a>    <span class="nd">@neuron_obj_func</span>
    <span class="k">def</span> <span class="nf">segment_id_to_synapse_table_optimized_proofread</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="n">Neuron</span><span class="p">],</span>
        <span class="n">split_index</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">synapse_type</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Purpose: to return a dataframe</span>
<span class="sd">        of the valid connections in the proofread segment/split. Currently only implemented for local solution of where synapse information stored in local csv and proofrad synapses are stored in neuron object. Could override to pull original or proofread synapses from an external source.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : Union[int,Neuron]</span>
<span class="sd">            neuron obj with proofread synapses, or just segment id if synapses stored externally</span>
<span class="sd">        split_index : int, optional</span>
<span class="sd">            identifier for segment if stored externally, by default 0</span>
<span class="sd">        synapse_type : str, optional</span>
<span class="sd">            presyn or postsyn restriction, by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        synapse_df : pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">segment_id</span>
        
        <span class="n">orig_syn_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_id_to_synapse_table_optimized</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="p">,</span>
            <span class="n">synapse_type</span> <span class="o">=</span> <span class="n">synapse_type</span><span class="p">,</span>
            <span class="c1">#synapse_filepath = &quot;../Auto_Proof_Pipeline/Single_Soma_Inh/864691135567721964_synapses.csv&quot;</span>
        <span class="p">)</span>

        <span class="n">syn_df</span> <span class="o">=</span> <span class="n">syu</span><span class="o">.</span><span class="n">synapses_df</span><span class="p">(</span>
            <span class="n">neuron_obj</span><span class="o">.</span><span class="n">synapses_valid</span><span class="p">,</span>
            <span class="n">add_compartment_coarse_fine</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">decode_head_neck_shaft_idx</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="p">)</span>
        
        <span class="n">syn_df</span> <span class="o">=</span> <span class="n">syn_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;compartment_coarse != &#39;error&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        

        <span class="n">syn_df</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">rename_columns</span><span class="p">(</span>
            <span class="n">syn_df</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">syn_type</span> <span class="o">=</span> <span class="s2">&quot;prepost&quot;</span><span class="p">,</span>
                <span class="n">syn_id</span> <span class="o">=</span> <span class="s2">&quot;synapse_id&quot;</span><span class="p">,</span>
                <span class="n">head_neck_shaft</span> <span class="o">=</span> <span class="s2">&quot;spine_bouton&quot;</span><span class="p">,</span>
                <span class="n">soma_distance</span> <span class="o">=</span> <span class="s2">&quot;skeletal_distance_to_soma&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">synapse_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">syn_df</span> <span class="o">=</span> <span class="n">syn_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;prepost == &#39;</span><span class="si">{</span><span class="n">synapse_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 

        <span class="n">merge_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">orig_syn_df</span><span class="p">,</span>
            <span class="n">syn_df</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;synapse_id&#39;</span><span class="p">,</span><span class="s1">&#39;prepost&#39;</span><span class="p">],</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merge_df</span></div>

<div class="viewcode-block" id="DataInterfaceDefault.soma_nm_coordinate"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.soma_nm_coordinate">[docs]</a>    <span class="nd">@neuron_obj_func</span>
    <span class="k">def</span> <span class="nf">soma_nm_coordinate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="n">Neuron</span><span class="p">],</span>
        <span class="n">split_index</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">return_dict</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the soma coordinate for a segment. Implemented with local solution of accepting neuron object but could override with external store fetching.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : Union[int,Neuron]</span>
<span class="sd">            </span>
<span class="sd">        split_index : int, optional</span>
<span class="sd">            by default 0</span>
<span class="sd">        return_dict : bool, optional</span>
<span class="sd">            by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        soma coordinate: np.array (3,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">segment_id</span>
        
        <span class="n">return_value</span>  <span class="o">=</span> <span class="n">neuron_obj</span><span class="p">[</span><span class="s2">&quot;S0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mesh_center</span>

        <span class="k">if</span> <span class="n">return_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;centroid_</span><span class="si">{</span><span class="n">ax</span><span class="si">}</span><span class="s2">_nm&quot;</span><span class="p">:</span><span class="n">val</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">,</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="s2">&quot;z&quot;</span><span class="p">],</span><span class="n">return_value</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">return_value</span></div>

    
<div class="viewcode-block" id="DataInterfaceDefault.graph_obj_from_proof_stage"><a class="viewcode-back" href="../../neurd.html#neurd.vdi_default.DataInterfaceDefault.graph_obj_from_proof_stage">[docs]</a>    <span class="nd">@neuron_obj_func</span>
    <span class="k">def</span> <span class="nf">graph_obj_from_proof_stage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segment_id</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="n">Neuron</span><span class="p">],</span>
        <span class="n">split_index</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">clean</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Purpose: Retrieve the lite neuron_obj (implemented). Local implementation where retrieved from pipeline products of neuron obj but could override to fetch from an external store using the segment id and split index</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segment_id : Union[int,Neuron]</span>
<span class="sd">            </span>
<span class="sd">        split_index : int, optional</span>
<span class="sd">            by default 0</span>
<span class="sd">        clean : bool, optional</span>
<span class="sd">            by default True</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neuron_obj_lite: nx.DiGraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="n">neuron_obj</span> <span class="o">=</span> <span class="n">segment_id</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">neuron_obj</span><span class="o">.</span><span class="n">neuron_graph_after_proof</span>
            
        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> 
            <span class="n">G</span> <span class="o">=</span> <span class="n">nxu</span><span class="o">.</span><span class="n">clean_G</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">G</span></div></div>
    
    
        

<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">pandas_utils</span> <span class="k">as</span> <span class="n">pu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">ipyvolume_utils</span> <span class="k">as</span> <span class="n">ipvu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">numpy_utils</span> <span class="k">as</span> <span class="n">nu</span>
<span class="kn">from</span> <span class="nn">datasci_tools</span> <span class="kn">import</span> <span class="n">mesh_utils</span> <span class="k">as</span> <span class="n">meshu</span>

<span class="kn">from</span> <span class="nn">mesh_tools</span> <span class="kn">import</span> <span class="n">trimesh_utils</span> <span class="k">as</span> <span class="n">tu</span>

<span class="kn">from</span> <span class="nn">neuron_morphology_tools</span> <span class="kn">import</span> <span class="n">neuron_nx_utils</span> <span class="k">as</span> <span class="n">nxu</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">graph_filters</span> <span class="k">as</span> <span class="n">gf</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">proofreading_utils</span> <span class="k">as</span> <span class="n">pru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">parameter_utils</span> <span class="k">as</span> <span class="n">paru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">synapse_utils</span> <span class="k">as</span> <span class="n">syu</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_visualizations</span> <span class="k">as</span> <span class="n">nviz</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron_utils</span> <span class="k">as</span> <span class="n">nru</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">neuron</span>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Brendan Celii.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>